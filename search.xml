<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>00-JS基本数据类型及类型判断</title>
    <url>/2022/12/04/00-JS%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<h1 id="JS数据类型及类型判断"><a href="#JS数据类型及类型判断" class="headerlink" title="JS数据类型及类型判断"></a>JS数据类型及类型判断</h1><p>5种<strong>简单数据类型</strong>（也称为<strong>基本数据类型</strong>）: <code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>和<code>String</code></p>
<p>1种复杂数据类型：<code>Object</code></p>
<ul>
<li>Object是所有对象的父类</li>
<li><strong>引用类型</strong>又可以细分为 <code>Array Function Object</code></li>
</ul>
<span id="more"></span>

<h2 id="js数据类型"><a href="#js数据类型" class="headerlink" title="js数据类型"></a>js数据类型</h2><ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number"><code>Number</code></a>（数字）</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>String</code></a>（字符串）</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><code>Boolean</code></a>（布尔）</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol"><code>Symbol</code></a>（符号）（ES2015 新增）即（ES6新增）</p>
</li>
<li><p><code>Object</code></p>
<p>（对象）</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Function</code></a>（函数）</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a>（数组）</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a>（日期）</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp"><code>RegExp</code></a>（正则表达式）</li>
</ul>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a>（空）</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>（未定义）</p>
</li>
</ul>
<br>

<h3 id="1-Number"><a href="#1-Number" class="headerlink" title="1. Number"></a>1. Number</h3><p>JavaScript的<code>Number</code>类型为<u>双精度IEEE 754 64位浮点</u>类型。</p>
<p>也就是说可以表示<strong>整数和小数</strong></p>
<p>Number对象的方法</p>
<ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN"><code>Number.isNaN()</code></a></p>
<ul>
<li>判断参数是否为NaN</li>
</ul>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger"><code>Number.isInteger()</code></a></p>
<ul>
<li>参数是否为<strong>数字且为整数</strong></li>
</ul>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt"><code>Number.parseInt()</code></a></p>
<ul>
<li>与全局对象<code>parseInt()</code>相同</li>
<li><code>parseFloat()</code>同理</li>
</ul>
</li>
</ul>
<h4 id="Number-构造器返回值"><a href="#Number-构造器返回值" class="headerlink" title="Number()构造器返回值"></a>Number()构造器返回值</h4><p>使用Number函数<strong>将参数转换为数字</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number(&#39;123&#39;)     &#x2F;&#x2F; 123</span><br><span class="line">Number(&#39;12.3&#39;)    &#x2F;&#x2F; 12.3</span><br><span class="line">Number(&#39;12.00&#39;)   &#x2F;&#x2F; 12</span><br><span class="line">Number(&#39;&#39;)        &#x2F;&#x2F; 0</span><br><span class="line">Number(null)      &#x2F;&#x2F; 0</span><br><span class="line">Number(&#39;foo&#39;)     &#x2F;&#x2F; NaN</span><br><span class="line">Number(&#39;-Infinity&#39;) &#x2F;&#x2F;-Infinity</span><br></pre></td></tr></table></figure>

<ul>
<li>对于有小数点但小数位均为0的浮点数，返回整数</li>
<li>对于<strong>空字符串和null</strong>，返回0</li>
<li>对于非数值（非空字符串），返回NaN <strong>(NaN的类型为Number)</strong></li>
<li>NaN与<strong>任何数据都不相等</strong> 返回false（包括NaN）</li>
<li>对于字符串 ‘-Infinity’ 和 ‘Infinity’，返回其本身</li>
</ul>
<br>

<h3 id="2-String"><a href="#2-String" class="headerlink" title="2. String"></a>2. String</h3><p>字符串字面量采取以下方式表示：</p>
<ul>
<li><code>‘hello world’</code>单引号</li>
<li><code>&quot;hello world&quot;</code> 双引号</li>
<li>`hello ${a}` 反引号<ul>
<li>ES6新增的模板字符串表示方式</li>
<li>可以使用<code>$&#123;变量名&#125;</code>将变量值直接拼接在字符串中，不需要使用普通字符串的<code>+</code>拼接形式</li>
<li>${a} 即将a变量的值比如’world’拼接进字符串</li>
</ul>
</li>
</ul>
<h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p><img data-src="/images/00-JS%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/image-20210917110913544.png" alt="image-20210917110913544"></p>
<br>

<h4 id="获取单个字符"><a href="#获取单个字符" class="headerlink" title="获取单个字符"></a>获取单个字符</h4><ul>
<li>使用<code>charAt(&#39;字符串索引&#39;)</code>方法</li>
<li>将字符串当作一个类似数组的对象，使用数值索引获取其中单个字符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return &#39;cat&#39;.charAt(1); &#x2F;&#x2F; returns &quot;a</span><br><span class="line">return &#39;cat&#39;[1]; &#x2F;&#x2F; returns &quot;a&quot;</span><br></pre></td></tr></table></figure>

<h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><p>直接使用比较运算符（<code>&lt;,&gt;,=</code>等）</p>
<p>比较时使用字符的<strong>ASCⅡ码</strong>进行比较</p>
<br>

<h3 id="3-Boolean"><a href="#3-Boolean" class="headerlink" title="3. Boolean"></a>3. Boolean</h3><p>对于<code>Boolean()</code>构造器</p>
<p>将参数转换为Boolean值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="built_in">Boolean</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b ,<span class="string">&quot;value:&quot;</span>+ b); <span class="comment">//Boolean value:false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>b的类型为Boolean</li>
<li>b的值为false</li>
</ul>
<br>

<p>对于<code>new Boolean()</code></p>
<p>其返回一个<strong>Boolean对象</strong>，注意是<strong>对象</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a,<span class="keyword">typeof</span> a);	<span class="comment">//[Boolean: false] object</span></span><br><span class="line"><span class="comment">//判断时a为true进入分支语句</span></span><br><span class="line"><span class="keyword">if</span>(a)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>a为一个Boolean对象，值为Boolean类型的false</li>
<li>判断时将a当作对象，非空对象判断时返回true</li>
</ul>
<h3 id="4-Symbol"><a href="#4-Symbol" class="headerlink" title="4. Symbol"></a>4. Symbol</h3><p><strong>symbol</strong> 是一种基本数据类型 （<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive">primitive data type</a>）。<code>Symbol()</code>函数会返回<strong>symbol</strong>类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：”<code>new Symbol()</code>“。</p>
<ul>
<li>每个从<code>Symbol()</code>返回的symbol值都是<strong>唯一的</strong>。（即使参数一样，返回的值也不同）</li>
<li>一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>) === <span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>));	<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="5-null"><a href="#5-null" class="headerlink" title="5.null"></a>5.null</h3><p>JavaScript的<strong>基本数据类型之一</strong></p>
<p>null指<strong>空对象</strong>或<strong>对象的值未设置</strong>，在<strong>布尔运算中被认为是false</strong></p>
<ul>
<li>null<strong>不是全局对象（window）的一个属性</strong>，它指示<strong>变量未指向任何对象</strong></li>
</ul>
<h4 id="null与undefined的不同点"><a href="#null与undefined的不同点" class="headerlink" title="null与undefined的不同点"></a>null与undefined的不同点</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>        <span class="comment">// &quot;object&quot; (因为一些以前的原因而不是&#x27;null&#x27;)</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>   <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span>  == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line">!<span class="literal">null</span> <span class="comment">//true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">1</span> + <span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">1</span> + <span class="literal">undefined</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>typeof null</code> 返回object（null是空对象）</p>
</li>
<li><p><code>typeof undefined</code> 返回 undefined</p>
</li>
<li><p><code>===</code>不执行类型转换 所以<code>null === undefined // false</code></p>
</li>
<li><p><code>==</code>执行类型转换 <code>null  == undefined // true</code></p>
</li>
<li><p><code>isNaN(1 + null) // false</code></p>
</li>
<li><p><code>isNaN(1 + undefined) // true</code></p>
</li>
</ul>
<br>

<h3 id="6-undefined"><a href="#6-undefined" class="headerlink" title="6. undefined"></a>6. undefined</h3><p>它是一个JavaScript的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive">原始数据类型</a> 。</p>
<ul>
<li><p>一个<strong>被声明</strong>但是<strong>没有被赋值的变量</strong>的类型是undefined</p>
</li>
<li><p>一个函数如果没有使用return语句指定<code>返回</code>值，就会返回一个undefined值。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="built_in">console</span>.log(a);	<span class="comment">//undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b());	<span class="comment">//undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>一个未赋值的变量 <code>=== undefined</code> 时返回<strong>true</strong></li>
<li><code>typeof</code> 一个未赋值的变量 <code>=== &#39;undefined&#39;</code> 时返回<strong>true</strong><ul>
<li>typeof返回一个代表类型的<strong>字符串</strong></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a</span><br><span class="line">console.log(a &#x3D;&#x3D;&#x3D; undefined);	&#x2F;&#x2F;true</span><br><span class="line">console.log(typeof a &#x3D;&#x3D;&#x3D; &#39;undefined&#39;);	&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>

<br>

<h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><strong><code>typeof</code></strong> 操作符返回一个<strong>字符串</strong>，表示未经计算的操作数的类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (<span class="keyword">typeof</span> a));	<span class="comment">//String</span></span><br></pre></td></tr></table></figure>

<p>即typeof 操作符返回的值为字符串，字符串再经typeof操作符后返回String</p>
<p>typeof使用时两种方式：</p>
<ul>
<li><code>typeof a</code></li>
<li><code>typeof (a)</code></li>
</ul>
<br>

<h4 id="typeof操作符常见的返回值"><a href="#typeof操作符常见的返回值" class="headerlink" title="typeof操作符常见的返回值"></a>typeof操作符常见的返回值</h4><p><img data-src="/images/00-JS%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/image-20210917125835866.png" alt="image-20210917125835866"></p>
<ul>
<li><code>typeof null</code> 返回’object’</li>
<li>typeof function对象 返回’function’</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a);	<span class="comment">//&#x27;object&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn);	<span class="comment">//&#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="new操作符生成的实例对象-使用typeof时的返回值"><a href="#new操作符生成的实例对象-使用typeof时的返回值" class="headerlink" title="new操作符生成的实例对象 使用typeof时的返回值"></a>new操作符生成的实例对象 使用typeof时的返回值</h4><ul>
<li>使用new操作符生成的实例对象本质是对象，所以使用typeof返回’Object’,</li>
<li>但有一个特例 <code>new Function</code> 时产生的实例对象 使用typeof时返回’function’</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; 11</span><br><span class="line">var b &#x3D; new Number(11)</span><br><span class="line">var c &#x3D; new Function()</span><br><span class="line">console.log(typeof c);	&#x2F;&#x2F;&#39;function&#39;</span><br><span class="line">console.log(typeof a);	&#x2F;&#x2F;&#39;number&#39;</span><br><span class="line">console.log(typeof b);	&#x2F;&#x2F;&#39;object&#39; b本质是对象</span><br></pre></td></tr></table></figure>

<br>

<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>使用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object instanceof constructor</span><br></pre></td></tr></table></figure>

<p><code>instanceof</code> 运算符用来检测 <code>constructor.prototype </code>是否存在于参数 <code>object</code> 的<strong>原型链上</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义构造函数</span><br><span class="line">function C()&#123;&#125;</span><br><span class="line">function D()&#123;&#125;</span><br><span class="line"></span><br><span class="line">var o &#x3D; new C();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o instanceof C; &#x2F;&#x2F; true，因为 Object.getPrototypeOf(o) &#x3D;&#x3D;&#x3D; C.prototype</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o instanceof D; &#x2F;&#x2F; false，因为 D.prototype 不在 o 的原型链上</span><br></pre></td></tr></table></figure>

<ul>
<li>实例对象o的原型链为 <code>o -&gt; C.prototype -&gt; Object.prototype -&gt; null</code><ul>
<li>所以<code>o instanceof C</code> 返回true</li>
<li><code>o instanceof D</code> 返回false</li>
</ul>
</li>
</ul>
<br>

<h2 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符=="></a>相等操作符==</h2><p>相等操作符当比较的两者数据类型不同时会<strong>自动进行类型转换</strong></p>
<h3 id="类型转换的算法流程"><a href="#类型转换的算法流程" class="headerlink" title="类型转换的算法流程"></a>类型转换的算法流程</h3><p><code>x == y</code></p>
<ul>
<li><p>相等运算符算法流程就是下面的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.如果x非正常值(比如x本身会抛出错误)，则中断执行</span><br><span class="line"></span><br><span class="line">2.如果y非正常值(同上)，则中断执行</span><br><span class="line"></span><br><span class="line">3.如果x的数据类型和y的数据类型相同，则返回以严格运算符执行判断的结果，即x&#x3D;&#x3D;&#x3D;y的结果</span><br><span class="line"></span><br><span class="line">4.如果x是null，y是undefined，返回true</span><br><span class="line"></span><br><span class="line">5.如果x是undefined，y是null，返回true</span><br><span class="line"></span><br><span class="line">6.如果x的数据类型是Number，y的数据类型是String，则将y转成Number，然后返回x&#x3D;&#x3D;Number(y)的结果</span><br><span class="line"></span><br><span class="line">7.如果x的数据类型是String，y的数据类型是Number，则将x转成Number，然后返回Number(x)&#x3D;&#x3D;y的结果</span><br><span class="line"></span><br><span class="line">8.如果x的数据类型是Boolean，则将x转成Number，然后返回Number(x)&#x3D;&#x3D;y的结果</span><br><span class="line"></span><br><span class="line">9.如果y的数据类型是Boolean，则将y转成Number，然后返回x&#x3D;&#x3D;Number(y)的结果</span><br><span class="line"></span><br><span class="line">10.如果x的数据类型是String、Number或者Symbol，y的数据类型是Object，则将y转成原始类型，然后返回x&#x3D;&#x3D;toPrimitive(y)的结果</span><br><span class="line"></span><br><span class="line">11.如果x的数据类型是Object，y的数据类型是String、Number或者Symbol，则将x转成原始类型，然后返回toPrimitive(x)&#x3D;&#x3D;y的结果</span><br><span class="line"></span><br><span class="line">12.返回false</span><br></pre></td></tr></table></figure>

<p style="color:red;">将Object类型的x转换成原始类型解释如下(==运算符下的转换)：</p>

<ul>
<li>在执行<code>ToPrimitive(obj,preferredType)</code>时如果<strong>第二个参数为空并且obj为Date的实例</strong>时，此时<code>preferredType</code>会被设置为String，其他情况下<code>preferredType</code>都会被设置为<strong>Number</strong>、</li>
</ul>
<br>

<ul>
<li>如果<code>preferredType</code>为<strong>Number</strong>，ToPrimitive执行过程如下：<ul>
<li>如果obj为原始值，直接返回；**(原始值：五种基本数据类型(不含symbol))**</li>
<li>否则调用 <code>obj.valueOf()</code>，如果执行结果是原始值，返回之；</li>
<li>否则调用<code>obj.toString()</code>，如果执行结果是原始值，返回之；</li>
<li>否则抛异常。</li>
</ul>
</li>
</ul>
<br>

<ul>
<li>如果<code>preferredType</code>为<strong>String</strong>，将上面的<strong>第2步和第3步调换</strong>，即：<ul>
<li>如果obj为原始值，直接返回；</li>
<li>否则调用<code>obj.toString()</code>，如果执行结果是原始值，返回之；</li>
<li>否则调用 <code>obj.valueOf()</code>，如果执行结果是原始值，返回之；</li>
<li>否则抛异常。</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>

<ul>
<li><p style="color:red;">！可将变量转换成boolean类型，null、undefined、NaN以及空字符串('')取反都为true，其余取反都为false。</p></li>
</ul>
<br>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">![] == <span class="string">&#x27;&#x27;</span>	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code> ![]</code>为false（空数组取反为false）</p>
</li>
<li><p>比较转换为 <code>false == &#39;&#39;</code></p>
</li>
<li><p>Boolean类型值在比较前转换为Number类型</p>
</li>
<li><p>比较转换为 <code>0 == &#39;&#39;</code></p>
</li>
<li><p>将String类型的<code>&#39;&#39;</code>转换为Number类型（空字符串转换为Number类型结果为 0 ）</p>
</li>
<li><p>比较转换为 <code>0 == 0</code></p>
</li>
<li><p>结果为<code>true</code></p>
</li>
</ul>
<br>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;true&#39;&#x3D;&#x3D;true	&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<ul>
<li>Boolean类型的<strong>true转换为 1</strong></li>
<li>比较转换为 <code>&#39;true&#39; == 1</code></li>
<li>String类型的**’true’被转换为Number类型的NaN**</li>
<li>比较转换为 <code>NaN == 1</code></li>
<li>NaN与任何类型数据比较均返回false(包括NaN)</li>
</ul>
<br>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &#x3D;&#x3D; null	&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<ul>
<li>根据算法流程，前11条均不匹配</li>
<li>根据12条返回false</li>
</ul>
<br>

<h2 id="全等运算符"><a href="#全等运算符" class="headerlink" title="全等运算符 ==="></a>全等运算符 ===</h2><p>全等运算符<strong>不会进行类型转换</strong>，类型不同即返回false</p>
<p>类型相同则比较其值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="string">&#x27;1&#x27;</span> <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语言语法</title>
    <url>/2022/11/27/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="SQL语言语法"><a href="#SQL语言语法" class="headerlink" title="SQL语言语法"></a>SQL语言语法</h1><p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212114510149.png" alt="image-20220212114510149"></p>
<h2 id="1-DDL"><a href="#1-DDL" class="headerlink" title="1.DDL"></a>1.DDL</h2><p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212133035141.png" alt="image-20220212133035141"></p>
<h3 id="1-1-数据库操作"><a href="#1-1-数据库操作" class="headerlink" title="1.1 数据库操作"></a>1.1 数据库操作</h3><p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212133405533.png" alt="image-20220212133405533"></p>
<h3 id="1-2-表结构操作"><a href="#1-2-表结构操作" class="headerlink" title="1.2 表结构操作"></a>1.2 表结构操作</h3><p>对表整体操作</p>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212135928960.png" alt="image-20220212135928960"></p>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212141405556.png" alt="image-20220212141405556"></p>
<p>查看某个表的创建语句，可以查看<strong>默认值和编码格式</strong>等信息</p>
<h4 id="1-2-1-数值类型"><a href="#1-2-1-数值类型" class="headerlink" title="1.2.1 数值类型"></a>1.2.1 数值类型</h4><p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212140603085.png" alt="image-20220212140603085"></p>
<p><code>DECIMAL(M,D)</code></p>
<ul>
<li>M代表有效位数</li>
<li>D代表小数位数</li>
</ul>
<h4 id="1-2-2-字符串类型"><a href="#1-2-2-字符串类型" class="headerlink" title="1.2.2 字符串类型"></a>1.2.2 字符串类型</h4><p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212140859529.png" alt="image-20220212140859529"></p>
<h4 id="1-2-3-日期类型"><a href="#1-2-3-日期类型" class="headerlink" title="1.2.3 日期类型"></a>1.2.3 日期类型</h4><p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212141153208.png" alt="image-20220212141153208"></p>
<h4 id="1-2-4-表结构修改"><a href="#1-2-4-表结构修改" class="headerlink" title="1.2.4 表结构修改"></a>1.2.4 表结构修改</h4><p>添加表的列</p>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212142033249.png" alt="image-20220212142033249"></p>
<p>修改列名和类型</p>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212142317947.png" alt="image-20220212142317947"></p>
<p>删除列</p>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212142425713.png" alt="image-20220212142425713"></p>
<p>修改表名</p>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212142518584.png" alt="image-20220212142518584"></p>
<p>修改字段数据类型</p>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220421124317990.png" alt="image-20220421124317990"></p>
<h2 id="2-DML"><a href="#2-DML" class="headerlink" title="2.DML"></a>2.DML</h2><p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212142617317.png" alt="image-20220212142617317"></p>
<h3 id="2-1-数据插入"><a href="#2-1-数据插入" class="headerlink" title="2.1 数据插入"></a>2.1 数据插入</h3><p>插入一行数据</p>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212142800043.png" alt="image-20220212142800043"></p>
<ul>
<li>可以向某些列插入，可以向所有列插入</li>
</ul>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212143028085.png" alt="image-20220212143028085"></p>
<ul>
<li>通过<strong>逗号</strong>分隔多个<code>values</code>的方式可以一次插入多行</li>
</ul>
<h3 id="2-2-数据修改"><a href="#2-2-数据修改" class="headerlink" title="2.2 数据修改"></a>2.2 数据修改</h3><p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212143325789.png" alt="image-20220212143325789"></p>
<ul>
<li><p>第一种方式修改表中<strong>该字段所有值</strong></p>
</li>
<li><p>第二种根据条件修改表中<strong>该字段的某个值</strong></p>
</li>
<li><p>条件中可以使用 <code>= &lt; &gt;</code>等符号</p>
</li>
</ul>
<h3 id="2-3-数据删除"><a href="#2-3-数据删除" class="headerlink" title="2.3 数据删除"></a>2.3 数据删除</h3><p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212143755006.png" alt="image-20220212143755006"></p>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212143833910.png" alt="image-20220212143833910"></p>
<h2 id="3-数据的约束"><a href="#3-数据的约束" class="headerlink" title="3.数据的约束"></a>3.数据的约束</h2><p>创建表时可以选择添加约束</p>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212162856772.png" alt="image-20220212162856772"></p>
<h3 id="3-1-主键约束"><a href="#3-1-主键约束" class="headerlink" title="3.1 主键约束"></a>3.1 主键约束</h3><p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212163218687.png" alt="image-20220212163218687"></p>
<p>作为主键的列，<strong>非空且唯一</strong></p>
<p>一张表只有<strong>一个主键</strong></p>
<h4 id="3-1-1-创建单列主键"><a href="#3-1-1-创建单列主键" class="headerlink" title="3.1.1 创建单列主键"></a>3.1.1 创建单列主键</h4><ul>
<li>在创建表结构时在字段加入<code>primary key</code>约束</li>
</ul>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212163346731.png" alt="image-20220212163346731"></p>
<ul>
<li>创建表结构的字段设置完后单独添加主键</li>
</ul>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212163628074.png" alt="image-20220212163628074"></p>
<h4 id="3-1-2-创建多列主键"><a href="#3-1-2-创建多列主键" class="headerlink" title="3.1.2 创建多列主键"></a>3.1.2 创建多列主键</h4><p>创建表结构时，所有字段定义完后，再添加多列主键</p>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212164141927.png" alt="image-20220212164141927"></p>
<p>多列联合主键</p>
<ul>
<li>每条信息的主键<strong>不能完全相同</strong></li>
<li>每个字段<strong>均不能为空</strong></li>
</ul>
<h4 id="3-1-3-修改表结构增加主键"><a href="#3-1-3-修改表结构增加主键" class="headerlink" title="3.1.3 修改表结构增加主键"></a>3.1.3 修改表结构增加主键</h4><p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212164808085.png" alt="image-20220212164808085"></p>
<h4 id="3-1-4-删除主键"><a href="#3-1-4-删除主键" class="headerlink" title="3.1.4 删除主键"></a>3.1.4 删除主键</h4><p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212164946090.png" alt="image-20220212164946090"></p>
<ul>
<li>单列和多列主键的删除语句相同</li>
</ul>
<h3 id="3-2-自增长约束"><a href="#3-2-自增长约束" class="headerlink" title="3.2 自增长约束"></a>3.2 自增长约束</h3><p>MySQL中为主键指定自增长约束后，数据库会自动对该字段进行赋值。</p>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212170840783.png" alt="image-20220212170840783"></p>
<p>自增长约束一般与主键一起使用</p>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212170901702.png" alt="image-20220212170901702"></p>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212170926821.png" alt="image-20220212170926821"></p>
<h4 id="3-2-1-指定自增初始值"><a href="#3-2-1-指定自增初始值" class="headerlink" title="3.2.1 指定自增初始值"></a>3.2.1 指定自增初始值</h4><p>设定初始值后，该字段就会从初始值开始自增</p>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212175314442.png" alt="image-20220212175314442"></p>
<p>方式2修改表结构的方式指定</p>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212175407567.png" alt="image-20220212175407567"></p>
<h4 id="3-2-2-delete和truncate执行后自增列变化"><a href="#3-2-2-delete和truncate执行后自增列变化" class="headerlink" title="3.2.2 delete和truncate执行后自增列变化"></a>3.2.2 delete和truncate执行后自增列变化</h4><p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212175543285.png" alt="image-20220212175543285"></p>
<h3 id="3-3-非空约束"><a href="#3-3-非空约束" class="headerlink" title="3.3 非空约束"></a>3.3 非空约束</h3><p>非空约束的字段在添加数据时不指定则会报错</p>
<h4 id="3-3-1-添加非空约束"><a href="#3-3-1-添加非空约束" class="headerlink" title="3.3.1 添加非空约束"></a>3.3.1 添加非空约束</h4><p>方式一：在创建表时指定</p>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212180228569.png" alt="image-20220212180228569"></p>
<h4 id="3-3-2-删除非空约束"><a href="#3-3-2-删除非空约束" class="headerlink" title="3.3.2 删除非空约束"></a>3.3.2 删除非空约束</h4><p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212180355729.png" alt="image-20220212180355729"></p>
<h2 id="4-DQL-基本查询"><a href="#4-DQL-基本查询" class="headerlink" title="4.DQL 基本查询"></a>4.DQL 基本查询</h2><p>MySQL使用SELECT语句来查询</p>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212180624443.png" alt="image-20220212180624443"></p>
<h3 id="4-1查询时起别名"><a href="#4-1查询时起别名" class="headerlink" title="4.1查询时起别名"></a>4.1查询时起别名</h3><p>多表联合查询有时通过别名简化操作</p>
<p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212181654448.png" alt="image-20220212181654448"></p>
<h3 id="4-2查询时去掉重复值"><a href="#4-2查询时去掉重复值" class="headerlink" title="4.2查询时去掉重复值"></a>4.2查询时去掉重复值</h3><p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212181706422.png" alt="image-20220212181706422"></p>
<p><code>distinct 列名</code> 查询结果删去其中的重复值</p>
<p><code>distinct *</code> 将查询结果中<strong>完全一样的行</strong>删去</p>
<h3 id="4-3查询结果进行运算"><a href="#4-3查询结果进行运算" class="headerlink" title="4.3查询结果进行运算"></a>4.3查询结果进行运算</h3><p><img data-src="/images/01-SQL%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/image-20220212182111876.png" alt="image-20220212182111876"></p>
<p>将列名当作变量进行运算，修改查询出来显示的数据（原表不变）</p>
]]></content>
      <categories>
        <category>SQL语言</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>00-浏览器调试js程序代码</title>
    <url>/2021/04/13/00-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95js%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="浏览器调试JS程序代码（chrome浏览器）"><a href="#浏览器调试JS程序代码（chrome浏览器）" class="headerlink" title="浏览器调试JS程序代码（chrome浏览器）"></a>浏览器调试JS程序代码（chrome浏览器）</h1><ul>
<li><p><strong>-将js代码写在html文件的script标签中</strong></p>
</li>
<li><p>在浏览器打开html文件</p>
</li>
<li><p>点击检查中的<strong>Sources选项</strong></p>
</li>
<li><p>点击代码前面序号<strong>设置断点</strong></p>
</li>
<li><p>刷新当前页面<strong>执行js代码</strong></p>
</li>
<li><p>代码中<code>console.log</code>语句的<strong>输出结果显示在Console选项中</strong></p>
</li>
</ul>
<span id="more"></span>

<p><img data-src="/images/00-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95js%E7%A8%8B%E5%BA%8F/image-20210914163555091.png" alt="image-20210914163555091"></p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议、HTTPS协议和TCP协议</title>
    <url>/2022/11/27/01-http%E5%92%8Chttps%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="HTTP协议、HTTPS协议和TCP协议"><a href="#HTTP协议、HTTPS协议和TCP协议" class="headerlink" title="HTTP协议、HTTPS协议和TCP协议"></a>HTTP协议、HTTPS协议和TCP协议</h1><h2 id="1-HTTP和HTTPS协议基本概念"><a href="#1-HTTP和HTTPS协议基本概念" class="headerlink" title="1. HTTP和HTTPS协议基本概念"></a>1. HTTP和HTTPS协议基本概念</h2><p><strong>HTTP协议</strong>：</p>
<ul>
<li>超文本传输协议，互联网应用最广泛的一种网络协议</li>
<li>一个客户端和服务器端请求和应答的标准</li>
<li>用于<strong>从www服务器传输超文本到本地浏览器的传输协议</strong></li>
<li>使浏览器更加高效</li>
</ul>
<p><strong>HTTPS协议</strong>：</p>
<ul>
<li>以安全为目标的HTTP通道</li>
<li>HTTP的安全版本，使用<strong>SSL安全套接字层</strong>进行加密</li>
<li>主要作用：建立一个信息安全通道，确保<strong>数据传输和网站的真实性</strong></li>
</ul>
<span id="more"></span>

<h2 id="2-HTTP和HTTPS协议区别"><a href="#2-HTTP和HTTPS协议区别" class="headerlink" title="2. HTTP和HTTPS协议区别"></a>2. HTTP和HTTPS协议区别</h2><ul>
<li>HTTP传输的数据未加密，是明文的</li>
<li>HTTPS协议是由HTTP协议和SSL协议构建的<strong>可进行加密传输和身份验证的网络协议</strong>，比HTTP安全性更高</li>
<li>主要区别：<ul>
<li>HTTPS：需要ca证书，费用高</li>
<li>HTTP明文传输数据，HTTPS是<strong>SSL加密传输协议</strong>，安全性高</li>
<li>HTTP的端口80，HTTPS的端口443</li>
<li><strong>HTTP连接简单，无状态</strong></li>
</ul>
</li>
</ul>
<h2 id="3-HTTPS工作原理"><a href="#3-HTTPS工作原理" class="headerlink" title="3. HTTPS工作原理"></a>3. HTTPS工作原理</h2><p>客户端使用HTTPS协议与WEB服务器通信步骤：</p>
<ul>
<li>使用HTTPS URL访问服务器，<strong>要求web服务器建立SSL链接</strong></li>
<li>web服务器接受到请求后，将<strong>包含公钥的网站证书</strong>传输给客户端</li>
<li>客户端和服务器开始<strong>协商SSL连接的安全等级</strong>，加密等级</li>
<li><strong>客户端</strong>浏览器通过协商后<strong>建立会话密钥</strong>，通过网站公钥加密后<strong>传送给网站服务器</strong></li>
<li>WEB服务器通过自己的私钥解密出会话密钥</li>
<li>web服务器<strong>通过会话密钥加密</strong>与客户端之间的通信</li>
</ul>
<h3 id="3-1-对称加密和非对称加密的优缺点"><a href="#3-1-对称加密和非对称加密的优缺点" class="headerlink" title="3.1 对称加密和非对称加密的优缺点"></a>3.1 对称加密和非对称加密的优缺点</h3><p>对称加密：DES/AES算法</p>
<ul>
<li>加密解密使用同样的密钥</li>
<li>优点：计算量小，<strong>加密效率高</strong></li>
<li>缺点：密钥的管理和分发困难，不够安全</li>
</ul>
<p>非对称加密：RSA算法</p>
<ul>
<li>使用公钥和私钥进行加密与解密，公钥可以发送给任意请求它的人，公钥加密的消息只有私钥的持有者才能解密</li>
<li>优点：普遍比对称加密更安全</li>
<li>缺点：<strong>算法复杂，效率低</strong></li>
</ul>
<h2 id="4-HTTPS协议的优点"><a href="#4-HTTPS协议的优点" class="headerlink" title="4. HTTPS协议的优点"></a>4. HTTPS协议的优点</h2><ul>
<li>可以认证用户和服务器，确保<strong>数据发送到正确</strong>客户机和服务器</li>
<li>保证<strong>数据完整性</strong>（传输过程不被窃取改变等）</li>
<li>HTTPS是<strong>现行架构下最安全的解决方案</strong>，增加中间人攻击的成本</li>
</ul>
<h2 id="5-HTTPS的缺点"><a href="#5-HTTPS的缺点" class="headerlink" title="5.HTTPS的缺点"></a>5.HTTPS的缺点</h2><ul>
<li>HTTPS握手阶段花费时间较大，<strong>延长页面加载时间</strong></li>
<li>缓存不如HTTP高效，<strong>增加数据开销</strong></li>
<li>SSL证书需要<strong>付费</strong></li>
<li>SSL证书需要绑定IP，<strong>不能在同一个IP上绑定多个域名</strong>（ipv4资源不够）</li>
</ul>
<h2 id="6-TCP和UDP区别"><a href="#6-TCP和UDP区别" class="headerlink" title="6. TCP和UDP区别"></a>6. TCP和UDP区别</h2><ul>
<li><strong>TCP协议</strong>：传输控制协议<ul>
<li>面向连接，需要<strong>建立连接后才可以发送数据</strong></li>
<li>提供<strong>可靠的服务</strong>，无差错，不丢失，按时到达</li>
<li>面向<strong>字节流</strong></li>
<li>TCP是<strong>一对一</strong>的</li>
</ul>
</li>
<li><strong>UDP协议</strong>：用户数据报<ul>
<li>无连接</li>
<li>尽最大努力交付，<strong>不保证可靠交付</strong></li>
<li>面向<strong>报文</strong></li>
<li>UDP支持<strong>一对一和一对多</strong></li>
</ul>
</li>
</ul>
<h2 id="7-TCP三次握手四次挥手"><a href="#7-TCP三次握手四次挥手" class="headerlink" title="7. TCP三次握手四次挥手"></a>7. TCP三次握手四次挥手</h2><h3 id="7-1-三次握手"><a href="#7-1-三次握手" class="headerlink" title="7.1 三次握手"></a>7.1 三次握手</h3><p>客户端和服务端都需要确认**对方和自己可收发(信道正常)**，所以需要三次握手</p>
<ul>
<li>第一次握手：客户端向服务器发起连接请求，等待服务器响应</li>
<li>第二次握手：服务端接受请求后向客户端发送响应ack报文，客户端接受响应后<strong>明确了客户端到服务器的传输正常</strong></li>
<li>第三次握手：客户端向服务端发送ack报文，服务端接受后<strong>明确了服务端到客户端的传输正常</strong></li>
</ul>
<p><img data-src="/images/01-http%E5%92%8Chttps%E5%8D%8F%E8%AE%AE/image-20210914092803504.png" alt="image-20210914092803504"></p>
<h3 id="7-2-四次挥手"><a href="#7-2-四次挥手" class="headerlink" title="7.2 四次挥手"></a>7.2 四次挥手</h3><p>服务器和客户端<strong>都可以发起四次挥手</strong></p>
<p><img data-src="/images/01-http%E5%92%8Chttps%E5%8D%8F%E8%AE%AE/image-20210914092733068.png" alt="image-20210914092733068"></p>
<p>例如客户端发起四次挥手</p>
<ul>
<li><p>第一次挥手：客户端发送请求启动四次挥手，并<strong>停止向服务端传送数据</strong></p>
</li>
<li><p>第二次挥手：服务端向客户端响应确认收到请求，但<strong>可能还有数据没有传送完毕</strong>，接着传送剩下的数据</p>
</li>
<li><p>第三次挥手：<strong>同样是服务端发送</strong>，告知客户端服务端数据发送完毕，并<strong>停止向客户端发送数据</strong></p>
</li>
<li><p>第四次挥手：客户端收到第三次挥手后确认服务端准备关闭，发送第四次挥手报文，服务端接受到第四次挥手后<strong>立即关闭连接</strong>，客户端在发送第四次挥手报文后<strong>等待2MSL后关闭</strong></p>
</li>
</ul>
<p>注意：</p>
<p>客户端发送第四次挥手报文后<strong>等待2MSL后再关闭</strong></p>
<ul>
<li><p>MSL：一段TCP报文在传输过程最大生命周期（来回即2MSL）</p>
</li>
<li><p>因为若服务端在1MSL内没有收到第四次挥手，则会向客户端发出FIN报文。此时客户端需要再次发送第四次挥手请求</p>
</li>
<li><p><strong>经过2MSL没有接受到服务端报文</strong>，说明服务端已经正常关闭，客户端也可以关闭</p>
<ul>
<li>若服务端没有正常关闭，则客户端必在2MSL内收到服务端的报文</li>
</ul>
</li>
</ul>
<h2 id="8-HTTP报文中的头部字段"><a href="#8-HTTP报文中的头部字段" class="headerlink" title="8. HTTP报文中的头部字段"></a>8. HTTP报文中的头部字段</h2><h3 id="8-1-请求头"><a href="#8-1-请求头" class="headerlink" title="8.1 请求头"></a>8.1 请求头</h3><p>  <strong>Accept</strong>: <em>/</em>(客户端能接收的资源类型)<br>  <strong>Accept-Language</strong>: en-us(客户端接收的语言类型)<br>  <strong>Connection</strong>: Keep-Alive(维护客户端和服务端的连接关系)<br>  <strong>Host</strong>: localhost:8080(连接的目标主机和端口号)<br>  <strong>Referer</strong>: <a href="http://localhost/links.asp(%E5%91%8A%E8%AF%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%88%91%E6%9D%A5%E8%87%AA%E4%BA%8E%E5%93%AA%E9%87%8C)">http://localhost/links.asp(告诉服务器我来自于哪里)</a><br>  <strong>User-Agent</strong>: Mozilla/4.0(客户端版本号的名字)<br>  Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型)<br>  <strong>If-Modified-Since</strong>: Tue, 11 Jul 2000 18:23:51 GMT(缓存时间)  （上次请求响应的<strong>Last-Modified</strong>）<br>  Cookie：(客户端暂存服务端的信息)</p>
<p>  <strong>Content-Type</strong>: <strong>请求体的MIME类型（用于POST请求中）</strong></p>
<p>  <strong>Date</strong>: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间)</p>
<h3 id="8-2-响应头"><a href="#8-2-响应头" class="headerlink" title="8.2 响应头"></a>8.2 响应头</h3><p>  <strong>Location</strong>: <a href="http://www.baidu.com**(服务端需要客户端访问的页面路径)/">http://www.baidu.com**(服务端需要客户端访问的页面路径)</a>** </p>
<p>  <strong>Server</strong>:apache tomcat(服务端的Web服务端名)</p>
<p>  Content-Encoding: gzip(服务端能够发送压缩编码类型) </p>
<p>  Content-Length: 80(服务端发送的压缩数据的长度) </p>
<p>  Content-Language: zh-cn(服务端发送的语言类型) </p>
<p>  <strong>Content-Type</strong>: text/html; charset=GB2312**(服务端发送数据的类型及采用的编码方式)**</p>
<p>  Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT(服务端对该资源最后修改的时间)</p>
<p>  <strong>Set-Cookie</strong>:SS=Q0=5Lb_nQ; path=/search(<strong>服务端发送到客户端的暂存数据)</strong></p>
<p><strong>强缓存</strong>响应头：</p>
<ul>
<li><p>Expires: 服务器返回该请求的结果缓存的<strong>到期时间</strong></p>
</li>
<li><p>Cache-Control: 默认取值为<strong>private</strong>（所有内容只有客户端可以缓存）</p>
<p><strong>Connection</strong>: close(1.0)/(1.1)Keep-Alive**(维护客户端和服务端的连接关系)**  </p>
<p>Date: Tue, 11 Jul 2000 18:23:51 GMT(服务端响应客户端的时间)</p>
</li>
</ul>
<p><strong>在服务器响应客户端的时候，带上Access-Control-Allow-Origin头信息，解决跨域的一种方法。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// * ：允许所有ip地址发送请求</span></span><br><span class="line">res.header(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>,<span class="string">&#x27;*&#x27;</span>)</span><br></pre></td></tr></table></figure>

<br>

<h2 id="9-HTTP请求方式"><a href="#9-HTTP请求方式" class="headerlink" title="9. HTTP请求方式"></a>9. HTTP请求方式</h2><p>共有<strong>8种</strong>：</p>
<ul>
<li>GET：请求指定页面的信息，返回实体主题，可以传递少量请求参数数据，请求参数数据在URL中</li>
<li>POST：向指定资源<strong>提交数据进行处理请求</strong>，数据包含在请求体中</li>
<li>HEAD：与GET请求类似，<strong>返回的响应没有具体内容</strong>，用户<strong>获取报头</strong></li>
<li>OPTIONS：客户端<strong>查看服务器的性能</strong>请求</li>
<li>PUT：修改请求</li>
<li>DELETE：删除请求</li>
<li>等等</li>
</ul>
<h2 id="10-HTTP-2-0"><a href="#10-HTTP-2-0" class="headerlink" title="10. HTTP 2.0"></a>10. HTTP 2.0</h2><p><strong>http2.0</strong>是基于1999年发布的http1.0之后的首次更新</p>
<ul>
<li><p>相比HTTP1.0<strong>提升了访问速度</strong></p>
</li>
<li><p>允许<strong>多路复用</strong>：同时通过单一的HTTP/2.0 连接<strong>发送多重请求-响应信息</strong>。</p>
<ul>
<li>在http1.1中，浏览器客户端在同一时间，针对同一域名下的<strong>请求有一定数量限制</strong>（连接数量），超过限制会被阻塞。</li>
</ul>
</li>
<li><p><strong>二进制分帧</strong>：HTTP2.0会将所有的传输信息分割为更小的信息或者帧，并对他们进行<strong>二进制编码</strong></p>
</li>
<li><p><strong>首部压缩</strong></p>
</li>
</ul>
<h2 id="11-HTTP状态码"><a href="#11-HTTP状态码" class="headerlink" title="11. HTTP状态码"></a>11. HTTP状态码</h2><ul>
<li>1**：服务器收到请求，需要请求者继续执行操作</li>
<li>2**：成功，请求被接受并处理</li>
<li>3**：重定向，需要进一步操作完成请求</li>
<li>4**：客户端错误，请求包含语法错误或无法完成请求</li>
<li>5**：服务端错误，服务器在请求处理过程中出错</li>
</ul>
<p><strong>200  OK  请求成功。一般用于GET与POST请求</strong></p>
<p>300  Multiple Choices  多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</p>
<p>301  Moved Permanently  永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</p>
<p>302  Found  临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</p>
<p><strong>304  Not Modified  未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</strong></p>
<p><strong>400  Bad Request  客户端错误</strong></p>
<p><strong>401  Unauthorized  请求要求用户的身份认证</strong>(请求一个受保护资源但是没有证书或者证书错误)</p>
<p>403  Forbidden  服务器理解客户端的请求，但是<strong>拒绝执行此请求</strong>(一般用于只在特定时间允许访问的资源)</p>
<p><strong>404  Not Found  服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</strong></p>
<p><strong>500  Internal Server Error  服务器内部错误，无法完成请求</strong></p>
<p><strong>501</strong> Not Implemented  服务器不支持请求的功能，无法完成请求</p>
<p><strong>502</strong> Bad Gateway 作为<strong>网关或者代理工作的服务器</strong>尝试执行请求时，从远程服务器接收到了一个无效的响应(代理与上行服务器之间出现问题)</p>
<p>505  HTTP Version not supported  服务器不支持请求的HTTP协议的版本，无法完成处理</p>
<br>

<h2 id="12-HTTP请求报文和响应报文"><a href="#12-HTTP请求报文和响应报文" class="headerlink" title="12. HTTP请求报文和响应报文"></a>12. HTTP请求报文和响应报文</h2><h3 id="12-1-请求报文"><a href="#12-1-请求报文" class="headerlink" title="12.1 请求报文"></a>12.1 请求报文</h3><p><img data-src="/images/01-http%E5%92%8Chttps%E5%8D%8F%E8%AE%AE/image-20211013170501555.png" alt="image-20211013170501555"></p>
<p><strong>请求行：GET(请求的方式) /newcoder/hello.html(请求的目标资源) HTTP/1.1(请求采用的协议和版本号)</strong></p>
<p>GET请求的请求参数存放于URL中，<strong>没有报文主体</strong></p>
<p>POST请求的请求参数<strong>存放于报文体中</strong></p>
<h3 id="12-2-响应报文"><a href="#12-2-响应报文" class="headerlink" title="12.2 响应报文"></a>12.2 响应报文</h3><p><img data-src="/images/01-http%E5%92%8Chttps%E5%8D%8F%E8%AE%AE/image-20211013170539574.png" alt="image-20211013170539574"></p>
<p><strong>状态行：HTTP/1.1(响应采用的协议和版本号) 200(状态码) OK(描述信息)</strong></p>
]]></content>
      <categories>
        <category>HTMLandCss</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>01-jQuery基本使用</title>
    <url>/2022/04/13/01-jQuery%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="jQuery基本使用"><a href="#jQuery基本使用" class="headerlink" title="jQuery基本使用"></a>jQuery基本使用</h1><p>Query是**快速简洁的一个js库(**本质就是一个js文件,将原生js的DOM操作等封装在一个js文件中) </p>
<p>j代表js,query代表查询,jQuery即查询js。学习jQuery就是学习<strong>如何调用封装在jQuery中的函数</strong></p>
<h2 id="jQuery顶级对象"><a href="#jQuery顶级对象" class="headerlink" title="$jQuery顶级对象"></a>$jQuery顶级对象</h2><p>$是jQuery的别称(可以互换) $是jQuery的顶级对象(就像window是原生jsBOM的顶级对象)</p>
<h2 id="jQuery入口函数"><a href="#jQuery入口函数" class="headerlink" title="jQuery入口函数"></a>jQuery入口函数</h2><p><code>$(function()&#123;jQuery代码&#125;)</code></p>
<p>这种形式相当于原生js的DOMContentLoaded事件</p>
<p>在<strong>DOM主要元素加载完后执行jq代码</strong></p>
<h2 id="jq选择器"><a href="#jq选择器" class="headerlink" title="jq选择器"></a>jq选择器</h2><p><code>$(&quot;选择器&quot;)</code> ：即为一个jq对象</p>
<ul>
<li>选择器：可以是类选择器（<code>.class1</code>）,id选择器（<code>#id1</code>）和元素选择器等</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.$是jQuery的别称(可以互换) $是jQuery的顶级对象(就像window是原生jsBOM的顶级对象)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.jQuery入口函数</span></span><br><span class="line">        <span class="comment">//$(function()&#123;jQuery代码&#125;)这种形式相当于原生js的DOMContentLoaded</span></span><br><span class="line">        <span class="comment">//在DOM主要元素加载完毕后再执行</span></span><br><span class="line">        $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//3.利用$把元素包装成jQuery对象,就可以调用jQuery的方法</span></span><br><span class="line">            $(<span class="string">&quot;div&quot;</span>).hide();</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="jQuery的链式调用和隐式迭代"><a href="#jQuery的链式调用和隐式迭代" class="headerlink" title="jQuery的链式调用和隐式迭代"></a>jQuery的链式调用和隐式迭代</h2><p><strong>隐式迭代</strong>：jq选择器可以依次选中<strong>符合条件的多个元素</strong>（存储为伪数组）</p>
<p>对这个存储了多个元素的jq对象调用方法时，会<strong>对伪数组中的每个一元素调用方法</strong></p>
<ul>
<li>不需要手动进行循环遍历元素，这就称之为<strong>隐式迭代</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将所有4个div的文字颜色都改为红色</span></span><br><span class="line">        $(<span class="string">&quot;div&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure>

<br>

<p><strong>链式调用</strong>：对于多个jq方法，可以<strong>在jq对象后依次调用</strong>，而<strong>不用写多行代码</strong></p>
<p>原理：jq方法的<strong>返回值是一个jq对象</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            $(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">//1.通常编程派他思想写法(写两条语句)</span></span><br><span class="line">                <span class="comment">// $(this).css(&quot;color&quot;,&quot;red&quot;);</span></span><br><span class="line">                <span class="comment">// $(this).siblings().css(&quot;color&quot;,&quot;&quot;);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//2.链式编程写法(将上面两句有共同点的语句合成一句)(减少代码量)</span></span><br><span class="line">                <span class="comment">//将点击的按钮变为红色,并且将其兄弟元素颜色设置为空</span></span><br><span class="line">                $(<span class="built_in">this</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>).siblings().css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>01-JS严格模式</title>
    <url>/2022/12/04/01-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><p>ES5中加入了严格模式(IE10以上开始支持)</p>
<p>​    严格模式(strict mode)对<strong>JS语法做出了限制性规范</strong></p>
<p>​    1.消除了JS语法的不合理不严谨之处</p>
<p>​    2.消除了代码运行的不安全之处</p>
<p>​    3.提高编译器效率</p>
<p>​    4.禁用了在ECMAScript未来版本中可能会定义的语法，为未来新版本JS做好铺垫</p>
<p>  <strong>严格模式对正常语义做出了更改</strong></p>
<ol>
<li>严格模式通过<strong>抛出错误</strong>来消除了一些原有<strong>静默错误</strong>。</li>
<li>严格模式修复了一些导致 JavaScript引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下<strong>运行得更快</strong>。</li>
<li>  比如在ES6中<strong>新增的一些保留字</strong>如class、export等在ES5<strong>严格模式中不能用作变量名</strong></li>
</ol>
<span id="more"></span>

<h2 id="开启严格模式"><a href="#开启严格模式" class="headerlink" title="开启严格模式"></a>开启严格模式</h2><ul>
<li>使用<code>&quot;use srtict&quot;</code>语句开启<ul>
<li>在整个脚本开启<ul>
<li>直接书写<code>&quot;use srtict&quot;</code></li>
<li>在自动执行函数中书写<code>&quot;use srtict&quot;</code></li>
</ul>
</li>
<li>在函数内部开启</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="comment">//开启严格模式(整个脚本或者函数内部)</span></span><br><span class="line">        <span class="comment">//1.给整个脚本开启严格模式</span></span><br><span class="line"><span class="meta">        &quot;use strict&quot;</span>; <span class="comment">//开启严格模式</span></span><br><span class="line">        <span class="comment">//下面的语句都要按照严格模式书写</span></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="comment">//可以在自动执行函数中开启 也相当于在整个script中开启</span></span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">            &quot;use strict&quot;</span>;<span class="comment">//开启严格模式</span></span><br><span class="line">            <span class="comment">//下面的语句都要按照严格模式书写</span></span><br><span class="line">        &#125;)()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="comment">//2.给某个函数单独开启严格模式</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">            &quot;use strict&quot;</span>;<span class="comment">//给fn()函数开启严格模式</span></span><br><span class="line">            <span class="comment">//里面的代码使用严格模式</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用普通模式</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//使用普通模式</span></span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="开启严格模式后的实际变化"><a href="#开启严格模式后的实际变化" class="headerlink" title="开启严格模式后的实际变化"></a>开启严格模式后的实际变化</h2><ol>
<li>变量必须<strong>先声明再使用</strong></li>
<li>不能随意删除已经声明的变量</li>
<li>严格模式下<strong>普通函数的this指向是undefined</strong></li>
<li>构造函数<strong>不使用new调用</strong> 构造函数中的this会报错 此时this指向undefined</li>
<li><strong>定时器的this指向仍然是window</strong></li>
<li>函数中的<strong>形参不允许重名</strong>（正常模式中允许重名但是前面参数值会被后面重名参数覆盖）</li>
<li>严格模式<strong>不允许在非函数的块级作用域(ES6引入块级作用域)中声明函数</strong></li>
</ol>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>01-什么是Node</title>
    <url>/2021/04/13/01-%E4%BB%80%E4%B9%88%E6%98%AFNode.js/</url>
    <content><![CDATA[<h1 id="1-Node-js介绍"><a href="#1-Node-js介绍" class="headerlink" title="1.Node.js介绍"></a>1.Node.js介绍</h1><h2 id="1-1学习Node-js的目的"><a href="#1-1学习Node-js的目的" class="headerlink" title="1.1学习Node.js的目的"></a>1.1学习Node.js的目的</h2><ul>
<li><p>用来<strong>操作使用WEB后台服务器</strong>(能够实现同样功能的后台语言还有java、python、php等)</p>
</li>
<li><p>了解后台服务器才能更好的与后端开发人员协同开发</p>
</li>
<li><p>生态系统活跃，有许多开源库可以使用</p>
</li>
<li><p>前端开发工具大多基于Node开发</p>
</li>
<li><p>学习Node.js实际上就是在学习<strong>WEB服务器开发</strong></p>
</li>
</ul>
<span id="more"></span>

<h2 id="1-2什么是Node-js"><a href="#1-2什么是Node-js" class="headerlink" title="1.2什么是Node.js"></a>1.2什么是Node.js</h2><p>Node.js官网<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p>
<p>官网对于Node.js的描述：</p>
<ul>
<li><p>Node.js® is a JavaScript runtime built on <a href="https://v8.dev/">Chrome’s V8 JavaScript engine</a>.</p>
<ul>
<li><p>Node.js是一个基于Chrome V8引擎的<strong>javaScript运行环境</strong></p>
</li>
<li><p>基于Chrome V8引擎</p>
<ul>
<li>代码只是具有特定格式的字符串</li>
<li>引擎可以帮我们去解释执行这些代码</li>
<li>Google Chrome 的V8引擎是当前公认的解释执行JavaScript最快的</li>
<li>Node.js的作者把Google Chrome的<strong>V8引擎移植出来</strong>，开发了一个<strong>独立的JavaScript运行环境</strong></li>
</ul>
</li>
<li><p>Node.js<strong>不是一门语言</strong></p>
</li>
<li><p>Node.js<strong>不是库、不是框架</strong></p>
</li>
<li><p>Node.js可以解析执行JavaScript代码</p>
</li>
<li><p>以前只有浏览器可以解释执行JavaScript代码</p>
</li>
<li><p>现在Node.js可以使JavaScript脱离浏览器解释执行</p>
</li>
<li><p>浏览器中的JavaScript</p>
<ul>
<li>ECMAScript(基本的语法)</li>
<li>DOM</li>
<li>BOM</li>
<li>DOM和BOM是浏览器给JavaScript提供的API</li>
</ul>
</li>
<li><p>Node.js中的JavaScript</p>
<ul>
<li><p><strong>不同于原来浏览器中的JavaScript</strong></p>
</li>
<li><p><strong>没有DOM、BOM</strong></p>
</li>
<li><p>由<strong>ECMAScript</strong>以及Node环境提供的一些<strong>附加API</strong>组成</p>
</li>
<li><p>Node.js这个JavaScript运行环境为JavaScript提供了一些服务器级别的操作API(应用编程接口)</p>
<ul>
<li>例如文件读写</li>
<li>网络服务构建</li>
<li>网络通信</li>
<li>http服务器等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Node.js uses an event-driven,non-blocking I/O model that makes it lightweight and efficient.</p>
<ul>
<li><p>Node.js的<strong>特性</strong></p>
</li>
<li><p>1、event-driven 事件驱动</p>
</li>
<li><p>2、non-blocking I/O model 无阻塞的I/O模组 (异步)</p>
</li>
<li><p>lightweight and efficient 轻量化和高效的</p>
</li>
</ul>
</li>
<li><p>Node.js’ package ecosystem,npm,is the largest ecosystem of open source libraries in the world.</p>
<ul>
<li>Node.js包生态系统——npm，是世界上最大的开源库生态系统</li>
<li>绝大多数JavaScript相关的包(第三方包等)都存放在npm上，为了让开发人员更方便的下载使用</li>
<li>例如使用 <code>npm install jquery</code>就可以下载jQuery的npm包</li>
</ul>
</li>
</ul>
<h2 id="1-3Node-js能做什么"><a href="#1-3Node-js能做什么" class="headerlink" title="1.3Node.js能做什么"></a>1.3Node.js能做什么</h2><ul>
<li>WEB服务器后台</li>
<li>命令行工具<ul>
<li>npm(Node开发)</li>
<li>git(C语言开发)</li>
<li>hexo(Node开发)</li>
<li>。。。</li>
</ul>
</li>
<li>对于前端工程师来说，接触Node最多的就是它的命令行工具<ul>
<li>主要是使用别人开发的第三方命令行工具<ul>
<li>webpack</li>
<li>gulp</li>
<li>。。。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-4学习资源"><a href="#1-4学习资源" class="headerlink" title="1.4学习资源"></a>1.4学习资源</h2><ul>
<li><p>《深入浅出Node.js》</p>
<ul>
<li>作者：朴(piao)灵</li>
<li>偏理论、没有实例性内容</li>
<li>对于理解底层原理有帮助</li>
<li>结合其他实例来学习更好</li>
</ul>
</li>
<li><p>《Node.js权威指南》</p>
<ul>
<li>API讲解</li>
<li>没有实例</li>
</ul>
</li>
<li><p>CNODE社区：<a href="https://cnodejs.org/">https://cnodejs.org</a></p>
<ul>
<li>其中新手入门有一些参考资料</li>
</ul>
</li>
</ul>
<h2 id="1-5学习Node-js得到什么"><a href="#1-5学习Node-js得到什么" class="headerlink" title="1.5学习Node.js得到什么"></a>1.5学习Node.js得到什么</h2><ul>
<li><p>操作使用WEB服务器后台</p>
</li>
<li><p>B/S编程模型</p>
<ul>
<li>Browser-Server 浏览器-服务器模型</li>
<li>back-end 后端</li>
<li>任何服务器端技术这种B/S编程模型都是一样的</li>
</ul>
</li>
<li><p>Node只是作为我们学习这种B/S编程模型的工具</p>
</li>
<li><p>模块化编程</p>
<ul>
<li>Node中可以像 <code>@import()</code>一样引用加载JavaScript脚本文件</li>
</ul>
</li>
<li><p>Node常用API</p>
</li>
<li><p>异步编程</p>
<ul>
<li>promise</li>
<li>回调函数</li>
<li>async</li>
<li>generator</li>
</ul>
</li>
<li><p>Express Web开发框架</p>
</li>
<li><p>ES6(穿插讲解)</p>
</li>
<li><p>为以后学习Vue，React，angular前端框架打基础</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序简介</title>
    <url>/2022/11/27/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="小程序简介"><a href="#小程序简介" class="headerlink" title="小程序简介"></a>小程序简介</h1><h2 id="1-小程序与普通网页区别"><a href="#1-小程序与普通网页区别" class="headerlink" title="1. 小程序与普通网页区别"></a>1. 小程序与普通网页区别</h2><p>1.运行环境不同</p>
<ul>
<li>普通网页在浏览器，小程序在微信环境</li>
</ul>
<p>2.使用的API不同</p>
<ul>
<li>微信小程序不能调用DOM及BOM的API</li>
<li>小程序可以使用微信提供的一些API<ul>
<li>扫码</li>
<li>定位</li>
<li>支付</li>
</ul>
</li>
</ul>
<p>3.开发流程不同</p>
<ul>
<li>微信小程序开发流程<ul>
<li>申请开发账号</li>
<li>安装开发者工具</li>
<li>创建和配置小程序项目</li>
</ul>
</li>
</ul>
<br>

<span id="more"></span>

<h2 id="2-小程序项目结构"><a href="#2-小程序项目结构" class="headerlink" title="2. 小程序项目结构"></a>2. 小程序项目结构</h2><p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220124172505701.png" alt="image-20220124172505701"></p>
<h3 id="2-1-小程序页面组成部分"><a href="#2-1-小程序页面组成部分" class="headerlink" title="2.1 小程序页面组成部分"></a>2.1 小程序页面组成部分</h3><p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220124172954051.png" alt="image-20220124172954051"></p>
<br>

<h3 id="2-2-JSON配置文件"><a href="#2-2-JSON配置文件" class="headerlink" title="2.2 JSON配置文件"></a>2.2 JSON配置文件</h3><p><code>JSON</code>在实际开发中总是以<strong>配置文件</strong>的形式出现，通过不同<code>JSON</code>文件可以对项目进行不同级别的配置。</p>
<p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220124173444518.png" alt="image-20220124173444518"></p>
<h4 id="2-2-1-app-json配置文件"><a href="#2-2-1-app-json配置文件" class="headerlink" title="2.2.1 app.json配置文件"></a>2.2.1 <code>app.json</code>配置文件</h4><p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220124173743798.png" alt="image-20220124173743798"></p>
<ul>
<li><code>&quot;style&quot;: &quot;v2&quot;</code> 意为使用最新的样式版本，若需要使用旧版样式，删除<code>style</code>字段即可。</li>
</ul>
<h4 id="2-2-2-project-config-json配置文件"><a href="#2-2-2-project-config-json配置文件" class="headerlink" title="2.2.2 project.config.json配置文件"></a>2.2.2 <code>project.config.json</code>配置文件</h4><p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220124174215275.png" alt="image-20220124174215275"></p>
<ul>
<li>setting中的字段与<strong>本地设置中的复选框</strong>对应</li>
</ul>
<p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220124174505118.png" alt="image-20220124174505118"></p>
<h4 id="2-2-3-sitemap-json配置文件"><a href="#2-2-3-sitemap-json配置文件" class="headerlink" title="2.2.3 sitemap.json配置文件"></a>2.2.3 <code>sitemap.json</code>配置文件</h4><p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220124175129691.png" alt="image-20220124175129691"></p>
<ul>
<li><code>action</code>字段的值取<code>disallow</code>时页面不允许被索引</li>
<li><code>page</code>字段的值代表哪些页面应用规则（*代表所有页面）</li>
</ul>
<h4 id="2-2-4-页面的json配置文件"><a href="#2-2-4-页面的json配置文件" class="headerlink" title="2.2.4 页面的json配置文件"></a>2.2.4 页面的json配置文件</h4><p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220124180031996.png" alt="image-20220124180031996"></p>
<br>

<h3 id="2-3-新建小程序页面"><a href="#2-3-新建小程序页面" class="headerlink" title="2.3 新建小程序页面"></a>2.3 新建小程序页面</h3><p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220124182649023.png" alt="image-20220124182649023"></p>
<br>

<h3 id="2-4-修改项目首页"><a href="#2-4-修改项目首页" class="headerlink" title="2.4 修改项目首页"></a>2.4 修改项目首页</h3><p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220124182952790.png" alt="image-20220124182952790"></p>
<br>

<h3 id="2-5-WXML与HTML的区别"><a href="#2-5-WXML与HTML的区别" class="headerlink" title="2.5 WXML与HTML的区别"></a>2.5 WXML与HTML的区别</h3><p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220124183342910.png" alt="image-20220124183342910"></p>
<p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220124183458024.png" alt="image-20220124183458024"></p>
<h3 id="2-6-WXSS和CSS的区别"><a href="#2-6-WXSS和CSS的区别" class="headerlink" title="2.6 WXSS和CSS的区别"></a>2.6 WXSS和CSS的区别</h3><p><code>WXSS</code>是微信小程序的样式文件，用于描述<code>WXML</code>的组件样式。</p>
<p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220124184158571.png" alt="image-20220124184158571"></p>
<br>

<h3 id="2-7-小程序中js文件分类"><a href="#2-7-小程序中js文件分类" class="headerlink" title="2.7 小程序中js文件分类"></a>2.7 小程序中js文件分类</h3><p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220124185952057.png" alt="image-20220124185952057"></p>
<h2 id="3-宿主环境"><a href="#3-宿主环境" class="headerlink" title="3. 宿主环境"></a>3. 宿主环境</h2><p>宿主环境：程序运行所必须的依赖环境。（例如安卓和iOS）</p>
<p>小程序的宿主环境：手机微信</p>
<h3 id="3-1-小程序宿主环境包含的内容"><a href="#3-1-小程序宿主环境包含的内容" class="headerlink" title="3.1 小程序宿主环境包含的内容"></a>3.1 小程序宿主环境包含的内容</h3><p>即手机微信对小程序的支持</p>
<p><strong>1.通信模型</strong></p>
<p><strong>2.运行机制</strong></p>
<p><strong>3.组件</strong></p>
<p><strong>4.API</strong></p>
<br>

<h3 id="3-2-通信模型"><a href="#3-2-通信模型" class="headerlink" title="3.2 通信模型"></a>3.2 通信模型</h3><h4 id="3-2-1-通信主体"><a href="#3-2-1-通信主体" class="headerlink" title="3.2.1 通信主体"></a>3.2.1 通信主体</h4><p>主体是<strong>渲染层</strong>和<strong>逻辑层</strong></p>
<ul>
<li>WXML模板和WXSS样式工作在渲染层</li>
<li>JS脚本工作在逻辑层</li>
</ul>
<h4 id="3-2-2-两种通信模型"><a href="#3-2-2-两种通信模型" class="headerlink" title="3.2.2 两种通信模型"></a>3.2.2 两种通信模型</h4><ul>
<li>渲染层和逻辑层之间的通信</li>
<li>逻辑层和第三方服务器的通信</li>
</ul>
<p>两种模型均由微信客户端负责转发</p>
<p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220126145840025.png" alt="image-20220126145840025"></p>
<h3 id="3-3-运行机制"><a href="#3-3-运行机制" class="headerlink" title="3.3 运行机制"></a>3.3 运行机制</h3><h4 id="3-3-1-启动过程"><a href="#3-3-1-启动过程" class="headerlink" title="3.3.1 启动过程"></a>3.3.1 启动过程</h4><p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220126151145704.png" alt="image-20220126151145704"></p>
<h4 id="3-3-2-页面渲染过程"><a href="#3-3-2-页面渲染过程" class="headerlink" title="3.3.2 页面渲染过程"></a>3.3.2 页面渲染过程</h4><p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220126151236737.png" alt="image-20220126151236737"></p>
<h3 id="3-4-组件"><a href="#3-4-组件" class="headerlink" title="3.4 组件"></a>3.4 组件</h3><h4 id="3-4-1-组件分类"><a href="#3-4-1-组件分类" class="headerlink" title="3.4.1 组件分类"></a>3.4.1 组件分类</h4><p>官方把小程序组件分为<strong>9类</strong></p>
<p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220126151612014.png" alt="image-20220126151612014"></p>
<h4 id="3-4-2-常见的视图容器类组件"><a href="#3-4-2-常见的视图容器类组件" class="headerlink" title="3.4.2 常见的视图容器类组件"></a>3.4.2 常见的视图容器类组件</h4><p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220126151854219.png" alt="image-20220126151854219"></p>
<h5 id="3-4-2-1-view组件基本使用"><a href="#3-4-2-1-view组件基本使用" class="headerlink" title="3.4.2.1 view组件基本使用"></a>3.4.2.1 view组件基本使用</h5><p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220126153610454.png" alt="image-20220126153610454"></p>
<h5 id="3-4-2-2-scroll-view组件基本使用"><a href="#3-4-2-2-scroll-view组件基本使用" class="headerlink" title="3.4.2.2 scroll-view组件基本使用"></a>3.4.2.2 scroll-view组件基本使用</h5><p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220126154131677.png" alt="image-20220126154131677"></p>
<h5 id="3-4-2-3-swiper组件基本使用"><a href="#3-4-2-3-swiper组件基本使用" class="headerlink" title="3.4.2.3 swiper组件基本使用"></a>3.4.2.3 swiper组件基本使用</h5><p>实现轮播图的基本功能</p>
<p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220126163118822.png" alt="image-20220126163118822"></p>
<h5 id="3-4-2-4-swiper组件常用属性"><a href="#3-4-2-4-swiper组件常用属性" class="headerlink" title="3.4.2.4 swiper组件常用属性"></a>3.4.2.4 swiper组件常用属性</h5><p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220126162926685.png" alt="image-20220126162926685"></p>
<br>

<h4 id="3-4-3-基础内容组件"><a href="#3-4-3-基础内容组件" class="headerlink" title="3.4.3 基础内容组件"></a>3.4.3 基础内容组件</h4><p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220127083102878.png" alt="image-20220127083102878"></p>
<h5 id="3-4-3-1-text组件基本使用"><a href="#3-4-3-1-text组件基本使用" class="headerlink" title="3.4.3.1 text组件基本使用"></a>3.4.3.1 text组件基本使用</h5><p>实现长按选中效果</p>
<p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220127083117251.png" alt="image-20220127083117251"></p>
<h5 id="3-4-3-2-rich-text组件基本使用"><a href="#3-4-3-2-rich-text组件基本使用" class="headerlink" title="3.4.3.2 rich-text组件基本使用"></a>3.4.3.2 rich-text组件基本使用</h5><p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220127083158345.png" alt="image-20220127083158345"></p>
<h4 id="3-4-4-其他基本组件"><a href="#3-4-4-其他基本组件" class="headerlink" title="3.4.4 其他基本组件"></a>3.4.4 其他基本组件</h4><p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220127083316202.png" alt="image-20220127083316202"></p>
<h5 id="3-4-4-1-button按钮基本使用"><a href="#3-4-4-1-button按钮基本使用" class="headerlink" title="3.4.4.1 button按钮基本使用"></a>3.4.4.1 button按钮基本使用</h5><p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220127083602904.png" alt="image-20220127083602904"></p>
<h5 id="3-4-4-2-image图片组件基本使用"><a href="#3-4-4-2-image图片组件基本使用" class="headerlink" title="3.4.4.2 image图片组件基本使用"></a>3.4.4.2 image图片组件基本使用</h5><p>image组件有默认的 <code>宽300px,高240px</code></p>
<p><strong>空的image标签</strong>也会占据位置</p>
<p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220127084033671.png" alt="image-20220127084033671"></p>
<br>

<p>使用image标签的<strong>mode属性</strong>对图片进行<strong>裁剪和缩放</strong></p>
<p><img data-src="/images/01-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E4%BB%8B/image-20220127084217584.png" alt="image-20220127084217584"></p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>01-树相关算法</title>
    <url>/2021/09/12/01-%E6%A0%91%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="树相关算法"><a href="#树相关算法" class="headerlink" title="树相关算法"></a>树相关算法</h1><h2 id="1-树的先中后序遍历"><a href="#1-树的先中后序遍历" class="headerlink" title="1.树的先中后序遍历"></a>1.树的先中后序遍历</h2><span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单二叉树为&#123;1,2,3&#125;</span></span><br><span class="line"><span class="keyword">var</span> root = &#123;</span><br><span class="line">    val:<span class="number">1</span>,</span><br><span class="line">    left:&#123;</span><br><span class="line">        val:<span class="number">2</span>,</span><br><span class="line">        left:<span class="literal">null</span>,</span><br><span class="line">        right:<span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    right:&#123;</span><br><span class="line">        val:<span class="number">3</span>,</span><br><span class="line">        left:<span class="literal">null</span>,</span><br><span class="line">        right:<span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归完成</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">threeOrder</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = []</span><br><span class="line">    <span class="keyword">let</span> pre = []</span><br><span class="line">    <span class="keyword">let</span> mid = []</span><br><span class="line">    <span class="keyword">let</span> next = []</span><br><span class="line">    <span class="comment">//先序</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> []</span><br><span class="line">        pre.push(root.val)</span><br><span class="line">        first(root.left)</span><br><span class="line">        first(root.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">middle</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> []</span><br><span class="line">        middle(root.left)</span><br><span class="line">        mid.push(root.val)</span><br><span class="line">        middle(root.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">nextS</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> []</span><br><span class="line">        nextS(root.left)</span><br><span class="line">        nextS(root.right)</span><br><span class="line">        next.push(root.val)</span><br><span class="line">    &#125;</span><br><span class="line">    first(root)</span><br><span class="line">    middle(root)</span><br><span class="line">    nextS(root)</span><br><span class="line">    result[<span class="number">0</span>]=pre</span><br><span class="line">    result[<span class="number">1</span>]=mid</span><br><span class="line">    result[<span class="number">2</span>]=next</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(threeOrder(root));</span><br></pre></td></tr></table></figure>

<br>

<h2 id="2-树的层序遍历"><a href="#2-树的层序遍历" class="headerlink" title="2.树的层序遍历"></a>2.树的层序遍历</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//节点格式</span></span><br><span class="line"><span class="comment">// * function TreeNode(x) &#123;</span></span><br><span class="line"><span class="comment">//     *   this.val = x;</span></span><br><span class="line"><span class="comment">//     *   this.left = null;</span></span><br><span class="line"><span class="comment">//     *   this.right = null;</span></span><br><span class="line"><span class="comment">//     * &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入     * @param root TreeNode类 </span></span><br><span class="line"><span class="comment">//      * @return int整型二维数组</span></span><br><span class="line"><span class="comment">//      或者</span></span><br><span class="line"><span class="comment">//      * @return int整型一维数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//循环实现层序遍历</span></span><br><span class="line"><span class="comment">//输出一个二维数组，每一个元素为一层的遍历数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">levelOrder</span>(<span class="params"> root </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">let</span> now = [root]    <span class="comment">//当前正在遍历层使用的数组</span></span><br><span class="line">    <span class="keyword">let</span> temp = []       <span class="comment">//下一层节点 因为每一层用一个数组保存所以多用一个数组</span></span><br><span class="line">    <span class="keyword">let</span> res = []    <span class="comment">//当前遍历层结果</span></span><br><span class="line">    <span class="keyword">while</span>(now.length &gt; <span class="number">0</span> || temp.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(now.length == <span class="number">0</span>)&#123;</span><br><span class="line">            result.push(res)</span><br><span class="line">            now = temp</span><br><span class="line">            temp = []</span><br><span class="line">            res = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> node = now.shift()</span><br><span class="line">        <span class="keyword">if</span>(node)&#123;</span><br><span class="line">            res.push(node.val)</span><br><span class="line">            temp.push(node.left)</span><br><span class="line">            temp.push(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环实现 </span></span><br><span class="line"><span class="comment">//结果输出为一维数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">levelOrder</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> result</span><br><span class="line">    res.push(root)</span><br><span class="line">    <span class="keyword">while</span>(res.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = res.shift()</span><br><span class="line">        result.push(node.val)</span><br><span class="line">        <span class="keyword">if</span>(node.left) res.push(node.left)</span><br><span class="line">        <span class="keyword">if</span>(node.right) res.push(node.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归实现 输出二维数组</span></span><br><span class="line"><span class="comment">//使用先序遍历的流程 通过判断层数索引index与结果数组的大小来确定当前节点放在哪一层数组中</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [], index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">index, root</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">        <span class="comment">//例如index=1 &gt;= res.length =1 说明当前遍历的节点在第二层，而结果数组中只保存了第一层的数组，需要新建数组</span></span><br><span class="line">      <span class="keyword">if</span> (index &gt;= res.length) res[index] = []</span><br><span class="line">      res[index].push(root.val)</span><br><span class="line">      dfs(index + <span class="number">1</span>, root.left)</span><br><span class="line">      dfs(index + <span class="number">1</span>, root.right)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(index, root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟DOM</title>
    <url>/2022/11/27/01-%E8%99%9A%E6%8B%9FDOM/</url>
    <content><![CDATA[<h1 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h1><p>React内部实现了虚拟DOM</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在浏览器中对DOM树进行结构上的修改往往会导致<strong>大量DOM元素的重绘重排</strong>(即使实际修改的DOM元素很少，也会发生大量DOM元素的重绘重排)，这就浪费了性能。</p>
<span id="more"></span>

<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>实现DOM节点的按需更新，<strong>只更新那些被修改的DOM元素</strong>，对于没有被修改的DOM元素不必强制更新。</p>
<h2 id="解决办法的实现"><a href="#解决办法的实现" class="headerlink" title="解决办法的实现"></a>解决办法的实现</h2><p>拿到页面更新前内存中的<strong>旧DOM树</strong>，再拿到页面更新前新渲染出来的<strong>新DOM树</strong>，对新旧两颗DOM树进行比较，以此<strong>找出需要修改的DOM元素来进行按需更新</strong>。</p>
<h2 id="虚拟DOM的出现"><a href="#虚拟DOM的出现" class="headerlink" title="虚拟DOM的出现"></a>虚拟DOM的出现</h2><p>浏览器JS<strong>并没有这样的API来实现</strong> 得到新旧两棵DOM树</p>
<p><span style="color:red;">我们可以通过模拟的方式得到这两棵DOM树，这时虚拟DOM就出现了</span></p>
<br>

<h2 id="虚拟DOM的实现"><a href="#虚拟DOM的实现" class="headerlink" title="虚拟DOM的实现"></a>虚拟DOM的实现</h2><p>虚拟DOM实际上是<strong>使用JS的对象</strong>来模拟DOM节点</p>
<p>例如一个DOM节点</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">P</span> <span class="attr">title</span>=<span class="string">&#x27;nihao&#x27;</span>&gt;</span></span><br><span class="line">    这是一个p标签</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用JS对象模拟的结果为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Vnode = &#123;</span><br><span class="line">	tagName:<span class="string">&#x27;p&#x27;</span>,		<span class="comment">//标签名</span></span><br><span class="line">	attrs:&#123;				<span class="comment">//属性</span></span><br><span class="line">		title:<span class="string">&#x27;nihao&#x27;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	childrens:[			<span class="comment">//此DOM节点的子节点数组</span></span><br><span class="line">		<span class="string">&#x27;这是一个p标签&#x27;</span>,	<span class="comment">//文本节点</span></span><br><span class="line">		&#123;				<span class="comment">//span标签 子节点</span></span><br><span class="line">			tagName:<span class="string">&#x27;span&#x27;</span></span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时使用JS模拟的虚拟DOM节点通过<code>childrens</code>数组实现了<strong>嵌套关系</strong>，就模拟出了一棵DOM树(虚拟DOM)。</p>
<p><img data-src="/images/Untitled/image-20220331103122147.png" alt="image-20220331103122147"></p>
<p>此时通过新旧两颗虚拟DOM树的比较，就可以<strong>找出要修改的DOM节点</strong>进行按需修改。</p>
<h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>使用JS对象来模拟DOM树</p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>实现DOM节点的<strong>高效更新</strong></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>02-01-系统核心模块</title>
    <url>/2021/04/15/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="系统-核心-模块"><a href="#系统-核心-模块" class="headerlink" title="系统(核心)模块"></a>系统(核心)模块</h1><h2 id="1-fs模块"><a href="#1-fs模块" class="headerlink" title="1.fs模块"></a>1.fs模块</h2><p>文件系统file system模块</p>
<h3 id="1-1-fs-readFile-方法"><a href="#1-1-fs-readFile-方法" class="headerlink" title="1.1 fs.readFile()方法"></a>1.1 fs.readFile()方法</h3><p>读取文件数据方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">&quot;文件路径/文件名&quot;</span>[,<span class="string">&quot;文件编码格式&quot;</span>],callback)</span><br></pre></td></tr></table></figure>

<p>文件路径：文件存放路径</p>
<span id="more"></span>

<p>文件编码格式：utf-8等</p>
<p>callback回调函数：</p>
<ul>
<li>有两个参数err和data<ul>
<li>err错误对象<ul>
<li>如果读取出错则err为错误对象</li>
<li>如果正确则err为null</li>
</ul>
</li>
<li>data文件数据<ul>
<li>默认以二进制数串的16进制形式保存</li>
<li>如果指定了”文件编码格式“就按照编码格式输出</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;./fs.txt&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;文件读取出错&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;以二进制数串的16进制表示文件数据&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;./fs.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;文件读取出错&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;以utf-8编码格式打印文件数据&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210415211208528.png" alt="image-20210415211208528"></p>
<h3 id="1-2-插入-Nodejs中的回调函数callback"><a href="#1-2-插入-Nodejs中的回调函数callback" class="headerlink" title="1.2(插入)Nodejs中的回调函数callback"></a>1.2(插入)Nodejs中的回调函数callback</h3><p>Nodejs中所有API的回调函数的第一个参数一定是err</p>
<ul>
<li>在发生错误时err为错误对象</li>
<li>正确执行时err为null</li>
</ul>
<p>所以Nodejs中的回调函数又被称为错误优先的回调函数</p>
<h3 id="1-3-fs-writeFile-方法"><a href="#1-3-fs-writeFile-方法" class="headerlink" title="1.3 fs.writeFile()方法"></a>1.3 fs.writeFile()方法</h3><p>写入文件方法</p>
<p>文件不存在时会自动创建</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.writeFile(<span class="string">&#x27;文件路径/文件名&#x27;</span>,<span class="string">&#x27;写入的数据&#x27;</span>,callback)</span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<p>​    程序运行报错时，自动将报错信息写入错误日志(一个文件)中</p>
<p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.writeFile(<span class="string">&#x27;./fs.writeFile.txt&#x27;</span>,<span class="string">&#x27;写入fs.writeFile.txt中的数据&#x27;</span>,<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err!==<span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;写入失败&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;写入成功&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210415212815487.png" alt="image-20210415212815487"></p>
<p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210415212837679.png" alt="image-20210415212837679"></p>
<h2 id="2-path模块"><a href="#2-path模块" class="headerlink" title="2. path模块"></a>2. path模块</h2><p>路径操作</p>
<h3 id="2-1为什么要进行路径拼接"><a href="#2-1为什么要进行路径拼接" class="headerlink" title="2.1为什么要进行路径拼接"></a>2.1为什么要进行路径拼接</h3><p>不同操作系统的路径分隔符不同</p>
<ul>
<li>window使用 / 或 \</li>
<li>Linux只能使用 /</li>
</ul>
<p>Nodejs写的代码可能要在不同的操作系统上使用，所以要明确使用什么路径分隔符</p>
<h3 id="2-2-path-join"><a href="#2-2-path-join" class="headerlink" title="2.2 path.join()"></a>2.2 path.join()</h3><p>路径拼接API</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">path.join(<span class="string">&#x27;路径&#x27;</span>,<span class="string">&#x27;路径&#x27;</span>,...)</span><br></pre></td></tr></table></figure>

<p>这个API会自动检测当前系统并使用合适的分隔符</p>
<p>返回拼接之后的结果</p>
<p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前是windows系统，采用&#x27;\&#x27;作为分隔符</span></span><br><span class="line"><span class="comment">//输出a\b\c.txt</span></span><br><span class="line"><span class="built_in">console</span>.log(path.join(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c.txt&#x27;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210415220350958.png" alt="image-20210415220350958"></p>
<h3 id="2-3相对路径和绝对路径"><a href="#2-3相对路径和绝对路径" class="headerlink" title="2.3相对路径和绝对路径"></a>2.3相对路径和绝对路径</h3><ul>
<li><p>大多数情况使用绝对路径</p>
</li>
<li><p>相对路径有时候相对的是命令行工具的当前目录</p>
</li>
<li><p>读取文件和设置文件时都选择绝对路径</p>
</li>
<li><p>使用__dirname可以获取当前文件所在目录的绝对路径</p>
</li>
</ul>
<h4 id="1-相对路径有时候相对的是命令行工具的当前目录"><a href="#1-相对路径有时候相对的是命令行工具的当前目录" class="headerlink" title="1.相对路径有时候相对的是命令行工具的当前目录"></a>1.相对路径有时候相对的是命令行工具的当前目录</h4><h5 id="1-1命令行工具当前目录与执行的文件所在目录相同时"><a href="#1-1命令行工具当前目录与执行的文件所在目录相同时" class="headerlink" title="1.1命令行工具当前目录与执行的文件所在目录相同时"></a>1.1命令行工具当前目录与执行的文件所在目录相同时</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path=<span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时使用相对路径打开当前目录下的01-path。。。文件</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;./01-path.join.js&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210416110904752.png" alt="image-20210416110904752"></p>
<p>此时在<strong>02-绝对路径和相对路径.js</strong>使用相对路径打开当前目录下的<strong>01-path.join.js</strong>文件</p>
<p>由于命令行工具的当前目录就是执行文件的目录</p>
<p>所以readFile()中<code>./01-path.join.js</code>实际打开的文件为<strong>E:\HTML_CSS_JS学习\nodejs\new\02-核心模块path\01-path.join.js</strong></p>
<p>所以此时使用相对路径不会引起问题</p>
<h5 id="1-2命令行工具当前目录与执行的文件所在目录不同时"><a href="#1-2命令行工具当前目录与执行的文件所在目录不同时" class="headerlink" title="1.2命令行工具当前目录与执行的文件所在目录不同时"></a>1.2命令行工具当前目录与执行的文件所在目录不同时</h5><p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210416111449458.png" alt="image-20210416111449458"></p>
<p>此时命令行工具的当前目录为E:\HTML_CSS_JS学习\nodejs\new</p>
<p>执行文件所在目录为E:\HTML_CSS_JS学习\nodejs\new\02-核心模块path</p>
<p>两个目录所在位置不同</p>
<p>readFile()方法中的url如果写相对路径，则这个<strong>相对路径就相对于命令行工具目录</strong></p>
<p>此时readFile()中<code>./01-path.join.js</code>实际打开的文件为<strong>E:\HTML_CSS_JS学习\nodejs\new\01-path.join.js</strong></p>
<p>即相对路径相对于命令行工具的当前目录（上图红框）</p>
<p>此时因为找不到<strong>E:\HTML_CSS_JS学习\nodejs\new\01-path.join.js</strong>文件，会报错<code>no such file or directory</code></p>
<p>所以打开或设置文件时使用相对路径是<strong>不安全的</strong>，容易导致错误</p>
<h4 id="2-在require-中的相对路径比较特殊，就是相对于当前执行文件所在的目录"><a href="#2-在require-中的相对路径比较特殊，就是相对于当前执行文件所在的目录" class="headerlink" title="2.在require()中的相对路径比较特殊，就是相对于当前执行文件所在的目录"></a><strong>2.在require()中的相对路径比较特殊，就是相对于当前执行文件所在的目录</strong></h4><h4 id="3-读取文件和设置文件时都选择绝对路径"><a href="#3-读取文件和设置文件时都选择绝对路径" class="headerlink" title="3.读取文件和设置文件时都选择绝对路径"></a>3.读取文件和设置文件时都选择绝对路径</h4><p>nodejs中使用<code>__dirname</code>可以获取当前文件所在目录的绝对路径</p>
<p>使用<code>__dirname</code>和当前文件名进行路径拼接就可以<strong>方便的得到当前文件的绝对路径</strong></p>
<p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210416113339756.png" alt="image-20210416113339756"></p>
<p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210416113325415.png" alt="image-20210416113325415"></p>
<p>此时红框中第一行即为<code>__dirname</code>,当前执行文件所在目录</p>
<p>红框第二行即为拼接后的要打开文件的绝对路径</p>
<p>此时命令行工具目录与执行文件所在目录不同</p>
<p>因为代码使用了绝对路径，不会发生找不到文件的错误</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>02-02-第三方模块</title>
    <url>/2021/04/19/02-02-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h1><p><a href="https://www.npmjs.com/">npmjs.com</a>: 第三方模块的存储和分发仓库</p>
<h2 id="1-第三方模块-nodemon"><a href="#1-第三方模块-nodemon" class="headerlink" title="1.第三方模块 nodemon"></a>1.第三方模块 nodemon</h2><p>nodemon是命令行工具，辅助项目开发</p>
<p>在Node.js中，每次修改文件都需要重新执行文件，比较繁琐</p>
<p>nodemon可以在保存时自动执行文件</p>
<span id="more"></span>

<h3 id="1-2使用"><a href="#1-2使用" class="headerlink" title="1.2使用"></a>1.2使用</h3><ul>
<li><p>安装</p>
<ul>
<li><p><code>npm install nodemon -g</code></p>
</li>
<li><p>命令行工具全局安装使用 -g</p>
</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li>在命令行工具中使用<code>nodemon</code>替代<code>node</code>执行nodejs文件</li>
</ul>
</li>
</ul>
<p><img data-src="/images/02-02-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/image-20210419110644336.png" alt="image-20210419110644336"></p>
<p>执行完文件后会将命令行窗口挂起，等待执行的文件保存，保存文件后会<strong>自动执行文件</strong>，使用Ctrl+C可以退出nodemon</p>
<p>现在在文件中添加一个输出后保存，效果如下</p>
<p><img data-src="/images/02-02-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/image-20210419111005039.png" alt="image-20210419111005039"></p>
<h2 id="2-第三方模块nrm"><a href="#2-第三方模块nrm" class="headerlink" title="2.第三方模块nrm"></a>2.第三方模块nrm</h2><p>nrm(npm registry manager)：npm下载地址切换工具</p>
<p>npm默认下载地址在国外，下载速度较慢，经常断线</p>
<p>nrm可以将下载地址切换为为国内的服务器</p>
<ul>
<li>如阿里巴巴就有这样的服务器，每隔10分钟与官方的node服务器同步一次</li>
<li>使用国内服务器就可以加快下载速度，与使用官方服务器下载的包是一样的</li>
</ul>
<h3 id="2-1下载使用"><a href="#2-1下载使用" class="headerlink" title="2.1下载使用"></a>2.1下载使用</h3><ol>
<li><code>npm install nrm -g </code>   全局安装</li>
<li>使用nrm ls 查询可用下载地址列表<ul>
<li>npm为国外官方下载地址</li>
<li>带*号的是当前选择的下载地址</li>
</ul>
</li>
<li>切换npm下载地址为国内服务器 <code>nrm use 下载地址名称</code><ul>
<li>这里选择阿里巴巴的taobao</li>
</ul>
</li>
</ol>
<p><img data-src="/images/02-02-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/image-20210419113538099.png" alt="image-20210419113538099"></p>
<h2 id="3-第三方模块Gulp"><a href="#3-第三方模块Gulp" class="headerlink" title="3.第三方模块Gulp"></a>3.第三方模块Gulp</h2><p>gulp是一种基于Node平台开发的前端构建工具</p>
<p>可以将机械化的操作编写成任务，在执行时只需要在命令行输入编写好的命令任务就可以。</p>
<p>机器代替手工，加开效率</p>
<h4 id="3-1Gulp能做什么"><a href="#3-1Gulp能做什么" class="headerlink" title="3.1Gulp能做什么"></a>3.1Gulp能做什么</h4><ul>
<li>项目上线时，HTML，CSS，JS代码压缩合并</li>
<li>语法转换(es6转es5，less转css等)</li>
<li>公共文件抽离(修改时只需要修改抽离的文件)</li>
<li>修改文件浏览器自动刷新(之前修改完需要手动刷新)</li>
</ul>
<h4 id="3-2使用Gulp"><a href="#3-2使用Gulp" class="headerlink" title="3.2使用Gulp"></a>3.2使用Gulp</h4><p>下载</p>
<p><code>npm install gulp</code>下载<strong>库文件</strong>，库文件是本地安装，只有当前项目能用</p>
<p>使用</p>
<ol>
<li>在项目根目录下新建gulpfile.js文件(文件名不能随意更改)</li>
<li>重构项目的文件夹结构，src目录下放置源代码文件，dist目录放置构建后的文件</li>
<li>在gulpfile.js中编写任务</li>
<li>在命令行工具中执行gulp任务</li>
</ol>
<h4 id="3-3Gulp提供了哪些编写任务的API"><a href="#3-3Gulp提供了哪些编写任务的API" class="headerlink" title="3.3Gulp提供了哪些编写任务的API"></a>3.3Gulp提供了哪些编写任务的API</h4><ul>
<li>gulp.src()：获取任务要处理的文件</li>
<li>gulp.dest()：输出文件</li>
<li>gulp.task()：建立gulp任务</li>
<li>gulp.watch()：监控文件变化</li>
</ul>
<h4 id="3-4第一个gulp任务"><a href="#3-4第一个gulp任务" class="headerlink" title="3.4第一个gulp任务"></a>3.4第一个gulp任务</h4><p>gulp任务写在gulpfile.js文件中</p>
<p><strong>1.使用 <code>gulp.task(&#39;任务名&#39;,callback</code>)  创建任务</strong></p>
<ul>
<li>两个参数<ul>
<li>任务名，标识任务时使用</li>
<li>回调函数，执行任务就是执行这个函数</li>
</ul>
</li>
</ul>
<p><strong>2.完成复制文件的操作</strong></p>
<ul>
<li>使用 <code>gulp.src(&#39;文件路径/文件名&#39;)</code> 获取文件</li>
<li>在   <code>.pipe()</code> 中写处理代码 </li>
<li><code>.pipe(gulp.dest(&#39;路径/文件名&#39;))</code> 这里将base.css这个文件复制到<code>dist/css</code>文件夹下(css文件夹会自动创建)</li>
</ul>
<p><img data-src="/images/02-02-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/image-20210419193029547.png" alt="image-20210419193029547"></p>
<p><strong>3.执行这个gulp任务需要用到与gulp库文件同名的gulp命令行工具</strong></p>
<p>执行的不是gulpfile.js这个文件，而是文件中的 ‘first’ 任务</p>
<p>所以需要使用gulp命令行工具</p>
<p>1.安装gulp命令行工具</p>
<p><code>npm install gulp-cli -g</code>    命令行工具全局安装</p>
<p>2.使用gulp命令执行gulp任务</p>
<p><code>gulp first</code>  即执行了名为first的任务</p>
<p><img data-src="/images/02-02-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/image-20210419194002502.png" alt="image-20210419194002502"></p>
<ul>
<li><p>输出了<code>我的第一个gulp任务</code></p>
</li>
<li><p>接着在 <code>./dist/css</code>文件夹下也发现了复制的base.css文件</p>
</li>
<li><p>执行成功</p>
</li>
<li><p>Using gulpfile代表使用了gulpfile.js文件</p>
</li>
<li><p>Starting ‘first’ 开始执行first任务</p>
</li>
</ul>
<p><strong>但是在执行时出现了两行红字</strong></p>
<ul>
<li>因为任务可能包含异步代码，所以必须在任务完成执行时发出信号（“异步完成”）。</li>
</ul>
<p>在“Gulp3.x”中，你可以不做这个就离开。如果您没有显式地发出异步完成的信号，那么Gulp只会假定您的任务是同步的，</p>
<p>并且一旦您的任务函数返回，它就完成了。<strong>Gulp4.x在这方面更严格。你必须明确地发出任务完成的信号。</strong></p>
<p>这里我是用的gulp版本为4.0.2，需要明确发出任务完成的信号。</p>
<p><strong>解决办法</strong></p>
<p>在callback回调函数中使用一个done形参，在函数内部的最后加上<code>done()</code> 来标识<strong>异步任务结束</strong></p>
<p><img data-src="/images/02-02-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/image-20210419195502159.png" alt="image-20210419195502159"></p>
<p>此时不再报错</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>Diff算法</title>
    <url>/2022/11/27/02-Diff%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h1><p>虚拟DOM实现后，通过Diff算法来<strong>对新旧两颗DOM进行比较</strong>以找出需要修改的DOM元素</p>
<p><img data-src="/images/02-Diff%E7%AE%97%E6%B3%95/image-20220331104307975.png" alt="image-20220331104307975"></p>
<span id="more"></span>

<h2 id="tree-diff"><a href="#tree-diff" class="headerlink" title="tree diff"></a>tree diff</h2><p>对新旧两颗虚拟DOM树进行<strong>逐层对比</strong>的方式</p>
<h2 id="component-diff"><a href="#component-diff" class="headerlink" title="component diff"></a>component diff</h2><p>逐层对比时，<strong>组件</strong>之间的对比称为 <code>component diff</code></p>
<h2 id="element-diff"><a href="#element-diff" class="headerlink" title="element diff"></a>element diff</h2><p>组件中，每个<strong>元素</strong>之间的对比</p>
<h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>key属性，将<strong>页面DOM节点</strong>和<strong>虚拟DOM节点中的对象</strong>，形成一层关联关系。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML超文本标记语言</title>
    <url>/2022/11/27/02-HTML/</url>
    <content><![CDATA[<h1 id="HTML：超文本标记语言"><a href="#HTML：超文本标记语言" class="headerlink" title="HTML：超文本标记语言"></a>HTML：超文本标记语言</h1><h2 id="1-Doctype-严格模式和混杂模式"><a href="#1-Doctype-严格模式和混杂模式" class="headerlink" title="1.Doctype|严格模式和混杂模式"></a>1.Doctype|严格模式和混杂模式</h2><p>Doctype声明于文档最前面，告诉浏览器<strong>以什么方式渲染页面</strong></p>
<ul>
<li><strong>严格模式</strong>：严格模式的排版和JS 运作模式是 以该浏览器支持的<strong>最高标准</strong>运行</li>
<li><strong>混杂模式</strong>：向后兼容，模拟老式浏览器，防止浏览器无法兼容页面</li>
</ul>
<span id="more"></span>

<h2 id="2-HTML5语义化标签"><a href="#2-HTML5语义化标签" class="headerlink" title="2. HTML5语义化标签"></a>2. HTML5语义化标签</h2><ul>
<li><p>正确的标签包含了正确的内容</p>
</li>
<li><p>语义化标签有：</p>
<ul>
<li><code>&lt;nav&gt;</code>导航条</li>
<li><code>&lt;article&gt;</code>文章</li>
<li><code>&lt;header&gt;</code>页面头部</li>
<li><code>&lt;footer&gt;</code>页面尾部</li>
</ul>
</li>
<li><p>标签有了语义，<strong>提高代码的可读性</strong>，<strong>页面结构更清晰</strong>，<strong>便于开发和维护</strong></p>
</li>
<li><p>遵循W3C标准的团队都遵循这个标准，<strong>减少差异化</strong></p>
</li>
</ul>
<h2 id="3-iframe"><a href="#3-iframe" class="headerlink" title="3. iframe"></a>3. iframe</h2><ul>
<li><p>iframe是<strong>HTML标签/元素</strong></p>
</li>
<li><p>iframe元素会创建包含另一个文档的内联框架</p>
<ul>
<li>通俗的说就是一个网页中内联了一个网页（一个网页内部还有其他网页）</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：请求一个网页的下一个页面的时候,还有 一个网页是一直显示着的</p>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>阻塞主页面onload事件</strong></li>
<li>iframe和主页面共享连接池，而浏览器对相同区域有限制所以会<strong>影响性能</strong></li>
</ul>
]]></content>
      <categories>
        <category>HTMLandCss</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>02-Vue简单案例图书管理</title>
    <url>/2021/09/19/02-Vue%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="Vue图书管理简单案例"><a href="#Vue图书管理简单案例" class="headerlink" title="Vue图书管理简单案例"></a>Vue图书管理简单案例</h1><p><img data-src="/images/02-Vue%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86/image-20210919200854285.png" alt="效果图"></p>
<span id="more"></span>

<h2 id="1-数组更新检测"><a href="#1-数组更新检测" class="headerlink" title="1. 数组更新检测"></a>1. 数组更新检测</h2><p>Vue对于数据的处理默认都是<strong>响应式的</strong>，即修改模板中的数据，视图中显示的数据也会同步变化</p>
<p>但是<strong>对于数组来说</strong>，Vue使用一些数组方法<strong>将数组数据的修改变为响应式的</strong></p>
<h3 id="1-1-变更方法（影响原数组）"><a href="#1-1-变更方法（影响原数组）" class="headerlink" title="1.1 变更方法（影响原数组）"></a>1.1 变更方法（影响原数组）</h3><p>Vue 将被侦听的数组的变更方法进行了包裹，所以它们<strong>也将会触发视图更新</strong>。这些被包裹过的方法包括：</p>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>shift()</code></li>
<li><code>unshift()</code></li>
<li><code>splice()</code></li>
<li><code>sort()</code></li>
<li><code>reverse()</code></li>
</ul>
<h3 id="1-2-替换数组-（返回新数组）"><a href="#1-2-替换数组-（返回新数组）" class="headerlink" title="1.2 替换数组 （返回新数组）"></a>1.2 替换数组 （返回新数组）</h3><ul>
<li><code>filter()</code></li>
<li><code>concat()</code></li>
<li><code>slice()</code></li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>02-nodejs中JavaScript的模块化</title>
    <url>/2021/04/13/02-nodejs%E4%B8%ADJavaScript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Nodejs的模块化"><a href="#Nodejs的模块化" class="headerlink" title="Nodejs的模块化"></a>Nodejs的模块化</h1><h2 id="1-浏览器JavaScript开发弊端"><a href="#1-浏览器JavaScript开发弊端" class="headerlink" title="1.浏览器JavaScript开发弊端"></a>1.浏览器JavaScript开发弊端</h2><p>浏览器JavaScript在使用时存在两大问题</p>
<ul>
<li>文件依赖<ul>
<li>通过script标签引入的多个js文件的依赖关系不明确，查找依赖关系不便</li>
</ul>
</li>
<li>命名冲突<ul>
<li>浏览器JavaScript通过script引入的多个js文件是<strong>完全开放</strong>的，例如a.js里声明的变量可以在b.js中访问</li>
<li>如果在后续引入的js文件中声明了一个之前引入的js文件中已有的变量，就会导致之前的变量声明被后来的覆盖</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="2-软件中的模块化"><a href="#2-软件中的模块化" class="headerlink" title="2.软件中的模块化"></a>2.软件中的模块化</h2><p>一个功能就是一个模块，多个模块可以组成完整的应用，抽离一个模块不会影响其他功能的运行。</p>
<p>比如用户页面有增加用户和删除用户两个模块</p>
<p>​    抽离删除用户的模块并不会影响增加用户的功能</p>
<h2 id="3-Nodejs模块化开发"><a href="#3-Nodejs模块化开发" class="headerlink" title="3.Nodejs模块化开发"></a>3.Nodejs模块化开发</h2><p>Nodejs的模块化开发可以解决浏览器中JavaScript开发的两大弊端</p>
<h3 id="3-1Nodejs的模块化开发规范"><a href="#3-1Nodejs的模块化开发规范" class="headerlink" title="3.1Nodejs的模块化开发规范"></a>3.1Nodejs的模块化开发规范</h3><p>Nodejs规定<strong>一个JavaScript文件就是一个模块</strong>。</p>
<p>Nodejs中引入的多个模块(JS文件)处于<strong>半封闭状态。</strong></p>
<p>Nodejs中导入模块使用require()方法</p>
<ul>
<li>require(“导入模块的路径”)</li>
<li>模块的”.js”后缀可以省略，require(a)就代表导入当前目录下的a.js模块</li>
</ul>
<h4 id="3-1-1模块成员导出的两种方式"><a href="#3-1-1模块成员导出的两种方式" class="headerlink" title="3.1.1模块成员导出的两种方式"></a>3.1.1模块成员导出的两种方式</h4><p>半封闭的模块可以将<strong>希望被外界访问的成员</strong>导出</p>
<ol>
<li><p>通过<strong>exports</strong>导出接口对象</p>
<ul>
<li><p>只有挂载在<strong>exports导出接口对象</strong>上的成员才能被外界访问</p>
</li>
<li><p>使用require()方法可以导入其他模块</p>
<ul>
<li><p>require()方法有<strong>两个作用</strong></p>
<p>**1.**加载模块并执行其中的代码</p>
<p><strong>2.<strong>拿到被加载模块的</strong>导出接口对象exports</strong>(require的返回值）</p>
<ul>
<li>通过<code>require的返回值.成员</code>即可访问导出的成员</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>通过<strong>module.exports</strong>导出接口对象</p>
<ul>
<li>挂载在<strong>module.exports导出接口对象</strong>上的成员也能被外界访问</li>
</ul>
</li>
</ol>
<h4 id="3-1-2两种导出方式的区别"><a href="#3-1-2两种导出方式的区别" class="headerlink" title="3.1.2两种导出方式的区别"></a>3.1.2两种导出方式的区别</h4><p>exports是module.exports的别名(地址引用关系，内存空间相同)</p>
<p>若两者指向的内存空间变化后不再相同，此时导出对象<strong>最终以module.exports为准</strong></p>
<ul>
<li>例如我们手动操作<code>module.exports=&#123;name:&#39;yangxiao&#39;&#125;</code></li>
<li>此时更改了module.exports对象指向的内存空间，此时module.exports和exports指向不同的内存空间</li>
<li>这时候导出接口对象以module.exports为准，exports不再作为导出接口对象</li>
</ul>
<h3 id="3-2核心-系统-模块"><a href="#3-2核心-系统-模块" class="headerlink" title="3.2核心(系统)模块"></a>3.2核心(系统)模块</h3><p>Nodejs的模块包含：</p>
<ul>
<li>核心(系统)模块(fs,http等)</li>
<li>用户自定义模块(即自己写的.js文件)</li>
<li>第三方模块</li>
</ul>
<p><strong>Node运行环境为JavaScript提供</strong>了很多服务器级别的API，这些API绝大多数都被封装到一个具有名字的<strong>核心模块</strong>中。</p>
<p>如文件操作的<code>fs</code>模块，http服务构建的 <code>http</code>模块，<code>path</code> 路径操作模块，<code>os</code>操作系统信息模块等。。。</p>
<h4 id="3-2-1使用核心模块必须先加载模块"><a href="#3-2-1使用核心模块必须先加载模块" class="headerlink" title="3.2.1使用核心模块必须先加载模块"></a>3.2.1使用核心模块必须先加载模块</h4><p>形如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//require()方法用来加载模块</span></span><br><span class="line"><span class="keyword">var</span> fs=<span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http);</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3用户自定义模块"><a href="#3-3用户自定义模块" class="headerlink" title="3.3用户自定义模块"></a>3.3用户自定义模块</h3><p>用户自定义模块：即自己写的.js文件</p>
<h3 id="3-4第三方模块"><a href="#3-4第三方模块" class="headerlink" title="3.4第三方模块"></a>3.4第三方模块</h3><p>第三方模块是别人写好的，具有特定功能的，我们可以直接使用的模块。</p>
<p>第三方模块通常<strong>由多个文件组成并且放在文件夹中</strong>，所以又名<strong>包</strong>。</p>
<h4 id="3-4-1第三方模块的两种存在方式"><a href="#3-4-1第三方模块的两种存在方式" class="headerlink" title="3.4.1第三方模块的两种存在方式"></a>3.4.1第三方模块的两种存在方式</h4><ul>
<li>以<strong>js文件</strong>存在，提供实现项目具体功能的API。</li>
<li>以<strong>命令行工具</strong>形式存在，辅助项目开发。</li>
</ul>
<h4 id="3-4-2获取第三方模块"><a href="#3-4-2获取第三方模块" class="headerlink" title="3.4.2获取第三方模块"></a>3.4.2获取第三方模块</h4><p><a href="https://www.npmjs.com/">npmjs.com</a>: 第三方模块的存储和分发仓库</p>
<p>npm: Node的包(第三方模块)管理工具，npm本身也是Node的第三方模块，npm在Node安装时就自动安装</p>
<p>使用npm获取第三方模块：</p>
<ul>
<li><strong>下载</strong> <code>npm install 模块名</code><ul>
<li>下载到命令行工具的当前目录下</li>
<li>在当前目录自动创建一个node_modules文件夹，下载的包就存放在这个文件夹下</li>
<li>还会在当前目录创建一个package-lock.json文件</li>
</ul>
</li>
<li><strong>卸载</strong> <code>npm uninstall package 模块名</code><ul>
<li>若删除包后node_modules文件夹为空，则会自动删除node_modules文件夹</li>
</ul>
</li>
<li><strong>全局安装</strong>和<strong>本地安装</strong><ul>
<li>本地安装：将模块下载到当前项目中，仅供<strong>当前项目</strong>使用<ul>
<li>一般将<strong>库文件</strong>本地安装</li>
</ul>
</li>
<li>全局安装：将项目安装到一个公共目录，<strong>所有的项目</strong>都可以使用<ul>
<li>一般将<strong>命令行工具</strong>全局安装</li>
</ul>
</li>
<li>上面给出的下载命令<code>npm install 模块名</code>是本地安装</li>
</ul>
</li>
</ul>
<h2 id="4-实现简单的模块化"><a href="#4-实现简单的模块化" class="headerlink" title="4.实现简单的模块化"></a>4.实现简单的模块化</h2><p>a.js文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//require()方法会执行相应模块中的代码</span></span><br><span class="line"><span class="comment">//在a.js文件中调用执行b.js自定义模块</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;./b.js&quot;</span>);<span class="comment">//执行b.js后会输出&quot;b.js被执行了&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>b.js文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;b.js被执行了&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>执行a.js文件后输出结果为</p>
<p><img data-src="/images/02-nodejs%E4%B8%ADJavaScript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/image-20210412112221108.png" alt="image-20210412112221108"></p>
<h3 id="4-1Nodejs中没有全局作用域，只有模块作用域"><a href="#4-1Nodejs中没有全局作用域，只有模块作用域" class="headerlink" title="4.1Nodejs中没有全局作用域，只有模块作用域"></a>4.1Nodejs中没有全局作用域，只有模块作用域</h3><ul>
<li><p>模块作用域</p>
<ul>
<li><p>内部访问不到外部</p>
</li>
<li><p>外部也访问不到内部</p>
</li>
</ul>
</li>
</ul>
<p>a.js文件</p>
<p>在a.js中定义的变量foo只在a.js**文件(模块)**中生效</p>
<p>同样a.js中定义的函数也只能在a.js文件中调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在a.js文件中定义了变量foo，这个foo文件只在a.js这个文件(模块)中生效</span></span><br><span class="line"><span class="keyword">var</span> foo=<span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//require()调用模块时，.js后缀名可以省略</span></span><br><span class="line"><span class="comment">//相对路径的./不能省略</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;./b.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里输出的foo是a.js中的foo=&quot;aaa&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>b.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b.js中定义的foo变量只在b.js文件中生效</span></span><br><span class="line"><span class="comment">//不会影响a.js文件中的foo变量</span></span><br><span class="line"><span class="keyword">var</span> foo=<span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;b.js被执行了&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>运行a.js结果</p>
<p><code>console.log(foo);</code>执行结果为aaa</p>
<p><img data-src="/images/02-nodejs%E4%B8%ADJavaScript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/image-20210412113217274.png" alt="image-20210412113217274"></p>
<h3 id="4-2模块之间怎样通信"><a href="#4-2模块之间怎样通信" class="headerlink" title="4.2模块之间怎样通信"></a>4.2模块之间怎样通信</h3><ul>
<li><p>模块作用域默认是半封闭</p>
</li>
<li><p>我们可以使用<strong>exports导出接口对象</strong>实现模块间的通信</p>
<ul>
<li>require()方法返回被调用模块的导出接口对象exports</li>
<li>每个文件模块中都提供一个对象：<strong>exports</strong>     (exports意为导出，出口)</li>
</ul>
</li>
<li><p>exports默认是一个空对象</p>
<ul>
<li>将本模块中<strong>需要被其他模块访问的属性和方法</strong>挂载在exports对象下</li>
<li>其他模块通过require()方法获取本模块的exports对象后就可以访问</li>
</ul>
</li>
</ul>
<p>a.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.js文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//require()方法返回被调用模块的导出接口对象exports</span></span><br><span class="line"><span class="keyword">var</span> ex=<span class="built_in">require</span>(<span class="string">&quot;./b&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用ex.&quot;属性，方法&quot;就可以访问b.js中导出的属性和方法</span></span><br><span class="line"><span class="built_in">console</span>.log(ex.age);</span><br><span class="line"><span class="built_in">console</span>.log(ex.add(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>b.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b.js文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> age=<span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将需要导出的属性和方法挂载在exports对象下</span></span><br><span class="line"><span class="built_in">exports</span>.age=age;</span><br><span class="line"><span class="built_in">exports</span>.add=add;</span><br></pre></td></tr></table></figure>

<p>执行a.js结果为</p>
<p><img data-src="/images/02-nodejs%E4%B8%ADJavaScript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/image-20210412120622983.png" alt="image-20210412120622983"></p>
<p><strong>同理</strong></p>
<p><strong>fs和http等核心模块加载后就可以使用其中导出的方法如fs.readFile()等</strong></p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>02-JS原型链</title>
    <url>/2022/12/04/02-%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>JavaScript 常被描述为一种<strong>基于原型的语言 (prototype-based language)<strong>——每个对象拥有一个</strong>原型</strong>，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为<strong>原型链 (prototype chain)</strong></p>
<ul>
<li>对象从其**构造函数的原型对象中(原型)**继承属性和方法</li>
</ul>
<span id="more"></span>

<br>

<p><strong>先明确两个名词</strong></p>
<p><strong>原型</strong>：<code>__proto__</code> </p>
<p><strong>原型对象</strong>：<code>prototype</code></p>
<ul>
<li>对象都会有<code>__proto__</code>原型     它指向对象的构造函数的<strong>原型对象prototype</strong><ul>
<li>实例对象ldh的原型指向<strong>Star.prototype</strong></li>
<li><code>console.log(ldh.__proto__);//输出Star.prototype</code></li>
</ul>
</li>
<li>构造函数的<strong>原型对象</strong>也是一个对象 也有<code>__proto__</code>原型属性<ul>
<li><code>console.log(Star.prototype.__proto__);</code></li>
<li><code>Star.prototype.__proto__</code>指向 <strong>Star.prototype</strong> 的<strong>构造函数</strong>的原型对象</li>
<li><strong>Star.prototype</strong>的<strong>构造函数</strong>即为<strong>Object</strong> (Object对象是所有对象的父类)</li>
<li>那么<code>Star.prototype.__proto__</code>指向Object的原型对象即为<strong>Object.prototype</strong></li>
<li><code>console.log(Star.prototype.__proto__===Object.prototype);//2.输出true 说明原型指向Object的原型对象</code></li>
<li><strong>Object.prototype</strong>的原型指向<strong>null</strong>（因为作为所有对象父类的Object.prototype已经没有上一级构造函数了，所以返回null）</li>
</ul>
</li>
<li>实例对象没有prototype属性，输出为undefined</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Star</span>(<span class="params">name,age</span>)</span>&#123; </span><br><span class="line">            <span class="built_in">this</span>.name=name;</span><br><span class="line">            <span class="built_in">this</span>.age=age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> ldh=<span class="keyword">new</span> Star(<span class="string">&quot;刘德华&quot;</span>,<span class="number">20</span>)</span><br><span class="line">        <span class="comment">//1.对象都会有__proto__原型     它指向构造函数的原型对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(ldh.__proto__);<span class="comment">//输出Star.prototype</span></span><br><span class="line">        <span class="comment">//构造函数的原型对象也是一个对象 也有__proto__原型</span></span><br><span class="line">        <span class="comment">// console.log(Star.prototype);//输出中有__proto__原型</span></span><br><span class="line">        <span class="built_in">console</span>.log(Star.prototype.__proto__);<span class="comment">//输出Object.prototype</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.constructor);<span class="comment">//原型中的constructor指向Object()构造函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(Star.prototype.__proto__===<span class="built_in">Object</span>.prototype);<span class="comment">//2.输出true 说明原型指向Object的原型对象</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//3.Object.prototype是Object()构造函数的原型对象</span></span><br><span class="line">        <span class="comment">//同样Object.prototype中也有一个原型__proto__</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__);<span class="comment">//返回null</span></span><br></pre></td></tr></table></figure>

<h2 id="原型链形成流程"><a href="#原型链形成流程" class="headerlink" title="原型链形成流程"></a>原型链形成流程</h2><p>分析从ldh这个对象实例开始的原型(<strong>proto</strong>)的指向</p>
<p>​      1.l<code>dh.__proto__</code>指向Star.prototype</p>
<p>​      2.<code>Star.prototype.__proto__</code>指向Object.prototype</p>
<p>​      3.<code>Object.prototype.__proto__</code>指向null</p>
<p>​    指向null时，原型链到达最顶层，这就形成了原型链</p>
<p>原型链给访问对象成员时<strong>提供了一条路径</strong></p>
<p>​    访问ldh对象中的成员时，<strong>先在对象实例ldh上查找</strong>，若没有则<strong>沿着原型链逐级向上查找</strong></p>
<p>​    先查找ldh对象有无该成员-&gt;若没找到则再沿着原型链查找Star.prototype原型对象中有无该成员-&gt;…..Object.prototype-&gt;,,,null</p>
<ul>
<li>对象成员只能在<strong>对象实例本身</strong>或者<strong>上级构造函数的prototype</strong>上找到</li>
</ul>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>多表关系</title>
    <url>/2022/11/27/02-%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h1><h2 id="1-一对一"><a href="#1-一对一" class="headerlink" title="1.一对一"></a>1.一对一</h2><p>一张表中的一行 <strong>唯一对应</strong> 另一张表的一行</p>
<p><img data-src="/images/02-%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB/image-20220329203914561.png" alt="image-20220329203914561"></p>
<p>学生表和身份证表就是<strong>一对一的关系</strong></p>
<ul>
<li>一对一的关系通常<strong>合表处理</strong></li>
</ul>
<br>

<h2 id="2-一对多"><a href="#2-一对多" class="headerlink" title="2.一对多"></a>2.一对多</h2><p>一张表的一行 对应 另一张表的多行</p>
<p><img data-src="/images/02-%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB/image-20220329204022659.png" alt="image-20220329204022659"></p>
<p>部门表的一行(研发部) 对应 员工表中的三行(研发部有3名员工)</p>
<br>

<h2 id="3-多对多"><a href="#3-多对多" class="headerlink" title="3.多对多"></a>3.多对多</h2><p>两张表互相都存在一对多的关系</p>
<p><img data-src="/images/02-%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB/image-20220329204130718.png" alt="image-20220329204130718"></p>
<p>学生表的一行可以对应课程表的多行(一个学生选择多个课程)</p>
<p>课程表的一行可以对应学生表的多行(一个课程被多个学生选择)</p>
<ul>
<li>此时学生表和课程表是多对多的关系</li>
<li>多对多关系通常使用<strong>中间表</strong>来处理<ul>
<li>展示两张表中行的对应关系</li>
</ul>
</li>
</ul>
<br>

<h1 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h1><p>外键约束用来<strong>展示控制</strong>多表关系，与主键一起使用</p>
<p><img data-src="/images/02-%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB/image-20220329204730119.png" alt="image-20220329204730119"></p>
<ul>
<li>两个关联的表，主键所在的表为<strong>主表</strong>，外键所在的表为<strong>从表</strong></li>
<li>外键列受到主键列的控制和限制</li>
</ul>
<br>

<h2 id="1-外键的限制"><a href="#1-外键的限制" class="headerlink" title="1.外键的限制"></a>1.外键的限制</h2><p>定义外键时，遵守规则：</p>
<ul>
<li>主表已经存在，或者是当前正创建的表</li>
<li>主表有主键</li>
<li>外键的数据类型与主键相同</li>
<li>主键和外键列的数目相同(联合主键的情况下)</li>
</ul>
<h2 id="2-创建外键"><a href="#2-创建外键" class="headerlink" title="2.创建外键"></a>2.创建外键</h2><h3 id="2-1创建表示指定外键"><a href="#2-1创建表示指定外键" class="headerlink" title="2.1创建表示指定外键"></a>2.1创建表示指定外键</h3><p><img data-src="/images/02-%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB/image-20220329205523257.png" alt="image-20220329205523257"></p>
<p><code>constraint &lt;外键名&gt;</code>：给外键约束起名(后续可以根据名字删除外键约束)</p>
<p><code>foregin key 字段名 [,字段名2，...]</code>：指定哪些列是外键列(一列或多列)</p>
<p><code>references &lt;主表名&gt; 主键列 [,主键列2,..]</code>：外键收到哪个主表的哪些主键约束(一个或多个主键列)</p>
<p><img data-src="/images/02-%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB/image-20220329205743276.png" alt="image-20220329205743276"></p>
<center>主表</center>

<p><img data-src="/images/02-%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB/image-20220329205801505.png" alt="image-20220329205801505"></p>
<center>从表</center>

<ul>
<li>黄色语句即创建一个名为<code>emp_fk</code>的外键，外键列为 <code>dept_id</code>，被主表<code>dept</code> 的 <code>detpno</code> 主键列控制</li>
</ul>
<h3 id="2-2修改表结构方式指定外键"><a href="#2-2修改表结构方式指定外键" class="headerlink" title="2.2修改表结构方式指定外键"></a>2.2修改表结构方式指定外键</h3><p><img data-src="/images/02-%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB/image-20220329210232189.png" alt="image-20220329210232189"></p>
<br>

<h2 id="3-外键约束下的数据操作"><a href="#3-外键约束下的数据操作" class="headerlink" title="3.外键约束下的数据操作"></a>3.外键约束下的数据操作</h2><h3 id="1-数据插入"><a href="#1-数据插入" class="headerlink" title="1.数据插入"></a>1.数据插入</h3><p>给从表插入数据时，外键列的值必须为主键列中存在的值，否则报错</p>
<ul>
<li>先给主表添加数据，在根据主键列向从表添加数据</li>
</ul>
<h3 id="2-数据删除"><a href="#2-数据删除" class="headerlink" title="2.数据删除"></a>2.数据删除</h3><p>从表的数据可以随意删除</p>
<p>主表的数据被从表依赖，不能删除</p>
<p>主表的数据没有被从表依赖，可以删除</p>
<br>

<h2 id="4-外键删除"><a href="#4-外键删除" class="headerlink" title="4.外键删除"></a>4.外键删除</h2><p><img data-src="/images/02-%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB/image-20220329211115140.png" alt="image-20220329211115140"></p>
<br>

<h2 id="5-多对多外键约束"><a href="#5-多对多外键约束" class="headerlink" title="5.多对多外键约束"></a>5.多对多外键约束</h2><p><img data-src="/images/02-%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB/image-20220329211603493.png" alt="image-20220329211603493"></p>
<p>score表为从表，两个外键列(<code>sid和cid</code>)分别被student表和course表约束，<strong>两个</strong>外键约束</p>
<p>student表和course表为主表，分别约束从表中的一个外键列</p>
<ul>
<li><p>创建多对多关系的外键约束时，需要创建两个外键约束(<code>score的sid和cid</code>)</p>
</li>
<li><p>先创建两个主表，再创建从表</p>
</li>
<li><p>删除时，被依赖的主表数据不能删除</p>
</li>
</ul>
]]></content>
      <categories>
        <category>SQL语言</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序API</title>
    <url>/2022/11/27/02-%E5%B0%8F%E7%A8%8B%E5%BA%8FAPI/</url>
    <content><![CDATA[<h1 id="小程序API"><a href="#小程序API" class="headerlink" title="小程序API"></a>小程序API</h1><p><img data-src="/images/02-%E5%B0%8F%E7%A8%8B%E5%BA%8FAPI/image-20220127084735431.png" alt="image-20220127084735431"></p>
<h2 id="1-三大类小程序API"><a href="#1-三大类小程序API" class="headerlink" title="1.三大类小程序API"></a>1.三大类小程序API</h2><p><img data-src="/images/02-%E5%B0%8F%E7%A8%8B%E5%BA%8FAPI/image-20220127084831773.png" alt="image-20220127084831773"></p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS选择器</title>
    <url>/2022/11/27/03-CSS%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h1><ul>
<li><p>元素选择器 （HTML标签）</p>
</li>
<li><p>类选择器  （class）</p>
</li>
<li><p>id选择器</p>
</li>
<li><p>属性选择器</p>
<span id="more"></span>

<ul>
<li><p>按照给定的<strong>属性或属性值</strong>匹配所有满足的元素</p>
</li>
<li><p>```css<br>/* 存在title属性的<a> 元素 */<br>a[title] {<br>  color: purple;<br>}</p>
<p>/* 存在href属性并且属性值匹配”<a href="https://example.org&quot;的/">https://example.org&quot;的</a><a> 元素 */<br>a[href=”<a href="https://example.org&quot;]">https://example.org&quot;]</a> {<br>  color: green;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    &lt;!-- more --&gt;</span><br><span class="line"></span><br><span class="line">- 后代选择器</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;css</span><br><span class="line">    &#x2F;*ul后代的所有p标签 *&#x2F;</span><br><span class="line">    ul p&#123;</span><br><span class="line">    	color:red;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>子代选择器</p>
<ul>
<li>```css<br>/*ul的子代中所有的p元素<br>  更远的后代不生效<br>*/<br>ul &gt; p{<br>color:red;<br>}<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 紧邻兄弟选择器</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;css</span><br><span class="line">    &#x2F;*匹配同一父元素下p标签后的第一个span标签*&#x2F;</span><br><span class="line">    p + span&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>一般兄弟选择器</p>
<ul>
<li>```css<br>/<em>匹配同一父元素下p标签后的所有span标签</em>/<br>p ~ span{}<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 选择器列表</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;css</span><br><span class="line">    &#x2F;*匹配所有的p和span标签*&#x2F;</span><br><span class="line">    p,span&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="选择器的优先级"><a href="#选择器的优先级" class="headerlink" title="选择器的优先级"></a>选择器的优先级</h2><p><strong>ID选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配符选择器</strong></p>
<br>

<h2 id="样式属性的优先级计算"><a href="#样式属性的优先级计算" class="headerlink" title="样式属性的优先级计算"></a>样式属性的优先级计算</h2><p><span style="color:red">同一个元素同一种样式属性</span>的优先级可以<strong>根据其所属的选择器来判断</strong>，由四个部分相加 (分量)，可以认为是 <code>个十百千 — 四位数</code>的四个位数：</p>
<ol>
<li><strong>千位</strong>： 如果声明在标签 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes#attr-style">style</a> 的属性（行内样式）则该位得一分。这样的声明没有选择器，所以它得分总是1000。</li>
<li><strong>百位</strong>： 选择器中包含<strong>ID选择器</strong>则该位得一分。</li>
<li><strong>十位</strong>： 选择器中包含<strong>类选择器</strong>、<strong>属性选择器</strong>或者<strong>伪类</strong>则该位得一分。</li>
<li><strong>个位</strong>：<strong>标签选择器</strong>、<strong>伪元素选择器</strong>和<strong>属性选择器</strong>则该位得一分。</li>
<li><ol>
<li>通用选择器 (*)，组合符 (+, &gt;, ~, ‘ ‘)，和否定伪类 (:not) 不会影响优先级。</li>
<li><strong>继承来的属性优先级为0</strong></li>
<li><strong>!important的优先级最高</strong>（万位为1）</li>
</ol>
</li>
</ol>
<p><img data-src="/images/03-CSS%E9%80%89%E6%8B%A9%E5%99%A8/image-20210913193120565.png" alt="image-20210913193120565"></p>
<p><img data-src="/images/03-CSS%E9%80%89%E6%8B%A9%E5%99%A8/image-20210913184435506.png" alt="优先级判断"></p>
<p><strong>例子：</strong>color属性的优先级判断</p>
<ul>
<li><code>ul &#123; color: blue !important; &#125;</code><ul>
<li><code>!important</code>优先级最高，但是后面的li标签<strong>继承color:blue，所以在li中优先级为0</strong>（继承来的样式属性优先级为0）</li>
</ul>
</li>
<li> <code>ul &gt; li &#123; color: green; &#125;</code> 有两个标签选择器，优先级为0002</li>
<li> <code>ul li + li &#123; color: red; &#125;</code> 有3个标签选择器，优先级为0003</li>
<li> <code>li &#123; color: yellow; &#125;</code> 一个标签选择器，优先级为0001</li>
</ul>
<br>

<h2 id="伪类和伪元素选择器"><a href="#伪类和伪元素选择器" class="headerlink" title="伪类和伪元素选择器"></a>伪类和伪元素选择器</h2><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>CSS <strong>伪类</strong> 是添加到选择器的关键字，指定要选择的元素的<span style="color:red">特殊状态</span></p>
<p><code>:</code> 伪选择器支持按照<strong>未被包含在文档树中的状态信息</strong>来选择元素。<br><strong>例子：</strong><code>a:visited</code> 匹配所有<strong>曾被访问过</strong>的 <code>&lt;a&gt;</code> 元素。</p>
<p><img data-src="/images/03-CSS%E9%80%89%E6%8B%A9%E5%99%A8/image-20210913193740683.png" alt="image-20210913193740683"></p>
<h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><p>伪元素是一个附加至选择器末的关键词，允许你对被选择元素的<span style="color:red">特定部分</span>修改样式</p>
<p><code>::first-line</code> 伪元素可改变段落<strong>首行文字</strong>的样式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 每一个 &lt;p&gt; 元素的第一行。 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">text-transform</span>: uppercase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>伪元素使用两个冒号（<code>::</code>）与伪类进行区分<ul>
<li>由于旧版本的 W3C 规范并未对此进行特别区分,目前绝大多数浏览器同时支持<strong>单冒号和双冒号</strong>两种方式表示伪元素</li>
</ul>
</li>
<li><strong>一个选择器中只能使用一个伪元素</strong>。伪元素必须紧跟在语句中的简单选择器/基础选择器之后</li>
</ul>
<p><img data-src="/images/03-CSS%E9%80%89%E6%8B%A9%E5%99%A8/image-20210913193702632.png" alt="image-20210913193702632"></p>
]]></content>
      <categories>
        <category>HTMLandCss</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>03-DOM文档对象模型</title>
    <url>/2022/12/04/03-DOM%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="DOM文档对象模型"><a href="#DOM文档对象模型" class="headerlink" title="DOM文档对象模型"></a>DOM文档对象模型</h1><p>DOM文档对象模型是用来<strong>呈现</strong>以及<strong>与任意 HTML 或 XML文档交互的API</strong>。DOM 是载入到浏览器中的文档模型，以<strong>节点树的形式</strong>来表现文档，每个节点代表文档的构成部分（例如:页面元素、字符串或注释等等）。</p>
<p>DOM中的节点组织为<strong>节点树</strong></p>
<p>DOM的<strong>顶层对象为 document</strong></p>
<p>DOM中的元素分为三种</p>
<ul>
<li>文本节点</li>
<li>元素节点</li>
<li>属性节点</li>
</ul>
<p>可以获取文档对象模型中的节点进行操作（对html中的标签进行操作）</p>
<ul>
<li>创建节点</li>
<li>删除节点</li>
<li>添加事件绑定等</li>
</ul>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>React基本使用</title>
    <url>/2022/11/27/03-React%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="React基本使用"><a href="#React基本使用" class="headerlink" title="React基本使用"></a>React基本使用</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p><img data-src="/images/03-React%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20220331155001475.png" alt="image-20220331155001475"></p>
<span id="more"></span>

<h2 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2.基本使用"></a>2.基本使用</h2><p><img data-src="/images/03-React%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20220331155258977.png" alt="image-20220331155258977"></p>
<ul>
<li><p><code>React.createElement()</code> 创建一个React元素</p>
<p>三个或以上参数</p>
<ul>
<li>参数1：元素名</li>
<li>参数2：元素属性对象</li>
<li>参数3,4,…：元素子节点</li>
</ul>
</li>
<li><p><code>ReactDOM.render()</code> 将创建的React元素渲染到页面的容器DOM元素中</p>
<p>两个参数</p>
<ul>
<li>参数1：React元素</li>
<li>参数2：作为容器的DOM元素</li>
</ul>
</li>
</ul>
<br>

<h2 id="3-React脚手架"><a href="#3-React脚手架" class="headerlink" title="3.React脚手架"></a>3.React脚手架</h2><p>类似于Vue脚手架</p>
<p><code>npx create-react-app my-app</code> 创建一个名为my-app的react-app</p>
<p><code>npm start</code> 在react-app目录下执行开启项目</p>
<p><img data-src="/images/03-React%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20220331213855919.png" alt="image-20220331213855919"></p>
<br>

<h3 id="3-1-使用"><a href="#3-1-使用" class="headerlink" title="3.1 使用"></a>3.1 使用</h3><p><img data-src="/images/03-React%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20220331214655330.png" alt="image-20220331214655330"></p>
<ul>
<li>在项目入口文件(<code>index.js</code>)渲染React元素，容器为<code>public/index.html</code>中的id为root的div元素</li>
<li><code>App.js</code>文件类似于Vue中的<code>App.vue</code>，是React的根元素</li>
<li>React和ReactDOM通过ES6模块化引入(项目初始化时自动完成)</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>React概述</title>
    <url>/2022/11/27/03-React%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="React概述"><a href="#React概述" class="headerlink" title="React概述"></a>React概述</h1><ul>
<li>React是一个构建<strong>用户界面</strong>的<strong>JavaScript库</strong><ul>
<li>主要用来写HTML页面，构建web应用</li>
</ul>
</li>
<li>属于MVC的视图层(View)</li>
</ul>
<span id="more"></span>

<h2 id="React特点"><a href="#React特点" class="headerlink" title="React特点"></a>React特点</h2><ul>
<li>声明式</li>
<li>基于组件</li>
<li>应用范围广<ul>
<li>web应用(网站)</li>
<li>React-native开发原生移动端app</li>
<li>VR</li>
</ul>
</li>
</ul>
<h2 id="React与Vue的区别"><a href="#React与Vue的区别" class="headerlink" title="React与Vue的区别"></a>React与Vue的区别</h2><ul>
<li>React完全使用JS语言自身的能力来编写UI，而不是增强HTML的功能</li>
</ul>
<p>例如：条件渲染使用 <code>if/else</code> 或者 <code>三元表达式</code>，列表渲染使用数组的<code>map</code>方法，这些都是<strong>JS语言自身的能力</strong>或者API</p>
<br>

<ul>
<li>Vue使用框架提供的指令来增强HTML的功能</li>
</ul>
<p>例如：条件渲染使用指令 <code>v-if/v-else</code>，列表渲染使用 <code>v-for</code></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>WXML模板语法</title>
    <url>/2022/11/27/03-WXML%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="WXML模板语法"><a href="#WXML模板语法" class="headerlink" title="WXML模板语法"></a>WXML模板语法</h1><h2 id="1-数据绑定"><a href="#1-数据绑定" class="headerlink" title="1.数据绑定"></a>1.数据绑定</h2><p>在页面js文件Page方法中的data字段定义数据，通过<strong>插值表达式</strong>（Mustache语法）在wxml文件中使用数据</p>
<p>（与Vue模板语法数据绑定类似）</p>
<p>插值表达式可以<strong>渲染模板数据</strong>，进行<strong>三元运算</strong>和<strong>算数运算</strong></p>
<p>WXML数据绑定中<strong>动态属性绑定</strong>同样使用插值表达式</p>
<p><img data-src="/images/03-WXML%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/image-20220204195549937.png" alt="image-20220204195549937"></p>
<span id="more"></span>

<h2 id="2-事件绑定"><a href="#2-事件绑定" class="headerlink" title="2.事件绑定"></a>2.事件绑定</h2><h3 id="2-1-微信小程序常见事件"><a href="#2-1-微信小程序常见事件" class="headerlink" title="2.1 微信小程序常见事件"></a>2.1 微信小程序常见事件</h3><p><img data-src="/images/03-WXML%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/image-20220204200620597.png" alt="image-20220204200620597"></p>
<h3 id="2-2-事件对象-event-的属性列表"><a href="#2-2-事件对象-event-的属性列表" class="headerlink" title="2.2 事件对象(event)的属性列表"></a>2.2 事件对象(event)的属性列表</h3><p><img data-src="/images/03-WXML%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/image-20220204200650987.png" alt="image-20220204200650987"></p>
<h3 id="2-3-事件对象属性target和currentTarget的区别"><a href="#2-3-事件对象属性target和currentTarget的区别" class="headerlink" title="2.3 事件对象属性target和currentTarget的区别"></a>2.3 事件对象属性target和currentTarget的区别</h3><p><code>e.target</code>为触发该事件的<strong>源头组件</strong></p>
<p><code>e.currentTarget</code>为<strong>该事件绑定的组件</strong></p>
<p>事件可以通过冒泡的方式进行触发，此时两个属性的值不是同一个组件</p>
<h3 id="2-4-bindtap的语法格式"><a href="#2-4-bindtap的语法格式" class="headerlink" title="2.4 bindtap的语法格式"></a>2.4 bindtap的语法格式</h3><p><img data-src="/images/03-WXML%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/image-20220204201115808.png" alt="image-20220204201115808"></p>
<p>事件处理函数位于页面js文件，与data字段同级</p>
<p><img data-src="/images/03-WXML%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/image-20220204201226720.png" alt="image-20220204201226720"></p>
<h3 id="2-5-事件处理函数中修改data中的数据"><a href="#2-5-事件处理函数中修改data中的数据" class="headerlink" title="2.5 事件处理函数中修改data中的数据"></a>2.5 事件处理函数中修改data中的数据</h3><p>通过<code>this.setData</code>方法修改模板数据</p>
<p><img data-src="/images/03-WXML%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/image-20220204202857204.png" alt="image-20220204202857204"></p>
<p><code>this.setData</code>方法接收一个对象作为参数，上例修改<code>testinfo</code>模板数据加1</p>
<h3 id="2-6-事件传参"><a href="#2-6-事件传参" class="headerlink" title="2.6 事件传参"></a>2.6 事件传参</h3><p>传参使用自定义属性<code>data-*</code>进行（在绑定事件时传参无效）</p>
<p><img data-src="/images/03-WXML%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/image-20220204203459700.png" alt="image-20220204203459700"></p>
<p>参数名为info，值为数字2（不使用插值表达式则为字符串2）</p>
<p>获取参数通过<code>e.target.dataset.参数名</code></p>
<p><img data-src="/images/03-WXML%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/image-20220204203601783.png" alt="image-20220204203601783"></p>
<h3 id="2-7-bindinput语法格式"><a href="#2-7-bindinput语法格式" class="headerlink" title="2.7 bindinput语法格式"></a>2.7 bindinput语法格式</h3><p><img data-src="/images/03-WXML%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/image-20220204203910943.png" alt="image-20220204203910943"></p>
<p>通过<code>e.detail.value</code>获取文本框最新数据</p>
<h3 id="2-8-文本框和data中数据同步"><a href="#2-8-文本框和data中数据同步" class="headerlink" title="2.8 文本框和data中数据同步"></a>2.8 文本框和data中数据同步</h3><p><img data-src="/images/03-WXML%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/image-20220204204223713.png" alt="image-20220204204223713"></p>
<p>input事件触发后通过this.setData方法修改data中的数据为文本框数据</p>
<br>

<h2 id="3-条件渲染"><a href="#3-条件渲染" class="headerlink" title="3. 条件渲染"></a>3. 条件渲染</h2><h3 id="3-1-wx-if"><a href="#3-1-wx-if" class="headerlink" title="3.1 wx:if"></a>3.1 <code>wx:if</code></h3><p><img data-src="/images/03-WXML%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/image-20220208130952358.png" alt="image-20220208130952358"></p>
<h3 id="3-2-结合-lt-block-gt-使用条件渲染"><a href="#3-2-结合-lt-block-gt-使用条件渲染" class="headerlink" title="3.2 结合&lt;block&gt;使用条件渲染"></a>3.2 结合<code>&lt;block&gt;</code>使用条件渲染</h3><p><img data-src="/images/03-WXML%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/image-20220208131231704.png" alt="image-20220208131231704"></p>
<h3 id="3-3-hidden控制显示隐藏"><a href="#3-3-hidden控制显示隐藏" class="headerlink" title="3.3 hidden控制显示隐藏"></a>3.3 <code>hidden</code>控制显示隐藏</h3><p><img data-src="/images/03-WXML%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/image-20220208131408852.png" alt="image-20220208131408852"></p>
<h3 id="3-4-wx-if和hidden的区别"><a href="#3-4-wx-if和hidden的区别" class="headerlink" title="3.4 wx:if和hidden的区别"></a>3.4 <code>wx:if</code>和<code>hidden</code>的区别</h3><p><img data-src="/images/03-WXML%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/image-20220208131705908.png" alt="image-20220208131705908"></p>
<h2 id="4-列表渲染"><a href="#4-列表渲染" class="headerlink" title="4.列表渲染"></a>4.列表渲染</h2><h3 id="4-1-wx-for"><a href="#4-1-wx-for" class="headerlink" title="4.1 wx:for"></a>4.1 <code>wx:for</code></h3><p><img data-src="/images/03-WXML%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/image-20220208132357485.png" alt="image-20220208132357485"></p>
<h4 id="4-1-1-手动指定索引和当前项的变量名"><a href="#4-1-1-手动指定索引和当前项的变量名" class="headerlink" title="4.1.1 手动指定索引和当前项的变量名"></a>4.1.1 手动指定索引和当前项的变量名</h4><p><img data-src="/images/03-WXML%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/image-20220208132709938.png" alt="image-20220208132709938"></p>
<h4 id="4-1-2-wx-key提高循环渲染效率"><a href="#4-1-2-wx-key提高循环渲染效率" class="headerlink" title="4.1.2 wx:key提高循环渲染效率"></a>4.1.2 <code>wx:key</code>提高循环渲染效率</h4><p><img data-src="/images/03-WXML%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/image-20220208133053477.png" alt="image-20220208133053477"></p>
<p><img data-src="/images/03-WXML%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/image-20220208133514404.png" alt="image-20220208133514404"></p>
<p>一般使用数组元素的id值作为key值，也可以使用循环索引index作为key值</p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>多表联合查询</title>
    <url>/2022/11/27/03-%E5%A4%9A%E8%A1%A8%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h1 id="多表联合查询"><a href="#多表联合查询" class="headerlink" title="多表联合查询"></a>多表联合查询</h1><p>外键约束只影响表的增删改，<strong>不影响查询</strong></p>
<h2 id="1-交叉连接查询"><a href="#1-交叉连接查询" class="headerlink" title="1.交叉连接查询"></a>1.交叉连接查询</h2><p><img data-src="/images/03-%E5%A4%9A%E8%A1%A8%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2/image-20220329212840634.png" alt="image-20220329212840634"></p>
<p>返回被连接的<strong>多张表指定数据行</strong>的<strong>笛卡尔积</strong></p>
<p><strong>笛卡尔积：</strong>一张表的每一行和另一张表的任意一行匹配</p>
<ul>
<li>例如A表有<strong>m</strong>行，B表有<strong>n</strong>行<ul>
<li>查询结果有<strong>m*n行</strong>数据</li>
</ul>
</li>
</ul>
<br>

<h2 id="2-内连接查询"><a href="#2-内连接查询" class="headerlink" title="2.内连接查询"></a>2.内连接查询</h2><p>根据条件求多张表的<strong>交集</strong></p>
<p><img data-src="/images/03-%E5%A4%9A%E8%A1%A8%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2/image-20220414101152500.png" alt="image-20220414101152500"></p>
<p>显示内连接与隐式的区别</p>
<ul>
<li>隐式的<code>,</code>在显示中被<code>inner join</code>替换(<code>inner</code>可省略)</li>
<li>隐式的<code>where</code>，在显示中被<code>on</code>替换</li>
</ul>
]]></content>
      <categories>
        <category>SQL语言</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>03-第三方模块Gulp</title>
    <url>/2021/04/19/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/</url>
    <content><![CDATA[<h1 id="Gulp第三方模块"><a href="#Gulp第三方模块" class="headerlink" title="Gulp第三方模块"></a>Gulp第三方模块</h1><p>Gulp的基础介绍在<strong>02-02第三方模块</strong>文章中</p>
<h2 id="Gulp的插件"><a href="#Gulp的插件" class="headerlink" title="Gulp的插件"></a>Gulp的插件</h2><p>Gulp是轻内核级第三方插件，本身提供的方法很少，只有几种</p>
<ul>
<li>gulp.src()：获取任务要处理的文件</li>
<li>gulp.dest()：输出文件</li>
<li>gulp.task()：建立gulp任务</li>
<li>gulp.watch()：监控文件变化</li>
</ul>
<span id="more"></span>

<p>其他的功能都是<strong>通过插件的形式</strong>实现的</p>
<ul>
<li>gulp-htmlmin：html文件压缩</li>
<li>gulp-csso：css文件压缩</li>
<li>gulp-babel：JavaScript语法转化 (ES6 -&gt; ES5)</li>
<li>gulp-less：less转换为css</li>
<li>broswersync：浏览器实时同步</li>
<li>gulp-file-include：提取公共文件</li>
</ul>
<h3 id="1-Gulp插件使用"><a href="#1-Gulp插件使用" class="headerlink" title="1.Gulp插件使用"></a>1.Gulp插件使用</h3><ol>
<li>下载<ul>
<li>在<a href="https://www.npmjs.com/">npmjs.com</a>官网中可以搜索gulp模块的插件 (有完整使用说明)</li>
<li>使用npm命令安装</li>
</ul>
</li>
<li>在gulpfile.js文件中引入插件<ul>
<li>require()方法</li>
</ul>
</li>
<li>调用插件</li>
</ol>
<h4 id="1-1HTML操作插件"><a href="#1-1HTML操作插件" class="headerlink" title="1.1HTML操作插件"></a>1.1HTML操作插件</h4><h5 id="1-html文件代码压缩任务"><a href="#1-html文件代码压缩任务" class="headerlink" title="1.html文件代码压缩任务"></a>1.html文件代码压缩任务</h5><p>在项目上线服务器运行时代码一般要经过压缩</p>
<p>安装html压缩插件</p>
<p><code>npm install gulp-htmlmin</code>  </p>
<p>创建任务</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//压缩html文件代码任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入gulp的htmlmin插件</span></span><br><span class="line"><span class="keyword">const</span> htmlmin=<span class="built_in">require</span>(<span class="string">&#x27;gulp-htmlmin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">&#x27;htmlmin&#x27;</span>, <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//&#x27;*&#x27;匹配所有html文件</span></span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/*.html&#x27;</span>)</span><br><span class="line">    <span class="comment">//使用插件的方法压缩html文件</span></span><br><span class="line">    <span class="comment">//collapseWhitespace意为压缩空格</span></span><br><span class="line">    .pipe(htmlmin(&#123; <span class="attr">collapseWhitespace</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">    <span class="comment">//输出到dist文件夹</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在powershell中执行后，./dist文件夹下产生两个同名的html文件，里面的代码都被压缩为1行显示</p>
<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210419212228699.png" alt="image-20210419212228699"></p>
<h5 id="2-提取html文件中的公共代码"><a href="#2-提取html文件中的公共代码" class="headerlink" title="2.提取html文件中的公共代码"></a>2.提取html文件中的公共代码</h5><p>提取公共代码可以在代码变化时只需要修改公共代码，而不用修改每一个html文件，提高效率</p>
<ul>
<li>下载插件</li>
</ul>
<p><code>npm install gulp-file-include</code></p>
<ul>
<li>找到公共代码</li>
</ul>
<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210419213419546.png" alt="image-20210419213419546"></p>
<p>两个html文件同属一个网站，他们的头部框架都是相同的，头部框架就是<strong>公共代码</strong></p>
<ul>
<li>提取公共代码</li>
</ul>
<p>在src文件夹下创建common文件夹，文件夹中创建header.html用来存放两个html的公共代码</p>
<p>将公共代码即头部框架剪切到header.html文件中，删除html文件中的公共代码(<strong>后面通过header.html引回</strong>)</p>
<p>在gulpfile.js中引入模块插件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fileinclude = <span class="built_in">require</span>(<span class="string">&#x27;gulp-file-include&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>gulpfile.js的任务代码，两个功能(提取代码，压缩html)合并为一个任务</p>
<p>任务中使用插件方法<code>fileinclude()</code></p>
<p>具体插件使用方法<a href="https://www.npmjs.com/package/gulp-file-include">gulp-file-include</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.压缩html文件代码任务</span></span><br><span class="line"><span class="comment">//2.抽取html文件的公共代码</span></span><br><span class="line"><span class="comment">//在压缩前先引回提取的公共代码</span></span><br><span class="line">gulp.task(<span class="string">&#x27;htmlmin&#x27;</span>, <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//&#x27;*&#x27;匹配所有html文件</span></span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/*.html&#x27;</span>)</span><br><span class="line">    <span class="comment">//使用插件引回提取的公共代码</span></span><br><span class="line">    .pipe(fileinclude())</span><br><span class="line">    <span class="comment">//使用插件的方法压缩html文件</span></span><br><span class="line">    .pipe(htmlmin(&#123; <span class="attr">collapseWhitespace</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">    <span class="comment">//输出到dist文件夹</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在html文件中使用<code>@@include(&#39;./common/header.html&#39;)</code> ， 将公共代码引回文件中</p>
<p>gulpfile.js文件中的任务使用了<code>fileinclude()</code>插件方法后，才能在html文件中使用<code>@@include(&#39;公共代码文件路径&#39;)</code></p>
<p>此时执行<code>htmlmin</code>任务，<strong>公共代码被引回html文件</strong>，并且<strong>html文件被压缩为一行</strong></p>
<h4 id="1-2-CSS和less操作插件"><a href="#1-2-CSS和less操作插件" class="headerlink" title="1.2 CSS和less操作插件"></a>1.2 CSS和less操作插件</h4><h5 id="1-less语法转换"><a href="#1-less语法转换" class="headerlink" title="1.less语法转换"></a>1.less语法转换</h5><p>下载将less文件转换为css的gulp插件</p>
<p><a href="https://www.npmjs.com/package/gulp-less">gulp-less官方文档</a></p>
<p><code>npm install gulp-less</code></p>
<p>在gulpfiles.js文件中引入插件并编写任务</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入less代码转css代码的插件</span></span><br><span class="line"><span class="keyword">const</span> less = <span class="built_in">require</span>(<span class="string">&#x27;gulp-less&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.less代码转css代码</span></span><br><span class="line"><span class="comment">//2.压缩css代码</span></span><br><span class="line">gulp.task(<span class="string">&#x27;cssmin&#x27;</span>,<span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//取src目录下所有less文件</span></span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/*.less&#x27;</span>)</span><br><span class="line">    .pipe(less())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./dist/css&#x27;</span>))</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>a.less文件被转换为a.css文件</p>
<center>a.less文件</center>

<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210425172427623.png" alt="image-20210425172427623"></p>
<center>a.css文件</center>

<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210425172652353.png" alt="image-20210425172652353"></p>
<h5 id="2-css代码压缩"><a href="#2-css代码压缩" class="headerlink" title="2.css代码压缩"></a>2.css代码压缩</h5><p><code>gulp.src([&#39;路径&#39;,&#39;路径])</code>的参数可以传递一个数组，数组中的每个元素是一个路径，将这些路径指示的文件全部获取。</p>
<p>下载gulp-csso插件</p>
<p><a href="https://www.npmjs.com/package/gulp-csso">gulp-csso官方文档</a></p>
<p><code>npm install gulp-csso</code></p>
<p>代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//css压缩</span></span><br><span class="line"><span class="keyword">const</span> csso = <span class="built_in">require</span>(<span class="string">&#x27;gulp-csso&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.less代码转css代码</span></span><br><span class="line"><span class="comment">//2.压缩css代码</span></span><br><span class="line">gulp.task(<span class="string">&#x27;cssmin&#x27;</span>,<span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//取src/css目录下所有less文件</span></span><br><span class="line">    gulp.src([<span class="string">&#x27;./src/css/*.less&#x27;</span>,<span class="string">&#x27;./src/css/*.css&#x27;</span>])</span><br><span class="line">    <span class="comment">//less代码转换</span></span><br><span class="line">    .pipe(less())</span><br><span class="line">    <span class="comment">//css压缩</span></span><br><span class="line">    .pipe(csso())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./dist/css&#x27;</span>))</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>压缩后代码</center>

<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210425173744670.png" alt="image-20210425173744670"></p>
<h4 id="1-3JS操作插件"><a href="#1-3JS操作插件" class="headerlink" title="1.3JS操作插件"></a>1.3JS操作插件</h4><p>下载插件</p>
<p><a href="https://www.npmjs.com/package/gulp-babel">gulp-babel官方文档</a></p>
<p><code>npm install gulp-babel @babel/core @babel/preset-env</code></p>
<p>@babel/core 和 @babel/preset-env 是gulp-babel依赖的包，一起下载</p>
<h5 id="1-ES6代码转换"><a href="#1-ES6代码转换" class="headerlink" title="1.ES6代码转换"></a>1.ES6代码转换</h5><p>代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//js任务</span></span><br><span class="line"><span class="comment">//1.ES6代码转换</span></span><br><span class="line"><span class="comment">//2.js代码压缩</span></span><br><span class="line">gulp.task(<span class="string">&#x27;jsmin&#x27;</span>,<span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/js/*.js&#x27;</span>)</span><br><span class="line">    .pipe(babel(&#123;</span><br><span class="line">        <span class="comment">//presets 自动判断当前环境，将代码转换为当前支持的格式</span></span><br><span class="line">        presets: [<span class="string">&#x27;@babel/env&#x27;</span>]</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./dist/js&#x27;</span>))</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center><strong>转换结果</strong></center>

<p>将右侧的ES6代码转换为左侧的<strong>严格模式的ES5代码</strong></p>
<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210425175329969.png" alt="image-20210425175329969"></p>
<h5 id="2-js代码压缩"><a href="#2-js代码压缩" class="headerlink" title="2.js代码压缩"></a>2.js代码压缩</h5><p>gulp-uglify 插件 ：压缩js代码</p>
<p>下载插件</p>
<p><a href="https://www.npmjs.com/package/gulp-uglify">gulp-uglify官方文档</a></p>
<p><code>npm install gulp-uglify</code></p>
<p>代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//js代码压缩</span></span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">&#x27;gulp-uglify&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//js任务</span></span><br><span class="line"><span class="comment">//1.ES6代码转换</span></span><br><span class="line"><span class="comment">//2.js代码压缩</span></span><br><span class="line">gulp.task(<span class="string">&#x27;jsmin&#x27;</span>,<span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/js/*.js&#x27;</span>)</span><br><span class="line">    <span class="comment">//ES6转换</span></span><br><span class="line">    .pipe(babel(&#123;</span><br><span class="line">        <span class="comment">//presets 自动判断当前环境，将代码转换为当前支持的格式</span></span><br><span class="line">        presets: [<span class="string">&#x27;@babel/env&#x27;</span>]</span><br><span class="line">    &#125;))</span><br><span class="line">    <span class="comment">//js代码压缩</span></span><br><span class="line">    .pipe(uglify())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./dist/js&#x27;</span>))</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<center>ES6转换并压缩后文件</center>

<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210425180011653.png" alt="image-20210425180011653"></p>
<h4 id="1-4文件拷背"><a href="#1-4文件拷背" class="headerlink" title="1.4文件拷背"></a>1.4文件拷背</h4><p>代码</p>
<ul>
<li>此处/*代表匹配一级的所有文件和目录<ul>
<li>若使用images/*来匹配images/a/b.jpg ，则<strong>只能匹配到images/a这个文件夹</strong>，不会匹配到b.jpg</li>
<li>此时匹配获取文件后输出的images/a文件夹是空的</li>
</ul>
</li>
<li>lib/**/*代表匹配lib文件夹下的所有目录<strong>及其子目录</strong>中的文件<ul>
<li>**代表匹配所有目录及其子目录</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将剩下的images文件夹和lib文件夹拷贝到dist文件夹下</span></span><br><span class="line">gulp.task(<span class="string">&#x27;copy&#x27;</span>,<span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/images/*&#x27;</span>)</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./dist/images&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/lib/**/*&#x27;</span>)</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./dist/lib&#x27;</span>))</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="1-5一次执行多个任务"><a href="#1-5一次执行多个任务" class="headerlink" title="1.5一次执行多个任务"></a>1.5一次执行多个任务</h4><p>代码</p>
<p>执行default任务时依次执行后面数组中的每个任务</p>
<ul>
<li><strong>gulp4.0及更高版本</strong>需要使用<code>gulp.parallel(&#39;任务名&#39;,&#39;任务名&#39;,...)</code>来执行多个任务</li>
<li>gulp4.0之前的版本可以使用<code>gulp.task(&#39;default&#39;,[&#39;任务名&#39;,&#39;任务名&#39;,...])</code>来执行多个任务</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">&#x27;default&#x27;</span>,gulp.parallel(<span class="string">&#x27;htmlmin&#x27;</span>,<span class="string">&#x27;cssmin&#x27;</span>,<span class="string">&#x27;jsmin&#x27;</span>,<span class="string">&#x27;copy&#x27;</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>在命令行中执行gulp命令，gulp会自动在gulpfile.js文件中寻找名为default的任务并执行</li>
<li>在命令行中执行<code>gulp</code>相当于执行<code>gulp default</code></li>
</ul>
<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210426112637572.png" alt="image-20210426112637572"></p>
<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210426112702650.png" alt="image-20210426112702650"></p>
<ul>
<li>此时只需执行default任务就可以执行项目中所有的任务</li>
</ul>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS盒模型</title>
    <url>/2022/11/27/04-CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h1><p>当一个文档进行布局时浏览器渲染引擎会<strong>根据设定的盒模型</strong>将<strong>所有元素表示为一个矩形区域</strong></p>
<ul>
<li>行内元素的矩形区域没有width和height等值</li>
</ul>
<p><strong>CSS3中的box-sizing属性</strong>可以指定页面元素使用的盒模型</p>
<ul>
<li>box-sizing属性定义了<strong>如何计算一个元素的总高度和总宽度</strong></li>
</ul>
<h2 id="box-sizing的属性取值"><a href="#box-sizing的属性取值" class="headerlink" title="box-sizing的属性取值"></a>box-sizing的属性取值</h2><ul>
<li><strong>content-box</strong>：默认值，<ul>
<li>width和height<strong>只包含内容区域</strong>的宽高    width=内容宽度</li>
<li><strong>不包含</strong>margin，padding和border</li>
<li>margin，padding和border<strong>都在盒子外部</strong></li>
</ul>
</li>
<li><strong>border-box</strong>：<ul>
<li>width = 内容宽度 + padding + border</li>
<li>宽度和高度<strong>不包含 margin</strong></li>
</ul>
</li>
<li><strong>inherit</strong>：<strong>从父元素继承box-sizing的值</strong><ul>
<li>此属性MDN文档没有提及</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>HTMLandCss</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>JSX</title>
    <url>/2022/11/27/04-JSX/</url>
    <content><![CDATA[<h1 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h1><h2 id="1-React-createElement-存在的问题"><a href="#1-React-createElement-存在的问题" class="headerlink" title="1.  React.createElement()存在的问题"></a>1.  <code>React.createElement()</code>存在的问题</h2><p>创建结构复杂的React元素时繁琐且不直观</p>
<span id="more"></span>

<h2 id="2-JSX简介"><a href="#2-JSX简介" class="headerlink" title="2. JSX简介"></a>2. JSX简介</h2><p><img data-src="/images/04-JSX/image-20220331215627059.png" alt="image-20220331215627059"></p>
<p>使用<code>JSX</code>可以直接用HTML创建React元素</p>
<p><img data-src="/images/04-JSX/image-20220331215935227.png" alt="image-20220331215935227"></p>
<ul>
<li>JSX是React的核心内容，<strong>用来创建React元素</strong></li>
<li>相比于<code>createElement</code>，JSX更加方便直观</li>
<li>JSX可以更好的体现React声明式的特点</li>
</ul>
<p><img data-src="/images/04-JSX/image-20220331220156571.png" alt="image-20220331220156571"></p>
<br>

<h2 id="3-注意点"><a href="#3-注意点" class="headerlink" title="3. 注意点"></a>3. 注意点</h2><p><img data-src="/images/04-JSX/image-20220331220448995.png" alt="image-20220331220448995"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> title = (<span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&#x27;title&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="xml">             	hello JSX</span></span><br><span class="line"><span class="xml">             	&#123;/* 没有子节点的React元素可以写为单标签形式 */&#125;</span></span><br><span class="line"><span class="xml">    			<span class="tag">&lt;<span class="name">span</span>/&gt;</span> </span></span><br><span class="line"><span class="xml">        	<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>)</span><br></pre></td></tr></table></figure>

<br>

<h2 id="4-JSX中使用JavaScript表达式"><a href="#4-JSX中使用JavaScript表达式" class="headerlink" title="4. JSX中使用JavaScript表达式"></a>4. JSX中使用JavaScript表达式</h2><p>语法：<span style="color:red;">将js表达式包裹在<code>&#123; &#125;</code>中</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Jack&#x27;</span></span><br><span class="line"><span class="keyword">let</span> title = (<span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&#x27;title&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="xml">              hello JSX,&#123;name&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="4-1-注意点"><a href="#4-1-注意点" class="headerlink" title="4.1 注意点"></a>4.1 注意点</h3><p><img data-src="/images/04-JSX/image-20220331221350997.png" alt="image-20220331221350997"></p>
<p><img data-src="/images/04-JSX/image-20220331221538856.png" alt="image-20220331221538856"></p>
<br>

<h2 id="5-JSX条件渲染"><a href="#5-JSX条件渲染" class="headerlink" title="5. JSX条件渲染"></a>5. JSX条件渲染</h2><p><img data-src="/images/04-JSX/image-20220331222531610.png" alt="image-20220331222531610"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isLoading = <span class="literal">false</span></span><br><span class="line"><span class="comment">//if-else</span></span><br><span class="line"><span class="keyword">let</span> loading = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(isLoading === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>加载中<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>加载完成<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三元表达式</span></span><br><span class="line"><span class="keyword">let</span> loading = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> isLoading ? (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>加载中<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>) : (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>加载完成<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与运算符</span></span><br><span class="line"><span class="keyword">let</span> loading = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//isLoading为true时，表达式结果为 (&lt;div&gt;加载中&lt;/div&gt;)，否则没有结果</span></span><br><span class="line">  <span class="keyword">return</span> isLoading &amp;&amp; (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>加载中<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> title = (<span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&#x27;title&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="xml">              &#123; loading() &#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>)</span><br></pre></td></tr></table></figure>

<br>

<h2 id="6-JSX列表渲染"><a href="#6-JSX列表渲染" class="headerlink" title="6. JSX列表渲染"></a>6. JSX列表渲染</h2><p><img data-src="/images/04-JSX/image-20220331223006977.png" alt="image-20220331223006977"></p>
<br>

<h2 id="7-JSX样式处理"><a href="#7-JSX样式处理" class="headerlink" title="7. JSX样式处理"></a>7. JSX样式处理</h2><ul>
<li>使用行内样式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> title = (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span>&#x27;<span class="attr">red</span>&#x27;,<span class="attr">backgroundColor:</span>&#x27;<span class="attr">skyblue</span>&#x27;&#125;&#125;&gt;</span>Hello JSX<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br></pre></td></tr></table></figure>

<p>元素使用style属性，<code>&#123;&#125;</code>中为一个<strong>样式对象</strong>(样式使用驼峰命名键值对形式)</p>
<p>JSX中JS对象一般出现在style属性中</p>
<br>

<ul>
<li>使用类名(<strong>推荐</strong>)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入index.css，文件中定义header类</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> title = (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;header&#x27;</span>&gt;</span>Hello JSX<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>WXSS模板样式</title>
    <url>/2022/11/27/04-WXSS%E6%A8%A1%E6%9D%BF%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="WXSS模板样式"><a href="#WXSS模板样式" class="headerlink" title="WXSS模板样式"></a>WXSS模板样式</h1><h2 id="1-WXSS与CSS区别"><a href="#1-WXSS与CSS区别" class="headerlink" title="1. WXSS与CSS区别"></a>1. WXSS与CSS区别</h2><p><img data-src="../images/04-WXSS%E6%A8%A1%E6%9D%BF%E6%A0%B7%E5%BC%8F/image-20220208133844059.png" alt="image-20220208133844059"></p>
<span id="more"></span>

<h2 id="2-rpx的实现原理"><a href="#2-rpx的实现原理" class="headerlink" title="2. rpx的实现原理"></a>2. rpx的实现原理</h2><p>rpx是微信小程序独有的，用来解决屏幕适配的尺寸单位</p>
<p><img data-src="../images/04-WXSS%E6%A8%A1%E6%9D%BF%E6%A0%B7%E5%BC%8F/image-20220208134054326.png" alt="image-20220208134054326"></p>
<h2 id="3-rpx与px的换算"><a href="#3-rpx与px的换算" class="headerlink" title="3. rpx与px的换算"></a>3. rpx与px的换算</h2><p>以iphone6为例，<code>1rpx = 0.5px</code></p>
<p>不同的屏幕有着不同的换算比例</p>
<p>开发小程序推荐使用iphone6屏幕，因为其换算规则正好是整数 2倍</p>
<h2 id="4-样式导入"><a href="#4-样式导入" class="headerlink" title="4. 样式导入"></a>4. 样式导入</h2><p>小程序开发使用<code>@import</code>进行外联WXSS样式导入</p>
<p><img data-src="../images/04-WXSS%E6%A8%A1%E6%9D%BF%E6%A0%B7%E5%BC%8F/image-20220208135515703.png" alt="image-20220208135515703"></p>
<h2 id="5-全局和局部样式"><a href="#5-全局和局部样式" class="headerlink" title="5. 全局和局部样式"></a>5. 全局和局部样式</h2><p>局部样式和全局样式冲突时，当局部样式的<strong>权重高于或等于</strong>全局样式时，局部会覆盖全局</p>
<p>当全局的样式权重高时，仍是全局样式生效</p>
<p><img data-src="../images/04-WXSS%E6%A8%A1%E6%9D%BF%E6%A0%B7%E5%BC%8F/image-20220208172128325.png" alt="image-20220208172128325"></p>
<center>全局样式</center>

<p><img data-src="../images/04-WXSS%E6%A8%A1%E6%9D%BF%E6%A0%B7%E5%BC%8F/image-20220208172139528.png" alt="image-20220208172139528"></p>
<center>局部样式</center>

<p>此时全局样式设置第一个view组件背景为亮粉色，其权重高于局部样式，所以第一个view组件应用全局样式</p>
<p><img data-src="../images/04-WXSS%E6%A8%A1%E6%9D%BF%E6%A0%B7%E5%BC%8F/image-20220208172227053.png" alt="image-20220208172227053"></p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>04-webpack</title>
    <url>/2021/04/26/04-Webpack/</url>
    <content><![CDATA[<h1 id="1-webpack概述"><a href="#1-webpack概述" class="headerlink" title="1. webpack概述"></a>1. webpack概述</h1><p><strong>webpack</strong>是一个流行的<strong>前端项目构建工具</strong>（打包工具），提高<strong>开发效率和项目可维护性</strong></p>
<p>好处：</p>
<ul>
<li>提供<strong>友好的模块化支持</strong>（ES6模块化）</li>
<li>代码压缩混淆</li>
<li>处理js兼容性问题</li>
<li>性能优化</li>
<li>etc…</li>
</ul>
<h1 id="2-webpack基本使用"><a href="#2-webpack基本使用" class="headerlink" title="2. webpack基本使用"></a>2. webpack基本使用</h1><h2 id="2-1-构建一个列表隔行变色的项目"><a href="#2-1-构建一个列表隔行变色的项目" class="headerlink" title="2.1 构建一个列表隔行变色的项目"></a>2.1 构建一个列表隔行变色的项目</h2><p><img data-src="/images/04-Webpack/image-20211008202145336.png" alt="image-20211008202145336"></p>
<ul>
<li>项目源代码都放在src文件夹中</li>
</ul>
<p><img data-src="/images/04-Webpack/image-20211008204717641.png" alt="image-20211008204717641"></p>
<center>项目目录</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ES6模块化导入 jquery</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span></span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;li:odd&#x27;</span>).css(<span class="string">&#x27;backgroundColor&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">    $(<span class="string">&#x27;li:even&#x27;</span>).css(<span class="string">&#x27;backgroundColor&#x27;</span>,<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>index.js</center>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 调用js文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<center>index.html</center>

<ul>
<li>此时运行index.html文件<strong>没有效果并报错</strong><ul>
<li>浏览器对于ES6模块化规范<strong>支持的并不好</strong></li>
<li>运行index.js文件时因为使用了ES6模块化而报错</li>
</ul>
</li>
<li>使用webpack处理js文件后可以正常使用<ul>
<li>因为webpack提供了<strong>友好的ES6模块化支持</strong></li>
</ul>
</li>
</ul>
<br>

<h2 id="2-2-webpack安装"><a href="#2-2-webpack安装" class="headerlink" title="2.2 webpack安装"></a>2.2 webpack安装</h2><p><img data-src="/images/04-Webpack/image-20211008204812707.png" alt="image-20211008204812707"></p>
<ul>
<li><p>运行<code>npm run dev</code> 命令后</p>
<ul>
<li>webpack将项目中的<code>index.js</code>和之前通过npm命令安装的<code>jquery.js</code>一起打包为<code>main.js</code>文件</li>
<li><code>main.js</code>文件位于项目根目录下的dist文件夹下 <code>(/dist/main.js)</code></li>
</ul>
</li>
<li><p>此时在<code>index.html</code>文件中直接引用<code>main.js</code>文件，因为ES6模块化导致的错误消失（webpack处理js兼容性问题）</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/dist/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<center>index.html文件引用打包后的main.js</center>

<p><img data-src="/images/04-Webpack/image-20211008205206982.png" alt="image-20211008205206982"></p>
<center>效果实现</center>

<h3 id="2-2-1-webpack配置项mode"><a href="#2-2-1-webpack配置项mode" class="headerlink" title="2.2.1 webpack配置项mode"></a>2.2.1 webpack配置项mode</h3><p><code>webpack.config.js</code>文件中导出配置项<strong>mode</strong></p>
<p><strong>mode可取值为</strong></p>
<ul>
<li><p>development ：开发模式，不压缩代码，不进行代码混淆，速度快</p>
</li>
<li><p>production：生产模式，压缩并混淆代码，速度慢</p>
</li>
</ul>
<br>

<h2 id="2-3-配置打包的入口与出口"><a href="#2-3-配置打包的入口与出口" class="headerlink" title="2.3 配置打包的入口与出口"></a>2.3 配置打包的入口与出口</h2><p>webpack打包时有默认入口和出口</p>
<ul>
<li>默认入口：<code>./src/index.js</code></li>
<li>默认出口：<code>./dist/main.js</code></li>
</ul>
<p>可以在<code>webpack.config.js</code>文件中<strong>手动指定打包入口和出口</strong></p>
<ul>
<li><strong>entry</strong>配置项指定打包的入口</li>
<li><strong>output</strong>配置项指定打包后输出文件的<strong>名字和路径</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode:<span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">    entry:path.join(__dirname,<span class="string">&#x27;src/index.js&#x27;</span>),  <span class="comment">//打包入口文件路径</span></span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:<span class="string">&#x27;bundle.js&#x27;</span>,   <span class="comment">//打包输出文件名</span></span><br><span class="line">        path:path.join(__dirname,<span class="string">&#x27;dist&#x27;</span>)    <span class="comment">//输出文件路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/04-Webpack/image-20211008211718961.png" alt="image-20211008211718961"></p>
<h2 id="2-4-配置自动打包功能"><a href="#2-4-配置自动打包功能" class="headerlink" title="2.4 配置自动打包功能"></a>2.4 配置自动打包功能</h2><p><code>index.html</code>文件中引用的是打包后输出的js文件</p>
<p>如果对js文件作出修改则需要<strong>重新打包生成输出文件</strong>，而每次手动打包很繁琐</p>
<br>

<p>使用自动打包功能可以监听文件的变化，当文件变化后自动打包</p>
<p>使用<code>webpack-dev-server</code>模块实现自动打包功能</p>
<h3 id="2-4-1-使用webpack-dev-server插件"><a href="#2-4-1-使用webpack-dev-server插件" class="headerlink" title="2.4.1 使用webpack-dev-server插件"></a>2.4.1 使用webpack-dev-server插件</h3><ol>
<li>项目根目录下安装<code>webpack-dev-server</code>插件</li>
</ol>
<ul>
<li><code>npm install webpack-dev-server -D</code></li>
</ul>
<ol start="2">
<li><code>package.json</code>文件下的scripts中新增命令如下</li>
</ol>
<ul>
<li><img data-src="/images/04-Webpack/image-20211009123331749.png" alt="image-20211009123331749"></li>
</ul>
<ol start="3">
<li><p>将index.html中js文件引用路径改为<code>/bundle.js</code></p>
</li>
<li><p><code>webpack.config.js</code>中配置devServer配置项（将dist目录下的文件挂载到localhost:8080下）</p>
<ul>
<li><p>static可以将路径设置为项目根目录（<code>static:__dirname</code>）</p>
</li>
<li><p><img data-src="/images/04-Webpack/image-20211009123605059.png" alt="image-20211009123605059"></p>
</li>
</ul>
</li>
<li><p>运行<code>npm run start</code>重新进行打包</p>
<p><img data-src="/images/04-Webpack/image-20211009124126614.png" alt="image-20211009124126614"></p>
</li>
<li><p>浏览器访问<code>http://localhost:8080</code>查看index.html文件效果</p>
<ul>
<li>此时修改index.js文件并保存后，会自动打包并刷新index.html页面</li>
</ul>
</li>
</ol>
<p style="color:red;">注意：</p>

<ul>
<li><p>webpack-dev-server启动一个<strong>实时打包的http服务器</strong>（访问服务器实时查看修改后的效果）</p>
</li>
<li><p>webpack-dev-server打包生成的输出文件（<code>bundle.js</code>）放在static配置项指定的目录下，而且<strong>存放于内存中，在硬盘中不可见</strong></p>
</li>
<li><p>当<code>static</code>配置项的值为<strong>dist文件夹下时</strong>，index.html文件要放在dist目录下，否则访问<code>http://localhost:8080</code>只能看到打包后的js文件</p>
</li>
</ul>
<br>

<h3 id="2-4-2-配置自动打包的相关参数"><a href="#2-4-2-配置自动打包的相关参数" class="headerlink" title="2.4.2 配置自动打包的相关参数"></a>2.4.2 配置自动打包的相关参数</h3><p>在<code>package.json</code>文件中<code>scripts</code>字段下的<strong>自动打包命令中</strong>添加参数即可</p>
<ul>
<li><code>--open</code> 运行自动打包命令后<strong>自动打开浏览器</strong></li>
<li><code>--host</code> 配置打开的http服务器的<strong>IP地址</strong>（默认为localhost/127.0.0.1）</li>
<li><code>--port</code> 配置打开的http服务器的<strong>端口号</strong>（默认为8080）</li>
</ul>
<p><img data-src="/images/04-Webpack/image-20211009222901947.png" alt="image-20211009222901947"></p>
<p>配置服务器IP为127.0.0.1 运行于4000端口</p>
<br>

<h2 id="2-5-配置自动生成预览页面"><a href="#2-5-配置自动生成预览页面" class="headerlink" title="2.5 配置自动生成预览页面"></a>2.5 配置自动生成预览页面</h2><p><code>webpack-dev-server</code>模块自动打包开启http服务器时，若指定<code>static配置项</code>的值为项目根目录</p>
<p>此时访问<code>http://localhost:8080</code>会打开根目录路径显示页面，<strong>并不会直接显示index.html页面</strong></p>
<p><img data-src="/images/04-Webpack/image-20211009221333896.png" alt="image-20211009221333896"></p>
<center>显示路径页面</center>

<p>此时需要手动点击src目录才能看到index.html页面效果（index.html文件位于src目录下）</p>
<p>这对于调试过程来说<strong>比较繁琐</strong></p>
<p>使用<code>html-webpack-plugin</code>模块直接生成预览页面解决问题</p>
<h3 id="2-5-1-安装使用html-webpack-plugin模块"><a href="#2-5-1-安装使用html-webpack-plugin模块" class="headerlink" title="2.5.1 安装使用html-webpack-plugin模块"></a>2.5.1 安装使用html-webpack-plugin模块</h3><p><img data-src="/images/04-Webpack/image-20211009221732963.png" alt="image-20211009221732963"></p>
<p>此时再使用<code>webpack-dev-server</code>插件打开http服务器即可直接访问index.html页面</p>
<p>会在项目根目录下生成预览的index.html文件（文件存放于内存）</p>
<br>

<h2 id="2-6-webpack中的加载器"><a href="#2-6-webpack中的加载器" class="headerlink" title="2.6 webpack中的加载器"></a>2.6 webpack中的加载器</h2><p>webpack在打包时<strong>默认只能打包 .js后缀的文件</strong>，对于其他后缀的文件，需要<strong>配置对应的加载器</strong>才能进行打包</p>
<p>如果不使用加载器，打包非.js后缀的模块时会报错</p>
<p><strong>加载器loader</strong></p>
<h3 id="2-6-1-loader加载器调用过程"><a href="#2-6-1-loader加载器调用过程" class="headerlink" title="2.6.1 loader加载器调用过程"></a>2.6.1 loader加载器调用过程</h3><p><img data-src="/images/04-Webpack/image-20211009223332588.png" alt="image-20211009223332588"></p>
<h3 id="2-6-2-加载器基本使用"><a href="#2-6-2-加载器基本使用" class="headerlink" title="2.6.2 加载器基本使用"></a>2.6.2 加载器基本使用</h3><h3 id="2-6-3-打包处理css文件"><a href="#2-6-3-打包处理css文件" class="headerlink" title="2.6.3 打包处理css文件"></a>2.6.3 打包处理css文件</h3><ol>
<li>安装<code>style-loader</code>和<code>css-loader</code>加载器</li>
</ol>
<ul>
<li><code>npm install style-loader css-loader -D</code></li>
</ul>
<ol start="2">
<li>在<code>webpack.config.js</code>中<strong>新增module配置对象</strong>，在module对象下的<strong>rules数组中配置加载器匹配规则</strong></li>
</ol>
<ul>
<li>```js<br>module:{<pre><code>    //配置加载器匹配规则
    rules:[
        //test匹配指定后缀文件
        //use调用对应加载器处理
        &#123;test:/\.css$/,use:[&#39;style-loader&#39;,&#39;css-loader&#39;]&#125;
    ]
&#125;
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 在&#96;index.js&#96;模块主入口中引入其他所有模块（包括后缀不是.js的其他模块）</span><br><span class="line"></span><br><span class="line">- &lt;span style&#x3D;&quot;color:red&quot;&gt;此时在html文件中只需要引入**index.js**主模块就行&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">- ![image-20211009230010208](&#x2F;images&#x2F;04-Webpack&#x2F;image-20211009230010208.png)</span><br><span class="line"></span><br><span class="line">4. 执行命令进行打包</span><br><span class="line"></span><br><span class="line">- 此时index.js和index.css被整合打包，其中index.css使用加载器处理后进行打包</span><br><span class="line"></span><br><span class="line">![image-20211009230406230](&#x2F;images&#x2F;04-Webpack&#x2F;image-20211009230406230.png)</span><br><span class="line"></span><br><span class="line">&lt;center&gt;去除列表前面的点&lt;&#x2F;center&gt;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">- css文件打包时两个加载器书写顺序固定，先&#96;style-loader&#96;，再&#96;css-loader&#96;</span><br><span class="line">- 多个loader的调用顺序**从后往前**</span><br><span class="line">  - 打包处理css文件时，先对css文件调用&#96;css-loader&#96;，再调用&#96;style-loader&#96;，最后交给webpack进行打包</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">### 2.6.4 打包处理less文件</span><br><span class="line"></span><br><span class="line">1. 安装less和less-loader模块</span><br><span class="line">   - &#96;npm install less-loader less -D&#96;</span><br><span class="line">   - less是less-loader的内置依赖项</span><br><span class="line"></span><br><span class="line">2. 配置加载器匹配规则</span><br><span class="line">   - &#96;&#123;test:&#x2F;\.less$&#x2F;,use:[&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;less-loader&#39;]&#125;&#96;</span><br><span class="line">   - less文件加载器依赖于 &#96;style-loader和css-loader&#96;</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">### 2.6.5 打包处理scss文件</span><br><span class="line"></span><br><span class="line">1. 安装&#96;sass-loader和node-sass&#96;模块**（注意安装的是sass不是scss）**</span><br><span class="line">   - &#96;npm install sass-loader node-sass -D&#96;</span><br><span class="line">2. 配置加载器匹配规则</span><br><span class="line">   - &#96;&#123;test:&#x2F;\.scss$&#x2F;,use:[&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;sass-loader&#39;]&#125;&#96;</span><br><span class="line">   - &#96;sass-loader&#96;依赖于&#96;style-loader和css-loader&#96;</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">### 2.6.6 配置postcss自动添加css兼容性前缀</span><br><span class="line"></span><br><span class="line">**不同的浏览器**对一些CSS样式兼容性不同,，例如下述设置在chrome和IE浏览器中显示效果不同</span><br><span class="line"></span><br><span class="line">- chrome中显示字体为红色</span><br><span class="line"></span><br><span class="line">- IE中仍为灰色</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;css</span><br><span class="line">::placeholder&#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>配置postcss在打包时自动添加css兼容性前缀可以解决问题</p>
<p><strong>兼容型前缀例如</strong> </p>
<ul>
<li>chrome和safari使用的<code>-webkit</code></li>
<li>IE使用的 <code>-ms</code> 等</li>
</ul>
<br>

<p><strong>安装使用postcss-loader和autoprefixer模块</strong></p>
<p><img data-src="/images/04-Webpack/image-20211010165259004.png" alt="image-20211010165259004"></p>
<br>

<h3 id="2-6-7-打包处理样式表中图片和字体文件"><a href="#2-6-7-打包处理样式表中图片和字体文件" class="headerlink" title="2.6.7 打包处理样式表中图片和字体文件"></a>2.6.7 打包处理样式表中图片和字体文件</h3><p>webpack<strong>旧版本</strong>在打包时默认不识别css文件中<strong>图片和字体文件的路径</strong></p>
<p><img data-src="/images/04-Webpack/image-20211010172758535.png" alt="image-20211010172758535"></p>
<p><span style="color:red">但是在webpack5.58.0 版本中已经可以自动识别路径</span></p>
<p>对于旧版本可以使用<code>url-loader</code>和<code>file-loader</code>模块识别图片和字体文件的路径</p>
<h4 id="2-6-7-1-安装使用url-loader和file-loader模块"><a href="#2-6-7-1-安装使用url-loader和file-loader模块" class="headerlink" title="2.6.7.1 安装使用url-loader和file-loader模块"></a>2.6.7.1 安装使用<code>url-loader</code>和<code>file-loader</code>模块</h4><p><img data-src="/images/04-Webpack/image-20211010173108628.png" alt="image-20211010173108628"></p>
<ul>
<li><strong>大于等于</strong>limit值的图片URL会直接打包为 URL的形式</li>
<li><strong>小于</strong>limit值的图片URL转换为base64格式打包<ul>
<li>base64格式的URL可以<strong>提升加载图片的速度</strong></li>
</ul>
</li>
</ul>
<h3 id="2-6-8-打包处理js文件中的高级语法"><a href="#2-6-8-打包处理js文件中的高级语法" class="headerlink" title="2.6.8 打包处理js文件中的高级语法"></a>2.6.8 打包处理js文件中的高级语法</h3><p>webpack<strong>默认不识别ES6的js高级语法</strong>，直接打包有ES6高级语法的js文件会<strong>报错</strong></p>
<p>需要使用<code>babel-loader</code>加载器</p>
<p><img data-src="/images/04-Webpack/image-20211011172429140.png" alt="image-20211011172429140"></p>
<ul>
<li>第四步<strong>添加exclude</strong>表示对<strong>除了node_modules文件夹之外的js文件</strong>应用babel-loader加载器<ul>
<li>node_modules文件夹中的js文件是第三方模块，不需要babel-loader加载器处理</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">New</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> info = <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(New.info);</span><br></pre></td></tr></table></figure>

<ul>
<li>在index.js文件中加入<strong>ES6的类语法</strong></li>
</ul>
<p><img data-src="/images/04-Webpack/image-20211011174711474.png" alt="image-20211011174711474"></p>
<ul>
<li>成功输出aaa</li>
</ul>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>04-node_modules文件夹的问题</title>
    <url>/2021/04/26/04-node_modules%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="node-modules文件夹的问题"><a href="#node-modules文件夹的问题" class="headerlink" title="node_modules文件夹的问题"></a>node_modules文件夹的问题</h1><ul>
<li>文件夹下的文件过多过碎，<strong>拷贝项目时速度慢</strong></li>
<li>复杂的<strong>模块依赖关系</strong>以及<strong>模块的版本号</strong>需要被记录，避免拷贝后模块版本号不同而导致运行报错</li>
</ul>
<h2 id="1-package-json文件"><a href="#1-package-json文件" class="headerlink" title="1.package.json文件"></a>1.package.json文件</h2><ul>
<li><strong>拷贝项目给他人时不需要拷贝node_modules文件夹，只需要拷贝package.json文件</strong></li>
<li>package.json项目描述文件会记录当前项目依赖的第三方模块及其版本号和项目名称等一系列项目信息</li>
<li>别人根据package.json文件就可以下载对应的依赖第三方模块</li>
</ul>
<span id="more"></span>

<h3 id="创建package-json文件"><a href="#创建package-json文件" class="headerlink" title="创建package.json文件"></a>创建package.json文件</h3><p><strong>1.使用<code>npm init -y</code>命令在项目根目录下生成package.json文件</strong></p>
<ul>
<li><code>npm init</code> 命令执行时会询问要填写的项目基本信息，如项目名称，版本等</li>
<li><code>npm init -y</code>   <strong>-y</strong>  即意味着所有询问的信息全部采用默认值</li>
</ul>
<center>创建package.json文件</center>

<p><img data-src="/images/04-node_modules%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E9%97%AE%E9%A2%98/image-20210426115738307.png" alt="image-20210426115738307"></p>
<ul>
<li>main ：项目的主模块</li>
<li>script：命令别名</li>
<li>keywords：项目关键字</li>
<li>author：作者</li>
<li>license：协议，ISC是开放源代码协议</li>
</ul>
<p><strong>2.创建好package.json文件后，使用npm命令下载第三方模块时，该模块的版本号等信息就会被自动记录在package.json文件中</strong></p>
<p>此处使用<code>npm install formidable mime</code>命令下载两个模块</p>
<p>package.json文件中的license字段下新增dependencies字段</p>
<p>该字段中就保存了项目依赖的模块名字与版本信息</p>
<p><img data-src="/images/04-node_modules%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E9%97%AE%E9%A2%98/image-20210426120400050.png" alt="image-20210426120400050"></p>
<h2 id="2-别人拿到拷贝的package-json文件如何使用"><a href="#2-别人拿到拷贝的package-json文件如何使用" class="headerlink" title="2.别人拿到拷贝的package.json文件如何使用"></a>2.别人拿到拷贝的package.json文件如何使用</h2><ul>
<li>在项目根目录下执行<code>npm Install</code>命令</li>
<li>npm会在项目根目录下找到package.json文件中的dependencies字段</li>
<li>将其中的依赖模块<strong>自动按版本号进行下载</strong></li>
<li>下载完毕后根目录下会自动生成node_modules文件夹，其中就存放着下载的依赖模块</li>
</ul>
<h2 id="3-项目-开发依赖"><a href="#3-项目-开发依赖" class="headerlink" title="3.项目/开发依赖"></a>3.项目/开发依赖</h2><ul>
<li>项目依赖：即开发和上线运行都需要的第三方模块</li>
<li>开发依赖：只在开发过程需要，在<strong>上线运行时不需要</strong>的第三方模块</li>
</ul>
<p>安装npm包时</p>
<ul>
<li>使用<code>npm install 包名</code>，此时安装的包信息自动添加到package.json文件中的<strong>dependencies字段</strong>，属于<strong>项目依赖</strong></li>
<li>使用 <code>npm install 包名 --save-dev</code> ，此时安装的包信息添加到package.json文件中的<strong>devDependencies字段</strong>，属于<strong>开发依赖</strong></li>
</ul>
<p>例如gulp第三发模块就是<strong>开发依赖</strong>，只在开发阶段使用。</p>
<p>使用 <code>npm install gulp --save-dev</code>安装后，package.json文件如下</p>
<p>在<strong>devDependencies字段</strong>中出现gulp的模块名和版本信息</p>
<p><img data-src="/images/04-node_modules%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E9%97%AE%E9%A2%98/image-20210426195127018.png" alt="image-20210426195127018"></p>
<p>根据package.json文件安装依赖时</p>
<ul>
<li>使用 <code>npm install</code>命令会安装package.json文件中<strong>所有的依赖</strong>，包括项目和开发依赖</li>
<li>使用 <code>npm install --production</code>命令只会安装package.json文件中的<strong>项目依赖</strong>，即<strong>independencies字段</strong>中的第三方模块</li>
</ul>
<h2 id="4-package-lock-json文件"><a href="#4-package-lock-json文件" class="headerlink" title="4.package-lock.json文件"></a>4.package-lock.json文件</h2><p><strong>记录模块与模块之间复杂的依赖关系</strong></p>
<p>下载模块时在目录下<strong>自动生成</strong>package-lock.json文件</p>
<p>详细记录了包的信息，如下载地址、版本和依赖关系等</p>
<p><img data-src="/images/04-node_modules%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E9%97%AE%E9%A2%98/image-20210426200058484.png" alt="image-20210426200058484"></p>
<h3 id="package-lock-json文件的作用"><a href="#package-lock-json文件的作用" class="headerlink" title="package-lock.json文件的作用"></a>package-lock.json文件的作用</h3><ul>
<li>详细记录了包的版本等信息，确保再次下载时不会下载错误的版本</li>
<li>加快下载速度，文件中记录了包的下载地址及项目依赖的第三方包的树状结构，重新下载时不需要做额外工作</li>
</ul>
<h2 id="5-package-json中scripts字段的作用"><a href="#5-package-json中scripts字段的作用" class="headerlink" title="5.package.json中scripts字段的作用"></a>5.package.json中scripts字段的作用</h2><p>scripts字段可以给常用的较长的命令起别名，提升开发效率</p>
<p>使用别名执行命令：<code>npm run &quot;别名&quot;</code></p>
<p>例如 <code>nodemon a.js</code> 这个命令经常执行</p>
<p>可以在scripts字段中添加以下代码</p>
<p><img data-src="/images/04-node_modules%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E9%97%AE%E9%A2%98/image-20210426200608237.png" alt="image-20210426200608237"></p>
<p>即给<code>nodemon a.js</code>这个命令起了一个别名 build</p>
<p>之后可以使用 <code>npm run build</code>命令来代替<code>nodemon a.js</code>命令</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>04-JS两种事件绑定区别</title>
    <url>/2022/12/04/04-%E6%99%AE%E9%80%9A%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%92%8CaddEventListener%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="普通事件绑定和addEventListener事件绑定的区别"><a href="#普通事件绑定和addEventListener事件绑定的区别" class="headerlink" title="普通事件绑定和addEventListener事件绑定的区别"></a>普通事件绑定和addEventListener事件绑定的区别</h1><ul>
<li><p>普通事件绑定指 <code>&#39;element&#39;.onclick = function()&#123;&#125;</code>等事件</p>
</li>
<li><p>addEventListener事件绑定指 <code>‘element’.addEventListener(&#39;click&#39;,function()&#123;&#125;)</code></p>
</li>
</ul>
<br>

<p>普通事件绑定<strong>不能绑定多个相同事件</strong>，后面的会覆盖前面的</p>
<p>addEventListener<strong>可以绑定多个相同事件</strong>，触发时<strong>多个事件会依次执行</strong></p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">box.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只会执行最后一个事件</span></span><br><span class="line">box.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">box.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   alert(<span class="number">1</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line">box.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   alert(<span class="number">2</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line"><span class="comment">//两个事件绑定触发时依次执行</span></span><br></pre></td></tr></table></figure>

<ul>
<li>普通事件绑定可以通过<strong>重新赋值为null删除</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">divs[<span class="number">0</span>].onclick=<span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>addEventListener事件绑定<strong>可以通过removeEventListener()删除</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解绑事件监听</span></span><br><span class="line">divs[<span class="number">1</span>].removeEventListener(<span class="string">&quot;click&quot;</span>,fn);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>04-组件化开发案例-购物车</title>
    <url>/2021/09/20/04-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%A1%88%E4%BE%8B-%E8%B4%AD%E7%89%A9%E8%BD%A6/</url>
    <content><![CDATA[<h1 id="组件化开发案例-购物车"><a href="#组件化开发案例-购物车" class="headerlink" title="组件化开发案例-购物车"></a>组件化开发案例-购物车</h1><ul>
<li>将静态页面转化为Vue组件化页面</li>
<li>通过js逻辑实现Vue组件的功能</li>
</ul>
<p><img data-src="/images/04-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%A1%88%E4%BE%8B-%E8%B4%AD%E7%89%A9%E8%BD%A6/image-20210923120231415.png" alt="image-20210923120231415"></p>
<center>图一</center>

<span id="more"></span>

<h2 id="1-Vue组件化页面"><a href="#1-Vue组件化页面" class="headerlink" title="1. Vue组件化页面"></a>1. Vue组件化页面</h2><ul>
<li>购物车<strong>标题</strong>、<strong>商品列表</strong>和<strong>总计</strong>分为三个组件<ul>
<li>三个组件作为my-cart全局组件的子组件</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//标题组件</span></span><br><span class="line"><span class="keyword">var</span> CartTitle = &#123;</span><br><span class="line">      template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;title&quot;&gt;我的商品&lt;/div&gt;</span></span><br><span class="line"><span class="string">      `</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//商品列表组件</span></span><br><span class="line">    <span class="keyword">var</span> CartList = &#123;</span><br><span class="line">      template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">          &lt;div class=&quot;item&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;img/a.jpg&quot;/&gt;</span></span><br><span class="line"><span class="string">            &lt;div class=&quot;name&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;div class=&quot;change&quot;&gt;</span></span><br><span class="line"><span class="string">              &lt;a href=&quot;&quot;&gt;－&lt;/a&gt;</span></span><br><span class="line"><span class="string">              &lt;input type=&quot;text&quot; class=&quot;num&quot; /&gt;</span></span><br><span class="line"><span class="string">              &lt;a href=&quot;&quot;&gt;＋&lt;/a&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;div class=&quot;del&quot;&gt;×&lt;/div&gt;</span></span><br><span class="line"><span class="string">          &lt;/div&gt;</span></span><br><span class="line"><span class="string">          &lt;div class=&quot;item&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;img/b.jpg&quot;/&gt;</span></span><br><span class="line"><span class="string">            &lt;div class=&quot;name&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;div class=&quot;change&quot;&gt;</span></span><br><span class="line"><span class="string">              &lt;a href=&quot;&quot;&gt;－&lt;/a&gt;</span></span><br><span class="line"><span class="string">              &lt;input type=&quot;text&quot; class=&quot;num&quot; /&gt;</span></span><br><span class="line"><span class="string">              &lt;a href=&quot;&quot;&gt;＋&lt;/a&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;div class=&quot;del&quot;&gt;×&lt;/div&gt;</span></span><br><span class="line"><span class="string">          &lt;/div&gt;</span></span><br><span class="line"><span class="string">          &lt;div class=&quot;item&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;img/c.jpg&quot;/&gt;</span></span><br><span class="line"><span class="string">            &lt;div class=&quot;name&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;div class=&quot;change&quot;&gt;</span></span><br><span class="line"><span class="string">              &lt;a href=&quot;&quot;&gt;－&lt;/a&gt;</span></span><br><span class="line"><span class="string">              &lt;input type=&quot;text&quot; class=&quot;num&quot; /&gt;</span></span><br><span class="line"><span class="string">              &lt;a href=&quot;&quot;&gt;＋&lt;/a&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;div class=&quot;del&quot;&gt;×&lt;/div&gt;</span></span><br><span class="line"><span class="string">          &lt;/div&gt;</span></span><br><span class="line"><span class="string">          &lt;div class=&quot;item&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;img/d.jpg&quot;/&gt;</span></span><br><span class="line"><span class="string">            &lt;div class=&quot;name&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;div class=&quot;change&quot;&gt;</span></span><br><span class="line"><span class="string">              &lt;a href=&quot;&quot;&gt;－&lt;/a&gt;</span></span><br><span class="line"><span class="string">              &lt;input type=&quot;text&quot; class=&quot;num&quot; /&gt;</span></span><br><span class="line"><span class="string">              &lt;a href=&quot;&quot;&gt;＋&lt;/a&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;div class=&quot;del&quot;&gt;×&lt;/div&gt;</span></span><br><span class="line"><span class="string">          &lt;/div&gt;</span></span><br><span class="line"><span class="string">          &lt;div class=&quot;item&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;img/e.jpg&quot;/&gt;</span></span><br><span class="line"><span class="string">            &lt;div class=&quot;name&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;div class=&quot;change&quot;&gt;</span></span><br><span class="line"><span class="string">              &lt;a href=&quot;&quot;&gt;－&lt;/a&gt;</span></span><br><span class="line"><span class="string">              &lt;input type=&quot;text&quot; class=&quot;num&quot; /&gt;</span></span><br><span class="line"><span class="string">              &lt;a href=&quot;&quot;&gt;＋&lt;/a&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;div class=&quot;del&quot;&gt;×&lt;/div&gt;</span></span><br><span class="line"><span class="string">          &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      `</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//总计组件</span></span><br><span class="line">    <span class="keyword">var</span> CartTotal = &#123;</span><br><span class="line">      template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;total&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;span&gt;总价：123&lt;/span&gt;</span></span><br><span class="line"><span class="string">          &lt;button&gt;结算&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      `</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//全局组件my-cart</span></span><br><span class="line">    Vue.component(<span class="string">&#x27;my-cart&#x27;</span>,&#123;</span><br><span class="line">      template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div class=&#x27;cart&#x27;&gt;</span></span><br><span class="line"><span class="string">          &lt;cart-title&gt;&lt;/cart-title&gt;</span></span><br><span class="line"><span class="string">          &lt;cart-list&gt;&lt;/cart-list&gt;</span></span><br><span class="line"><span class="string">          &lt;cart-total&gt;&lt;/cart-total&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      `</span>,</span><br><span class="line">        <span class="comment">//定义三个子组件</span></span><br><span class="line">      components: &#123;</span><br><span class="line">        <span class="string">&#x27;cart-title&#x27;</span>: CartTitle,</span><br><span class="line">        <span class="string">&#x27;cart-list&#x27;</span>: CartList,</span><br><span class="line">        <span class="string">&#x27;cart-total&#x27;</span>: CartTotal</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<br>

<h2 id="2-组件功能实现"><a href="#2-组件功能实现" class="headerlink" title="2.组件功能实现"></a>2.组件功能实现</h2><ul>
<li>头部组件 ：显示用户名称 （<strong>‘用户’的购物车</strong>）</li>
<li>总计组件 ：计算并显示购物车商品总价</li>
</ul>
<h3 id="2-1-头部组件功能"><a href="#2-1-头部组件功能" class="headerlink" title="2.1 头部组件功能"></a>2.1 头部组件功能</h3><ul>
<li>在my-cart父组件中定义<code>uname</code>数据</li>
<li>将<code>uname</code>数据传递给子组件cart-title（父子组件传值）</li>
<li>cart-title组件接受后在模板内容中使用</li>
</ul>
<p><img data-src="/images/04-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%A1%88%E4%BE%8B-%E8%B4%AD%E7%89%A9%E8%BD%A6/image-20210923121939512.png" alt="image-20210923121939512"></p>
<center>图二</center>

<h3 id="2-2-总计组件功能"><a href="#2-2-总计组件功能" class="headerlink" title="2.2 总计组件功能"></a>2.2 总计组件功能</h3><ul>
<li>将my-cart组件的<strong>list数据</strong>（存储商品信息的数组）传递给子组件cart-total</li>
<li>cart-total中定义<strong>计算属性</strong>（computed）根据商品数量和单价计算总价后在模板内容中使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">            total:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> t = <span class="number">0</span></span><br><span class="line">                <span class="built_in">this</span>.list.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                    t += item.price * item.num</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">return</span> t</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/04-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%A1%88%E4%BE%8B-%E8%B4%AD%E7%89%A9%E8%BD%A6/image-20210923122126797.png" alt="image-20210923122126797"></p>
<center>图三</center>

<h3 id="2-3-列表组件功能"><a href="#2-3-列表组件功能" class="headerlink" title="2.3 列表组件功能"></a>2.3 列表组件功能</h3><ul>
<li>商品信息展示</li>
<li>删除商品</li>
<li>修改商品数量</li>
</ul>
<h4 id="2-3-1-商品信息展示"><a href="#2-3-1-商品信息展示" class="headerlink" title="2.3.1 商品信息展示"></a>2.3.1 商品信息展示</h4><ul>
<li>my-cart组件将list数据传递给cart-list子组件</li>
<li>子组件通过循环list数组生成商品信息列表</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">template: `</span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">:key</span>=<span class="string">&#x27;item.id&#x27;</span> <span class="attr">v-for</span>=<span class="string">&#x27;item in list&#x27;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;item.img&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;change&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>－<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;num&quot;</span> /&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>＋<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;del&quot;</span>&gt;</span>×<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       `</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/04-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%A1%88%E4%BE%8B-%E8%B4%AD%E7%89%A9%E8%BD%A6/image-20210923122932996.png" alt="image-20210923122932996"></p>
<center>图四</center>

<h4 id="2-3-2-商品删除"><a href="#2-3-2-商品删除" class="headerlink" title="2.3.2 商品删除"></a>2.3.2 商品删除</h4><p>通过点击商品后面的<code>‘X’</code>号删除商品</p>
<ul>
<li>因为删除商品需要对list数组进行操作，而list数组是my-cart父组件的数据</li>
<li>所以通过<strong>子组件向父组件传值</strong>的方式在父组件中修改list数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cart-list组件中设置&#x27;X&#x27;被点击时触发del函数并传入当前商品id</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;del&quot;</span> @click=<span class="string">&#x27;del(item.id)&#x27;</span>&gt;×&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//del函数触发自定义事件把商品id传递给父组件</span></span><br><span class="line">del:<span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">                <span class="comment">//触发自定义事件给父组件传值</span></span><br><span class="line">                <span class="built_in">this</span>.$emit(<span class="string">&#x27;item-del&#x27;</span>,id)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父组件template模板内容中进行自定义事件监听后获取商品id</span></span><br><span class="line">&lt;cart-list :list=<span class="string">&#x27;list&#x27;</span> @item-del=<span class="string">&#x27;delItem($event)&#x27;</span>&gt;&lt;/cart-list&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过事件处理函数删除list数组中的目标商品</span></span><br><span class="line">delItem:<span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">              <span class="comment">//找出list数组中匹配的元素并删除</span></span><br><span class="line">              <span class="keyword">let</span> target = <span class="built_in">this</span>.list.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span>(item.id == id)&#123;</span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">              <span class="built_in">this</span>.list.splice(target,<span class="number">1</span>)</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="2-3-3-商品数量修改"><a href="#2-3-3-商品数量修改" class="headerlink" title="2.3.3 商品数量修改"></a>2.3.3 商品数量修改</h4><ul>
<li>表单输入域修改</li>
<li>通过 <code>&#39;+&#39;</code> 和 <code>&#39;-&#39;</code> 修改</li>
</ul>
<p>先通过给<strong>表单输入域进行value属性绑定</strong>获取商品默认的数量</p>
<h5 id="表单输入域修改数量"><a href="#表单输入域修改数量" class="headerlink" title="表单输入域修改数量"></a>表单输入域修改数量</h5><ul>
<li>表单输入域添加change事件，出发后将<strong>当前商品id和新数量</strong>传递给处理函数</li>
<li>处理函数触发自定义函数将数据传递给父组件</li>
<li>父组件监听自定义事件后修改list数组中商品数量</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//属性绑定value显示初始数量 change事件绑定触发自定义事件</span></span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;num&quot;</span> :value=<span class="string">&#x27;item.num&#x27;</span> @change=<span class="string">&#x27;changeNum(item.id,$event)&#x27;</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发自定义事件num-change</span></span><br><span class="line"><span class="comment">//因为传递给父组件的数据只能为一个变量，所以将两个数据包裹为对象传递</span></span><br><span class="line">changeNum:<span class="function"><span class="keyword">function</span>(<span class="params">id,event</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.$emit(<span class="string">&#x27;num-change&#x27;</span>,&#123;</span><br><span class="line">                    id:id,</span><br><span class="line">                    num:event.target.value</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父组件接受数据后修改list中商品数量</span></span><br><span class="line">changeNum:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.list.some(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(item.id == val.id)&#123;</span><br><span class="line">                    item.num = <span class="built_in">parseInt</span>(val.num)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>此处子组件向父组件传递数据时需要传递<strong>商品id和新数量两个数据</strong></li>
<li>而父组件接受数据时只使用<code>$event</code>一个变量，索引将两个数据<strong>包裹为一个对象传送</strong></li>
</ul>
<br>

<h5 id="或-修改数量"><a href="#或-修改数量" class="headerlink" title="+或-修改数量"></a><code>+</code>或<code>-</code>修改数量</h5><p>点击<code>+</code>或<code>-</code>触发点击事件，在事件处理函数中使用自定义事件向父组件传递数据</p>
<ul>
<li><p>此处<strong>三种修改方式使用同一个自定义事件</strong>(父组件接受后根据传递的type值判断是哪一种修改方式)</p>
</li>
<li><p>因为<code>+</code>和<code>-</code>为a标签，再点击事件触发时要禁止其默认行为<code>(@click.prevent)</code></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//+ - 点击事件绑定</span></span><br><span class="line">&lt;a href=<span class="string">&quot;&quot;</span> @click.prevent=<span class="string">&#x27;sub(item.id)&#x27;</span>&gt;－&lt;/a&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;&quot;</span> @click.prevent=<span class="string">&#x27;add(item.id)&#x27;</span>&gt;＋&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向父组件传递的数据中type值代表了修改的方式</span></span><br><span class="line">sub:<span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.$emit(<span class="string">&#x27;num-change&#x27;</span>,&#123;</span><br><span class="line">                    id:id,</span><br><span class="line">                    type:<span class="string">&#x27;sub&#x27;</span>,</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            </span><br><span class="line"><span class="comment">//父组件判断type值进行不同修改方式的处理</span></span><br><span class="line">changeNum:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.list.some(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(item.id == val.id)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(val.type == <span class="string">&#x27;change&#x27;</span>)&#123;</span><br><span class="line">                        item.num = <span class="built_in">parseInt</span>(val.num)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val.type == <span class="string">&#x27;add&#x27;</span>)&#123;</span><br><span class="line">                        item.num += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        item.num -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS弹性盒子布局</title>
    <url>/2022/11/27/05-CSS%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="CSS弹性盒子布局"><a href="#CSS弹性盒子布局" class="headerlink" title="CSS弹性盒子布局"></a>CSS弹性盒子布局</h1><p><strong>CSS 弹性盒子布局</strong>是 CSS 的模块之一，定义了一种针对用户界面设计而优化的 CSS 盒子模型。</p>
<p>这是一种用于在<strong>单个维度（行或列）中显示项目的布局模型</strong></p>
<ul>
<li>在弹性布局模型中，弹性容器的<strong>子元素可以在任何方向上排布</strong>，</li>
<li>也可以“<strong>弹性伸缩”其尺寸</strong>，既可以增加尺寸以填满未使用的空间，也可以收缩尺寸以避免父元素溢出。</li>
<li>子元素的<strong>水平对齐和垂直对齐</strong>都能很方便的进行操控。</li>
<li>通过嵌套这些框（水平框在垂直框内，或垂直框在水平框内）可以<strong>在两个维度上构建布局</strong>。</li>
</ul>
<span id="more"></span>

<br>

<h2 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        .box&#123;</span><br><span class="line"><span class="css">            <span class="comment">/* 设置为弹性容器 */</span></span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span></span><br><span class="line">             /* 均匀排列每个元素</span><br><span class="line">                首个元素放置于起点，末尾元素放置于终点 */</span><br><span class="line"><span class="css">            <span class="attribute">justify-content</span>: space-between;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.box</span>&gt;<span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: aquamarine;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/05-CSS%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E5%B8%83%E5%B1%80/image-20210915214314099.png" alt="image-20210915214314099"></p>
<ul>
<li>外层div设置 <code>display:flex</code> 成为弹性容器</li>
<li>内层三个div称为弹性项</li>
<li>内层三个div<strong>自动沿着弹性盒子主轴方向（当前默认为水平方向）排列</strong></li>
</ul>
<h2 id="主轴"><a href="#主轴" class="headerlink" title="主轴"></a>主轴</h2><p>在弹性容器中使用<code>flex-direction;</code>属性可以修改主轴方向</p>
<ul>
<li><code>row</code> ：水平方向</li>
<li><code>row-reverse</code> ：反水平方向：即向左为正，元素<strong>从容器最右侧开始排列</strong></li>
<li><code>column</code> ：垂直方向</li>
<li><code>column-reverse</code></li>
</ul>
<p><img data-src="/images/05-CSS%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E5%B8%83%E5%B1%80/image-20210915215353219.png" alt="image-20210915215353219"></p>
<ul>
<li>设置<code>flex-direction:row-reverse</code></li>
<li>从最右侧开始水平排列 1的div元素在最右侧</li>
</ul>
<h2 id="交叉轴（侧轴）"><a href="#交叉轴（侧轴）" class="headerlink" title="交叉轴（侧轴）"></a>交叉轴（侧轴）</h2><p>交叉轴的方向与主轴垂直</p>
<p>若主轴为 <strong>row 或 row-reverse</strong> </p>
<p>则侧轴为 <strong>column</strong> （垂直方向）</p>
<p><code>align-items</code>属性：align-items属性设置<strong>弹性项在弹性容器交叉轴方向上的对齐方式</strong></p>
<br>

<h2 id="弹性盒子的属性"><a href="#弹性盒子的属性" class="headerlink" title="弹性盒子的属性"></a>弹性盒子的属性</h2><ul>
<li><p><code>flex-direction:row-reverse/row/column/column-reverse</code>：设定<strong>主轴方向</strong></p>
</li>
<li><p><code>flex-wrap: nowrap/wrap</code>：设定子元素总宽度超过父容器宽度时的<strong>换行与否</strong></p>
<ul>
<li>nowrap不换行，缩进超长元素，不能缩进则会溢出</li>
<li>wrap超长元素换到下一行显示，每一行相当于一个flex容器</li>
</ul>
</li>
<li><p><code>flex-flow</code>：<code>flex-direction</code> 和 <code>flex-wrap</code>的简写，指定两个属性的值</p>
</li>
<li><p><code>align-item</code>：规定弹性项<strong>在侧轴方向上的排列方式</strong></p>
<ul>
<li><code>stretch</code>：默认值，所有弹性项都会<strong>被拉伸到与最高弹性项相同的高度</strong></li>
<li><code>flex-start</code>：顶部对齐</li>
<li><code>flex-end</code>：底部对齐</li>
<li><code>center</code>：在侧轴上<strong>居中排列</strong></li>
</ul>
</li>
<li><p><code>justify-content</code>：规定弹性项<strong>在主轴上的排列方式</strong></p>
<ul>
<li><code>stretch</code></li>
<li><code>flex-start</code>：默认值，从容器起始线开始排列</li>
<li><code>flex-end</code>：从容器终止线开始排列</li>
<li><code>center</code>：主轴居中排列</li>
<li><code>space-around</code>：元素<strong>之间间隔</strong>相等</li>
<li><code>space-between</code>：每个元素的<strong>左右空间</strong>相等</li>
</ul>
</li>
</ul>
<h2 id="弹性项（弹性盒子中的子元素）的flex属性"><a href="#弹性项（弹性盒子中的子元素）的flex属性" class="headerlink" title="弹性项（弹性盒子中的子元素）的flex属性"></a>弹性项（弹性盒子中的子元素）的flex属性</h2><p>flex属性<strong>是三个属性的简写</strong></p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-grow"><code>flex-grow</code></a>  默认值为0</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-shrink"><code>flex-shrink</code></a> 默认值为1</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-basis"><code>flex-basis</code></a> 默认值为auto</li>
</ul>
<p><strong>单值语法</strong>: 值必须为以下其中之一:</p>
<ul>
<li>一个无单位<strong>数</strong>: 它会被当作<code>flex:&lt;number&gt; 1 0;</code> <code>&lt;flex-shrink&gt;</code>的值被假定为1，然后<code>&lt;flex-basis&gt;</code> 的值被假定为<code>0</code>。</li>
<li>一个有效的**宽度(<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"><code>width</code></a>)**值: 它会被当作 <code>&lt;flex-basis&gt;的值。</code></li>
<li>关键字<code>none</code>，<code>auto</code>或<code>initial</code>.</li>
</ul>
<p><strong>双值语法</strong>: <strong>第一个值</strong>必须为一个无单位数，并且它会被当作 <code>&lt;flex-grow&gt;</code> 的值。<strong>第二个值</strong>必须为以下之一：</p>
<ul>
<li>一个无单位数：它会被当作 <code>&lt;flex-shrink&gt;</code> 的值。</li>
<li>一个有效的宽度值: 它会被当作 <code>&lt;flex-basis&gt;</code> 的值。</li>
</ul>
<p><strong>三值语法:</strong></p>
<ul>
<li>第一个值必须为一个<strong>无单位数</strong>，并且它会被当作 <code>&lt;flex-grow&gt;</code> 的值。</li>
<li>第二个值必须为一个<strong>无单位数</strong>，并且它会被当作 <code>&lt;flex-shrink&gt;</code> 的值。</li>
<li>第三个值必须为一个<strong>有效的px值</strong>， 并且它会被当作 <code>&lt;flex-basis&gt;</code> 的值。</li>
</ul>
<h3 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h3><p>处理弹性项<span style="color:red"><strong>尺寸增长问题</strong></span></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS</a>属性 <strong><code>flex-grow</code><strong>设置了一个flex项<a href="https://www.w3.org/TR/css-flexbox/#main-size">主尺寸</a>的flex增长系数。它指定了flex容器中</strong>剩余空间的多少应该分配给项目</strong>（flex增长系数）。</p>
<p><a href="https://www.w3.org/TR/css-flexbox/#main-size">主尺寸</a>是项的<strong>宽度或高度</strong>，这取决于<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction"><code>flex-direction</code></a>主轴方向。</p>
<p>剩余的空间是flex容器的大小减去所有flex项的大小。如果所有的兄弟项目都有相同的flex-grow系数，那么所有的项目将获得相同的剩余空间，否则将<strong>根据不同的flex-grow系数定义的比例进行分配</strong>。</p>
<h3 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h3><p>处理弹性项<span style="color:red"><strong>尺寸收缩问题</strong></span></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS</a> <strong><code>flex-shrink</code></strong> 属性指定了 flex 元素的收缩规则。flex 元素<strong>仅在默认宽度之和大于容器的时候才会发生收缩</strong>，其收缩的大小是依据 flex-shrink 的值。</p>
<h3 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h3><p>处理弹性项<span style="color:red"><strong>初始大小问题</strong></span></p>
<p>若元素<strong>设定尺寸</strong>，则flex-basis值即为设定的尺寸</p>
<p>若元素<strong>没有尺寸</strong>，则flex-basis值为内容的尺寸</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS</a> 属性 <strong><code>flex-basis</code></strong> 指定了 <strong>flex 元素在主轴方向上的初始大小</strong>。如果不使用  <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing"><code>box-sizing</code></a> 改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的尺寸。</p>
]]></content>
      <categories>
        <category>HTMLandCss</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>React组件</title>
    <url>/2022/11/27/05-React%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="React组件"><a href="#React组件" class="headerlink" title="React组件"></a>React组件</h1><p>组件是React重要内容</p>
<p>特点：可复用、独立、可组合</p>
<span id="more"></span>

<h2 id="1-创建组件两种方式"><a href="#1-创建组件两种方式" class="headerlink" title="1.创建组件两种方式"></a>1.创建组件两种方式</h2><h3 id="1-使用函数创建组件"><a href="#1-使用函数创建组件" class="headerlink" title="1.使用函数创建组件"></a>1.使用函数创建组件</h3><p><img data-src="/images/05-React%E7%BB%84%E4%BB%B6/image-20220402194558015.png" alt="image-20220402194558015"></p>
<ul>
<li>函数返回值为JSX或者<code>null</code></li>
</ul>
<p><img data-src="/images/05-React%E7%BB%84%E4%BB%B6/image-20220402194846440.png" alt="image-20220402194846440"></p>
<br>

<h3 id="2-使用class类创建组件"><a href="#2-使用class类创建组件" class="headerlink" title="2.使用class类创建组件"></a>2.使用class类创建组件</h3><p><img data-src="/images/05-React%E7%BB%84%E4%BB%B6/image-20220402195156744.png" alt="image-20220402195156744"></p>
<ul>
<li>不渲染内容返回null</li>
</ul>
<br>

<h2 id="2-组件抽离到单独js文件"><a href="#2-组件抽离到单独js文件" class="headerlink" title="2.组件抽离到单独js文件"></a>2.组件抽离到单独js文件</h2><p>组件具有独立的特性，为了对大量组件进行管理，将组件抽离到js文件中，一个js文件对应一个组件。</p>
<p><img data-src="/images/05-React%E7%BB%84%E4%BB%B6/image-20220402195805825.png" alt="image-20220402195805825"></p>
<ul>
<li>在<code>index.js</code>中引入Hello组件并使用</li>
</ul>
<br>

<h2 id="3-React事件绑定"><a href="#3-React事件绑定" class="headerlink" title="3.React事件绑定"></a>3.React事件绑定</h2><p><img data-src="/images/05-React%E7%BB%84%E4%BB%B6/image-20220402200438069.png" alt="image-20220402200438069"></p>
<ul>
<li><strong>函数创建的组件</strong>中进行事件绑定，<strong>处理函数不用this</strong></li>
</ul>
<br>

<h2 id="4-事件对象"><a href="#4-事件对象" class="headerlink" title="4.事件对象"></a>4.事件对象</h2><p><img data-src="/images/05-React%E7%BB%84%E4%BB%B6/image-20220402200720283.png" alt="image-20220402200720283"></p>
<br>

<h2 id="5-有状态组件和无状态组件"><a href="#5-有状态组件和无状态组件" class="headerlink" title="5. 有状态组件和无状态组件"></a>5. 有状态组件和无状态组件</h2><p><img data-src="/images/05-React%E7%BB%84%E4%BB%B6/image-20220402201058840.png" alt="image-20220402201058840"></p>
<ul>
<li><p>函数创建的组件，无状态，负责数据展示(静态)</p>
</li>
<li><p>class类创建的组件，有状态，可以改变状态(交互，更新)</p>
</li>
<li><p>状态即为组件内的数据(类似于Vue的data)</p>
</li>
</ul>
<br>

<h2 id="6-state和setState"><a href="#6-state和setState" class="headerlink" title="6. state和setState()"></a>6. state和setState()</h2><h3 id="1-state"><a href="#1-state" class="headerlink" title="1.state"></a>1.state</h3><p>状态state即为<strong>组件内部的私有数据</strong>，state的值为<strong>对象</strong>。</p>
<p><strong>state的两种初始化方式</strong></p>
<p><img data-src="/images/05-React%E7%BB%84%E4%BB%B6/image-20220402201604652.png" alt="image-20220402201604652"></p>
<p><strong>使用state数据</strong></p>
<p><img data-src="/images/05-React%E7%BB%84%E4%BB%B6/image-20220402201635175.png" alt="image-20220402201635175"></p>
<br>

<h3 id="2-setState-修改状态"><a href="#2-setState-修改状态" class="headerlink" title="2.setState()修改状态"></a>2.<code>setState()</code>修改状态</h3><p><img data-src="/images/05-React%E7%BB%84%E4%BB%B6/image-20220402202218389.png" alt="image-20220402202218389"></p>
<ul>
<li><code>this.setState()</code> （类似于微信小程序的<code>this.setData()</code>）</li>
</ul>
<br>

<h2 id="7-从JSX抽离事件处理函数"><a href="#7-从JSX抽离事件处理函数" class="headerlink" title="7. 从JSX抽离事件处理函数"></a>7. 从JSX抽离事件处理函数</h2><p>JSX中参杂太多JS代码会导致结构混乱，将事件处理函数抽离。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        count:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//事件处理函数抽离</span></span><br><span class="line">    handle = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//输出 Hello 类 (组件实例)</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改state数据</span></span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            count:<span class="built_in">this</span>.state.count + <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handle&#125;</span>&gt;</span>计数:&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>常规<code>function</code>方式声明函数，函数中this为<code>undefined</code>，此时使用<code>this.setState()</code>报错。</li>
<li>使用箭头函数可以解决this指向问题(this指向<strong>组件实例</strong>)。</li>
</ul>
<br>

<h2 id="8-事件处理函数this指向问题"><a href="#8-事件处理函数this指向问题" class="headerlink" title="8. 事件处理函数this指向问题"></a>8. 事件处理函数this指向问题</h2><p>目的：使处理函数中的<strong>this指向组件实例</strong></p>
<h4 id="1-箭头函数"><a href="#1-箭头函数" class="headerlink" title="1.箭头函数"></a>1.箭头函数</h4><p><img data-src="/images/05-React%E7%BB%84%E4%BB%B6/image-20220402204213927.png" alt="image-20220402204213927"></p>
<br>

<h4 id="2-bind-方法"><a href="#2-bind-方法" class="headerlink" title="2.bind()方法"></a>2.<code>bind()</code>方法</h4><p><img data-src="/images/05-React%E7%BB%84%E4%BB%B6/image-20220402204438546.png" alt="image-20220402204438546"></p>
<ul>
<li>bind()方法：返回修改了this指向后的新函数</li>
</ul>
<br>

<h4 id="3-箭头函数声明处理函数"><a href="#3-箭头函数声明处理函数" class="headerlink" title="3.箭头函数声明处理函数"></a>3.箭头函数声明处理函数</h4><p><img data-src="/images/05-React%E7%BB%84%E4%BB%B6/image-20220402204648876.png" alt="image-20220402204648876"></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>05-Vue单文件组件</title>
    <url>/2021/04/26/05-Vue%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="Vue单文件组件"><a href="#Vue单文件组件" class="headerlink" title="Vue单文件组件"></a>Vue单文件组件</h1><h2 id="1-传统组件的问题"><a href="#1-传统组件的问题" class="headerlink" title="1. 传统组件的问题"></a>1. 传统组件的问题</h2><p><img data-src="/images/05-Vue%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6/image-20211012171350105.png" alt="image-20211012171350105"></p>
<h2 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h2><p><img data-src="/images/05-Vue%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6/image-20211012171403057.png" alt="image-20211012171403057"></p>
<h2 id="3-Vue单文件组件基本用法"><a href="#3-Vue单文件组件基本用法" class="headerlink" title="3. Vue单文件组件基本用法"></a>3. Vue单文件组件基本用法</h2><p><code>app.vue</code>后缀为**.vue**</p>
<p>单文件组件的组成结构</p>
<ul>
<li><strong>template</strong>：组件的模板区域</li>
<li><strong>script</strong>：组件的业务逻辑区域<ul>
<li><code>export default &#123;&#125;</code>对象中进行组件的配置<code>(data,method等)</code></li>
</ul>
</li>
<li><strong>style</strong>：组件的私有样式（加上scoped防止多个组件的私有样式冲突）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 模板区域</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Vue.app test&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;业务逻辑</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    &#x2F;&#x2F;进行组件配置</span><br><span class="line">    data:function()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;私有样式</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    h1&#123;</span><br><span class="line">        color:red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<center>app.vue</center>

<h2 id="4-webpack配置vue单文件组件的加载器"><a href="#4-webpack配置vue单文件组件的加载器" class="headerlink" title="4. webpack配置vue单文件组件的加载器"></a>4. webpack配置vue单文件组件的加载器</h2><p><img data-src="/images/05-Vue%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6/image-20211012173138185.png" alt="image-20211012173138185"></p>
<br>

<p>在index.js文件中引入<code>vue和app.vue单文件组件</code></p>
<p><strong>创建Vue实例并渲染vue单文件组件有两种方式</strong></p>
<p>第一种</p>
<ul>
<li>使用<code>el</code>挂载到<code>index.html</code>的元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./components/app.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="comment">//render方法渲染单文件组件</span></span><br><span class="line">    render:<span class="function"><span class="params">h</span>=&gt;</span>h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><span style='color:red;'>vue使用npm安装，引入时直接<code>import Vue from &#39;vue&#39;</code></span></li>
<li>使用<code>render</code>渲染vue单文件组件<ul>
<li>创建的vue实例中只使用<code>render</code>这一个配置项</li>
</ul>
</li>
</ul>
<p>第二种</p>
<ul>
<li>使用实例的<code>$mount</code>方法挂载到<code>index.html</code>的元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">// el:&#x27;#app&#x27;,</span></span><br><span class="line">    <span class="comment">//render方法渲染单文件组件</span></span><br><span class="line">    render:<span class="function"><span class="params">h</span>=&gt;</span>h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<br>

<p>在index.html文件中加入<code>id为app的div</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/05-Vue%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6/image-20211012200859571.png" alt="image-20211012200859571"></p>
<h2 id="5-Vue单文件组件间传值问题"><a href="#5-Vue单文件组件间传值问题" class="headerlink" title="5. Vue单文件组件间传值问题"></a>5. Vue单文件组件间传值问题</h2><p>使用<code>@vue/cli</code> 创建的Vue项目中，均使用<strong>vue单文件组件</strong></p>
<ul>
<li><strong>根实例组件</strong>在项目根目录下</li>
<li><strong>其他组件</strong>位于components文件夹下</li>
</ul>
<h3 id="父子组件嵌套"><a href="#父子组件嵌套" class="headerlink" title="父子组件嵌套"></a>父子组件嵌套</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;home&quot;</span>&gt;</span><br><span class="line">    &lt;img alt=<span class="string">&quot;Vue logo&quot;</span> src=<span class="string">&quot;/assets/logo.png&quot;</span>&gt;</span><br><span class="line">    <span class="comment">//HelloWorld组件作为Hello组件的子组件</span></span><br><span class="line">    <span class="comment">//msg为父组件传给子组件的值</span></span><br><span class="line">    &lt;HelloWorld msg=<span class="string">&quot;Welcome to Your Vue.js App&quot;</span>/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// @ is an alias to /src</span></span><br><span class="line"><span class="comment">//  引入Helloworld单文件组件</span></span><br><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">&#x27;@/components/HelloWorld.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">  <span class="comment">// 局部组件注册</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="comment">// 给引入的组件进行注册</span></span><br><span class="line">    HelloWorld<span class="comment">// 相当于HelloWorld:HelloWorld</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<center>Hello.vue组件</center>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">msg</span>=<span class="string">&quot;Welcome to Your Vue.js App&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>HelloWorld组件作为Hello组件的子组件</li>
<li>msg为父组件传给子组件的值 (传值方式与普通组件一致)</li>
</ul>
<br>

<h4 id="父向子传值"><a href="#父向子传值" class="headerlink" title="父向子传值"></a>父向子传值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;HelloWorld&#x27;</span>,</span><br><span class="line">  <span class="comment">// 接收父组件传值</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    msg: <span class="built_in">String</span> <span class="comment">// String为传入数据的类型</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// props:[&#x27;msg&#x27;]</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<center>HelloWorld.vue子组件部分代码</center>

<p>接收数据</p>
<ul>
<li>使用props对象<ul>
<li><strong>键值</strong>为传递数据的类型</li>
<li><strong>键名</strong>为传递使用的属性值</li>
</ul>
</li>
<li>使用props数组</li>
</ul>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>05-nodejs中的模块加载机制</title>
    <url>/2021/04/26/05-nodejs%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="nodejs中的模块加载机制"><a href="#nodejs中的模块加载机制" class="headerlink" title="nodejs中的模块加载机制"></a>nodejs中的模块加载机制</h1><p>nodejs使用<code>require(&#39;&#39;)</code>方法来加载模块，参数即为模块名或者路径</p>
<h2 id="require-查找模块"><a href="#require-查找模块" class="headerlink" title="require()查找模块"></a>require()查找模块</h2><h3 id="1-拥有完整路径-有路径但没有模块后缀"><a href="#1-拥有完整路径-有路径但没有模块后缀" class="headerlink" title="1.拥有完整路径/有路径但没有模块后缀"></a>1.拥有完整路径/有路径但没有模块后缀</h3><p>1.如果<code>require(&#39;模块&#39;)</code>参数中使用完整路径，则直接按照路径引入，找不到文件则报错</p>
<ul>
<li>例如 <code>require(&#39;./find.js&#39;)</code></li>
<li>完整模块路径可以是<strong>相对/绝对路径</strong></li>
<li>此时执行<code>require(&#39;./find.js&#39;)</code>代码时，会在相应的目录下找对应的find.js文件引入执行</li>
</ul>
<span id="more"></span>

<p>2.如果参数中模块后缀省略，先找相应的同名js文件，再找同名的文件夹</p>
<ul>
<li>例如 <code>require(&#39;./find&#39;)</code></li>
<li>先找对应目录下的find.js文件</li>
<li>找不到就找同名的find文件夹</li>
</ul>
<p>3.如果找到同名文件夹则引入执行文件夹中的<strong>index.js模块</strong></p>
<ul>
<li>找不到同名文件夹则报错</li>
</ul>
<p>4.如果文件夹中没有index.js模块，就会找当前文件夹(与参数中模块同名的文件夹)下的package.json文件,并引入执行其中main字段的主/入口模块</p>
<p>5.如果没有指定的入口模块或者入口模块找不到，则报错</p>
<h3 id="2-没有路径且没有后缀"><a href="#2-没有路径且没有后缀" class="headerlink" title="2.没有路径且没有后缀"></a>2.没有路径且没有后缀</h3><p>例如：<code>require(&#39;find&#39;)</code></p>
<p>1.nodejs先假设find模块为系统模块，在系统模块中查找</p>
<p>2.系统模块查找不到就进入当前目录的node_modules文件夹中</p>
<p>3.在node_modules文件夹中首先查找同名js文件</p>
<p>4.查找不到同名文件则查找同名文件夹(find文件夹)</p>
<p>5.引入执行同名文件夹(find文件夹)中的index.js模块</p>
<p>6.如果没有index.js模块，则查看当前文件夹(find文件夹)下的package.json文件中main字段指示的入口模块</p>
<p>7.引入执行package.json文件中main字段指示的入口模块</p>
<p>8.若没有main字段，或者入口模块找不到则报错</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>05-JS事件捕获和冒泡</title>
    <url>/2022/12/04/05-%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E5%86%92%E6%B3%A1/</url>
    <content><![CDATA[<h1 id="事件捕获和冒泡"><a href="#事件捕获和冒泡" class="headerlink" title="事件捕获和冒泡"></a>事件捕获和冒泡</h1><p>使用<strong>addEventListener进行事件绑定</strong>时，<strong>第三个参数</strong>设置为：</p>
<ul>
<li>true 事件捕获阶段进行事件绑定</li>
<li>false 事件冒泡阶段进行事件绑定（默认值）</li>
</ul>
<span id="more"></span>

<h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><p>即<strong>父级元素的事件被触发时</strong>，会<strong>依次向内检查</strong>，若内层元素绑定了<strong>相同触发方式</strong>的事件，则这些事件都会被触发</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;father&quot;</span>&gt;</span><br><span class="line">        &lt;div id=<span class="string">&quot;son&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>例如father元素的点击事件被触发时，son元素的点击事件会被接着触发</li>
</ul>
<br>

<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>即<strong>子元素的事件被触发</strong>时，会依次<strong>向上级父元素检查</strong>，若上级父元素绑定了<strong>相同触发方式</strong>的事件，则均会被触发</p>
<ul>
<li>例如上述代码son元素的点击事件被触发时，father元素的点击事件会被接着触发</li>
</ul>
<h2 id="JavaScript标准事件模型顺序"><a href="#JavaScript标准事件模型顺序" class="headerlink" title="JavaScript标准事件模型顺序"></a>JavaScript标准事件模型顺序</h2><p style='color:red;'>事件捕获->事件处理->事件冒泡</p>

<p>事件流包括<strong>3个阶段</strong>：</p>
<p>①事件捕获，</p>
<p>②处于目标阶段（事件处理 ），</p>
<p>③事件冒泡阶段</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fa = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.fa&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> son = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.son&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fa.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;father on&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(e.target);</span><br><span class="line">&#125;,<span class="literal">true</span>)	<span class="comment">//设置fa的点击事件在事件捕获阶段绑定</span></span><br><span class="line"></span><br><span class="line">son.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;son on&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述代码点击son元素时，先弹窗<code>father on</code>，再弹窗<code>son on</code></p>
<p>因为fa的事件绑定<strong>设置在事件捕获阶段</strong>，根据事件模型顺序，先进行事件捕获，触发fa的点击事件，再到达son元素触发son的点击事件</p>
<br>

<p>若上述代码设置fa元素的点击事件在冒泡阶段绑定(第三个参数缺省或为false)，则点击son元素时先弹窗<code>son on</code> ，再通过冒泡触发fa元素的点击事件弹窗<code>father on</code></p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>全局配置文件</title>
    <url>/2022/11/27/05-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h1><h2 id="1-常用配置项"><a href="#1-常用配置项" class="headerlink" title="1. 常用配置项"></a>1. 常用配置项</h2><p><img data-src="/images/05-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-20220208172636823.png" alt="image-20220208172636823"></p>
<ul>
<li>window</li>
<li>tabBar</li>
</ul>
<span id="more"></span>

<h2 id="2-window节点"><a href="#2-window节点" class="headerlink" title="2. window节点"></a>2. window节点</h2><h3 id="2-1-小程序窗口组成部分"><a href="#2-1-小程序窗口组成部分" class="headerlink" title="2.1 小程序窗口组成部分"></a>2.1 小程序窗口组成部分</h3><p>三部分</p>
<p><img data-src="/images/05-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-20220208172751838.png" alt="image-20220208172751838"></p>
<p>window节点对<strong>导航栏和背景区域</strong>进行设置</p>
<h3 id="2-2-window节点常用配置项"><a href="#2-2-window节点常用配置项" class="headerlink" title="2.2 window节点常用配置项"></a>2.2 window节点常用配置项</h3><p><img data-src="/images/05-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-20220208173505872.png" alt="image-20220208173505872"></p>
<ul>
<li>第一类：对导航栏进行配置<ul>
<li>导航栏背景颜色配置仅支持16机制颜色</li>
</ul>
</li>
<li>第二类：对背景区域进行配置</li>
<li>第三类：对页面效果进行配置</li>
</ul>
<h3 id="2-3-全局下拉刷新设置"><a href="#2-3-全局下拉刷新设置" class="headerlink" title="2.3 全局下拉刷新设置"></a>2.3 全局下拉刷新设置</h3><p><img data-src="/images/05-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-20220208174445256.png" alt="image-20220208174445256"></p>
<p>设置<code>enablePullDownRefresh</code>为true为项目所有的小程序页面开启下拉刷新</p>
<h4 id="2-3-1-设置下拉刷新时的窗口背景颜色"><a href="#2-3-1-设置下拉刷新时的窗口背景颜色" class="headerlink" title="2.3.1 设置下拉刷新时的窗口背景颜色"></a>2.3.1 设置下拉刷新时的窗口背景颜色</h4><p><img data-src="/images/05-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-20220208174650873.png" alt="image-20220208174650873"></p>
<p>设置backgroundColor配置项，16进制颜色值</p>
<h4 id="2-3-2-设置下拉刷新时loading效果"><a href="#2-3-2-设置下拉刷新时loading效果" class="headerlink" title="2.3.2 设置下拉刷新时loading效果"></a>2.3.2 设置下拉刷新时loading效果</h4><p><img data-src="/images/05-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-20220208174726663.png" alt="image-20220208174726663"></p>
<p>通过<code>backgroundTextStyle</code>配置项设置loading效果</p>
<ul>
<li>只有<strong>light和dark</strong>可选</li>
</ul>
<h3 id="2-4-上拉触底设置"><a href="#2-4-上拉触底设置" class="headerlink" title="2.4 上拉触底设置"></a>2.4 上拉触底设置</h3><p><img data-src="/images/05-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-20220210155129894.png" alt="image-20220210155129894"></p>
<p>onReachBottomDistance的值不需要单位</p>
<h2 id="3-tabBar节点"><a href="#3-tabBar节点" class="headerlink" title="3. tabBar节点"></a>3. tabBar节点</h2><p><img data-src="/images/05-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-20220210160224765.png" alt="image-20220210160224765"></p>
<h3 id="3-1-tabBar组成部分"><a href="#3-1-tabBar组成部分" class="headerlink" title="3.1 tabBar组成部分"></a>3.1 tabBar组成部分</h3><p><img data-src="/images/05-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-20220210160240523.png" alt="image-20220210160240523"></p>
<h3 id="3-2-tabBar节点配置项"><a href="#3-2-tabBar节点配置项" class="headerlink" title="3.2 tabBar节点配置项"></a>3.2 tabBar节点配置项</h3><p>tabBar节点配置项在app.json文件中与window节点同级</p>
<p><img data-src="/images/05-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-20220210160249055.png" alt="image-20220210160249055"></p>
<h3 id="3-3-每个tab的配置项"><a href="#3-3-每个tab的配置项" class="headerlink" title="3.3 每个tab的配置项"></a>3.3 每个tab的配置项</h3><p><img data-src="/images/05-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-20220210160348811.png" alt="image-20220210160348811"></p>
<ul>
<li>与tab项关联的页面需要放在app.json文件中<strong>pages字段的头部</strong></li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>06-webpack简单打包发布</title>
    <url>/2021/04/26/06-webpack%E7%AE%80%E5%8D%95%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<h1 id="webpack简单打包发布"><a href="#webpack简单打包发布" class="headerlink" title="webpack简单打包发布"></a>webpack简单打包发布</h1><p>上线之前需要通过<code>webpack</code>将项目进行整体打包</p>
<ul>
<li>通过<code>package.json</code>文件配置<code>webpack</code>打包命令</li>
</ul>
<p><img data-src="/images/06-webpack%E7%AE%80%E5%8D%95%E6%89%93%E5%8C%85%E4%B8%8A%E7%BA%BF/image-20211012202745158.png" alt="image-20211012202745158"></p>
<ul>
<li>在<code>webpack.config.js</code>中配置打包文件输出在dist文件夹下</li>
</ul>
<p><img data-src="/images/06-webpack%E7%AE%80%E5%8D%95%E6%89%93%E5%8C%85%E4%B8%8A%E7%BA%BF/image-20211012202923749.png" alt="image-20211012202923749"></p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>06-JS事件对象event</title>
    <url>/2022/12/04/06-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1event/</url>
    <content><![CDATA[<h1 id="事件对象event"><a href="#事件对象event" class="headerlink" title="事件对象event"></a>事件对象event</h1><p>事件对象作为<strong>事件处理函数的参数</strong>，由系统自动创建，保存了与事件相关的信息(<strong>event代表事件对象的名字,可以简写为e</strong>)</p>
<p>事件相关的信息：<strong>触发的事件类型</strong>（click，blur等），<strong>事件绑定的对象</strong>等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//触发事件后打印event事件对象</span></span><br><span class="line">div.addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><img data-src="/images/06-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1event/image-20210916222556006.png" alt="image-20210916222556006"></p>
<center>打印出的事件对象</center>

<h2 id="事件对象的常见属性和方法"><a href="#事件对象的常见属性和方法" class="headerlink" title="事件对象的常见属性和方法"></a>事件对象的常见属性和方法</h2><h3 id="e-target-与-事件处理函数中的this指向"><a href="#e-target-与-事件处理函数中的this指向" class="headerlink" title="e.target 与 事件处理函数中的this指向"></a>e.target 与 事件处理函数中的this指向</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ul.addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//1.e.target与this的区别</span></span><br><span class="line">            <span class="comment">//e.target返回触发了事件的源元素，本例子中点击了li触发ul的点击事件，所以返回li</span></span><br><span class="line">            <span class="built_in">console</span>.log(e.target);</span><br><span class="line">            <span class="comment">//this是本事件的绑定元素，谁绑定了这个事件就返回谁，本例返回ul</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>e.target</code>为<strong>触发事件的源元素</strong>，上述代码点击li标签触发了事件，所以<strong>值为li标签</strong></li>
<li>this则是指向<strong>本事件绑定的元素</strong>，ul上绑定的click事件，则<strong>值为ul标签</strong></li>
</ul>
<h3 id="e-type"><a href="#e-type" class="headerlink" title="e.type"></a>e.type</h3><p>值为<strong>触发事件类型</strong></p>
<ul>
<li>点击事件触发则返回<code>click</code></li>
<li>鼠标经过触发则返回<code>mouseover</code></li>
</ul>
<h3 id="e-preventDefault-阻止默认事件"><a href="#e-preventDefault-阻止默认事件" class="headerlink" title="e.preventDefault() 阻止默认事件"></a>e.preventDefault() 阻止默认事件</h3><p>阻止当前<strong>事件绑定元素</strong>及其子元素的<strong>默认行为</strong></p>
<ul>
<li>阻止a标签的<strong>跳转</strong>默认行为</li>
<li>阻止表单submit输入域的<strong>提交功能</strong>默认行为</li>
</ul>
<h3 id="e-stopPropagation-阻止事件冒泡"><a href="#e-stopPropagation-阻止事件冒泡" class="headerlink" title="e.stopPropagation() 阻止事件冒泡"></a>e.stopPropagation() 阻止事件冒泡</h3><p>阻止冒泡</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>06-图书管理案例前后端交互</title>
    <url>/2021/09/20/06-%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<h1 id="图书管理案例前后端交互"><a href="#图书管理案例前后端交互" class="headerlink" title="图书管理案例前后端交互"></a>图书管理案例前后端交互</h1><h2 id="1-案例分析"><a href="#1-案例分析" class="headerlink" title="1. 案例分析"></a>1. 案例分析</h2><p><img data-src="../images/06-%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210925110848676.png" alt="image-20210925110848676"></p>
<center>图一</center>

<span id="more"></span>

<h2 id="2-项目初始化"><a href="#2-项目初始化" class="headerlink" title="2. 项目初始化"></a>2. 项目初始化</h2><p><img data-src="../images/06-%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210925114117214.png" alt="image-20210925114117214"></p>
<center>图二</center>

<ul>
<li>public静态资源文件夹<ul>
<li>html文件夹<ul>
<li><code>index.html</code>图书管理页面</li>
</ul>
</li>
<li>js文件夹<ul>
<li>三个js库<code>（axios,jQuery,Vue）</code></li>
</ul>
</li>
<li><code>data.json</code>文件：存放图书列表数据</li>
</ul>
</li>
<li>route路由模块文件夹<ul>
<li><code>router.js</code>路由列表文件</li>
<li><code>service.js</code>路由处理函数文件</li>
</ul>
</li>
<li>app.js 项目入口文件(服务器程序)</li>
</ul>
<br>

<p>服务器运行在<code>http://localhost:3000</code></p>
<br>

<h2 id="3-图书列表数据加载功能"><a href="#3-图书列表数据加载功能" class="headerlink" title="3. 图书列表数据加载功能"></a>3. 图书列表数据加载功能</h2><p>在<code>index.html</code>文件中的<code>mounted</code>函数中使用<code>axios</code>接口请求图书列表数据</p>
<p>使用<code>async/await</code>接受异步操作的<u>结果（图书列表数据）</u></p>
<ul>
<li><code>index.html</code>文件中设置了<code>axios</code>接口的基准URL</li>
<li>使用响应拦截器<strong>提取响应对象中的数据</strong>（图书数据数组）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//axios基准URL</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;http://localhost:3000/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//axios响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> config.data</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//mounted在Vue实例初始化完成后调用</span></span><br><span class="line">mounted: <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//axios API向服务器发送请求</span></span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> axios.get(<span class="string">&#x27;/books&#x27;</span>)</span><br><span class="line">    <span class="comment">//使用后台数据填充Vue实例中的模板数据</span></span><br><span class="line">    <span class="built_in">this</span>.list = data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/06-%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210925115455365.png" alt="image-20210925115455365"></p>
<center>图三</center>

<h2 id="4-增加图书功能"><a href="#4-增加图书功能" class="headerlink" title="4. 增加图书功能"></a>4. 增加图书功能</h2><p>表单中输入新增图书名字后点击提交</p>
<p>在<code>handle</code>函数中使用<code>axios API</code> 发送post请求获取服务器响应</p>
<ul>
<li>将新书名字作为post请求参数<ul>
<li>新增图书的<code>id</code>和<code>time</code>在后台动态添加</li>
</ul>
</li>
<li>后台接受增加请求后在<code>data.json</code>文件中新增书籍数据</li>
<li>修改json文件成功后响应<code>&#123;status:200&#125;</code></li>
<li>客户端接受服务端响应结果后，若status为200则调用<u><code>queryData</code>函数</u>（重新加载图书列表数据）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handle:<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                  <span class="comment">//判断当前操作是新建还是修改</span></span><br><span class="line">                  <span class="keyword">if</span>(<span class="built_in">this</span>.flag == <span class="literal">false</span>)&#123;</span><br><span class="line">                      <span class="comment">//添加</span></span><br><span class="line">                      <span class="keyword">let</span> res = <span class="keyword">await</span> axios.post(<span class="string">&#x27;books&#x27;</span>,&#123;</span><br><span class="line">                          name:<span class="built_in">this</span>.name</span><br><span class="line">                      &#125;)</span><br><span class="line">                      <span class="keyword">if</span>(res.status == <span class="number">200</span>)&#123;</span><br><span class="line">                          <span class="built_in">this</span>.queryData()</span><br><span class="line">                      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                          alert(<span class="string">&#x27;错误&#x27;</span>)</span><br><span class="line">                      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                          <span class="comment">//修改...</span></span><br><span class="line">                      &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>后台操作<code>data.json</code>的代码省略</li>
</ul>
<br>

<h2 id="5-验证图书名称是否存在"><a href="#5-验证图书名称是否存在" class="headerlink" title="5. 验证图书名称是否存在"></a>5. 验证图书名称是否存在</h2><p>在Vue的侦听器watch中使用<code>axios API</code>发送请求</p>
<p>当前文本框输入内容作为get请求参数</p>
<p>请求使用<code>Restful URL</code></p>
<p>后台查找名称是否存在并返回状态</p>
<ul>
<li>状态为1则存在，禁用提交按钮</li>
<li>否则解除禁用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">             <span class="comment">//监听name模板数据</span></span><br><span class="line">             <span class="comment">//val即为变化后的name数据值</span></span><br><span class="line">             name:<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                 <span class="keyword">let</span> res = <span class="keyword">await</span> axios.get(<span class="string">&#x27;books/book/&#x27;</span>+ val)</span><br><span class="line">                 <span class="keyword">if</span>(res.status == <span class="number">1</span>)&#123;</span><br><span class="line">                     <span class="comment">//存在 禁用提交按钮</span></span><br><span class="line">                     <span class="built_in">this</span>.submitFlag = <span class="literal">true</span></span><br><span class="line">                 &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     <span class="built_in">this</span>.submitFlag = <span class="literal">false</span></span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;,</span><br></pre></td></tr></table></figure>

<br>

<h2 id="6-编辑-根据ID查询图书信息"><a href="#6-编辑-根据ID查询图书信息" class="headerlink" title="6. 编辑-根据ID查询图书信息"></a>6. 编辑-根据ID查询图书信息</h2><p>当点击修改按钮后，向服务器发送数据</p>
<p>根据ID查询最新的图书信息后返回给客户端</p>
<p>客户端将最新数据显示在输入域中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">edit: <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//在后台寻找要修改的图书数据</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> axios.get(<span class="string">&#x27;books/&#x27;</span>+id)</span><br><span class="line">    <span class="built_in">this</span>.id = res.id</span><br><span class="line">    <span class="built_in">this</span>.name = res.name</span><br><span class="line">    <span class="comment">//标识当前是修改操作</span></span><br><span class="line">    <span class="built_in">this</span>.flag = <span class="literal">true</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<br>

<h2 id="7-编辑-提交修改图书信息"><a href="#7-编辑-提交修改图书信息" class="headerlink" title="7. 编辑-提交修改图书信息"></a>7. 编辑-提交修改图书信息</h2><p>点击按钮后根据flag数据的值判断是<strong>修改提交</strong>还是<strong>增加提交</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改</span></span><br><span class="line"><span class="keyword">let</span> res = <span class="keyword">await</span> axios.put(<span class="string">&#x27;books/&#x27;</span>+<span class="built_in">this</span>.id,&#123;</span><br><span class="line">    name:<span class="built_in">this</span>.name</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//修改成功</span></span><br><span class="line"><span class="keyword">if</span>(res.status == <span class="number">200</span>)&#123;</span><br><span class="line">    <span class="comment">//重新获取图书列表</span></span><br><span class="line">    <span class="built_in">this</span>.queryData()</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;错误&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-删除数据"><a href="#8-删除数据" class="headerlink" title="8. 删除数据"></a>8. 删除数据</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">deletebook: <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> axios.delete(<span class="string">&#x27;books/&#x27;</span>+id)</span><br><span class="line">    <span class="keyword">if</span>(res.status == <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.queryData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,	</span><br></pre></td></tr></table></figure>

<h2 id="9-遇见的问题"><a href="#9-遇见的问题" class="headerlink" title="9. 遇见的问题"></a>9. 遇见的问题</h2><p>在数组some方法<strong>内部</strong>使用<code>res.send()</code>进行请求的响应会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> find = <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> id = req.params.id</span><br><span class="line">    data.some(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(item.id == id)&#123;</span><br><span class="line">            <span class="comment">//响应查询到的书籍信息</span></span><br><span class="line">            res.send(item)	<span class="comment">//报错</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="../images/06-%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210925190929333.png" alt="image-20210925190929333"></p>
<p>解决办法：在some方法<strong>外部</strong>进行响应即可</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>06-服务器端基本概念</title>
    <url>/2021/04/26/06-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="服务器端基本概念"><a href="#服务器端基本概念" class="headerlink" title="服务器端基本概念"></a>服务器端基本概念</h1><h2 id="1-URL"><a href="#1-URL" class="headerlink" title="1.URL"></a>1.URL</h2><p><strong>URL：统一资源定位符，标识internet网上资源的一种编码方式</strong></p>
<p>使用URL可以唯一标识网络上的一个资源</p>
<p>URL组成：</p>
<ul>
<li><strong>传输协议</strong>://<strong>服务器IP或域名:端口号</strong>/<strong>资源所在位置的标识</strong></li>
<li>例如: <code>http://www.baidu.com/news/a.html</code></li>
<li>即使用http协议访问域名为<code>www.baidu.com</code>，端口号为默认80的这个web服务器上的news文件夹下的a.html文件</li>
<li>http：超文本传输协议，一种发布和接收html文件的方法</li>
<li>IP或域名可以找到网络上的一台服务器，端口则代表这台服务器上的应用程序提供的服务，http默认端口为80</li>
<li>资源所在位置标识：<strong>不一定是服务器上资源的路径</strong>，请求提交给服务器后，服务器可以根据位置标识做出其他的操作，服务器给客户端返回什么资源是服务器自身决定的</li>
</ul>
<span id="more"></span>

<h2 id="2-开发过程客户端和服务端说明"><a href="#2-开发过程客户端和服务端说明" class="headerlink" title="2.开发过程客户端和服务端说明"></a>2.开发过程客户端和服务端说明</h2><p>开发过程中，客户端和服务端使用同一台电脑，即开发人员的电脑</p>
<p>开发人员电脑上的<strong>浏览器</strong>即为<strong>客户端</strong></p>
<p>开发人员电脑上的Node可以编写服务器，可以作为<strong>服务端</strong>，即软件层面的服务器</p>
<p>本机域名：localhost</p>
<p>本机IP：127.0.0.1</p>
<p>使用本机IP/域名就可以使用本机的客户端访问本机的服务端</p>
<h2 id="3-nodejs构建简单web服务器"><a href="#3-nodejs构建简单web服务器" class="headerlink" title="3.nodejs构建简单web服务器"></a>3.nodejs构建简单web服务器</h2><p>server.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Node中有一个核心模块：http</span></span><br><span class="line"><span class="comment">//这个模块就是用来创建编写服务器的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器</span></span><br><span class="line">    <span class="comment">//接受请求</span></span><br><span class="line">    <span class="comment">//处理请求</span></span><br><span class="line">    <span class="comment">//给出响应(反馈)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.引入核心模块http</span></span><br><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用http.createServer()创建一个WEB服务器</span></span><br><span class="line"><span class="comment">//      方法返回一个Server实例</span></span><br><span class="line"><span class="keyword">var</span> server=http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.注册request请求事件，当浏览器请求发向服务器时触发</span></span><br><span class="line"><span class="comment">//第二个参数是事件处理函数</span></span><br><span class="line">    <span class="comment">//请求处理函数中接收两个参数</span></span><br><span class="line">        <span class="comment">//Request   请求对象</span></span><br><span class="line">            <span class="comment">//获取客户端的一些请求信息，例如请求路径</span></span><br><span class="line">        <span class="comment">//Response  响应对象</span></span><br><span class="line">            <span class="comment">//用来给客户端发送响应信息</span></span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//服务器接收到客户端请求后就在后台输出 请求的url(路径)</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;接受到请求，请求路径为：&quot;</span>+request.url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//response对象的write()方法可以给客户端发送响应数据</span></span><br><span class="line">        <span class="comment">//此时客户端访问http://127.0.0.1/3000/ 时会返回hello nodejs</span></span><br><span class="line">    response.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    response.write(<span class="string">&quot; nodejs&quot;</span>);</span><br><span class="line">    <span class="comment">//可以有多个write()但最后必须有一个end()结束响应 否则客户端会一直等待</span></span><br><span class="line">    <span class="comment">//也可以直接使用end()返回响应数据</span></span><br><span class="line">    response.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.绑定端口号，启动服务器</span></span><br><span class="line"><span class="comment">//第二个参数的函数在服务器启动时执行(起日志作用)</span></span><br><span class="line">server.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//在3000端口启动服务器</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;服务器启动成功，可以通过http://127.0.0.1/3000/访问&quot;</span>);</span><br><span class="line">    <span class="comment">//127.0.0.1也可以换成localhost</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>请求处理函数中接收两个参数</p>
<ul>
<li>Request   请求对象：获取客户端的一些请求信息，例如请求路径等</li>
<li>Response  响应对象：用来给客户端发送响应信息<ul>
<li>第一个<code>response.end()</code>执行完后，服务器就已经结束响应</li>
<li>后面代码中的<code>response.end()</code>将不再向浏览器响应数据</li>
</ul>
</li>
</ul>
<p>node执行这个文件</p>
<p><img data-src="/images/06-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20210426213253506.png" alt="image-20210426213253506"></p>
<p>浏览器访问结果</p>
<p><img data-src="/images/06-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20210426213340606.png" alt="image-20210426213340606"></p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>清除浮动的方法</title>
    <url>/2022/11/27/06-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h1><p>元素设置float浮动属性后会<strong>脱离标准流（不占据标准流位置）</strong>，这样会导致父元素高度塌陷</p>
<ul>
<li><strong>注意</strong>：清除浮动后虽然可以解决高度塌陷问题，但是<u>浮动元素即使在清除浮动后也不会回归标准流</u><ul>
<li>即父元素在<strong>计算高度时会加上浮动元素的高度</strong>，但是浮动元素后的标准流元素<strong>仍然会占据其位置</strong></li>
<li>且在<strong>一个标准流元素上覆盖有浮动流元素时</strong>，标准流中的<strong>内容</strong>（文字图片等）<strong>会自动避开浮动流元素</strong>（即不被浮动流元素遮挡）<u>（浮动的一个重要功能就是实现内容（文字，图片等）环绕）</u></li>
<li>当浮动元素遮挡的<strong>标准流元素过小</strong>导致为<u>无法实现内容环绕效果</u>时，标准流元素的内容就会自动按照标准流布局向下排列</li>
</ul>
</li>
<li><code>float:none</code> <strong>意为不浮动，元素仍在文档流中</strong></li>
</ul>
<span id="more"></span>

<p><code>float:left or right</code>一直向浮动的方向平移，<strong>直到遇到父级元素边框或者上一个浮动元素</strong></p>
<p>浮动元素因为脱离文档流会<strong>使自适应高度的父级块级元素丢失高度</strong></p>
<p>清除浮动可以：</p>
<ul>
<li>解决父元素高度塌陷问题</li>
<li>但是浮动元素<strong>不会回归标准流</strong></li>
</ul>
<h2 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h2><p>在浮动元素后 添加一个空的块级元素div，并设置clear:both属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- CSS样式 --&gt;</span></span><br><span class="line">	.d1&#123;</span><br><span class="line">            background-color: aquamarine;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">        .d2&#123;</span><br><span class="line">            clear: both;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;d&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用一个空块级元素div设置clear:both清除浮动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/06-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95/image-20210915231921327.png" alt="image-20210915231921327"></p>
<ul>
<li>空的块级元素**#d2清除了浮动后**，类名为d1的div参与高度计算</li>
</ul>
<h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><p>在浮动元素的父级元素增加<code>overflow: hidden;</code>属性</p>
<p>利用了<a href="07-BFC">BFC</a>特性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- CSS样式 --&gt;</span></span><br><span class="line">#d&#123;</span><br><span class="line">            border: 1px solid black;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">.d1&#123;</span><br><span class="line">            background-color: aquamarine;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line"> .d3&#123;</span><br><span class="line">            background-color: chartreuse;</span><br><span class="line">            float: right;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/06-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95/image-20210915232539843.png" alt="image-20210915232539843"></p>
<ul>
<li>清除浮动后两个div参与高度计算</li>
</ul>
<h2 id="第三种方法"><a href="#第三种方法" class="headerlink" title="第三种方法"></a>第三种方法</h2><p>在浮动元素的<strong>父级元素上设置浮动</strong>，此方法虽然能消除内部浮动，但父级元素又变为浮动，不推荐</p>
<h2 id="第四种方法"><a href="#第四种方法" class="headerlink" title="第四种方法"></a>第四种方法</h2><p>在浮动元素后面的正常元素（非空元素）添加<code>clear:both</code>属性</p>
<h2 id="第五种方法"><a href="#第五种方法" class="headerlink" title="第五种方法"></a>第五种方法</h2><p>使用伪元素<code>::after</code> 在创建的虚拟元素中设置<code>clear:both</code>属性清除浮动</p>
<h3 id="伪元素-after"><a href="#伪元素-after" class="headerlink" title="伪元素::after"></a>伪元素::after</h3><p>CSS<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements">伪元素</a><code>::after</code>用来<strong>创建一个伪元素</strong></p>
<ul>
<li>创建的伪元素作为<strong>已选中元素的最后一个子元素</strong></li>
<li>通常会配合<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content"><code>content</code></a>属性来为该元素添加装饰内容，这个虚拟元素<strong>默认是行内元素</strong>。</li>
<li>还可以为虚拟内容content添加样式</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- CSS样式 --&gt;</span></span><br><span class="line">#d&#123;</span><br><span class="line">            border: 1px solid black;</span><br><span class="line">        &#125;</span><br><span class="line">.d1&#123;</span><br><span class="line">            background-color: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line">.father::after &#123;</span><br><span class="line">            content:&#x27;nihao&#x27;;</span><br><span class="line">            color:red</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;d&quot;</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>.fater::after</code>伪元素，会创建一个虚拟元素 作为应用<code>fater</code>类名样式的元素的 <strong>最后一个子元素</strong></p>
<p><code>content:&#39;nihao&#39;</code>设置虚拟元素的内容为字符串<code>&#39;nihao&#39;</code></p>
<p><code>color:red</code>设置虚拟元素文字颜色为红色</p>
<p><img data-src="/images/06-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95/image-20210915234736701.png" alt="image-20210915234736701"></p>
<br>

<p>认识了伪元素<code>::after</code>的使用</p>
<ul>
<li><p>我们可以<strong>在需要清除浮动的元素的父元素</strong>上使用<code>::after</code>伪元素</p>
</li>
<li><p>在要清除浮动的元素后面增加一个<strong>空的虚拟元素</strong>，并设置虚拟元素的<code>clear:both</code>属性和<code>display:block</code>属性</p>
<ul>
<li>设置<code>display:block</code>是因为<strong>块级元素设置</strong><code>clear:both</code>属性<strong>才会生效</strong>，而虚拟元素<strong>默认为行内元素</strong>，需要转为块级元素</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- CSS样式 --&gt;</span>	</span><br><span class="line">	.d1&#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: aquamarine;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">        .father::after &#123;</span><br><span class="line">            content:&#x27;&#x27;;</span><br><span class="line">            clear: both;</span><br><span class="line">            display: block;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;d&quot;</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>      </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/06-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95/image-20210916000639758.png" alt="image-20210916000639758"></p>
<p>注意：虽然d1浮动被清除，d1只是参与父元素高度计算，并没有回归标准流</p>
]]></content>
      <categories>
        <category>HTMLandCss</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>页面配置文件</title>
    <url>/2022/11/27/06-%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="页面配置文件"><a href="#页面配置文件" class="headerlink" title="页面配置文件"></a>页面配置文件</h1><p>每个页面的json配置文件，对当前页面的**窗口效果(window)**进行配置</p>
<h2 id="1-页面配置与全局配置的关系"><a href="#1-页面配置与全局配置的关系" class="headerlink" title="1. 页面配置与全局配置的关系"></a>1. 页面配置与全局配置的关系</h2><p><img data-src="/images/06-%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-20220210161633250.png" alt="image-20220210161633250"></p>
<span id="more"></span>

<h2 id="2-页面配置常用配置项"><a href="#2-页面配置常用配置项" class="headerlink" title="2. 页面配置常用配置项"></a>2. 页面配置常用配置项</h2><p>与app.json文件中的window节点的配置项相同</p>
<p><img data-src="/images/06-%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/image-20220210161736182.png" alt="image-20220210161736182"></p>
<ul>
<li>对于上拉触底和下拉刷新的效果，一般对有需要的页面进行单独设置</li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>表单处理</title>
    <url>/2022/11/27/06-%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h1><h2 id="1-受控组件-常用-推荐"><a href="#1-受控组件-常用-推荐" class="headerlink" title="1.受控组件(常用 推荐)"></a>1.受控组件(常用 推荐)</h2><ul>
<li>HTML中表单元素可输入，它<strong>维护自己状态</strong></li>
<li>React的思想，<strong>状态都放在state中统一管理</strong></li>
</ul>
<p>为了解决上述冲突的问题，将其改造为受控组件：</p>
<ul>
<li>将表单元素的<strong>value属性设置为state中的状态</strong>(类似于Vue中的属性绑定)</li>
<li>通过表单元素的<code>Change</code>事件，使用<code>setState()</code>方法修改状态数据</li>
</ul>
<span id="more"></span>

<br>

<p><strong>受控组件使用实例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        val:<span class="string">&#x27;nihao&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    change = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//修改state</span></span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            <span class="comment">//e.target.value获取表单元素的value</span></span><br><span class="line">            val:e.target.value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">            <span class="comment">//使用state数据作为value，通过change事件修改state数据</span></span><br><span class="line">            &lt;input value=&#123;<span class="built_in">this</span>.state.val&#125; onChange=&#123;<span class="built_in">this</span>.change&#125; /&gt;</span><br><span class="line">        &lt;/div&gt;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：对于<code>type=&#39;checkbox&#39;</code>的复选框表单元素，改造为受控组件时，将其<strong>checked属性值作为state数据</strong>。</p>
<br>

<h3 id="多个表单元素的处理函数优化"><a href="#多个表单元素的处理函数优化" class="headerlink" title="多个表单元素的处理函数优化"></a>多个表单元素的处理函数优化</h3><p>目的：多个表单元素使用一个change事件处理函数，根据表单元素的<code>name</code>和<code>type</code>属性进行区分。</p>
<p><img data-src="/images/06-%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86/image-20220402211157825.png" alt="image-20220402211157825"></p>
<ul>
<li>表单元素设置name属性，属性值为state中对应数据名</li>
<li>处理函数中根据type属性值选择获取value值还是checked值(复选框表单元素特殊处理)</li>
<li>根据name属性值修改state中的数据<ul>
<li>使用<code>es6</code>的属性表达式 <code>[name]</code></li>
</ul>
</li>
</ul>
<br>

<h2 id="2-非受控组件"><a href="#2-非受控组件" class="headerlink" title="2.非受控组件"></a>2.非受控组件</h2><p>实现方式：借助ref，使用原生DOM方式获取表单元素值</p>
<p><strong>ref</strong>：获取原生DOM对象或者组件</p>
<p><img data-src="/images/06-%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86/image-20220402211920360.png" alt="image-20220402211920360"></p>
<ul>
<li>React不建议直接操控DOM，所以此方法在表单处理中不常用</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>BFC-块级格式化上下文</title>
    <url>/2022/11/27/07-BFC/</url>
    <content><![CDATA[<h1 id="BFC-块级格式化上下文"><a href="#BFC-块级格式化上下文" class="headerlink" title="BFC-块级格式化上下文"></a>BFC-块级格式化上下文</h1><p>块级元素满足<strong>特定条件</strong>会创建BFC</p>
<ul>
<li>每一个BFC只包含其子元素，不包含更深层次的后代（不包含子元素的子元素）</li>
<li>每一个BFC<strong>互相隔绝，互不影响</strong></li>
<li>BFC解决的问题：<ul>
<li>清除浮动</li>
<li>防止margin重叠</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="触发BFC的条件"><a href="#触发BFC的条件" class="headerlink" title="触发BFC的条件"></a><strong>触发BFC的条件</strong></h2><ul>
<li><p>·body根元素</p>
</li>
<li><p>·设置浮动，不包括none</p>
</li>
<li><p>·设置定位，absoulte或者fixed</p>
</li>
<li><p>·行内块显示模式，inline-block</p>
</li>
<li><p>·设置overflow，值为hidden，auto，scroll</p>
</li>
<li><p>·表格单元格，table-cell</p>
</li>
<li><p>·弹性布局，flex</p>
</li>
</ul>
<h2 id="BFC解决问题"><a href="#BFC解决问题" class="headerlink" title="BFC解决问题"></a>BFC解决问题</h2><p>根据每个BFC<strong>互不影响</strong>的特性可以解决一些问题</p>
<h3 id="1-解决两个块级元素外边距（margin）塌陷问题"><a href="#1-解决两个块级元素外边距（margin）塌陷问题" class="headerlink" title="1. 解决两个块级元素外边距（margin）塌陷问题"></a>1. 解决两个块级元素外边距（margin）塌陷问题</h3><p><img data-src="/images/07-BFC/image-20210916103058395.png" alt="image-20210916103058395"></p>
<ul>
<li>此时两个盒子都设置<code>margin:100px</code>,但是实际显示效果上下盒子相距不是200px而是100px</li>
</ul>
<p><strong>外边距(margin)重叠</strong></p>
<p>外边距重叠是指两个垂直相邻的块级元素，当上下两个边距相遇时，外边距会产生重叠现象，且重叠后的外边距，等于<strong>其中较大者</strong>。</p>
<ul>
<li>此时给两个块级元素添加属性<code>overflow:hidden</code>,让其生成两个BFC，两个BFC互不影响，则相距变为200px</li>
</ul>
<h3 id="2-解决嵌套的子元素设置margin-top影响到父元素问题"><a href="#2-解决嵌套的子元素设置margin-top影响到父元素问题" class="headerlink" title="2.解决嵌套的子元素设置margin-top影响到父元素问题"></a>2.解决嵌套的子元素设置margin-top影响到父元素问题</h3><p><img data-src="/images/07-BFC/image-20210916103841629.png" alt="image-20210916103841629"></p>
<ul>
<li><p>此时子元素设置<code>margin-top:50px</code>，我们想要的效果为，<strong>子元素与父元素上边框相距50px</strong></p>
</li>
<li><p>而实际效果为，父元素出现<code>margin-top:50px</code>的效果（据浏览器顶部50px），而子元素仍紧贴父元素上边框</p>
</li>
<li><p>此时就可以触发BFC，将<strong>父盒子变成一个独立的区域</strong>，这样在BFC区域内部的任何操作，都<strong>不会影响到外部</strong>。</p>
<ul>
<li>此时body一个BFC ，父元素一个BFC ，两个BFC互不影响，父元素内部样式改变不会影响body的BFC</li>
</ul>
</li>
</ul>
<h3 id="3-解决浮动子元素导致父元素高度塌陷问题"><a href="#3-解决浮动子元素导致父元素高度塌陷问题" class="headerlink" title="3.解决浮动子元素导致父元素高度塌陷问题"></a>3.解决浮动子元素导致父元素高度塌陷问题</h3><p><img data-src="/images/07-BFC/image-20210916104407405.png" alt="image-20210916104407405"></p>
<ul>
<li><p>此时内部7个子元素都设置浮动，产生七个BFC，导致父元素高度塌陷</p>
<ul>
<li>浮动元素脱离了标准流并覆盖在标准流的元素之上</li>
</ul>
</li>
<li><p>此时父元素高度为0（不显示），但是width:300px仍然影响子元素排列，所以七个son每行两个排列</p>
</li>
</ul>
<br>

<ul>
<li>此时只要给父元素生成一个BFC即与七个son生成的BFC互不影响<ul>
<li>父元素加入<code>overflow:hidden</code>属性生成BFC</li>
</ul>
</li>
</ul>
<p><img data-src="/images/07-BFC/image-20210916105135313.png" alt="image-20210916105135313"></p>
<ul>
<li>此时父元素高度被七个son撑起，父元素显示</li>
</ul>
<br>

<h3 id="4-利用BFC阻止标准流元素被浮动元素覆盖"><a href="#4-利用BFC阻止标准流元素被浮动元素覆盖" class="headerlink" title="4.利用BFC阻止标准流元素被浮动元素覆盖"></a>4.利用BFC阻止标准流元素被浮动元素覆盖</h3><ul>
<li>红盒子浮动生成BFC，蓝盒子标准流</li>
<li> 默认情况下浮动的红盒子会覆盖在蓝盒子上方</li>
</ul>
<p><img data-src="/images/07-BFC/image-20210916110351049.png" alt="image-20210916110351049"></p>
<ul>
<li>给蓝盒子设置<code>overflow:hidden</code>属性后，两个BFC（红/蓝盒子）互不影响</li>
<li>蓝盒子在<strong>当前标准流位置的基础上右移避开红色盒子</strong></li>
</ul>
<p><img data-src="/images/07-BFC/image-20210916110936595.png" alt="image-20210916110936595"></p>
<ul>
<li>同时会根据红盒子宽度的变化改变右移距离（始终在红盒子右侧）</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不同的BFC区域之间是相互独立的，互不影响的</p>
<ul>
<li>利用这个特性我们可以让不同BFC区域之间的<strong>布局不产生影响</strong>。</li>
</ul>
]]></content>
      <categories>
        <category>HTMLandCss</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>07-BOM浏览器对象模型</title>
    <url>/2022/12/04/07-BOM%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="BOM浏览器对象模型"><a href="#BOM浏览器对象模型" class="headerlink" title="BOM浏览器对象模型"></a>BOM浏览器对象模型</h1><p>BOM浏览器对象模型提供了独立于内容的、<strong>可以与浏览器窗口进行互动的对象结构</strong>。BOM由多个对象组成，其中代表浏览器窗口的<strong>Window对象是BOM的顶层对象</strong>，其他对象都是该对象的子对象</p>
<ul>
<li><strong>Window对象</strong>是BOM的顶层对象</li>
</ul>
<h2 id="1-window对象的事件"><a href="#1-window对象的事件" class="headerlink" title="1.window对象的事件"></a>1.window对象的事件</h2><h3 id="resize事件"><a href="#resize事件" class="headerlink" title="resize事件"></a>resize事件</h3><p>当浏览器窗口大小发生变化时即会触发</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">window.addEventListener(&quot;resize&quot;,function()&#123;&#125;)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="load事件"><a href="#load事件" class="headerlink" title="load事件"></a>load事件</h3><p>页面加载完毕事件，页面加载完毕即触发</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//页面加载事件新方法，可以存在多个window.addEventListener(&quot;load&quot;,function()&#123;&#125;)，都会生效</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;load&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用addEventListener绑定此事件可以在页面加载完成时<strong>执行多个处理函数</strong></li>
</ul>
<h3 id="DOMContentLoaded和load事件"><a href="#DOMContentLoaded和load事件" class="headerlink" title="DOMContentLoaded和load事件"></a>DOMContentLoaded和load事件</h3><p><code>DOMContentLoaded</code>是<strong>document对象</strong>的事件，意为：DOM内容加载完毕（不包含图片，css等的加载）</p>
<ul>
<li>可以在图片较多的网页中先体现出js的交互效果（DOM内容加载完就执行），提升用户体验</li>
<li>此事件<strong>先于load事件触发</strong></li>
</ul>
<br>

<p><code>load</code>事件是<strong>window对象</strong>的事件</p>
<ul>
<li>当<strong>页面完全加载完毕</strong>后触发</li>
</ul>
<h2 id="2-BOM中的其他对象"><a href="#2-BOM中的其他对象" class="headerlink" title="2.BOM中的其他对象"></a>2.BOM中的其他对象</h2><h3 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h3><ul>
<li><code>location.assign(&#39;url&#39;)</code>方法：页面重定向，记录历史，<strong>可以回退</strong></li>
<li><code>location.replace(&quot;url&quot;)</code>方法：页面重定向，<strong>不可回退</strong></li>
<li><code>location.reload();</code>方法：<strong>刷新页面</strong><ul>
<li>传入true参数可以强制刷新页面，即从服务器重新获取页面（不使用缓存）</li>
</ul>
</li>
<li><code>location.href(&#39;url&#39;)</code> 设置URL并跳转</li>
</ul>
<br>

<h3 id="History对象"><a href="#History对象" class="headerlink" title="History对象"></a>History对象</h3><ul>
<li><p><code>history.forward();</code> 在会话历史中向前移动一页（与<code>histoty.go(1)</code>效果相同）</p>
</li>
<li><p><code>history.go(n);</code> 在历史中向前或向后</p>
<ul>
<li>参数为正数时：前进n页</li>
<li>参数为负数时：后退n页</li>
</ul>
</li>
<li><p><code>history.back();</code> 与<code>histoty.go(-1)</code>效果相同，回退一页</p>
</li>
</ul>
<br>

<h3 id="Navigator对象"><a href="#Navigator对象" class="headerlink" title="Navigator对象"></a>Navigator对象</h3><ul>
<li>表示用户代理的状态和标识</li>
</ul>
<p><img data-src="/images/07-BOM%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/image-20210916230216351.png" alt="image-20210916230216351"></p>
<ul>
<li><code>navigator.userAgent</code>属性可以显示当前使用的浏览器信息(移动端或者PC端)，并可以据此跳转到相应的PC端或者移动端页面</li>
</ul>
<p><img data-src="/images/07-BOM%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/image-20210916230344598.png" alt="image-20210916230344598"></p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>07-HTTP协议</title>
    <url>/2021/04/26/07-HTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><h2 id="1-HTTP协议概念"><a href="#1-HTTP协议概念" class="headerlink" title="1.HTTP协议概念"></a>1.HTTP协议概念</h2><p>HTTP(Hyper Text Transfer Protocol)：超文本传输协议,规定如何从服务器传输超文本文件(HTML文件)到浏览器，基于浏览器-服务器(B-S)架构工作，是客户端和服务器请求和应答的标准</p>
<p>超文本(HTML)：在文本中不仅仅能包含文字，还可以包含音频视频图像等资源</p>
<h2 id="2-报文"><a href="#2-报文" class="headerlink" title="2.报文"></a>2.报文</h2><p>HTTP<strong>请求和响应的数据块</strong>被称为报文，包括要传送的数据和一些附加信息，并且遵守规定好的格式</p>
<p><strong>请求报文</strong>：浏览器发给服务器的HTTP请求报文</p>
<p><strong>响应报文</strong>：服务器发给浏览器的HTTP响应报文</p>
<span id="more"></span>

<center>利用浏览器的开发者工具可以看到浏览器和服务器进行通信的请求和响应报文</center>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426214103527.png" alt="image-20210426214103527"></p>
<p>Network选项卡可以看到当前浏览器和服务器之间的通信情况</p>
<p>下面的localhost和favicon.ico即为浏览器向服务器发送的两个HTTP请求</p>
<ul>
<li>localhost即为我们输出网址回车后发出的请求</li>
<li>favicon.ico为浏览器默认的请求，请求该网页的标识小图标</li>
</ul>
<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426214318773.png" alt="image-20210426214318773"></p>
<center>点击请求可以看到更详细的信息</center>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426214439234.png" alt="image-20210426214439234"></p>
<p>Headers选项卡展示了请求和响应的头部等信息，General中显示了请求和响应中的重要信息</p>
<ul>
<li>报文头部中的信息以<code>:</code>分隔的键值对表示，键值对之间使用 <code>,</code>分隔</li>
</ul>
<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426222733888.png" alt="image-20210426222733888"></p>
<p>Response中则展示了服务器实际响应的数据</p>
<h3 id="1-请求报文"><a href="#1-请求报文" class="headerlink" title="1.请求报文"></a>1.请求报文</h3><h4 id="1-请求方式-Request-Method"><a href="#1-请求方式-Request-Method" class="headerlink" title="1.请求方式(Request Method)"></a>1.请求方式(Request Method)</h4><ul>
<li><strong>GET</strong>: 一般用来获取数据，也可以向服务器发送少量数据(发送的数据大小有限制)，但是不安全</li>
<li><strong>POST</strong>: 一般用来向服务器发送数据(可以发送大量数据)，网站的一般逻辑操作也使用POST方法，POST方法比GET方法安全性高</li>
</ul>
<p><strong>例如：直接在浏览器输入网址访问服务器默认发送的是GET请求</strong></p>
<p>服务器端可以获取浏览器的请求方式</p>
<p><code>request.method</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取请求方式 在服务器后输出</span></span><br><span class="line"><span class="built_in">console</span>.log(request.method);</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426215848666.png" alt="image-20210426215848666"></p>
<p>使用浏览器输入网址访问服务器</p>
<p>服务器后台输出两个GET，代表localhost请求和favicon.ico请求均为GET请求</p>
<br>

<p><strong>例如：html文件中表格form提交时可以指定提交方式，指定为POST即使用POST方式请求</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">       action:提交到哪个服务器</span></span><br><span class="line"><span class="comment">       method：提交采用什么方式</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:3000&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<center>服务器后台显示</center>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426220411454.png" alt="image-20210426220411454"></p>
<p>此处第一次表格提交为POST请求，第二次请求页面小图标favicon.ico为GET请求</p>
<p><strong>服务器可以根据对同一网址的不同请求方式做出不同响应</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当请求方式为GET时</span></span><br><span class="line"><span class="keyword">if</span>(request.method == <span class="string">&#x27;GET&#x27;</span>)&#123;</span><br><span class="line">        response.end(<span class="string">&quot;GET&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(request.method == <span class="string">&#x27;POST&#x27;</span>)&#123;</span><br><span class="line">        response.end(<span class="string">&quot;POST&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        response.end(<span class="string">&quot;hello nodejs&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码会根据请求方式不同，给浏览器响应不同的数据</p>
<p>例如：直接按网址访问服务器会响应’GET’，点击表单提交按钮访问服务器会响应’POST’</p>
<h4 id="2-请求URL"><a href="#2-请求URL" class="headerlink" title="2.请求URL"></a>2.请求URL</h4><p><code>request.url</code>获取浏览器请求URL中从 ‘/‘ 开始的资源标识符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取请求URL根据请求URL返回不同的数据</span></span><br><span class="line">    <span class="keyword">if</span>(request.url == <span class="string">&#x27;/index&#x27;</span>|| request.url == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">        response.end(<span class="string">&#x27;index&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (request.url == <span class="string">&#x27;/list&#x27;</span>)&#123;</span><br><span class="line">        response.end(<span class="string">&#x27;list&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        response.end(<span class="string">&#x27;404NotFound!&#x27;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当请求地址为<code>http://localhost:3000</code>时，浏览器给服务器发送的请求会自动在url末尾加上 ‘/‘ </li>
<li>实际发送的url为<code>http://localhost:3000/</code>，所以服务器request.url获取的值都是以 ‘/‘ 开头的</li>
</ul>
<h4 id="3-请求头部Headers"><a href="#3-请求头部Headers" class="headerlink" title="3.请求头部Headers"></a>3.请求头部Headers</h4><p><code>request.headers</code> 获取请求报文的请求头</p>
<p><code>request.headers[&#39;字段名&#39;]</code>获取请求头中特定字段的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将请求头信息在后台输出</span></span><br><span class="line"><span class="built_in">console</span>.log(request.headers);</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426223953815.png" alt="image-20210426223953815"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回请求头中&#x27;accept&#x27;字段的值</span></span><br><span class="line"><span class="built_in">console</span>.log(request.headers[<span class="string">&#x27;accept&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426224158174.png" alt="image-20210426224158174"></p>
<br>

<h3 id="2-响应报文"><a href="#2-响应报文" class="headerlink" title="2.响应报文"></a>2.响应报文</h3><h4 id="1-HTTP状态码"><a href="#1-HTTP状态码" class="headerlink" title="1.HTTP状态码"></a>1.HTTP状态码</h4><ul>
<li>200 OK 代表请求成功</li>
<li>300 重定向</li>
<li>404 请求资源没找到</li>
<li>500 服务器端错误(服务器代码报错等)</li>
<li>400 客户端请求有语法错误等</li>
</ul>
<p>在浏览器开发者工具中可以看到HTTP响应的状态码</p>
<p>在服务器端可以使用<code>response.writeHead(HTTP状态码)</code> 指定响应时的状态码</p>
<p>如设置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">response.writeHead(<span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<p>服务器返回的响应报文中HTTP状态码就为200 OK</p>
<h4 id="2-内容类型"><a href="#2-内容类型" class="headerlink" title="2.内容类型"></a>2.内容类型</h4><p>响应数据时需要设定响应数据的类型，以便浏览器根据数据类型对返回的数据进行解析</p>
<ul>
<li>text/plain    纯文本 (默认的内容类型，不指定时默认纯文本) </li>
<li>text/html    html文本(浏览器自动解析其中的html代码)</li>
<li>text/css       css文本</li>
<li>application/javascript   javascript文本</li>
<li>application/json   json文本</li>
<li>image/jpeg     .jpeg格式的图片</li>
</ul>
<p>使用如下代码设置内容类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">response.writeHead(HTTP状态码,&#123;</span><br><span class="line">	<span class="string">&#x27;content-type&#x27;</span>:<span class="string">&#x27;text/plain;charset=utf-8&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其中<code>charset=utf-8</code>代表指明响应给浏览器的数据的编码格式，utf-8编码可以解析中文</p>
<h2 id="3-HTTP请求与响应处理"><a href="#3-HTTP请求与响应处理" class="headerlink" title="3.HTTP请求与响应处理"></a>3.HTTP请求与响应处理</h2><h3 id="1-请求参数"><a href="#1-请求参数" class="headerlink" title="1.请求参数"></a>1.请求参数</h3><p>客户端向服务端发送请求时，有时需要<strong>向服务端传递一些数据</strong>，这些数据通过<strong>请求参数的方式</strong>传递到服务端，例如登陆操作</p>
<h4 id="1-GET请求参数"><a href="#1-GET请求参数" class="headerlink" title="1.GET请求参数"></a>1.GET请求参数</h4><p>参数被放置在浏览器地址栏(URL)中，例如<strong><code>http://localhost:3000/?name=yang&amp;age=20</code></strong></p>
<p>这里的<code>name=yang&amp;age=20</code>就为请求参数</p>
<ul>
<li>请求参数使用<code>?</code>与URL隔开</li>
<li>请求参数中的不同参数使用<code>&amp;</code>分隔</li>
<li>请求参数以键值对的形式表示如： <code>name=yang</code>，键值之间使用<code>=</code>分隔</li>
</ul>
<h5 id="1-服务端如何获取GET请求参数"><a href="#1-服务端如何获取GET请求参数" class="headerlink" title="1.服务端如何获取GET请求参数"></a>1.服务端如何获取GET请求参数</h5><p>使用<code>request.url</code>可以获取请求URL，如果有请求参数，res.url会一并获取请求参数</p>
<center>获取的请求URL(带请求参数)</center>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210427214415414.png" alt="image-20210427214415414"></p>
<ul>
<li>可以通过字符串截取的方式获得？后的请求参数</li>
<li>node中内置了<strong>url系统模块</strong>，可以用来处理请求URL和请求参数</li>
</ul>
<br>

<p>url模块中的<code>url.parse(&#39;URL&#39;)</code>方法可以将URL的详细信息以对象的形式返回</p>
<p><strong>url.parse()</strong></p>
<ul>
<li>第一个参数为请求URL</li>
<li>第二个参数为true/false<ul>
<li>true意为<strong>将请求参数解析为对象形式</strong>(返回的URL对象的query属性为一个对象)</li>
<li>false意为请求参数以字符串返回(query属性为一个字符串)</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> url=<span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="comment">//获取url后以对象形式返回并在后台输出</span></span><br><span class="line"><span class="built_in">console</span>.log(url.parse(request.url));</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210427215213302.png" alt="image-20210427215213302"></p>
<p>query属性为<strong>字符串形式的请求参数</strong></p>
<br>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(url.parse(request.url,<span class="literal">true</span>));</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210427220107218.png" alt="image-20210427220107218"></p>
<p>query属性为<strong>对象形式的请求参数</strong></p>
<p>使用如下代码即可获取请求参数中的数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> query = url.parse(request.url,<span class="literal">true</span>).query</span><br><span class="line">    <span class="built_in">console</span>.log(query.name);</span><br><span class="line">    <span class="built_in">console</span>.log(query.age);</span><br></pre></td></tr></table></figure>

<h5 id="2-URL中加入请求参数后判断请求的资源标识符"><a href="#2-URL中加入请求参数后判断请求的资源标识符" class="headerlink" title="2.URL中加入请求参数后判断请求的资源标识符"></a>2.URL中加入请求参数后判断请求的资源标识符</h5><p>URL中加入请求参数后原来使用<code>request.url</code>判断请求资源标识符的方法需要修改</p>
<p><code>url.parse()</code>返回的对象中的<strong>pathname属性</strong>即为不带请求参数的请求资源标识符</p>
<p>使用ES6对象解构的方式获得query和pathname</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;query,pathname&#125; = url.parse(request.url,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>使用pathname判断请求资源标识符就可以解决这个问题</p>
<h4 id="2-POST请求参数"><a href="#2-POST请求参数" class="headerlink" title="2.POST请求参数"></a>2.POST请求参数</h4><p>一般在<strong>提交表单时</strong>请求参数使用POST方式发送</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:3000&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>POST方式的请求参数放在<strong>请求报文中</strong>，不在URL中</p>
<p>POST和GET方式的请求参数格式是<strong>一样</strong>的</p>
<p>表单中请求参数的名字写在<code>input</code>标签中，如<code>name=&quot;username&quot;</code></p>
<p><code>&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;</code></p>
<center>POST请求，请求报文中的请求参数，浏览器开发者工具查看</center>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210427222838580.png" alt="image-20210427222838580"></p>
<h5 id="1-服务端获取POST请求参数"><a href="#1-服务端获取POST请求参数" class="headerlink" title="1.服务端获取POST请求参数"></a>1.服务端获取POST请求参数</h5><p>POST请求参数通过request对象的事件接收</p>
<ul>
<li>data事件  当请求参数传递时触发(POST请求传递的数据理论上可以<strong>无限制</strong>，服务端可能需要<strong>分批接收</strong>)</li>
<li>end事件   当请求参数传递完毕时触发</li>
<li>request的data和end事件注册写在<strong>服务器的request请求事件中</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.on(<span class="string">&quot;request&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//创建变量接收POST请求参数</span></span><br><span class="line">    <span class="keyword">let</span> datasum=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">//data事件注册 params参数即为传来的参数</span></span><br><span class="line">    request.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//可能分批接收，所以使用+=接收所有数据</span></span><br><span class="line">        datasum+=params</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//end事件注册</span></span><br><span class="line">    request.on(<span class="string">&#x27;end&#x27;</span>,<span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(datasum);</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    response.end(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>将传来的数据在后台输出如下</center>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210427225303155.png" alt="image-20210427225303155"></p>
<br>

<h5 id="2-将获取的字符串格式的POST请求参数转换为对象格式"><a href="#2-将获取的字符串格式的POST请求参数转换为对象格式" class="headerlink" title="2.将获取的字符串格式的POST请求参数转换为对象格式"></a>2.将获取的字符串格式的POST请求参数转换为对象格式</h5><p>使用node系统模块<code>queryString</code>的<code>parse()</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入queryString模块转换请求参数格式</span></span><br><span class="line"><span class="keyword">const</span> queryString = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串格式的请求参数转换为对象格式并在后台输出</span></span><br><span class="line"><span class="comment">//此代码写在request对象的end事件中</span></span><br><span class="line"><span class="built_in">console</span>.log(queryString.parse(datasum));</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210427225733016.png" alt="image-20210427225733016"></p>
<h3 id="2-路由"><a href="#2-路由" class="headerlink" title="2.路由"></a>2.路由</h3><p>路由是指客户端<strong>请求地址</strong>与服务端<strong>程序代码</strong>的对应关系</p>
<p>简单来说即客户端请求什么，服务器响应什么</p>
<p>例如：</p>
<ul>
<li>客户端请求<code>http://localhost:3000/index.html</code>，服务端返回index.html</li>
<li>对于普不同的请求方式GET和POST，服务器也可以根据请求方式做出不同的响应</li>
</ul>
<h3 id="3-静态资源"><a href="#3-静态资源" class="headerlink" title="3.静态资源"></a>3.静态资源</h3><p>服务器端不需要处理，可以直接响应给客户端的资源被称为静态资源，例如CSS,JS,HTML文件</p>
<p>静态资源响应的例子：</p>
<p><strong>URL中的资源标识符不一定要写服务器端资源的路径</strong></p>
<ul>
<li>服务器端可以获取资源标识符后自己指定资源地址</li>
<li>此处就使用了字符串拼接<code>path.join</code>自己指定public文件夹下的静态资源</li>
</ul>
<br>

<p><strong>响应文件时需要在响应头中指定内容类型</strong><code>content-type</code></p>
<ul>
<li>在高级浏览器中即使不指定内容类型也可以正常解析文件，但一些浏览器可能发生错误</li>
<li>html文件通过<code>readFile()</code>方法获取，html文件中<strong>从外部引入的CSS等文件</strong>也是通过<code>readFile()</code>方法获取</li>
<li>在设置响应头中的<code>content-type</code>时，需要<strong>得知当前获取的文件类型</strong><ul>
<li>可以使用<strong>第三方模块mime</strong></li>
<li>mime模块的<code>getTaype(&quot;资源路径&quot;)</code>方法可以根据资源路径返回对应的文件类型</li>
<li>使用获取的文件类型设置<code>content-type</code></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> url=<span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">//引入第三方模块MIME 根据路径获取文件类型</span></span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">&#x27;mime&#x27;</span>)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//获取请求资源的标识符</span></span><br><span class="line">    <span class="keyword">let</span> pathname = url.parse(req.url).pathname</span><br><span class="line">    <span class="comment">//拼接路径</span></span><br><span class="line">    <span class="keyword">let</span> filepath = path.join(__dirname,<span class="string">&#x27;public&#x27;</span>+pathname)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> type = mime.getType(filepath)</span><br><span class="line">    <span class="comment">//获取对应文件</span></span><br><span class="line">    fs.readFile(filepath,<span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(err != <span class="literal">null</span>)&#123;</span><br><span class="line">            res.writeHead(<span class="number">404</span>,&#123;</span><br><span class="line">                <span class="string">&#x27;content-type&#x27;</span>:<span class="string">&#x27;text/plain;charset=utf-8&#x27;</span></span><br><span class="line">            &#125;)</span><br><span class="line">            res.end(<span class="string">&#x27;文件找不到&#x27;</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.writeHead(<span class="number">200</span>,&#123;</span><br><span class="line">                <span class="string">&#x27;content-type&#x27;</span>:type</span><br><span class="line">            &#125;)</span><br><span class="line">            res.end(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此处使用<code>http://localhost:3000/default.html</code>访问服务器的静态资源如下</p>
<ul>
<li>此处的URI：/default.html并不是资源在服务器路径</li>
<li>URI：统一资源<strong>标识符</strong></li>
<li>URL：统一资源<strong>定位符</strong></li>
</ul>
<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210428195929316.png" alt="image-20210428195929316"></p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>07-Vue脚手架</title>
    <url>/2021/04/26/07-Vue%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Vue脚手架"><a href="#Vue脚手架" class="headerlink" title="Vue脚手架"></a>Vue脚手架</h1><p><strong>Vue脚手架：快速生成Vue项目基础架构，是一个命令行工具</strong>，官网地址：<a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></p>
<p>安装<code>@vue/cli</code> npm包来使用Vue脚手架</p>
<p><code>npm install -g @vue/cli</code></p>
<p>最新版的<code>vue/cli</code>同时支持使用基于<strong>2.x版本</strong>的脚手架创建旧vue项目</p>
<h2 id="1-创建Vue项目"><a href="#1-创建Vue项目" class="headerlink" title="1.创建Vue项目"></a>1.创建Vue项目</h2><h3 id="创建时报错"><a href="#创建时报错" class="headerlink" title="创建时报错"></a>创建时报错</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">无法加载文件 C:\Users\Administrator\AppData\Roaming\npm\vue.ps1，因为在此系统中禁止执行脚本</span><br></pre></td></tr></table></figure>

<p>解决办法：</p>
<ul>
<li>管理员模式打开<code>powershall</code>，输入命令： <code>set-ExecutionPolicy RemoteSigned</code>，输入A后回车</li>
<li>更改执行策略后解决问题</li>
</ul>
<p><img data-src="/images/07-Vue%E8%84%9A%E6%89%8B%E6%9E%B6/1003225-20200428110453360-1648140217.png" alt="img"></p>
<h3 id="使用交互式命令行创建"><a href="#使用交互式命令行创建" class="headerlink" title="使用交互式命令行创建"></a>使用交互式命令行创建</h3><ol>
<li>在要创建的目录下输入命令 <code>vue create &#39;项目名称&#39;</code></li>
</ol>
<ul>
<li><p><span style="color:red">创建的项目默认带Git仓库，通过<code>vue create &#39;项目名称&#39; -n</code>创建不带Git仓库的本地调试项目</span></p>
</li>
<li><p>项目名称全英文、不能包含特殊字符<code>(&#39;_&#39;,&#39;-&#39;除外)</code></p>
</li>
</ul>
<br>

<ol start="2">
<li>输入命令后显示选择界面，选择<strong>手动选择插件</strong>还是<strong>自动安装</strong></li>
</ol>
<ul>
<li><p>此处选择手动选择，使用键盘 <strong>上下键切换</strong>，<strong>回车选择</strong></p>
</li>
<li><p><img data-src="/images/07-Vue%E8%84%9A%E6%89%8B%E6%9E%B6/image-20211018163250984.png" alt="image-20211018163250984"></p>
</li>
</ul>
<br>

<ol start="3">
<li>进行一系列选择</li>
</ol>
<ul>
<li><p><img data-src="/images/07-Vue%E8%84%9A%E6%89%8B%E6%9E%B6/image-20211018163346987.png" alt="image-20211018163346987"></p>
<ul>
<li>选择安装的模块，此处选择<code>babel，router(vue-router)，和Linter</code><ul>
<li>babel：将新版本js代码转换为兼容性的旧版代码</li>
<li>router：vue路由模块</li>
<li>Linter：代码规则校验</li>
</ul>
</li>
<li>使用<strong>空格选中</strong></li>
</ul>
</li>
<li><p><img data-src="/images/07-Vue%E8%84%9A%E6%89%8B%E6%9E%B6/image-20211018165313274.png" alt="image-20211018165313274"></p>
<ul>
<li>是否使用历史进行路由？此处<strong>选择否，我们使用hash进行前端路由</strong></li>
</ul>
</li>
<li><p><img data-src="/images/07-Vue%E8%84%9A%E6%89%8B%E6%9E%B6/image-20211018163522904.png" alt="image-20211018163522904"></p>
<ul>
<li>选择ESLint语法版本，此处选择标准配置</li>
</ul>
</li>
<li><p><img data-src="/images/07-Vue%E8%84%9A%E6%89%8B%E6%9E%B6/image-20211018163556552.png" alt="image-20211018163556552"></p>
<ul>
<li>选择ESLint语法校验的时间，选择默认值</li>
</ul>
</li>
<li><p><img data-src="/images/07-Vue%E8%84%9A%E6%89%8B%E6%9E%B6/image-20211018163623801.png" alt="image-20211018163623801"></p>
<ul>
<li>Babel，postCSS等模块的配置文件<strong>是单独创建</strong>还是<strong>整合到package.json中</strong></li>
</ul>
</li>
<li><p><img data-src="/images/07-Vue%E8%84%9A%E6%89%8B%E6%9E%B6/image-20211018163708307.png" alt="image-20211018163708307"></p>
<ul>
<li>选择是否将此次手动配置保存为模板供下次创建使用</li>
</ul>
</li>
</ul>
<br>

<ol start="4">
<li>选择完毕</li>
</ol>
<p><img data-src="/images/07-Vue%E8%84%9A%E6%89%8B%E6%9E%B6/image-20211018163822933.png" alt="image-20211018163822933"></p>
<ul>
<li><p>项目创建完毕提示可以cd到目录下运行serve命令查看效果</p>
</li>
<li><p>运行serve命令时自动使用webpack进行打包并打开http服务器供预览</p>
<ul>
<li><img data-src="/images/07-Vue%E8%84%9A%E6%89%8B%E6%9E%B6/image-20211018163953445.png" alt="image-20211018163953445"></li>
</ul>
</li>
<li><p>使用Local给出的URL进行预览</p>
<ul>
<li><img data-src="/images/07-Vue%E8%84%9A%E6%89%8B%E6%9E%B6/image-20211018164018046.png" alt="image-20211018164018046"></li>
</ul>
</li>
</ul>
<br>

<h3 id="使用图形化界面创建"><a href="#使用图形化界面创建" class="headerlink" title="使用图形化界面创建"></a>使用图形化界面创建</h3><p>上面使用命令行的方式创建项目时并不友好</p>
<p>可以使用 <code>vue ui</code>在可视化图形界面中创建项目</p>
<p>运行<code>vue ui</code> </p>
<p>会<strong>自动打开浏览器</strong>，在浏览器页面中进行项目的创建</p>
<p><img data-src="/images/07-Vue%E8%84%9A%E6%89%8B%E6%9E%B6/image-20211018164823762.png" alt="image-20211018164823762"></p>
<ul>
<li>页面中还可以<strong>管理所有使用图形化界面创建的vue项目</strong></li>
<li>可以通过点击页面中的按钮，进行<strong>开发环境下项目的打包调试</strong>，或者<strong>进行生产环境下的打包</strong></li>
<li>包括模块管理等一些列操作都可以在图形化的页面中完成</li>
</ul>
<br>

<h3 id="创建基于Vue2-x版本的旧vue项目"><a href="#创建基于Vue2-x版本的旧vue项目" class="headerlink" title="创建基于Vue2.x版本的旧vue项目"></a>创建基于Vue2.x版本的旧vue项目</h3><ol>
<li>安装<code>@vue/cli-init</code>模块</li>
</ol>
<ul>
<li><code>npm install @vue/cli-init -g</code></li>
</ul>
<ol start="2">
<li>使用 <code>vue init webpack &#39;项目名称&#39;</code>命令创建项目</li>
</ol>
<ul>
<li>在命令行中进行一系列配置后创建旧版项目</li>
</ul>
<br>

<h2 id="2-Vue脚手架生成项目的结构"><a href="#2-Vue脚手架生成项目的结构" class="headerlink" title="2.Vue脚手架生成项目的结构"></a>2.Vue脚手架生成项目的结构</h2><p><img data-src="/images/07-Vue%E8%84%9A%E6%89%8B%E6%9E%B6/image-20211018170612668.png" alt="image-20211018170612668"></p>
<ul>
<li>还有一些<strong>插件的配置文件</strong>如babel，postCSS的配置文件</li>
<li>src为源代码目录（程序员写的代码存放目录）</li>
</ul>
<p><img data-src="/images/07-Vue%E8%84%9A%E6%89%8B%E6%9E%B6/image-20211018170733578.png" alt="image-20211018170733578"></p>
<p>src目录下：</p>
<ul>
<li>assets：资源（样式表，图片等）</li>
<li>components：组件</li>
<li>router：路由配置文件</li>
<li>views：视图文件</li>
<li>App.vue：<strong>项目根组件</strong></li>
<li>main.js：项目使用webpack<strong>打包时的入口文件</strong></li>
</ul>
<br>

<h2 id="3-自定义Vue项目配置"><a href="#3-自定义Vue项目配置" class="headerlink" title="3.自定义Vue项目配置"></a>3.自定义Vue项目配置</h2><p>创建项目时，已经预先定义好了许多配置</p>
<p>可以在<code>vue.config.js</code>文件进行自定义配置</p>
<ul>
<li><code>vue.config.js</code>文件不存在时<strong>自行创建</strong></li>
</ul>
<p><img data-src="/images/07-Vue%E8%84%9A%E6%89%8B%E6%9E%B6/image-20211018181245894.png" alt="image-20211018181245894"></p>
<p><img data-src="/images/07-Vue%E8%84%9A%E6%89%8B%E6%9E%B6/image-20211018181252820.png" alt="image-20211018181252820"></p>
<ul>
<li>对devServer模块<strong>修改默认打开的端口号</strong>，设置<strong>打包完后自动打开浏览器访问服务器</strong></li>
</ul>
<p><img data-src="/images/07-Vue%E8%84%9A%E6%89%8B%E6%9E%B6/image-20220411155148802.png" alt="image-20220411155148802"></p>
<ul>
<li>关闭<code>eslint</code>验证，eslint<strong>对于一些警告会直接报错</strong>。</li>
</ul>
<h1 id="遇见的问题"><a href="#遇见的问题" class="headerlink" title="遇见的问题"></a>遇见的问题</h1><h2 id="App-vue文件报错"><a href="#App-vue文件报错" class="headerlink" title="App.vue文件报错"></a>App.vue文件报错</h2><p><img data-src="/images/07-Vue%E8%84%9A%E6%89%8B%E6%9E%B6/image-20211018184816579.png" alt="image-20211018184816579"></p>
<p>上图红框报错称template字段下的内容必须放在一个根元素中</p>
<p><strong>解决办法：</strong></p>
<ol>
<li>在<code>vscode</code>的设置中搜索<code>eslint</code></li>
</ol>
<p><img data-src="/images/07-Vue%E8%84%9A%E6%89%8B%E6%9E%B6/image-20211018185034967.png" alt="image-20211018185034967"></p>
<ol start="2">
<li>将上图红框选项的对勾去掉</li>
</ol>
<br>

<p><strong>原理：</strong><code>vscode</code>安装了<code>Vetur</code> 插件，它在检测 <code>vue-html</code> 模板时，使用了 <code>eslint-plugin-vue</code> 插件。</p>
<br>

<h2 id="vue单文件组件中注释的问题"><a href="#vue单文件组件中注释的问题" class="headerlink" title="vue单文件组件中注释的问题"></a>vue单文件组件中注释的问题</h2><p><img data-src="/images/07-Vue%E8%84%9A%E6%89%8B%E6%9E%B6/image-20211018224911354.png" alt="image-20211018224911354"></p>
<ul>
<li>对象键值前<strong>必须有空格</strong></li>
<li>注释// 后<strong>必须有一个空格</strong>或者<strong>tab缩进</strong></li>
<li><code>&#39;,&#39;</code>后<strong>不能有多余空格</strong></li>
<li>注释最后<strong>不能有多余空格</strong></li>
</ul>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>发表评论案例</title>
    <url>/2022/11/27/07-%E5%8F%91%E8%A1%A8%E8%AF%84%E8%AE%BA%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="发表评论案例"><a href="#发表评论案例" class="headerlink" title="发表评论案例"></a>发表评论案例</h1><p><img data-src="/images/Untitled/image-20220402221204295.png" alt="image-20220402221204295"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>()</span><br><span class="line">        <span class="comment">// 状态初始化</span></span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            comment: [],</span><br><span class="line">            name: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            val: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发表评论</span></span><br><span class="line">    handelComment = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//空提示</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">this</span>.state.name.trim() === <span class="string">&#x27;&#x27;</span> || <span class="built_in">this</span>.state.val.trim() === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> alert(<span class="string">&#x27;请输入评论人或内容&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="built_in">this</span>.state.comment</span><br><span class="line">        res.unshift(&#123; <span class="attr">name</span>: <span class="built_in">this</span>.state.name, <span class="attr">val</span>: <span class="built_in">this</span>.state.val &#125;)</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            comment: res,</span><br><span class="line">            <span class="comment">//提交后置空</span></span><br><span class="line">            name:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            val:<span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表单元素修改</span></span><br><span class="line">    change = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> value = e.target.type === <span class="string">&#x27;checkbox&#x27;</span> ? e.target.checked : e.target.value</span><br><span class="line">        <span class="keyword">let</span> name = e.target.name</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">            [name]: value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//条件渲染</span></span><br><span class="line">    isEmpty = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.state.comment.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span>&#x27;#<span class="attr">9a9a9a</span>&#x27;&#125;&#125;&gt;</span>暂无评论<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &lt;ul&gt;</span><br><span class="line">            &#123;<span class="built_in">this</span>.state.comment.map(<span class="function"><span class="params">item</span> =&gt;</span></span><br><span class="line">                &lt;li key=<span class="string">&#x27;index&#x27;</span> style=&#123;&#123; <span class="attr">width</span>: <span class="string">&#x27;300px&#x27;</span> &#125;&#125;&gt;</span><br><span class="line">                    &lt;div&gt;评论人：&#123;item.name&#125;&lt;/div&gt;</span><br><span class="line">                    &lt;div&gt;评论内容：&#123;item.val&#125;&lt;/div&gt;</span><br><span class="line">                    &lt;hr/&gt;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">            )&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;container&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> &#x27;<span class="attr">200px</span>&#x27; &#125;&#125; <span class="attr">placeholder</span>=<span class="string">&#x27;请输入评论人&#x27;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.name&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.change&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">className</span>=<span class="string">&#x27;textArea&#x27;</span> <span class="attr">placeholder</span>=<span class="string">&#x27;请输入评论内容&#x27;</span> <span class="attr">name</span>=<span class="string">&quot;val&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.val&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.change&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handelComment&#125;</span>&gt;</span>发表评论<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#123;/* 条件渲染 */&#125;</span></span><br><span class="line"><span class="xml">            &#123; this.isEmpty() &#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>Hello组件代码</center>

<span id="more"></span>

<h2 id="1-表单元素改造为受控组件"><a href="#1-表单元素改造为受控组件" class="headerlink" title="1.表单元素改造为受控组件"></a>1.表单元素改造为受控组件</h2><h2 id="2-有无评论的条件渲染"><a href="#2-有无评论的条件渲染" class="headerlink" title="2.有无评论的条件渲染"></a>2.有无评论的条件渲染</h2><h2 id="3-评论的列表渲染"><a href="#3-评论的列表渲染" class="headerlink" title="3.评论的列表渲染"></a>3.评论的列表渲染</h2><p>注意条件渲染的key值，此处应使用<strong>随机数id替代index</strong></p>
<h2 id="4-改进优化"><a href="#4-改进优化" class="headerlink" title="4.改进优化"></a>4.改进优化</h2><ul>
<li>提交时判空(<code>trim()</code>删去空格)</li>
<li>提交后重置表单</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>网络数据请求</title>
    <url>/2022/11/27/07-%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h1 id="网络数据请求"><a href="#网络数据请求" class="headerlink" title="网络数据请求"></a>网络数据请求</h1><h2 id="1-两个限制"><a href="#1-两个限制" class="headerlink" title="1.两个限制"></a>1.两个限制</h2><p><img data-src="/images/07-%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/image-20220210163140820.png" alt="image-20220210163140820"></p>
<p><strong>只能向配置的合法域名发起请求</strong></p>
<span id="more"></span>

<h2 id="2-配置request合法域名"><a href="#2-配置request合法域名" class="headerlink" title="2.配置request合法域名"></a>2.配置request合法域名</h2><p>在<strong>小程序网页后台</strong>进行合法域名的配置</p>
<p><img data-src="/images/07-%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/image-20220210163926678.png" alt="image-20220210163926678"></p>
<p><img data-src="/images/07-%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/image-20220210163640146.png" alt="image-20220210163640146"></p>
<h2 id="3-发起GET请求"><a href="#3-发起GET请求" class="headerlink" title="3.发起GET请求"></a>3.发起GET请求</h2><p>button按钮触摸事件处理函数中调用<code>wx.request</code>方法发起请求</p>
<p><code>wx</code>是微信小程序的顶级对象，类似于浏览器的<code>window</code></p>
<p><img data-src="/images/07-%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/image-20220210164629537.png" alt="image-20220210164629537"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">          url: <span class="string">&#x27;https://www.escook.cn/api/get&#x27;</span>,</span><br><span class="line">          method:<span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    		<span class="comment">//发送的数据</span></span><br><span class="line">          data: &#123;</span><br><span class="line">            name:<span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">            age:<span class="number">20</span></span><br><span class="line">          &#125;,</span><br><span class="line">    		<span class="comment">//回调函数处理响应</span></span><br><span class="line">          success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res.data);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/07-%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/image-20220210164713729.png" alt="image-20220210164713729"></p>
<h2 id="4-发起POST请求"><a href="#4-发起POST请求" class="headerlink" title="4.发起POST请求"></a>4.发起POST请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">            url: <span class="string">&#x27;https://www.escook.cn/api/post&#x27;</span>,</span><br><span class="line">            method:<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">              name:<span class="string">&#x27;ls&#x27;</span>,</span><br><span class="line">              age:<span class="number">30</span></span><br><span class="line">            &#125;,</span><br><span class="line">            success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(res.data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="5-在页面刚加载时发起请求"><a href="#5-在页面刚加载时发起请求" class="headerlink" title="5.在页面刚加载时发起请求"></a>5.在页面刚加载时发起请求</h2><p><img data-src="/images/07-%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/image-20220210164814938.png" alt="image-20220210164814938"></p>
<p>在页面刚加载时发送GET和POST测试请求</p>
<p>this为当前页面的实例</p>
<p><img data-src="/images/07-%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/image-20220210164846994.png" alt="image-20220210164846994"></p>
<h2 id="6-跳过request合法域名校验"><a href="#6-跳过request合法域名校验" class="headerlink" title="6.跳过request合法域名校验"></a>6.跳过request合法域名校验</h2><p><img data-src="/images/07-%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/image-20220210165457122.png" alt="image-20220210165457122"></p>
<h2 id="7-微信小程序的跨域和ajax说明"><a href="#7-微信小程序的跨域和ajax说明" class="headerlink" title="7.微信小程序的跨域和ajax说明"></a>7.微信小程序的跨域和<code>ajax</code>说明</h2><p><img data-src="/images/07-%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/image-20220210165511042.png" alt="image-20220210165511042"></p>
<ul>
<li>小程序不存在跨域问题</li>
<li>小程序中不能叫 ‘ajax请求’ ，叫做 ‘发起网络数据请求’</li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>08-Element-UI</title>
    <url>/2021/04/26/08-Element-UI/</url>
    <content><![CDATA[<h1 id="Element-UI"><a href="#Element-UI" class="headerlink" title="Element-UI"></a>Element-UI</h1><p><strong>Element-UI</strong>：一套为开发者、设计师和产品经理准备的<strong>基于 vue2.0</strong> 的桌面<strong>组件(component)库</strong></p>
<p><strong>Element-Plus</strong>：~基于<strong>vue3.0</strong>的组件库</p>
<p>使用它可以让程序员<strong>专注于项目的业务逻辑</strong>，省下了<strong>美化样式</strong>的工作量</p>
<p>官网:<a href="https://element.eleme.cn/#/zh-CN">https://element.eleme.cn/#/zh-CN</a></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="基于命令行手动安装Element-ui-vue2-0"><a href="#基于命令行手动安装Element-ui-vue2-0" class="headerlink" title="基于命令行手动安装Element-ui (vue2.0)"></a>基于命令行手动安装Element-ui (vue2.0)</h3><p><img data-src="/images/08-ElementUI/image-20211018182205249.png" alt="image-20211018182205249"></p>
<ul>
<li>在项目根目录下安装依赖包</li>
<li>在项目的<code>main.js</code>文件中导入相关资源<ul>
<li>组件相关样式需要单独导入</li>
</ul>
</li>
<li><img data-src="/images/08-Element-UI/image-20211018203919396.png" alt="image-20211018203919396"></li>
<li>在Element-UI官网找到写好的组件代码复制<ul>
<li>此处复制一段按钮的组件代码</li>
<li><img data-src="/images/08-Element-UI/image-20211018195954182.png" alt="image-20211018195954182"></li>
</ul>
</li>
<li>添加到vue单文件组件App.vue中<ul>
<li><img data-src="/images/08-Element-UI/image-20211018200025498.png" alt="image-20211018200025498"></li>
</ul>
</li>
<li>重新执行serve命令查看效果<ul>
<li><img data-src="/images/08-Element-UI/image-20211018200107055.png" alt="image-20211018200107055"></li>
</ul>
</li>
</ul>
<h3 id="基于命令行手动安装Element-Plus-vue3-0"><a href="#基于命令行手动安装Element-Plus-vue3-0" class="headerlink" title="基于命令行手动安装Element-Plus (vue3.0)"></a>基于命令行手动安装Element-Plus (vue3.0)</h3><p><span style="color:red">vue3.0下不能使用Element-ui，要使用Element-Plus</span></p>
<ol>
<li>安装依赖包</li>
</ol>
<ul>
<li><code>npm install element-plus - S</code></li>
</ul>
<ol start="2">
<li>在main.js文件中进行配置</li>
</ol>
<ul>
<li><img data-src="/images/08-Element-UI/image-20211018193314806.png" alt="image-20211018193314806"></li>
</ul>
<br>

<h3 id="基于图形化界面安装Element-UI"><a href="#基于图形化界面安装Element-UI" class="headerlink" title="基于图形化界面安装Element-UI"></a>基于图形化界面安装Element-UI</h3><p><img data-src="/images/08-Element-UI/image-20211018203237157.png" alt="image-20211018203237157"></p>
<ul>
<li>查找插件</li>
</ul>
<p><img data-src="/images/08-Element-UI/image-20211018203325896.png" alt="image-20211018203325896"></p>
<ul>
<li>配置插件按需导入<ul>
<li>红框为按需导入</li>
<li>默认为全部导入(导致项目体积大)</li>
</ul>
</li>
</ul>
<p><img data-src="/images/08-Element-UI/image-20211018203411857.png" alt="image-20211018203411857"></p>
<ul>
<li>测试效果</li>
</ul>
<p><img data-src="/images/08-Element-UI/image-20211018203530367.png" alt="image-20211018203530367"></p>
<p><img data-src="/images/08-Element-UI/image-20211018203544494.png" alt="image-20211018203544494"></p>
<p><img data-src="/images/08-Element-UI/image-20211018203556821.png" alt="image-20211018203556821"></p>
<p><img data-src="/images/08-Element-UI/image-20211018203606279.png" alt="image-20211018203606279"></p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>08-Vue后台管理路由案例</title>
    <url>/2021/09/20/08-Vue%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E8%B7%AF%E7%94%B1%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="Vue后台管理路由案例"><a href="#Vue后台管理路由案例" class="headerlink" title="Vue后台管理路由案例"></a>Vue后台管理路由案例</h1><h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><p><img data-src="/images/08-Vue/image-20210926215440605.png" alt="image-20210926215440605"></p>
<center>图一</center>

<center>图一为项目的效果图</center>

<span id="more"></span>

<ul>
<li>项目分为上中下三部分</li>
<li>中间部分<strong>通过左侧按钮进行路由跳转</strong></li>
<li>路由跳转后渲染的模板中还有详情<strong>子级路由</strong></li>
<li>子级路由对应组件渲染详情页面</li>
</ul>
<br>

<h2 id="1-抽离渲染app根组件"><a href="#1-抽离渲染app根组件" class="headerlink" title="1. 抽离渲染app根组件"></a>1. 抽离渲染app根组件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 中间主体区域 --&gt;</span><br><span class="line">       &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">           &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主体部分模板</span></span><br><span class="line"><span class="keyword">var</span> main = &#123;</span><br><span class="line">           template: <span class="string">`</span></span><br><span class="line"><span class="string">           &lt;div class=&quot;main&quot;&gt;</span></span><br><span class="line"><span class="string">               &lt;!-- 左侧菜单栏 --&gt;</span></span><br><span class="line"><span class="string">               &lt;div class=&quot;content left&quot;&gt;</span></span><br><span class="line"><span class="string">               &lt;ul&gt;</span></span><br><span class="line"><span class="string">                   &lt;li&gt;用户管理&lt;/li&gt;</span></span><br><span class="line"><span class="string">                   &lt;li&gt;权限管理&lt;/li&gt;</span></span><br><span class="line"><span class="string">                   &lt;li&gt;商品管理&lt;/li&gt;</span></span><br><span class="line"><span class="string">                   &lt;li&gt;订单管理&lt;/li&gt;</span></span><br><span class="line"><span class="string">                   &lt;li&gt;系统设置&lt;/li&gt;</span></span><br><span class="line"><span class="string">               &lt;/ul&gt;</span></span><br><span class="line"><span class="string">               &lt;/div&gt;</span></span><br><span class="line"><span class="string">               &lt;!-- 右侧内容区域 --&gt;</span></span><br><span class="line"><span class="string">               &lt;div class=&quot;content right&quot;&gt;&lt;div class=&quot;main-content&quot;&gt;添加用户表单&lt;/div&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">           &lt;/div&gt;`</span></span><br><span class="line">       &#125;</span><br><span class="line">   	<span class="comment">//创建路由实例配置规则</span></span><br><span class="line">       <span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">           routes:[&#123;</span><br><span class="line">               path:<span class="string">&#x27;/&#x27;</span>,<span class="attr">component</span>:main</span><br><span class="line">           &#125;]</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>当用户打开页面时默认hash为<code>/</code>，根据路由规则匹配渲染main组件中的模板</li>
</ul>
<br>

<h2 id="2-主体部分左侧菜单改造为路由链接"><a href="#2-主体部分左侧菜单改造为路由链接" class="headerlink" title="2. 主体部分左侧菜单改造为路由链接"></a>2. 主体部分左侧菜单改造为路由链接</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&#x27;/users&#x27;</span>&gt;</span>用户管理<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&#x27;/rights&#x27;</span>&gt;</span>权限管理<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&#x27;/goods&#x27;</span>&gt;</span>商品管理<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&#x27;/orders&#x27;</span>&gt;</span>订单管理<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&#x27;/settings&#x27;</span>&gt;</span>系统设置<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-左侧菜单创建路由组件"><a href="#3-左侧菜单创建路由组件" class="headerlink" title="3. 左侧菜单创建路由组件"></a>3. 左侧菜单创建路由组件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> User = &#123;</span><br><span class="line">            template:<span class="string">`&lt;div&gt;&lt;h3&gt;用户管理&lt;/h3&gt;&lt;/div&gt;`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> Right = &#123;</span><br><span class="line">            template:<span class="string">`&lt;div&gt;&lt;h3&gt;权限管理&lt;/h3&gt;&lt;/div&gt;`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> Good = &#123;</span><br><span class="line">            template:<span class="string">`&lt;div&gt;&lt;h3&gt;商品管理&lt;/h3&gt;&lt;/div&gt;`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> Order = &#123;</span><br><span class="line">            template:<span class="string">`&lt;div&gt;&lt;h3&gt;订单管理&lt;/h3&gt;&lt;/div&gt;`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> Setting = &#123;</span><br><span class="line">            template:<span class="string">`&lt;div&gt;&lt;h3&gt;系统设置&lt;/h3&gt;&lt;/div&gt;`</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-右侧主体内容添加路由占位符"><a href="#4-右侧主体内容添加路由占位符" class="headerlink" title="4. 右侧主体内容添加路由占位符"></a>4. 右侧主体内容添加路由占位符</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 右侧内容区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content right&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main-content&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">routes:[&#123;</span><br><span class="line">    //左侧菜单的路由为/的子级路由</span><br><span class="line">    path:&#x27;/&#x27;,component:main,children:[&#123;</span><br><span class="line">    	path:&#x27;/users&#x27;,component:User</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">    	path:&#x27;/rights&#x27;,component:Right</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">    	path:&#x27;/goods&#x27;,component:Good</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">    	path:&#x27;/orders&#x27;,component:Order</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">    	path:&#x27;/settings&#x27;,component:Setting</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<ul>
<li>左侧菜单的四个路由<code>/user ... /settings</code>为<code>/</code>路由的<strong>子路由</strong></li>
<li>路由规则定义在<code>/</code>路由规则的<strong>children属性中</strong></li>
</ul>
<p>main组件作为<strong>根组件app</strong>的子组件</p>
<p>左侧菜单的四个路由组件作为<strong>main组件</strong>的子组件</p>
<br>

<h2 id="5-设置默认路由重定向"><a href="#5-设置默认路由重定向" class="headerlink" title="5. 设置默认路由重定向"></a>5. 设置默认路由重定向</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">routes:[&#123;</span><br><span class="line">            path:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">            <span class="comment">//路由重定向到用户管理</span></span><br><span class="line">            redirect:<span class="string">&#x27;/users&#x27;</span>,</span><br><span class="line">            component:main,</span><br><span class="line">            children:...</span><br></pre></td></tr></table></figure>

<h2 id="6-渲染用户列表数据"><a href="#6-渲染用户列表数据" class="headerlink" title="6. 渲染用户列表数据"></a>6. 渲染用户列表数据</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="comment">//用户列表数据</span></span><br><span class="line">                    list:[</span><br><span class="line">                        &#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">&#x27;y1&#x27;</span>,<span class="attr">age</span>:<span class="number">10</span>&#125;,</span><br><span class="line">                        &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">&#x27;y2&#x27;</span>,<span class="attr">age</span>:<span class="number">10</span>&#125;,</span><br><span class="line">                        &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:<span class="string">&#x27;y3&#x27;</span>,<span class="attr">age</span>:<span class="number">10</span>&#125;,</span><br><span class="line">                        &#123;<span class="attr">id</span>:<span class="number">4</span>,<span class="attr">name</span>:<span class="string">&#x27;y4&#x27;</span>,<span class="attr">age</span>:<span class="number">10</span>&#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            template:<span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">                        &lt;h3&gt;用户管理&lt;/h3&gt;</span></span><br><span class="line"><span class="string">                        &lt;table&gt;</span></span><br><span class="line"><span class="string">                            &lt;thead&gt;</span></span><br><span class="line"><span class="string">                                &lt;tr&gt;</span></span><br><span class="line"><span class="string">                                    &lt;th&gt;编号&lt;/th&gt;</span></span><br><span class="line"><span class="string">                                    &lt;th&gt;姓名&lt;/th&gt;</span></span><br><span class="line"><span class="string">                                    &lt;th&gt;年龄&lt;/th&gt;</span></span><br><span class="line"><span class="string">                                    &lt;th&gt;操作&lt;/th&gt;</span></span><br><span class="line"><span class="string">                                &lt;/tr&gt;   </span></span><br><span class="line"><span class="string">                            &lt;/thead&gt;</span></span><br><span class="line"><span class="string">                            &lt;tbody&gt;</span></span><br><span class="line"><span class="string">								//循环生成用户数据表格</span></span><br><span class="line"><span class="string">                                &lt;tr v-for=&#x27;item in list&#x27;&gt;</span></span><br><span class="line"><span class="string">                                    &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;</span></span><br><span class="line"><span class="string">                                    &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;</span></span><br><span class="line"><span class="string">                                    &lt;td&gt;&#123;&#123;item.age&#125;&#125;&lt;/td&gt;</span></span><br><span class="line"><span class="string">                                    &lt;td&gt;&lt;a href=&quot;javascript:;&quot;&gt;修改&lt;/a&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">                                &lt;/tr&gt;</span></span><br><span class="line"><span class="string">                            &lt;/tbody&gt;    </span></span><br><span class="line"><span class="string">                        &lt;/table&gt;</span></span><br><span class="line"><span class="string">                    &lt;/div&gt;`</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在User路由组件中<strong>定义用户列表数据数组</strong></li>
<li>在User路由组件template中<strong>利用循环生成用户列表数据表格</strong></li>
</ul>
<h2 id="7-编程式导航跳转到用户详情页"><a href="#7-编程式导航跳转到用户详情页" class="headerlink" title="7. 编程式导航跳转到用户详情页"></a>7. 编程式导航跳转到用户详情页</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &lt;td&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span> @<span class="attr">click</span>=<span class="string">&#x27;change(item.id)&#x27;</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/td&gt;</span><br><span class="line">     </span><br><span class="line">change:<span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">                    <span class="comment">//编程式导航 路由跳转 传递id参数</span></span><br><span class="line">                    <span class="built_in">this</span>.$router.push(<span class="string">&#x27;/userinfo/&#x27;</span>+id)</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>表格中的修改超链接被点击后触发change事件并<strong>传递当前数据的id</strong></li>
<li>编程式导航跳转带上id参数</li>
</ul>
<h2 id="8-在用户详情页使用编程式导航回退到上一页"><a href="#8-在用户详情页使用编程式导航回退到上一页" class="headerlink" title="8. 在用户详情页使用编程式导航回退到上一页"></a>8. 在用户详情页使用编程式导航回退到上一页</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&#x27;back&#x27;</span>&gt;返回上一页&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">back:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.$router.go(-<span class="number">1</span>)</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>Userinfo</code>组件的template模板中创建button实现回退</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>08-node中的同步异步API</title>
    <url>/2021/04/28/08-node%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5API/</url>
    <content><![CDATA[<h1 id="node中的同步和异步API"><a href="#node中的同步和异步API" class="headerlink" title="node中的同步和异步API"></a>node中的同步和异步API</h1><p>nodejs中的API，拿到他们执行结果的方式有两种</p>
<ul>
<li>通过<strong>返回值</strong>的方式得到API执行结果<ul>
<li>比如<code>path.join()</code>等API</li>
</ul>
</li>
<li>通过<strong>函数</strong>的方式得到API执行结果<ul>
<li>比如<code>fs.readFile()</code> API，这个API执行的结果在其第二个参数<strong>回调函数中的data参数中</strong></li>
</ul>
</li>
</ul>
<span id="more"></span>

<br>

<p>由此引出同步和异步API</p>
<ul>
<li><strong>同步API</strong>：按顺序执行，只有上一个API执行完毕，下一个API才开始执行</li>
<li><strong>异步API</strong>：异步API的执行不会阻塞后续其他代码的执行 ，<strong>async</strong>即为异步</li>
</ul>
<p>例如下面这段代码执行结果为先输出before，再输出after，等待2s后再输出last</p>
<p>这里的<code>setTimeout()</code> API就是异步API，不会阻塞后续代码执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;before&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;last&#x27;</span>)</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;after&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="同步异步API的区别"><a href="#同步异步API的区别" class="headerlink" title="同步异步API的区别"></a>同步异步API的区别</h2><h3 id="1-获取执行结果"><a href="#1-获取执行结果" class="headerlink" title="1.获取执行结果"></a>1.获取执行结果</h3><ul>
<li><p>同步API可以通过<strong>返回值</strong>拿到API执行的结果</p>
</li>
<li><p>异步API不能通过返回值拿到API执行结果，可以通过<strong>回调函数的方式</strong>得到执行结果</p>
</li>
</ul>
<p><strong>同步API</strong></p>
<p>通过返回值拿到结果 30</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> datasum = sum(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="comment">//输出30</span></span><br><span class="line"><span class="built_in">console</span>.log(datasum);</span><br></pre></td></tr></table></figure>

<p><strong>异步API</strong></p>
<p>res输出为undefined</p>
<p>执行到定时器时因为定时器为异步API，不会阻塞下面代码的执行，所以早在2s前，msg函数就已经默认返回undefined，此时res输出为undefined，而2s后定时器中的函数才执行</p>
<p>异步API的执行结果<strong>不能通过返回值得到</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">msg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">name</span>:<span class="string">&quot;yang&quot;</span>&#125;</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = msg()</span><br><span class="line"><span class="comment">//输出undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure>

<br>

<p><strong>异步API的执行结果可以通过回调函数得到</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">msg</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        callback(&#123;<span class="attr">name</span>:<span class="string">&quot;yang&quot;</span>&#125;) </span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//输出对象&#123;name:&#x27;yang&#x27;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过给msg函数使用回调函数将异步API的执行结果作为参数传递给回调函数，然后在回调函数中处理异步API的结果</p>
<br>

<h3 id="2-执行顺序"><a href="#2-执行顺序" class="headerlink" title="2.执行顺序"></a>2.执行顺序</h3><p><strong>同步API</strong></p>
<p>同步API按代码编写顺序执行，上一个API执行完毕，下一个API才开始执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;循环后代码&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>对于上述代码，由于是同步API，会先输出0-99999这100000个数字，然后再输出”循环后代码”</p>
<p><strong>异步API</strong></p>
<p>异步API不会阻塞后续代码执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;开始&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;2s&quot;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;0s&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;结束&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>对于上述代码，两个定时器为异步API，不会阻塞后续代码执行</p>
<p>最后结果为：</p>
<ul>
<li><p>“开始”</p>
</li>
<li><p>“结束”</p>
</li>
<li><p>“0s”</p>
</li>
<li><p>“2s”</p>
</li>
</ul>
<p><strong>异步API执行机制</strong>：</p>
<ul>
<li><p>首先执行所有的同步代码，碰到异步代码就先放入<strong>异步任务队列</strong>中(只放入，不执行)</p>
</li>
<li><p>当所有同步代码执行完毕后，开始执行异步任务队列中的异步代码</p>
<ul>
<li>在此处例子中，执行异步代码创建两个定时器，一个定时0s，一个定时2s，并将他们的回调函数放入<strong>回调函数队列</strong>中等待执行</li>
</ul>
</li>
<li><p>异步代码执行完毕后进入回调函数队列，待满足条件时将回调函数队列中的回调函数<strong>调入同步代码执行区</strong>执行</p>
<ul>
<li>经过0s时执行0s定时器的回调函数先输出”0s”</li>
<li>经过2s时再执行2s定时器的回调函数再输出”2s”</li>
</ul>
</li>
<li><p>接着执行<strong>事件循环(eventloop)机制</strong>：循环等待直到有新的异步任务添加到异步任务队列中时，继续执行异步代码</p>
</li>
</ul>
<p><img data-src="/images/08-node%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5API/image-20210428213248420.png" alt="image-20210428213248420"></p>
<h2 id="nodejs中的常见异步API"><a href="#nodejs中的常见异步API" class="headerlink" title="nodejs中的常见异步API"></a>nodejs中的常见异步API</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打开文件是异步API</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;./demo.txt&#x27;</span>,<span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//事件处理函数也是异步API</span></span><br><span class="line"><span class="keyword">var</span> server = http.creatServer();</span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>上述两个异步API执行的结果只能通过<strong>回调函数</strong>获取</p>
<p>异步API不会阻塞后续代码的执行</p>
<br>

<h2 id="后续代码需要使用前面异步API的执行结果"><a href="#后续代码需要使用前面异步API的执行结果" class="headerlink" title="后续代码需要使用前面异步API的执行结果"></a>后续代码需要使用前面异步API的执行结果</h2><p>如果异步API后面代码的执行需要使用前面异步API的结果，但是实际后续代码执行时前面的异步API还没有执行，如何解决这个问题?</p>
<ul>
<li>可以将<strong>后续代码写在异步API的回调函数中</strong></li>
</ul>
<p>例如：需要依次打开三个文件，可以使用回调函数嵌套的方式完成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;./1.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">err , data1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data1);</span><br><span class="line">    <span class="comment">//嵌套在上一个readFile API的回调函数中</span></span><br><span class="line">    fs.readFile(<span class="string">&#x27;./2.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">err , data2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data2);</span><br><span class="line">        fs.readFile(<span class="string">&#x27;./3.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">err , data3</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(data3);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/08-node%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5API/image-20210506201909805.png" alt="image-20210506201909805"></p>
<p>使用这种方式可以解决后续代码使用前面异步API的执行结果的问题</p>
<p>但是会引入<strong>新的问题</strong>：嵌套层数过多导致<strong>维护困难</strong></p>
<p>回调嵌套回调被称为<strong>回调地狱</strong></p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>案例-本地生活首页</title>
    <url>/2022/11/27/08-%E6%A1%88%E4%BE%8B-%E6%9C%AC%E5%9C%B0%E7%94%9F%E6%B4%BB%E9%A6%96%E9%A1%B5/</url>
    <content><![CDATA[<h1 id="案例-本地生活首页"><a href="#案例-本地生活首页" class="headerlink" title="案例-本地生活首页"></a>案例-本地生活首页</h1><p><img data-src="/images/08-%E5%AE%9E%E4%BE%8B-%E6%9C%AC%E5%9C%B0%E7%94%9F%E6%B4%BB%E9%A6%96%E9%A1%B5/image-20220210181521879.png" alt="image-20220210181521879"></p>
<span id="more"></span>

<h2 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1. 项目结构"></a>1. 项目结构</h2><p><img data-src="/images/08-%E5%AE%9E%E4%BE%8B-%E6%9C%AC%E5%9C%B0%E7%94%9F%E6%B4%BB%E9%A6%96%E9%A1%B5/image-20220210181603797.png" alt="image-20220210181603797"></p>
<p>三个页面分别为首页home，消息message，联系我们contact</p>
<p><code>tabBar</code>的图标和下方大图使用images文件夹中图片，其他网络图片通过<code>url</code>获取</p>
<p>主要实现home页面的前端效果</p>
<h2 id="2-导航栏效果"><a href="#2-导航栏效果" class="headerlink" title="2.导航栏效果"></a>2.导航栏效果</h2><p>藏蓝色背景<code>#2b4b6b</code>，导航标题为本地生活</p>
<h2 id="3-tabBar效果"><a href="#3-tabBar效果" class="headerlink" title="3.tabBar效果"></a>3.<code>tabBar</code>效果</h2><p>三个tab项为首页，消息和联系我们</p>
<p>三个tab项的图标存放在images文件夹</p>
<h2 id="4-轮播图效果"><a href="#4-轮播图效果" class="headerlink" title="4.轮播图效果"></a>4.轮播图效果</h2><p>轮播图信息由GET请求获取</p>
<p><img data-src="/images/08-%E5%AE%9E%E4%BE%8B-%E6%9C%AC%E5%9C%B0%E7%94%9F%E6%B4%BB%E9%A6%96%E9%A1%B5/image-20220210182108739.png" alt="image-20220210182108739"></p>
<p>获取后存入模板数据<code>swiperList</code>中</p>
<h2 id="5-九宫格效果"><a href="#5-九宫格效果" class="headerlink" title="5.九宫格效果"></a>5.九宫格效果</h2><p>GET请求获取</p>
<p>存放在模板数据<code>gridList</code>变量中</p>
<p>通过<strong>flex布局</strong>实现九宫格样式</p>
<h2 id="6-下方图片布局"><a href="#6-下方图片布局" class="headerlink" title="6.下方图片布局"></a>6.下方图片布局</h2><p>使用<strong>flex布局</strong>、image组件的<strong>mode属性</strong>进行样式设计</p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>08-JS深浅拷贝</title>
    <url>/2022/12/04/08-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>例如<strong>在浅拷贝obj对象时</strong> </p>
<ul>
<li>只会<strong>完全拷贝值类型的数据(id,name)</strong> </li>
<li>引用数据类型如<strong>数组和对象</strong>(smg)只会<strong>拷贝引用</strong>(即内存地址相同)<ul>
<li>拷贝引用：<strong>修改拷贝后的副本也会影响原件</strong></li>
<li>数组和对象均属于引用数据对象（数组本身也是一种对象）</li>
</ul>
</li>
</ul>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">            id:<span class="number">1</span>,</span><br><span class="line">            name:<span class="string">&quot;andy&quot;</span>,</span><br><span class="line">            smg:&#123;</span><br><span class="line">                age:<span class="number">19</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现浅拷贝的方法"><a href="#实现浅拷贝的方法" class="headerlink" title="实现浅拷贝的方法"></a>实现浅拷贝的方法</h3><h4 id="1-循环赋值方式"><a href="#1-循环赋值方式" class="headerlink" title="1.循环赋值方式"></a>1.循环赋值方式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o=&#123;&#125;;</span><br><span class="line"><span class="comment">//ES5浅拷贝方式</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)   <span class="comment">//k每次循环取obj对象的属性名</span></span><br><span class="line">&#123;</span><br><span class="line">    o[k]=obj[k];    <span class="comment">//将obj对象中属性k的值拷贝给对象o中的属性k 完成拷贝(浅拷贝)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-使用对象的assign方法"><a href="#2-使用对象的assign方法" class="headerlink" title="2.使用对象的assign方法"></a>2.使用对象的assign方法</h4><p><code>Object.assign(target,sources)</code></p>
<ul>
<li>将sources浅拷贝给target对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;将obj1浅拷贝给o1</span><br><span class="line">Object.assign(o1,obj1)</span><br></pre></td></tr></table></figure>

<ul>
<li>这种方式实际开发中<strong>更常用</strong></li>
</ul>
<br>

<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>深拷贝 <strong>每个数据都完全拷贝(内存地址不同)</strong></p>
<ul>
<li>不存在修改副本导致原件变化的情况</li>
</ul>
<h3 id="实现深拷贝方法"><a href="#实现深拷贝方法" class="headerlink" title="实现深拷贝方法"></a>实现深拷贝方法</h3><ul>
<li><p>深拷贝时<strong>不能直接拷贝整个引用数据类型</strong>，这样会导致只拷贝引用</p>
</li>
<li><p>需要<strong>进入每一个引用数据类型</strong>去<strong>拷贝深层的值类型数据</strong></p>
</li>
<li><p>而对于值类型数据的拷贝<strong>默认即为完全拷贝</strong>（内存地址不同）</p>
</li>
<li><p>通过递归<strong>将所有数据都完全拷贝</strong>完成后，深拷贝即完成</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o=&#123;&#125;;</span><br><span class="line"><span class="comment">//实现递归函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">newobj,oldobj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> oldobj)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">var</span> item=oldobj[k]; <span class="comment">//获取当前遍历到的属性值</span></span><br><span class="line">        <span class="comment">//判断是否为复杂数据类型</span></span><br><span class="line">        <span class="keyword">if</span>(item <span class="keyword">instanceof</span> <span class="built_in">Array</span>)   <span class="comment">//若是数组类型(先判断数组 因为数组也是对象)</span></span><br><span class="line">        &#123;                           	<span class="comment">//先判断对象会导致数组也满足对象的判断 结果将数组拷贝为对象</span></span><br><span class="line">            newobj[k]=[];   <span class="comment">//在新对象中创建新的空数组接收拷贝来的数组</span></span><br><span class="line">            deepCopy(newobj[k],item)    <span class="comment">//递归调用后进入数组完成拷贝</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item <span class="keyword">instanceof</span> <span class="built_in">Object</span>)&#123;   <span class="comment">//若是对象类型</span></span><br><span class="line">            newobj[k]=&#123;&#125;;   <span class="comment">//在新对象中创建空对象接收拷贝来的对象</span></span><br><span class="line">            deepCopy(newobj[k],item);   <span class="comment">//递归调用</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            newobj[k]=item; <span class="comment">//若是基本数据类型 就直接创建新属性拷贝或拷贝到新数组对应位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">deepCopy(o,obj);<span class="comment">//将obj拷贝到o</span></span><br></pre></td></tr></table></figure>

<center>实现深拷贝的递归函数</center>

]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>盒子水平垂直居中</title>
    <url>/2022/11/27/08-%E7%9B%92%E5%AD%90%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<h1 id="盒子水平垂直居中"><a href="#盒子水平垂直居中" class="headerlink" title="盒子水平垂直居中"></a>盒子水平垂直居中</h1><h2 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h2><ul>
<li><code>position:absolute</code></li>
<li>left和top设置为50% (有定位时才生效)</li>
<li>margin<strong>设置负值</strong>或<strong>使用平移</strong>使盒子中心与容器中心对齐</li>
</ul>
<span id="more"></span>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/* 第一种方式 */</span><br><span class="line">        #d1&#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            /* left top偏移 */</span><br><span class="line">            left: 50%;</span><br><span class="line">            top: 50%;</span><br><span class="line">            /* 让#d1中心点与容器中心点重合*/</span><br><span class="line">            margin: -150px 0 0 -150px;</span><br><span class="line">			/*transform:translate(-50%,-50%)*;/</span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;d1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/08-%E7%9B%92%E5%AD%90%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/image-20210916130953003.png" alt="image-20210916130953003"></p>
<h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><ul>
<li><code>position:absolute</code></li>
<li>设置left，top，right，bottom均为0</li>
<li><code>margin:auto</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">	#d2&#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            /* 外边距自适应 */</span><br><span class="line">            margin: auto;</span><br><span class="line">            /* 四个方向偏移为0 */</span><br><span class="line">            top: 0;</span><br><span class="line">            left: 0;</span><br><span class="line">            right: 0;</span><br><span class="line">            bottom: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;d2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果与第一种一样</p>
<h2 id="第三种方法"><a href="#第三种方法" class="headerlink" title="第三种方法"></a>第三种方法</h2><ul>
<li>使用flex布局 <code>display:flex</code></li>
<li>弹性容器设置<code>justify-content: center;</code>和<code>align-items: center;</code></li>
<li>容器内的弹性项<strong>在主轴和侧轴方向上均居中</strong>（主轴默认为水平）</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/* 第三种方式 */</span><br><span class="line">        /* flex布局 容器设置 */</span><br><span class="line">        #flexbox&#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 300px;</span><br><span class="line">            display: flex;</span><br><span class="line">            border: 1px solid black;</span><br><span class="line">            /* 主轴上弹性项居中 */</span><br><span class="line">            justify-content: center;</span><br><span class="line">            /* 侧轴上弹性项居中 */</span><br><span class="line">            align-items: center;</span><br><span class="line">        &#125;</span><br><span class="line">        #d3&#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: tomato;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;flexbox&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;d3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/08-%E7%9B%92%E5%AD%90%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/image-20210916131330879.png" alt="image-20210916131330879"></p>
<ul>
<li>橘红色弹性项垂直居中</li>
</ul>
]]></content>
      <categories>
        <category>HTMLandCss</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>组件通信</title>
    <url>/2022/11/27/08-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h1><p>多个组件结合使用需要共享某些数据，就需要组件通信</p>
<h2 id="1-组件的props"><a href="#1-组件的props" class="headerlink" title="1. 组件的props"></a>1. 组件的props</h2><p><img data-src="/images/08-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/image-20220403125721647.png" alt="image-20220403125721647"></p>
<p><img data-src="/images/08-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/image-20220403125739361.png" alt="image-20220403125739361"></p>
<span id="more"></span>

<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>props可以传递<strong>任意类型</strong>的数据</p>
<ul>
<li>数组、函数、对象和JSX</li>
<li><img data-src="/images/08-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/image-20220403131253167.png" alt="image-20220403131253167"></li>
</ul>
</li>
<li><p>props是<strong>只读对象</strong>，不能修改其中的值</p>
</li>
<li><p>class类创建的组件，若使用<code>constructor</code>构造函数，则需要将<code>props</code>作为参数并且传递给<code>super()</code>，否则构造函数中不能使用<code>props</code>，<strong>对render()无影响</strong>。</p>
<ul>
<li><img data-src="/images/08-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/image-20220403131331802.png" alt="image-20220403131331802"></li>
</ul>
</li>
</ul>
<br>

<h2 id="2-组件通信三种方式"><a href="#2-组件通信三种方式" class="headerlink" title="2.组件通信三种方式"></a>2.组件通信三种方式</h2><h3 id="1-父组件向子组件传递数据"><a href="#1-父组件向子组件传递数据" class="headerlink" title="1.父组件向子组件传递数据"></a>1.父组件向子组件传递数据</h3><p>父组件<strong>将自身state数据作为子组件标签属性值</strong>进行传递</p>
<p>子组件通过<code>props</code>接收父组件传来的数据</p>
<p><img data-src="/images/08-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/image-20220403131913447.png" alt="image-20220403131913447"></p>
<br>

<h3 id="2-子组件向父组件传递数据"><a href="#2-子组件向父组件传递数据" class="headerlink" title="2.子组件向父组件传递数据"></a>2.子组件向父组件传递数据</h3><p>利用回调函数，父组件提供一个回调函数，将回调函数传递给子组件，子组件调用回调函数并将<strong>数据</strong>作为回调的参数传递。</p>
<p>1.父组件提供回调函数</p>
<p>2.将回调函数传递给子组件</p>
<p>3.子组件调用回调函数将<strong>数据</strong>作为参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state=&#123;</span><br><span class="line">    msg:<span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//回调函数</span></span><br><span class="line">  getMsg = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      msg:val</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">        子组件传递的数据:&#123;<span class="built_in">this</span>.state.msg&#125;</span><br><span class="line">        &#123;<span class="comment">/* 回调函数传递给子组件 */</span>&#125;</span><br><span class="line">        &lt;Child getMsg=&#123;<span class="built_in">this</span>.getMsg&#125;/&gt;</span><br><span class="line">      &lt;/div&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handle = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//调用回调向父组件传值</span></span><br><span class="line">    <span class="built_in">this</span>.props.getMsg(<span class="string">&#x27;child&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.handle&#125;&gt;向父组件传递数据&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="3-兄弟组件传递数据"><a href="#3-兄弟组件传递数据" class="headerlink" title="3.兄弟组件传递数据"></a>3.兄弟组件传递数据</h3><p><img data-src="/images/08-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/image-20220403134101806.png" alt="image-20220403134101806"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state=&#123;</span><br><span class="line">    <span class="comment">//共享状态</span></span><br><span class="line">    count:<span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//共享状态的操作方法</span></span><br><span class="line">  insertcount = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      count:<span class="built_in">this</span>.state.count+<span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">        &lt;Child1 count=&#123;<span class="built_in">this</span>.state.count&#125;/&gt;</span><br><span class="line">        &lt;Child2 insertcount=&#123;<span class="built_in">this</span>.insertcount&#125;/&gt;</span><br><span class="line">      &lt;/div&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 显示共享状态</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>计数值:&#123;this.props.count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">      &#123;<span class="comment">/* 按钮点击调用共享状态操作方法 */</span>&#125;</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.props.insertcount&#125;&gt;增加计数值&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="3-Context"><a href="#3-Context" class="headerlink" title="3. Context"></a>3. Context</h2><p>对于一些嵌套关系复杂的组件之间通信，一级一级使用<code>props</code>传递数据明显繁琐。</p>
<p>使用<code>Context</code>可以解决<strong>嵌套关系复杂的组件之间的通信问题</strong>(<strong>跨组件通信</strong>)</p>
<p><img data-src="/images/08-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/image-20220403135659283.png" alt="image-20220403135659283"></p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>1.使用<code>React.createContext()</code>方法创建<strong>两个组件</strong></p>
<ul>
<li>数据提供者<code>Provider</code>和数据消费者<code>Consumer</code></li>
</ul>
<p>2.使用<code>Provider</code>包裹<strong>数据的提供组件</strong></p>
<ul>
<li>使用<code>provider</code>组件的<code>value</code>属性传递数据</li>
</ul>
<p>3.使用<code>Consumer</code>组件在<strong>数据的接收组件</strong>中获得数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建两个组件：数据提供者和消费者</span></span><br><span class="line"><span class="keyword">const</span> &#123; Provider, Consumer &#125; = React.createContext()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// 包裹数据提供组件,value属性传递数据</span></span><br><span class="line">      &lt;Provider value=<span class="string">&#x27;pink123&#x27;</span>&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;SubNode/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/Provider&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubNode</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Child /&gt;</span><br><span class="line">    &lt;/div&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;<span class="comment">/* 在接受组件中获得数据 */</span>&#125;</span><br><span class="line">      &lt;Consumer&gt;</span><br><span class="line">        &#123; <span class="function"><span class="params">data</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>接收的数据:&#123;data&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;</span><br><span class="line">      &lt;/Consumer&gt;</span><br><span class="line">    &lt;/div&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="4-props深入"><a href="#4-props深入" class="headerlink" title="4. props深入"></a>4. props深入</h2><h3 id="1-props的childern属性"><a href="#1-props的childern属性" class="headerlink" title="1.props的childern属性"></a>1.props的childern属性</h3><p><img data-src="/images/08-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/image-20220403141319591.png" alt="image-20220403141319591"></p>
<ul>
<li><p><code>Hello</code><strong>组件标签</strong>有一个文本子节点<code>&#39;我是子节点&#39;</code></p>
</li>
<li><p>所以<code>Hello</code>组件中<code>props.children</code>即为<code>&#39;我是子节点&#39;</code></p>
</li>
<li><p><code>children</code>属性的值可以是任意类型(文本、函数、对象、React元素(<code>JSX</code>) )</p>
</li>
</ul>
<br>

<h3 id="2-props校验"><a href="#2-props校验" class="headerlink" title="2. props校验"></a>2. props校验</h3><ul>
<li><p><strong>问题：</strong>对于组件来说，<code>props</code>是外来的数据，用户向组件传递数据时，并不知道数据在组件内部的处理方式，若传递了类型不符的数据导致<strong>组件内部报错</strong>，用户则<strong>无法根据错误信息判断原因</strong>。</p>
</li>
<li><p><strong>解决办法：</strong>在创建组件时对<code>props</code>中数据<strong>做出类型上的限制</strong>，当传递不满足验证条件的数据时<strong>提供明确的错误信息</strong>，提高组件的健壮性。</p>
</li>
</ul>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>利用第三方模块<code>prop-types</code>实现<code>props</code>校验</p>
<p><img data-src="/images/08-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/image-20220403143100288.png" alt="image-20220403143100288"></p>
<ul>
<li>注意：<code>prop-types</code>模块只会在<strong>传入数据类型不符时报错</strong>，数据在组件内部处理不受影响。</li>
</ul>
<br>

<h4 id="约束规则"><a href="#约束规则" class="headerlink" title="约束规则"></a>约束规则</h4><p><img data-src="/images/08-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/image-20220403145258429.png" alt="image-20220403145258429"></p>
<br>

<h4 id="props默认值"><a href="#props默认值" class="headerlink" title="props默认值"></a>props默认值</h4><p>有时<code>props</code>中的属性在用户未传入时<strong>需要有一个默认值来保证组件的运行</strong>。</p>
<p>例如：分页组件中，用户未传入数据时，需要有一个默认的<strong>当前页码</strong>和<strong>一页数据条数</strong></p>
<p><img data-src="/images/08-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/image-20220403145751848.png" alt="image-20220403145751848"></p>
<ul>
<li>默认值仅在<strong>未传入改值时生效</strong></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>09-Vuex</title>
    <url>/2021/09/20/09-Vuex/</url>
    <content><![CDATA[<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><h1 id="1-组件之间共享数据的方式"><a href="#1-组件之间共享数据的方式" class="headerlink" title="1.组件之间共享数据的方式"></a>1.组件之间共享数据的方式</h1><ul>
<li><p><strong>父向子：</strong>v-bind属性绑定，通过props接收</p>
</li>
<li><p><strong>子向父：</strong>$emit触发自定义事件并传值，父组件$on监听相应事件接收数据</p>
</li>
<li><p>兄弟组件/不相干组件传值：<code>EventBus</code>事件中心</p>
<ul>
<li>发送数据组件：使用<code>EventBus.$emit</code>触发自定义事件并传值</li>
<li>接收数据组件：使用<code>EventBus.$on</code>监听自定义事件接收数据</li>
</ul>
</li>
</ul>
<p><strong>问题：</strong>当多个组件<strong>结构复杂</strong>时，传值<strong>操作繁琐</strong>且<strong>不利于维护</strong>。</p>
<span id="more"></span>

<br>

<h1 id="2-Vuex概念"><a href="#2-Vuex概念" class="headerlink" title="2. Vuex概念"></a>2. Vuex概念</h1><p>Vuex实现组件<strong>全局状态管理</strong>的一种机制。</p>
<p><img data-src="/images/09-Vuex/image-20220411151713435.png" alt="image-20220411151713435"></p>
<ul>
<li>左图没有使用Vuex传值繁琐不利于维护</li>
<li>右图使用Vuex，组件可以从<code>STORE</code>获取共享的全局数据</li>
</ul>
<br>

<h1 id="3-Vuex统一管理共享状态的好处"><a href="#3-Vuex统一管理共享状态的好处" class="headerlink" title="3.Vuex统一管理共享状态的好处"></a>3.Vuex统一管理共享状态的好处</h1><p><img data-src="/images/09-Vuex/image-20220411151922911.png" alt="image-20220411151922911"></p>
<p>Vuex中的数据<strong>响应式</strong>，保持模板与视图同步。</p>
<br>

<h1 id="4-Vuex存储哪类数据"><a href="#4-Vuex存储哪类数据" class="headerlink" title="4.Vuex存储哪类数据"></a>4.Vuex存储哪类数据</h1><p>需要<strong>在组件之间共享的数据</strong></p>
<ul>
<li>组件的<strong>私有数据</strong>仍存储在各自的data中</li>
</ul>
<br>

<h1 id="5-Vuex使用"><a href="#5-Vuex使用" class="headerlink" title="5.Vuex使用"></a>5.Vuex使用</h1><h2 id="1-安装Vuex插件"><a href="#1-安装Vuex插件" class="headerlink" title="1.安装Vuex插件"></a>1.安装Vuex插件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure>

<ul>
<li>或者在Vue脚手架图形化界面中创建组件时勾选安装Vuex</li>
</ul>
<h2 id="2-在项目中导入Vuex，使用Vue-use注册"><a href="#2-在项目中导入Vuex，使用Vue-use注册" class="headerlink" title="2.在项目中导入Vuex，使用Vue.use注册"></a>2.在项目中导入Vuex，使用<code>Vue.use</code>注册</h2><h2 id="3-创建Vuex-store实例"><a href="#3-创建Vuex-store实例" class="headerlink" title="3.创建Vuex.store实例"></a>3.创建<code>Vuex.store</code>实例</h2><p><img data-src="/images/09-Vuex/image-20220411154014914.png" alt="image-20220411154014914"></p>
<br>

<h2 id="4-将Vuex-Store实例挂载到Vue根实例上"><a href="#4-将Vuex-Store实例挂载到Vue根实例上" class="headerlink" title="4.将Vuex.Store实例挂载到Vue根实例上"></a>4.将Vuex.Store实例挂载到Vue根实例上</h2><p><img data-src="/images/09-Vuex/image-20220411154149998.png" alt="image-20220411154149998"></p>
<br>

<h1 id="6-Vuex核心概念"><a href="#6-Vuex核心概念" class="headerlink" title="6. Vuex核心概念"></a>6. Vuex核心概念</h1><p><img data-src="/images/09-Vuex/image-20220411162730924.png" alt="image-20220411162730924"></p>
<h2 id="1-State"><a href="#1-State" class="headerlink" title="1. State"></a>1. State</h2><p><img data-src="/images/09-Vuex/image-20220411162810440.png" alt="image-20220411162810440"></p>
<h3 id="访问state数据第一种方式"><a href="#访问state数据第一种方式" class="headerlink" title="访问state数据第一种方式"></a>访问state数据第一种方式</h3><p><img data-src="/images/09-Vuex/image-20220411162847251.png" alt="image-20220411162847251"></p>
<p><img data-src="/images/09-Vuex/image-20220411162903968.png" alt="image-20220411162903968"></p>
<br>

<h3 id="访问state数据第二种方式"><a href="#访问state数据第二种方式" class="headerlink" title="访问state数据第二种方式"></a>访问state数据第二种方式</h3><p><img data-src="/images/09-Vuex/image-20220411163258344.png" alt="image-20220411163258344"></p>
<p><img data-src="/images/09-Vuex/image-20220411163629515.png" alt="image-20220411163629515"></p>
<br>

<h2 id="2-Mutation"><a href="#2-Mutation" class="headerlink" title="2. Mutation"></a>2. Mutation</h2><p><img data-src="/images/09-Vuex/image-20220411164338066.png" alt="image-20220411164338066"></p>
<ul>
<li>其他组件<strong>修改全局数据</strong>使用<code>mutations</code>中的方法<ul>
<li>将修改全局数据的方法集中管理，易于维护</li>
</ul>
</li>
<li><code>mutations</code>中的方法，<strong>第一个参数为state</strong>(全局状态)，<strong>之后的参数为调用时传递的值</strong></li>
</ul>
<br>

<h3 id="触发mutations中方法的两种方式"><a href="#触发mutations中方法的两种方式" class="headerlink" title="触发mutations中方法的两种方式"></a>触发mutations中方法的两种方式</h3><p>1.<code>this.$store.commit(&#39;方法名&#39;)</code></p>
<p>2.导入<code>mapMutations</code>，将方法映射为组件<code>methods</code>中的方法</p>
<p><img data-src="/images/09-Vuex/image-20220411165218895.png" alt="image-20220411165218895"></p>
<h3 id="触发mutations中的方法时传递参数"><a href="#触发mutations中的方法时传递参数" class="headerlink" title="触发mutations中的方法时传递参数"></a>触发mutations中的方法时传递参数</h3><p><img data-src="/images/09-Vuex/image-20220411164757435.png" alt="image-20220411164757435"></p>
<h2 id="3-Action"><a href="#3-Action" class="headerlink" title="3. Action"></a>3. Action</h2><p><code>mutations</code>中的方法<span style="color:red;">不能执行异步代码</span>，会导致调试器<strong>错误显示state全局状态的值</strong></p>
<p>Action中定义的方法<strong>可以执行异步代码</strong>，但<span style="color:red;">最终修改state数据仍是通过mutations中的方法。</span></p>
<ul>
<li>只有<code>mutations</code>中的方法有权修改state状态</li>
</ul>
<p><img data-src="/images/09-Vuex/image-20220411170602067.png" alt="image-20220411170602067"></p>
<p><img data-src="/images/09-Vuex/image-20220411171028485.png" alt="image-20220411171028485"></p>
<ul>
<li>使用定时器延时1s修改count数据要使用<code>actions</code>中的方法完成</li>
</ul>
<br>

<h3 id="触发actions异步任务时传递参数"><a href="#触发actions异步任务时传递参数" class="headerlink" title="触发actions异步任务时传递参数"></a>触发actions异步任务时传递参数</h3><p><img data-src="/images/09-Vuex/image-20220412154747938.png" alt="image-20220412154747938"></p>
<br>

<h3 id="触发actions的两种方式"><a href="#触发actions的两种方式" class="headerlink" title="触发actions的两种方式"></a>触发actions的两种方式</h3><p>1.<code>this.$store.dispatch(&#39;actions函数名&#39;,参数)</code></p>
<p>2.通过导入<code>mapActions</code>函数将<code>actions</code>函数映射为当前组件的<code>methods</code></p>
<p><img data-src="/images/09-Vuex/image-20220412161538081.png" alt="image-20220412161538081"></p>
<br>

<h2 id="4-Getter"><a href="#4-Getter" class="headerlink" title="4.Getter"></a>4.Getter</h2><ul>
<li><code>Getter</code>用于对<code>state</code>中的数据进行加工处理后<strong>形成新的数据</strong>(不会修改state数据)<ul>
<li>形成新的数据 类似于Vue的<code>computed</code>计算属性</li>
<li>Getter形成的<strong>新数据会根据state响应式变化</strong></li>
</ul>
</li>
</ul>
<h3 id="使用Getter的两种方式"><a href="#使用Getter的两种方式" class="headerlink" title="使用Getter的两种方式"></a>使用Getter的两种方式</h3><ul>
<li><p>第一种方式直接过去store实例中的<code>getters</code></p>
</li>
<li><p>第二种方式映射为<code>computed</code>计算属性</p>
</li>
</ul>
<p><img data-src="/images/09-Vuex/image-20220412162238536.png" alt="image-20220412162238536"></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>position定位</title>
    <url>/2022/11/27/09-position%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="position定位"><a href="#position定位" class="headerlink" title="position定位"></a>position定位</h1><ul>
<li>static：静态定位 (默认)</li>
<li>absolute：绝对定位 脱离标准流 </li>
<li>relative：相对定位 不脱离标准流，显示效果在原位置上进行偏移（仍占据原位置）</li>
<li>fixed：固定定位 脱离标准流 相对浏览器窗口定位</li>
<li>sticky：粘性定位</li>
</ul>
<span id="more"></span>

<h2 id="absolute绝对定位"><a href="#absolute绝对定位" class="headerlink" title="absolute绝对定位"></a>absolute绝对定位</h2><p>元素会被<strong>移出正常文档流</strong>，并不为元素预留空间，通过指定元素<strong>相对于最近的非 static 定位祖先元素的偏移</strong>，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。</p>
<ul>
<li>偏移时<strong>相对于最近的有定位(非static)的父级元素</strong>进行偏移</li>
</ul>
<h2 id="relative相对定位"><a href="#relative相对定位" class="headerlink" title="relative相对定位"></a>relative相对定位</h2><p>该关键字下，元素<strong>先放置在未添加定位时的位置</strong>（原位置），再在<strong>不改变页面布局的前提下调整元素位置</strong>（即调整后元素的位置相对于原位置<strong>在视觉上发生变化</strong>，但是原位置<strong>仍被占据并显示空白</strong>）。position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。</p>
<ul>
<li>偏移时相对于原位置（未添加定位时的位置）进行偏移</li>
</ul>
<h2 id="fixed固定定位"><a href="#fixed固定定位" class="headerlink" title="fixed固定定位"></a>fixed固定定位</h2><p>元素会被<strong>移出正常文档流</strong>，并不为元素预留空间，而是通过<strong>指定元素相对于屏幕视口（viewport）的位置来指定元素位置</strong>。元素的位置在<strong>屏幕滚动时不会改变</strong>。打印时，元素会出现在的每页的固定位置。<code>fixed</code> 属性会创建新的层叠上下文。当元素祖先的 <code>transform</code>, <code>perspective</code> 或 <code>filter</code> 属性非 <code>none</code> 时，容器由视口改为该祖先。</p>
<ul>
<li>相对于<strong>屏幕视口（viewport）</strong>的位置进行偏移</li>
<li>元素位置在屏幕滚动时不会改变</li>
</ul>
<h2 id="sticky粘性定位"><a href="#sticky粘性定位" class="headerlink" title="sticky粘性定位"></a>sticky粘性定位</h2><p>粘性定位可以被认为是<strong>相对定位和固定定位的混合</strong>。元素在<strong>跨越特定阈值前为相对定位</strong>，<strong>之后为固定定位</strong>。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#one &#123; position: sticky; top: 10px; &#125;</span><br></pre></td></tr></table></figure>

<p>在 viewport 视口滚动到元素<code>#one</code>距离<strong>浏览器窗口上边界</strong> 大于等于 10px 之前，元素为相对定位。之后，元素将固定在与浏览器窗口顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下。</p>
<ul>
<li>必须设置left、top、right、bottom四个阈值其中一个，粘性定位才会生效，否则等同于相对定位</li>
</ul>
<h2 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h2><p>z-index属性值设定一个元素沿着Z轴的位置，取值可以为<strong>正数和负数</strong></p>
<ul>
<li>数值越大，元素离用户越近；数值越小，离用户越远</li>
<li><strong>只在设置了定位的元素上生效</strong></li>
<li>z-index数值较大的元素会挡住数值较小的元素</li>
</ul>
]]></content>
      <categories>
        <category>HTMLandCss</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>09-promise对象</title>
    <url>/2021/05/06/09-promise%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>promise对象出现的目的是解决nodejs中异步编程中<a href="08-node%E3%80%82%E3%80%82%E3%80%82">回调地狱</a>的问题。</p>
<p>promise并<strong>没有提供新的功能</strong>，它是一种异步编程<strong>语法上的改进</strong></p>
<p>可以将异步API的<strong>执行</strong>和<strong>结果的处理</strong>进行分离</p>
<p>promise是一种构造函数，使用时需要new 生成对象实例</p>
<span id="more"></span>

<br>

<h2 id="Promise基本使用"><a href="#Promise基本使用" class="headerlink" title="Promise基本使用"></a>Promise基本使用</h2><p>new Promise()中传入匿名函数<code>(resolve,reject) =&gt; &#123;&#125;</code></p>
<p>匿名函数的两个参数resolve，reject</p>
<ul>
<li>resolve 函数：当异步API执行成功时调用这个函数</li>
<li>reject函数：异步API执行失败时调用这个函数</li>
</ul>
<p>在匿名函数<code>(resolve,reject) =&gt; &#123;&#125;</code>中书写异步API代码</p>
<ul>
<li>在匿名函数中完成异步API的执行</li>
<li>利用resolve和reject这两个参数函数，在Promise实例对象外部处理异步API的结果</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Promise实例对象</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve , reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//匿名函数中书写异步API代码</span></span><br><span class="line">    fs.readFile(<span class="string">&#x27;./1.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">err , data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(err != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//文件打开失败调用reject函数</span></span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Promise实例对象外部处理异步API的结果</span></span><br><span class="line"><span class="comment">//在promise实例对象内部调用resolve函数即为调用promise.then()中的匿名函数，参数传递给then()中的匿名函数</span></span><br><span class="line">promise.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//调用reject函数即为调用下面promise.catch()中的匿名函数，此处使用了链式编程省略了promise</span></span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h2 id="Promise解决回调地狱"><a href="#Promise解决回调地狱" class="headerlink" title="Promise解决回调地狱"></a>Promise解决回调地狱</h2><ul>
<li><p>使用三个Promise对象包裹需要顺序执行的三个打开文件的异步API</p>
</li>
<li><p>将三个Promise对象分别用函数包裹保证执行时按函数调用的顺序执行</p>
</li>
<li><p>在使用<code>promise.then()</code>处理异步API结果时</p>
<ul>
<li>```js<br>p1().then((data) =&gt; {<pre><code>console.log(data)
return p2();
</code></pre>
})<br>.then((data) =&gt; {})<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 上面第一个&#96;p1().then()&#96;方法中的&#96;return p2()&#96;，会使**下一个链式编程的then方法变为p2().then**</span><br><span class="line"></span><br><span class="line">  - 即第二个链式编程的then()处理的是**第二个promise对象中的异步API**</span><br><span class="line"></span><br><span class="line">  - 第三个链式编程的then()同理，处理的是**第三个promise对象中的异步API**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用函数包裹Promise对象，保证执行时按函数调用的顺序执行</span><br><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">        fs.readFile(&#39;.&#x2F;1.txt&#39;,&#39;utf8&#39;,(err,data) &#x3D;&gt; &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function p2() &#123;</span><br><span class="line">    return new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">        fs.readFile(&#39;.&#x2F;2.txt&#39;,&#39;utf8&#39;,(err,data) &#x3D;&gt; &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function p3() &#123;</span><br><span class="line">    return new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">        fs.readFile(&#39;.&#x2F;3.txt&#39;,&#39;utf8&#39;,(err,data) &#x3D;&gt; &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;p1()的返回值即为第一个promise对象</span><br><span class="line">p1().then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">    &#x2F;&#x2F;此处return p2()，下一个链式编程的then方法即为p2()的返回值的then方法</span><br><span class="line">    return p2()</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;此处即为p2().then()方法</span><br><span class="line">.then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">    return p3()</span><br><span class="line">&#125;)</span><br><span class="line">.then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><img data-src="/images/09-promise%E5%AF%B9%E8%B1%A1/image-20210506211329533.png" alt="image-20210506211329533"></p>
<p>输出结果即为顺序的1 2 3</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>09-JS原型对象prototype</title>
    <url>/2022/12/04/09-%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1prototype/</url>
    <content><![CDATA[<h1 id="原型对象prototype原型-proto-和constructor"><a href="#原型对象prototype原型-proto-和constructor" class="headerlink" title="原型对象prototype原型__proto__和constructor"></a>原型对象prototype原型<code>__proto__</code>和constructor</h1><p>先明确几个属性</p>
<ul>
<li><code>__proto__</code>：称其为<strong>原型</strong>，指向对象的 原型对象（<code>构造函数.prototype</code>）<ul>
<li>实际上<code>__proto__</code>只是起一个指向的作用（类似于指针）</li>
<li><code>__proto__</code>是浏览器提供的，<code>javascript</code>标准<strong>没有做出规定</strong></li>
</ul>
</li>
<li><code>prototype</code>：称其为<strong>原型对象</strong>，只有<strong>构造函数</strong>才有prototype属性，<code>实例对象.prototype</code>为undefined</li>
<li><code>constructor</code>：是prototype的一个属性，<strong>指回</strong>prototype所属的构造函数<ul>
<li>即 <code>b.prototype.constructor</code> 指向 b</li>
</ul>
</li>
</ul>
<span id="more"></span>

<p>看一个简单例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">         <span class="comment">//创建一个构造函数b</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个构造函数b的实例对象a</span></span><br><span class="line">        <span class="keyword">var</span> a = <span class="keyword">new</span> b()</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">		<span class="built_in">console</span>.log(b);</span><br><span class="line">        <span class="built_in">console</span>.log(a.__proto__);</span><br><span class="line">        <span class="built_in">console</span>.log(b.prototype);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/09-%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1prototype/image-20210917135551612.png" alt="image-20210917135551612"></p>
<center>图1</center>

<ul>
<li><p>上图中红色框即为<code>console.log(a);</code>的输出结果</p>
<ul>
<li>a是构造函数b的实例对象</li>
<li>红框中的<code>[[Prototype]]</code>是 <strong>a的原型</strong>  <strong>b.prototype</strong>（<u>这个prototype是浏览器添加上的 当前对象的构造函数的prototype，即当前对象的原型</u>）</li>
</ul>
</li>
<li><p>上图蓝框，为<code>console.log(b);</code>的输出结果</p>
<ul>
<li>结果就是构造函数b</li>
</ul>
</li>
</ul>
<br>

<p><img data-src="/images/09-%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1prototype/image-20210917140035395.png" alt="image-20210917140035395"></p>
<center>图2</center>

<ul>
<li><p>上图红框为<code>b.prototype</code></p>
</li>
<li><p>上图绿框是<code>console.log(b.prototype);</code>的输出结果，证明了上图三个框均为<code>b.prototype</code></p>
</li>
<li><p>上图蓝框即为<code>console.log(a.__proto__);</code>的结果，与红框相同，说明a的原型（<code>a.__proto__</code>）指向a的构造函数的 原型对象（<code>b.prototype</code>）</p>
<ul>
<li>根据<u>图1</u>得到的结论，图2蓝框中的<code>[[Prototype]]</code>即为<strong>b.prototype的原型</strong>(<code>Object.prototype</code>)</li>
<li><code>b.prototype</code>的构造函数的<code>prototype</code> 即为 <code>b.prototype.__proto__</code></li>
</ul>
</li>
</ul>
<p><img data-src="/images/09-%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1prototype/image-20210917142113402.png" alt="image-20210917142113402"></p>
<center>图3</center>

<ul>
<li><strong>图3</strong>为<strong>图2蓝框中的<code>[[prototype]]</code>(<code>Object.prototype</code>)展开后</strong>，通过图三红框发现</li>
<li><code>b.prototype.__proto__.constructor</code> <code>= Object()</code></li>
<li><code>b.prototype</code>的构造函数为<code>Object()</code></li>
</ul>
<br>

<p>自此我们知道</p>
<ul>
<li><code>a.__proto__</code>指向<code>b.prototype</code>，</li>
<li><code>b.prototype.__proto__</code>指向<code>Object.prototype</code>，</li>
<li><code>Object.prototype.__proto__</code>指向<code>null</code>（因为Object作为所有对象的父类，其prototype的<code>__proto__</code>已经不存在）</li>
</ul>
<p>从a实例对象依次向上寻找<code>__proto__</code>(原型)直到<code>__proto__</code>指向null为止就形成了一条原型链</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>导航跳转</title>
    <url>/2022/11/27/09-%E5%AF%BC%E8%88%AA%E8%B7%B3%E8%BD%AC/</url>
    <content><![CDATA[<h1 id="导航跳转"><a href="#导航跳转" class="headerlink" title="导航跳转"></a>导航跳转</h1><h2 id="1-声明式导航"><a href="#1-声明式导航" class="headerlink" title="1. 声明式导航"></a>1. 声明式导航</h2><h3 id="1-1-导航到tabBar页面"><a href="#1-1-导航到tabBar页面" class="headerlink" title="1.1 导航到tabBar页面"></a>1.1 导航到tabBar页面</h3><p><img data-src="/images/09-%E5%AF%BC%E8%88%AA%E8%B7%B3%E8%BD%AC/image-20220218152916078.png" alt="image-20220218152916078"></p>
<span id="more"></span>

<h3 id="1-2-导航到非tabBar页面"><a href="#1-2-导航到非tabBar页面" class="headerlink" title="1.2 导航到非tabBar页面"></a>1.2 导航到非tabBar页面</h3><p><img data-src="/images/09-%E5%AF%BC%E8%88%AA%E8%B7%B3%E8%BD%AC/image-20220218153129149.png" alt="image-20220218153129149"></p>
<h3 id="1-3-后退导航"><a href="#1-3-后退导航" class="headerlink" title="1.3 后退导航"></a>1.3 后退导航</h3><p><img data-src="/images/09-%E5%AF%BC%E8%88%AA%E8%B7%B3%E8%BD%AC/image-20220218153354617.png" alt="image-20220218153354617"></p>
<h2 id="2-编程式导航"><a href="#2-编程式导航" class="headerlink" title="2. 编程式导航"></a>2. 编程式导航</h2><h3 id="2-1-导航到tabBar页面"><a href="#2-1-导航到tabBar页面" class="headerlink" title="2.1 导航到tabBar页面"></a>2.1 导航到tabBar页面</h3><p><img data-src="/images/09-%E5%AF%BC%E8%88%AA%E8%B7%B3%E8%BD%AC/image-20220218153706239.png" alt="image-20220218153706239"></p>
<h3 id="2-2-导航到非tabBar页面"><a href="#2-2-导航到非tabBar页面" class="headerlink" title="2.2 导航到非tabBar页面"></a>2.2 导航到非tabBar页面</h3><p><img data-src="/images/09-%E5%AF%BC%E8%88%AA%E8%B7%B3%E8%BD%AC/image-20220218153746170.png" alt="image-20220218153746170"></p>
<h3 id="2-3-后退导航"><a href="#2-3-后退导航" class="headerlink" title="2.3 后退导航"></a>2.3 后退导航</h3><p><img data-src="/images/09-%E5%AF%BC%E8%88%AA%E8%B7%B3%E8%BD%AC/image-20220218153904034.png" alt="image-20220218153904034"></p>
<h2 id="3-导航传参"><a href="#3-导航传参" class="headerlink" title="3. 导航传参"></a>3. 导航传参</h2><h3 id="3-1-声明式导航传参"><a href="#3-1-声明式导航传参" class="headerlink" title="3.1 声明式导航传参"></a>3.1 声明式导航传参</h3><p><img data-src="/images/09-%E5%AF%BC%E8%88%AA%E8%B7%B3%E8%BD%AC/image-20220218154206484.png" alt="image-20220218154206484"></p>
<h3 id="3-2-编程式导航传参"><a href="#3-2-编程式导航传参" class="headerlink" title="3.2 编程式导航传参"></a>3.2 编程式导航传参</h3><p><img data-src="/images/09-%E5%AF%BC%E8%88%AA%E8%B7%B3%E8%BD%AC/image-20220218174504166.png" alt="image-20220218174504166"></p>
<h3 id="3-3-在onLoad处理函数中接收导航参数"><a href="#3-3-在onLoad处理函数中接收导航参数" class="headerlink" title="3.3 在onLoad处理函数中接收导航参数"></a>3.3 在<code>onLoad</code>处理函数中接收导航参数</h3><p><img data-src="/images/09-%E5%AF%BC%E8%88%AA%E8%B7%B3%E8%BD%AC/image-20220218174826288.png" alt="image-20220218174826288"></p>
<ul>
<li>onLoad处理函数获取的导航参数一般转存到页面data数据中使用</li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>组件生命周期</title>
    <url>/2022/11/27/09-%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h1><p>生命周期：组件从<strong>被创建</strong>，到<strong>挂载到页面</strong>，再到<strong>组件不用时卸载</strong>的整个过程称为组件生命周期</p>
<p><span style="color:red;">只有class类组件才有生命周期</span></p>
<p>钩子函数：生命周期不同阶段调用的对应方法</p>
<p><img data-src="/images/09-%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20220403191248515.png" alt="image-20220403191248515"></p>
<br>

<span id="more"></span>

<h2 id="1-三个阶段"><a href="#1-三个阶段" class="headerlink" title="1.三个阶段"></a>1.三个阶段</h2><h3 id="1-创建时-挂载阶段"><a href="#1-创建时-挂载阶段" class="headerlink" title="1.创建时(挂载阶段)"></a>1.创建时(挂载阶段)</h3><p><img data-src="/images/09-%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20220403191401735.png" alt="image-20220403191401735"></p>
<ul>
<li>因为<code>setState()</code>方法会先更新<code>state</code>数据，再重新渲染组件，所以<code>render()</code>方法中调用<code>setState()</code>方法会<strong>因为递归渲染而报错</strong>。</li>
</ul>
<br>

<h3 id="2-更新时"><a href="#2-更新时" class="headerlink" title="2.更新时"></a>2.更新时</h3><p>在三种情况下组件会更新(调用<code>render()</code>方法重新渲染)</p>
<ul>
<li><code>setState()</code>方法调用</li>
<li>组件接收新的<code>props</code>属性</li>
<li>调用强制更新方法<code>forceUpdate()</code></li>
</ul>
<p><img data-src="/images/09-%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20220403192710417.png" alt="image-20220403192710417"></p>
<ul>
<li>注意：在<code>componentDidUpdate()</code>钩子函数中使用<code>setState()</code>需要<strong>放在if判断中进行</strong>，<strong>避免递归更新导致错误</strong> (<code>setState()</code>方法更新UI会依次调用<code>render</code>和<code>componentDidUpdate</code>)。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新完成钩子函数</span></span><br><span class="line"><span class="function"><span class="title">componentDidUpdate</span>(<span class="params">prevProps</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//prevProps更新前的props对象</span></span><br><span class="line">    <span class="keyword">if</span>(prevProps.count !== <span class="built_in">this</span>.props.count) &#123;</span><br><span class="line">        <span class="comment">//当更新前后props中的属性变化再进行更新操作</span></span><br><span class="line">        <span class="built_in">this</span>.setState()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以根据更新前后<code>props</code>中的属性是否变化选择是否使用<code>setState</code>方法<ul>
<li><code>componentDidUpdate</code>钩子可以通过**<code>prevProps</code>参数**接收更新前的<code>props</code>对象</li>
</ul>
</li>
</ul>
<br>

<h3 id="3-卸载时"><a href="#3-卸载时" class="headerlink" title="3.卸载时"></a>3.卸载时</h3><p><img data-src="/images/09-%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20220403195844731.png" alt="image-20220403195844731"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组件挂载后钩子</span></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//创建定时器</span></span><br><span class="line">    <span class="built_in">this</span>.timeId = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;定时器执行中&#x27;</span>);</span><br><span class="line">    &#125;,<span class="number">500</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//组件卸载钩子</span></span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">&#x27;Text组件钩子函数:componentWillUnmount&#x27;</span>);</span><br><span class="line">    <span class="comment">//清除定时器</span></span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timeId)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>组件挂载后钩子中创建的定时器，在组件卸载时需要手动清除，否则可能造成内存泄露问题。</li>
</ul>
<br>

<h2 id="2-不常用钩子函数"><a href="#2-不常用钩子函数" class="headerlink" title="2.不常用钩子函数"></a>2.不常用钩子函数</h2><p><img data-src="/images/09-%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20220403200418323.png" alt="image-20220403200418323"></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>10-ES7异步函数</title>
    <url>/2021/05/06/10-ES7%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="ES7异步函数"><a href="#ES7异步函数" class="headerlink" title="ES7异步函数"></a>ES7异步函数</h1><p>在09-promise对象中，学习到使用promise对象可以对异步编程语法进行<strong>改进</strong></p>
<ul>
<li>可以将异步API的执行和结果处理分离</li>
<li>可以解决异步API回调函数嵌套的<strong>维护困难</strong>和<strong>回调地狱</strong>问题</li>
</ul>
<p>但是promise对象在处理较多的需要顺序执行的异步API时<strong>仍然比较繁琐</strong></p>
<span id="more"></span>

<ul>
<li>需要使用promise对象将每一个异步API包裹起来</li>
<li>需要使用函数将每一个promise对象包裹以实现顺序调用</li>
<li>获取异步API<strong>结果</strong>和<strong>错误信息</strong>时还要在promise对象中使用resolve和reject两个参数函数<ul>
<li>并在promise对象外部使用promise.then 和 promise.catch 两个方法进行接收</li>
</ul>
</li>
<li>这使得代码比较臃肿繁琐</li>
</ul>
<p>在ES7中定义的<strong>异步函数</strong>可以在实现promise对象功能的基础上使得代码更加的简洁明了</p>
<h2 id="1-异步函数"><a href="#1-异步函数" class="headerlink" title="1.异步函数"></a>1.异步函数</h2><p>异步函数实际上就是基于promise对象，将一些比较繁琐的promise方法进行了封装</p>
<p>然后开放一些简单的关键字代替这些繁琐的操作</p>
<br>

<p><strong>异步函数是异步编程语法的终极解决方案，它可以将异步代码写成同步的形式，消除代码的回调函数嵌套。</strong></p>
<h2 id="2-异步函数使用"><a href="#2-异步函数使用" class="headerlink" title="2.异步函数使用"></a>2.异步函数使用</h2><h3 id="在普通函数的前面加上async，即可创建异步函数"><a href="#在普通函数的前面加上async，即可创建异步函数" class="headerlink" title="在普通函数的前面加上async，即可创建异步函数"></a>在普通函数的前面加上<code>async</code>，即可创建异步函数</h3><p>async即异步的意思</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fn()函数即为一个异步函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn());</span><br><span class="line">fn().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="异步函数的默认返回值为一个promise对象"><a href="#异步函数的默认返回值为一个promise对象" class="headerlink" title="异步函数的默认返回值为一个promise对象"></a>异步函数的默认返回值为一个<strong>promise对象</strong></h3><p>在异步函数中使用return进行结果的返回</p>
<p><code>console.log(fn());</code>返回的结果如下</p>
<p><img data-src="/images/10-ES7%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/image-20210506214213554.png" alt="image-20210506214213554"></p>
<p>将123包裹在promise对象中进行返回</p>
<p>此处异步函数的<strong>return 即替代了promise对象的resolve函数</strong></p>
<br>

<p>可以使用promise对象的then()方法获取执行结果</p>
<p>即使用<code>fn().then()</code>方法，输出123</p>
<br>

<h3 id="异步函数使用throw抛出错误信息"><a href="#异步函数使用throw抛出错误信息" class="headerlink" title="异步函数使用throw抛出错误信息"></a>异步函数使用throw抛出错误信息</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="string">&#x27;错误&#x27;</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line">fn().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用promise对象的<strong>catch方法</strong>即可获取错误信息<code>&#39;错误&#39;</code></p>
<p>此处throw语句后的return语句不再生效</p>
<p><strong>throw即替代了promise对象中的reject函数</strong></p>
<br>

<h3 id="异步函数的await关键字"><a href="#异步函数的await关键字" class="headerlink" title="异步函数的await关键字"></a>异步函数的await关键字</h3><ul>
<li>他只能出现在异步函数中</li>
<li>await promise可以<strong>暂停异步函数的执行</strong>，等待promise对象返回结果后再继续执行</li>
<li>await可以<strong>直接获取promise对象中的异步数据</strong>，代替了then方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">p1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;p1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">p2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;p2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">p3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;p3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> r1=<span class="keyword">await</span> p1()</span><br><span class="line">    <span class="comment">//r1即为&#x27;p1&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(r1);</span><br><span class="line">    <span class="keyword">let</span> r2=<span class="keyword">await</span> p2()</span><br><span class="line">    <span class="built_in">console</span>.log(r2);</span><br><span class="line">    <span class="keyword">let</span> r3=<span class="keyword">await</span> p3()</span><br><span class="line">    <span class="built_in">console</span>.log(r3);</span><br><span class="line">&#125;</span><br><span class="line">run()</span><br></pre></td></tr></table></figure>

<p>此处有三个异步函数p1()，p2()，p3()需要顺序执行</p>
<p>将三个函数放入run()异步函数中加上await关键字执行</p>
<p>只有当p1()函数执行后的promise对象返回结果后，代码才继续执行</p>
<p>同时可以利用await关键字直接获取返回的promise对象中的异步数据</p>
<br>

<h2 id="3-异步函数在nodejs中的应用"><a href="#3-异步函数在nodejs中的应用" class="headerlink" title="3.异步函数在nodejs中的应用"></a>3.异步函数在nodejs中的应用</h2><p>nodejs中的异步API使用<strong>回调函数</strong>来获取执行结果</p>
<p>因为使用回调函数获取结果，所以<strong>不能使用异步函数中的await关键字</strong></p>
<ul>
<li>await关键字后必须跟一个promise对象</li>
</ul>
<br>

<h3 id="util核心模块的promisify方法"><a href="#util核心模块的promisify方法" class="headerlink" title="util核心模块的promisify方法"></a><code>util</code>核心模块的promisify方法</h3><p>nodejs核心模块util的promisify方法可以<strong>改造异步API</strong></p>
<ul>
<li>在原异步API的基础上，产生一个新的异步API</li>
<li>新的异步API将执行结果包裹在promise对象中返回</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入util模块的promisify方法</span></span><br><span class="line"><span class="keyword">var</span> promisify = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>).promisify</span><br><span class="line"></span><br><span class="line"><span class="comment">//将要改造的异步API包裹在promisify方法中，形成一个新的异步API</span></span><br><span class="line"><span class="keyword">var</span> readFile = promisify(fs.readFile)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用新异步API</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> r1 = <span class="keyword">await</span> readFile(<span class="string">&#x27;./1.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">   <span class="built_in">console</span>.log(r1);</span><br><span class="line">&#125;</span><br><span class="line">run()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>readFile</code> 即为基于<code>fs.readFile</code>改造后的新异步API</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>10-Git命令行命令</title>
    <url>/2022/04/23/10-Git%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Git命令行命令"><a href="#Git命令行命令" class="headerlink" title="Git命令行命令"></a>Git命令行命令</h1><h2 id="1-git-status"><a href="#1-git-status" class="headerlink" title="1. git status"></a>1. <code>git status</code></h2><p>查看你的文件在工作目录与缓存的状态</p>
<ul>
<li>修改没有送入缓存区时</li>
<li>红色代表<strong>修改完但没有送入缓存区</strong></li>
</ul>
<p><img data-src="/images/10-Git%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%91%BD%E4%BB%A4/image-20211019172434607.png" alt="image-20211019172434607"></p>
<span id="more"></span>

<ul>
<li>修改文件送入缓存区并准备提交</li>
<li>绿色代表<strong>修改完并送入缓存区</strong></li>
</ul>
<p><img data-src="/images/10-Git%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%91%BD%E4%BB%A4/image-20211019172858490.png" alt="image-20211019172858490"></p>
<ul>
<li>缓存区文件已经提交到本地仓库，此时缓存区清空</li>
</ul>
<p><img data-src="/images/10-Git%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%91%BD%E4%BB%A4/image-20211019172947560.png" alt="image-20211019172947560"></p>
<br>

<h2 id="2-git-add"><a href="#2-git-add" class="headerlink" title="2. git add"></a>2. <code>git add</code></h2><p>添加文件到缓存</p>
<p><code>git add README</code>：将<code>README</code>文件送入缓存区</p>
<p><code>git add .</code>：将所有修改文件送入缓存区</p>
<br>

<h2 id="3-git-reset-HEAD"><a href="#3-git-reset-HEAD" class="headerlink" title="3. git reset HEAD"></a>3. <code>git reset HEAD</code></h2><p>取消缓存区中已缓存的内容</p>
<p><code>git reset HEAD</code> ：取消缓存区的<strong>所有文件</strong></p>
<p><code>git reset HEAD -- hello.vue</code>：取消缓存区中的**<code>hello.vue</code>文件** </p>
<br>

<h2 id="4-git-remote-add-lt-shortname-gt-lt-URL-gt"><a href="#4-git-remote-add-lt-shortname-gt-lt-URL-gt" class="headerlink" title="4. git remote add &lt;shortname&gt; &lt;URL&gt;"></a>4. <code>git remote add &lt;shortname&gt; &lt;URL&gt;</code></h2><ul>
<li><p>关联<strong>本地仓库与远程仓库</strong></p>
</li>
<li><p>给远程仓库的URL <code>&lt;URL&gt;</code> 起简写名称 <code>&lt;shortname&gt;</code></p>
</li>
<li><p>后续命令可以使用简写名称代替URL</p>
</li>
</ul>
<p><code>git remote add origin https://gitee.com/yang-xiao123/vue_shop.git</code></p>
<ul>
<li><p>给<code>https://gitee.com/yang-xiao123/vue_shop.git</code>这个远程仓库 <strong>vue_shop</strong>的<strong>URL</strong></p>
<p>起简写名称为<strong>origin</strong></p>
</li>
</ul>
<h2 id="5-git-push-lt-远程仓库名-gt-lt-本地分支名-gt-lt-远程分支名-gt"><a href="#5-git-push-lt-远程仓库名-gt-lt-本地分支名-gt-lt-远程分支名-gt" class="headerlink" title="5. git push &lt;远程仓库名&gt; &lt;本地分支名&gt; [&lt;远程分支名&gt;]"></a>5. <code>git push &lt;远程仓库名&gt; &lt;本地分支名&gt; [&lt;远程分支名&gt;]</code></h2><p>将<strong>本地仓库的分支</strong>推送到<strong>远程仓库的对应分支</strong></p>
<p><code>&lt;远程仓库名&gt;</code>即为上述的URL简写名称</p>
<p><code>git push origin master master</code> ：将本地仓库master分支推送到origin仓库的master分支</p>
<ul>
<li><code>&lt;远程分支名&gt;</code>省略时，使用本地分支名作为<code>&lt;远程分支名&gt;</code></li>
</ul>
<br>

<ul>
<li><code>git push -u origin master</code> </li>
<li><strong>-u</strong>：将本地分支master推送到远程分支master并<strong>建立追踪</strong><ul>
<li>将<strong>本地分支master</strong>与<strong>远程分支master</strong>建立追踪</li>
</ul>
</li>
</ul>
<br>

<ul>
<li><code>git push</code></li>
</ul>
<p>将<strong>当前所在的本地分支</strong>推送到<strong>与其建立追踪的远程分支</strong></p>
<ul>
<li>若当前分支<strong>没有建立过远程追踪则报错</strong></li>
</ul>
<br>

<h2 id="6-git-branch"><a href="#6-git-branch" class="headerlink" title="6. git branch"></a>6. <code>git branch</code></h2><p><code>git branch </code>：显示可用分支，当前所在分支<strong>加’*’号并绿色显示</strong></p>
<p><code>git branch &lt;new branch&gt;</code>：创建新分支</p>
<p><code>git branch -d &lt;branchname&gt;</code>：删除分支(删除时不能处于被删除分支上)</p>
<h2 id="7-git-checkout-lt-branchname-gt"><a href="#7-git-checkout-lt-branchname-gt" class="headerlink" title="7. git checkout &lt;branchname&gt;"></a>7. <code>git checkout &lt;branchname&gt;</code></h2><p>切换到新的分支上下文</p>
<p><code>git checkout -b &lt;newbranchname&gt;</code>：创建新分支并切换到该分支</p>
<ul>
<li><strong>会带着当前分支的状态</strong>创建新分支</li>
</ul>
<h2 id="8-git-init"><a href="#8-git-init" class="headerlink" title="8. git init"></a>8. <code>git init</code></h2><p>创建/初始化本地仓库</p>
<ol>
<li>在项目目录下执行命令 <code>git init</code></li>
</ol>
<ul>
<li><p>会创建一个隐藏的<code>.git</code>文件夹</p>
</li>
<li><p>会将项目初始化为本地仓库</p>
</li>
</ul>
<ol start="2">
<li>在gitee或者github上创建远程仓库</li>
<li>将创建的本地仓库与远程仓库关联</li>
</ol>
<ul>
<li><code>git remote add origin https://gitee.com/yang-xiao123/vue_shop.git</code></li>
<li>关联本地仓库与远程仓库并给远程仓库URL取简写名称</li>
</ul>
<ol start="4">
<li>推送本地分支到远程分支</li>
</ol>
<ul>
<li><code>git push ...</code></li>
<li>空的本地仓库不能推送</li>
</ul>
<br>

<h2 id="9-git-clone"><a href="#9-git-clone" class="headerlink" title="9. git clone"></a>9. <code>git clone</code></h2><p>执行<code>git clone [url]</code></p>
<ul>
<li><p>将远程仓库克隆到本地</p>
</li>
<li><p><code>[url]</code>：远程仓库的URL</p>
</li>
</ul>
<h2 id="10-git-commit"><a href="#10-git-commit" class="headerlink" title="10. git commit"></a>10. <code>git commit</code></h2><p>提交缓存到本体仓库</p>
<p><code>git commit -m &quot;add files&quot;</code></p>
<ul>
<li><strong>提交</strong>缓存到本地仓库并<strong>设置摘要</strong>(<code>add files</code>)</li>
</ul>
<p><img data-src="/images/10-Git%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%91%BD%E4%BB%A4/image-20211019192735436.png" alt="image-20211019192735436"></p>
<br>

<h2 id="11-git-log"><a href="#11-git-log" class="headerlink" title="11. git log"></a>11. <code>git log</code></h2><p>显示<strong>一个分支</strong>中提交的更改记录</p>
<ul>
<li><strong>不同分支</strong>的提交记录<strong>互相独立</strong></li>
</ul>
<br>

<h2 id="12-git-merge"><a href="#12-git-merge" class="headerlink" title="12. git merge"></a>12. <code>git merge</code></h2><p>将<strong>目标分支</strong>合并到你的<strong>当前分支</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master	<span class="comment">//当前处于mster分支</span></span><br><span class="line">  removals</span><br><span class="line">$ git merge removals	<span class="comment">//将removals分支合并到master分支(当前分支)</span></span><br></pre></td></tr></table></figure>

<p>当前分支(master)被removals分支覆盖</p>
<br>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li><p>本地仓库的缓存区是<strong>多个分支共享的</strong></p>
<ul>
<li>多个分支执行<code>git add ...</code> 命令会将文件加入同一个缓存区</li>
</ul>
</li>
<li><p>但是本地仓库分支的<strong>提交是独立的</strong></p>
<ul>
<li>在test分支下执行<code>git commit ...</code>命令进行提交</li>
<li>会将缓存区内容提交到test分支(<strong>更新test分支</strong>)</li>
<li>其他分支仍<strong>维持它们上次提交后的状态</strong></li>
</ul>
</li>
<li><p>仓库的<strong>多个分支之间是互相独立的</strong></p>
<ul>
<li>对于login分支进行修改并提交后，只有login分支被更新，其他分支仍维持其上次提交后的状态</li>
</ul>
</li>
<li><p>各个本地仓库的remote是独立的</p>
<ul>
<li>例如 仓库1: <code> git remote add origin [url1]</code> </li>
<li>仓库2: <code>git remote add origin [url2]</code></li>
<li><strong>两个origin不同</strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>10-Vuex案例 todoList</title>
    <url>/2021/09/20/10-Vuex%E6%A1%88%E4%BE%8BtodoList/</url>
    <content><![CDATA[<h1 id="Vuex案例-todoList"><a href="#Vuex案例-todoList" class="headerlink" title="Vuex案例 todoList"></a>Vuex案例 todoList</h1><h2 id="1-项目初始化"><a href="#1-项目初始化" class="headerlink" title="1.项目初始化"></a>1.项目初始化</h2><ul>
<li><p>项目目录</p>
<p><code>E:\1前端学习资料和代码\1-23 学习代码\17-Vue基础代码\06-Vuex\02-vuex-todolist</code></p>
</li>
</ul>
<p><img data-src="/images/10-Vuex%E6%A1%88%E4%BE%8BtodoList/image-20220412200231243.png" alt="image-20220412200231243"></p>
<span id="more"></span>

<ul>
<li>依赖版本</li>
</ul>
<p><img data-src="/images/10-Vuex%E6%A1%88%E4%BE%8BtodoList/image-20220412200253363.png" alt="image-20220412200253363"></p>
<br>

<h2 id="2-获取list数据"><a href="#2-获取list数据" class="headerlink" title="2.获取list数据"></a>2.获取list数据</h2><p><code>App.vue</code>组件的created钩子中调用store实例的actions方法</p>
<p>actions方法使用axios异步获取<code>list.json</code>中的数据</p>
<p><code>App.vue</code>通过调用<code>...mapState</code><strong>将state数据映射为计算属性后使用</strong></p>
<h2 id="3-input输入域数据绑定"><a href="#3-input输入域数据绑定" class="headerlink" title="3.input输入域数据绑定"></a>3.input输入域数据绑定</h2><p>与state.inputValue绑定</p>
<p>输入域change事件触发，调用<code>mutations</code>函数修改inputValue</p>
<h2 id="4-增加任务"><a href="#4-增加任务" class="headerlink" title="4.增加任务"></a>4.增加任务</h2><p>点击添加，根据<code>state.inputValue</code>进行添加</p>
<h2 id="5-删除任务"><a href="#5-删除任务" class="headerlink" title="5.删除任务"></a>5.删除任务</h2><p>根据id删除</p>
<h2 id="6-复选框状态绑定"><a href="#6-复选框状态绑定" class="headerlink" title="6.复选框状态绑定"></a>6.复选框状态绑定</h2><h2 id="7-修改复选框状态"><a href="#7-修改复选框状态" class="headerlink" title="7.修改复选框状态"></a>7.修改复选框状态</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a-checkbox</span> @<span class="attr">change</span>=<span class="string">&quot;(e) =&gt; &#123;checkboxChange(e,item.id)&#125;&quot;</span> <span class="attr">:checked</span>=<span class="string">&quot;item.done&quot;</span>&gt;</span>&#123;&#123;item.info&#125;&#125;<span class="tag">&lt;/<span class="name">a-checkbox</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取事件对象的同时传递参数</span></span><br><span class="line">(e) =&gt; &#123;checkboxChange(e,item.id)&#125;	<span class="comment">//change事件处理函数</span></span><br></pre></td></tr></table></figure>

<h2 id="8-计算未完成任务数目"><a href="#8-计算未完成任务数目" class="headerlink" title="8.计算未完成任务数目"></a>8.计算未完成任务数目</h2><p>通过getters根据state数据 计算出<strong>未完成数目(新数据)</strong></p>
<p>将getters<strong>映射为App.vue的计算属性</strong></p>
<h2 id="9-清除已完成任务"><a href="#9-清除已完成任务" class="headerlink" title="9.清除已完成任务"></a>9.清除已完成任务</h2><p>过滤出list数组中<code>done=false</code>的任务</p>
<h2 id="10-点击下方三个按钮改变样式"><a href="#10-点击下方三个按钮改变样式" class="headerlink" title="10.点击下方三个按钮改变样式"></a>10.点击下方三个按钮改变样式</h2><p>根据state.key值设置按钮的样式，点击按钮修改<code>state.key</code>值以实现样式的改变</p>
<h2 id="11-切换显示不同状态的任务"><a href="#11-切换显示不同状态的任务" class="headerlink" title="11.切换显示不同状态的任务"></a>11.切换显示不同状态的任务</h2><p>使用getters，根据key值(当前要显示的任务的状态)返回相应的任务列表</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前选择显示的任务列表</span></span><br><span class="line"><span class="function"><span class="title">infoList</span>(<span class="params">state</span>)</span> &#123;	<span class="comment">//getters</span></span><br><span class="line">    <span class="keyword">if</span>(state.key === <span class="string">&#x27;all&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.list</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state.key === <span class="string">&#x27;undone&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.list.filter(<span class="function"><span class="params">x</span> =&gt;</span> !x.done)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state.key === <span class="string">&#x27;done&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.list.filter(<span class="function"><span class="params">x</span> =&gt;</span> x.done)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state.list</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>组件复用</title>
    <url>/2022/11/27/10-%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h1 id="组件复用"><a href="#组件复用" class="headerlink" title="组件复用"></a>组件复用</h1><p>若<strong>两个组件中的部分功能相似</strong>，可以通过组件复用 (复用相似的功能) 的方式来优化程序</p>
<p>例如：同样需要使用鼠标相对于浏览器可视窗口坐标的组件，可以复用<strong>记录坐标的状态</strong>和<strong>其操作方法</strong>。</p>
<ul>
<li><p>复用什么：</p>
<ul>
<li>state状态 </li>
<li>操作状态的方法</li>
</ul>
</li>
<li><p>两种复用方式：</p>
<ul>
<li><code>render props</code>模式</li>
<li>高阶组件(HOC)</li>
</ul>
</li>
<li><p>两种复用方式<strong>不是新API</strong>，而是由React自身特点的编码技巧演化而成的<strong>固定模式</strong>。</p>
</li>
</ul>
<span id="more"></span>

<br>

<h2 id="1-render-props模式"><a href="#1-render-props模式" class="headerlink" title="1. render props模式"></a>1. render props模式</h2><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p><img data-src="/images/10-%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8/image-20220403201750221.png" alt="image-20220403201750221"></p>
<br>

<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p><img data-src="/images/10-%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8/image-20220403203417088.png" alt="image-20220403203417088"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;render props模式&lt;/h1&gt;</span><br><span class="line">        &#123;<span class="comment">/* render函数prop */</span>&#125;</span><br><span class="line">        &lt;Text render=&#123;<span class="function">(<span class="params">mouse</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>鼠标坐标为:&#123;mouse.x&#125; &#123;mouse.y&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">        &#125;&#125;&gt;&lt;/Text&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Text组件，实现鼠标坐标(状态)的复用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Text</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">//复用的状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    x:<span class="number">0</span>,</span><br><span class="line">    y:<span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//组件挂载完钩子</span></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//鼠标移动事件修改状态</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>,<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        x:e.clientX,</span><br><span class="line">        y:e.clientY</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//将复用状态作为render的参数，根据使用时render函数的返回值决定渲染的UI结构</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.props.render(<span class="built_in">this</span>.state)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Text</code>组件实现<strong>鼠标坐标状态</strong>的复用，复用后<strong>渲染的UI结构</strong>由使用者提供的render函数返回值决定。</li>
<li>render函数<strong>接收复用的状态逻辑</strong>，通过<strong>使用不同的返回值</strong>即可实现复用状态逻辑下的<strong>不同UI渲染</strong>。</li>
</ul>
<br>

<h3 id="复用的例子"><a href="#复用的例子" class="headerlink" title="复用的例子"></a>复用的例子</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">/* Text组件复用 渲染一个说明鼠标坐标的p标签 */</span>&#125;</span><br><span class="line">&lt;Text render=&#123;<span class="function">(<span class="params">mouse</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>鼠标坐标为:&#123;mouse.x&#125; &#123;mouse.y&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;&#125;&gt;&lt;/Text&gt;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">/* Text组件复用 渲染一个跟随鼠标移动的图片 */</span>&#125;</span><br><span class="line">&lt;Text render=&#123;<span class="function">(<span class="params">mouse</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//src值为引入的图片 style设置数值类型不加单位</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;img&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;logo&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="xml">                                            position: &#x27;absolute&#x27;,</span></span><br><span class="line"><span class="xml">                                            left: mouse.x - 100,</span></span><br><span class="line"><span class="xml">                                            top: mouse.y - 100,</span></span><br><span class="line"><span class="xml">                                            width: 200,</span></span><br><span class="line"><span class="xml">                                            height: 200,</span></span><br><span class="line"><span class="xml">                                           &#125;&#125;&gt;<span class="tag">&lt;/<span class="name">img</span>&gt;</span></span></span><br><span class="line">&#125;&#125;&gt;&lt;/Text&gt;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="使用children形式替代render"><a href="#使用children形式替代render" class="headerlink" title="使用children形式替代render"></a>使用children形式替代render</h3><p>使用<code>render-props</code>模式实现组件复用，<strong>并不意味着该prop函数必须名为render</strong>，使用<strong>其他形式</strong>达到相同目的即使用了 <code>render-props</code>模式。</p>
<p>例如：</p>
<p>使用<code>props.children</code>的形式代替<code>render</code>可以<strong>更直观</strong>的进行复用</p>
<p>将<strong>本来的render函数</strong>作为<strong>复用组件的子节点</strong>通过<code>props.children</code>方式调用更直观</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">/* render函数prop形式复用 */</span>&#125;</span><br><span class="line">&#123;<span class="comment">/* &lt;Text render=&#123;(mouse) =&gt; &#123;</span></span><br><span class="line"><span class="comment">        return &lt;p&gt;鼠标坐标为:&#123;mouse.x&#125; &#123;mouse.y&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">   &#125;&#125;&gt;&lt;/Text&gt; */</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">/* 使用props.children代替render以更直观形式复用 */</span>&#125;</span><br><span class="line">&lt;Text&gt;</span><br><span class="line">    <span class="comment">//Text组件props的children属性</span></span><br><span class="line">    &#123;<span class="function">(<span class="params">mouse</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>鼠标坐标为:&#123;mouse.x&#125; &#123;mouse.y&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &#125;&#125;</span><br><span class="line">&lt;/Text&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Text组件的render方法</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//调用props.children渲染复用后显示的UI结构</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.props.children(<span class="built_in">this</span>.state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>props.children代替render</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Consumer&gt;</span><br><span class="line">        &#123; <span class="function"><span class="params">data</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>接收的数据:&#123;data&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;</span><br><span class="line">&lt;/Consumer&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>组件通信的Context方式中的Consumer数据消费者组件，也使用了<code>props.children</code>形式进行复用。</li>
</ul>
<br>

<h3 id="例子中的代码优化"><a href="#例子中的代码优化" class="headerlink" title="例子中的代码优化"></a>例子中的代码优化</h3><p>1.使用<code>prop-types</code>模块进行<code>props</code>验证，规定<code>props.children</code>为<strong>函数且必填</strong>。</p>
<p>2.在组件卸载时<strong>清除window的鼠标移动事件绑定</strong>。</p>
<br>

<h2 id="2-高阶组件"><a href="#2-高阶组件" class="headerlink" title="2.高阶组件"></a>2.高阶组件</h2><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>采用包装模式</p>
<p><img data-src="/images/10-%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8/image-20220403212133391.png" alt="image-20220403212133391"></p>
<ul>
<li>由<code>WrappedComponent</code>组件决定复用状态后渲染的UI结构。</li>
</ul>
<br>

<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p><img data-src="/images/10-%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8/image-20220403212957517.png" alt="image-20220403212957517"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建高阶组件(一个函数) 参数为要包装增强的组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withMouse</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个类组件 提供复用的状态</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="comment">//复用状态</span></span><br><span class="line">        state = &#123;</span><br><span class="line">            x: <span class="number">0</span>,</span><br><span class="line">            y: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移动事件处理函数 状态逻辑处理</span></span><br><span class="line">        movehandle = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                x: e.clientX,</span><br><span class="line">                y: e.clientY</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//挂载完添加移动事件</span></span><br><span class="line">        <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>, <span class="built_in">this</span>.movehandle)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//卸载时清除移动事件绑定</span></span><br><span class="line">        <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">window</span>.removeEventListener(<span class="string">&#x27;mousemove&#x27;</span>, <span class="built_in">this</span>.movehandle)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">//返回增强后的组件</span></span><br><span class="line">            <span class="keyword">return</span> &lt;WrappedComponent&gt;</span><br><span class="line">                &#123;<span class="comment">/* 复用的数据 */</span>&#125;</span><br><span class="line">                &#123;<span class="built_in">this</span>.state&#125;</span><br><span class="line">            &lt;/WrappedComponent&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回Mouse组件渲染的增强组件</span></span><br><span class="line">    <span class="keyword">return</span> Mouse</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 显示坐标组件</span></span><br><span class="line"><span class="keyword">let</span> Position = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>鼠标的坐标为：&#123;props.children.x&#125; &#123;props.children.y&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 图片跟随组件</span></span><br><span class="line"><span class="keyword">let</span> Logo = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;img&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;logo&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="xml">        position: &#x27;absolute&#x27;,</span></span><br><span class="line"><span class="xml">        left: props.children.x - 100,</span></span><br><span class="line"><span class="xml">        top: props.children.y - 100,</span></span><br><span class="line"><span class="xml">        width: 200,</span></span><br><span class="line"><span class="xml">        height: 200,</span></span><br><span class="line"><span class="xml">    &#125;&#125;&gt;<span class="tag">&lt;/<span class="name">img</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用高阶组件返回复用后增强组件 被包装的组件要提前声明</span></span><br><span class="line"><span class="keyword">const</span> MousePosition = withMouse(Position)</span><br><span class="line"><span class="keyword">const</span> MouseLogo = withMouse(Logo)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;高阶组件&lt;/h1&gt;</span><br><span class="line">                &#123;<span class="comment">/* 使用复用后的增强组件 */</span>&#125;</span><br><span class="line">                &lt;MousePosition /&gt;</span><br><span class="line">                &lt;MouseLogo/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="设置displayName"><a href="#设置displayName" class="headerlink" title="设置displayName"></a>设置displayName</h3><p>高阶组件创建的多个增强组件在调试工具(React developer tools)中显示为一个组件名称，不利于调试分辨。</p>
<p><img data-src="/images/10-%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8/image-20220403223141935.png" alt="image-20220403223141935"></p>
<ul>
<li>此处<strong>高阶函数返回值为Mouse组件</strong>，所以渲染时两个增强组件均是被Mouse组件包裹</li>
</ul>
<p><img data-src="/images/10-%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8/image-20220403223226473.png" alt="image-20220403223226473"></p>
<p><img data-src="/images/10-%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8/image-20220403223455030.png" alt="image-20220403223455030"></p>
<p>设置<code>displayName</code>后的两个增强组件更易于区分，都由高阶组件<code>withMouse</code>生成，再加上各自功能名称。</p>
<br>

<h3 id="传递props"><a href="#传递props" class="headerlink" title="传递props"></a>传递props</h3><p><strong>增强组件：</strong>高阶组件返回的其<strong>内部定义的类组件</strong>(类组件渲染复用状态的原组件)</p>
<p>向高阶组件包装过的增强组件添加props后，原组件(被包装组件)取不到该值。</p>
<p><strong>原因：</strong>高阶组件<strong>返回值为其内部创建的类组件</strong>(上例中为Mouse)，而这个类组件渲染的UI结构是<strong>复用状态的原组件</strong>。向<strong>增强组件(高阶函数返回值)<strong>传递的props</strong>实际只传递给了Mouse组件</strong>，而Mouse组件并没有向原组件中传递。</p>
<p><strong>解决办法：</strong>手动让Mouse组件将props传递给原组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//返回复用状态的被包装组件 传递复用状态 和 props</span></span><br><span class="line">    <span class="comment">//此处 对象扩展运算符得到的结果直接作为组件标签属性 是JSX实现的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.state</span>&#125; &#123;<span class="attr">...this.props</span>&#125;&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">WrappedComponent</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>高阶组件中Mouse组件的render函数</center>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>高阶组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    &#123;/* 使用复用后的增强组件 */&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">MousePosition</span> /&gt;</span></span><br><span class="line">    &#123;/* 传递props */&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">MouseLogo</span> <span class="attr">a</span>=<span class="string">&#x27;1&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<center>Parent组件渲染的UI结构</center>

<p><img data-src="/images/10-%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8/image-20220403224658929.png" alt="image-20220403224658929"></p>
<ul>
<li>原组件接收到向增强组件(高阶函数返回值)传递的props</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>10-JS闭包</title>
    <url>/2022/12/04/10-%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>js<strong>变量的作用域</strong>有两种：局部变量和全局变量</p>
<ul>
<li>函数内部可以直接读取其外部作用域的变量(作用域链原理)</li>
<li>而函数外部无法读取函数内部的局部变量<ul>
<li>函数内部声明变量时，若不使用var声明而直接赋值，<span style="color:red">相当于声明了一个全局变量</span></li>
</ul>
</li>
</ul>
<p>为了在<strong>函数A</strong>外部访问<strong>函数A</strong>内部的局部变量，<strong>需要在函数A的内部再定义一个内层函数B</strong>，在<strong>内层函数B</strong>中获取<strong>函数A</strong>的局部变量，然后通过返回值等方法在外部得到这个<strong>内层函数B</strong>，这样就可以在<strong>函数A外部</strong>通过调用<strong>函数B</strong>来获取<strong>函数A内部</strong>的局部变量。</p>
<p>对于下面的代码，通过返回值得到内层函数<code>fun()</code>后，即可在<code>fn()</code>函数外部读取它的局部变量</p>
<ul>
<li>闭包：<strong>一个函数</strong>和<strong>对其外部作用域的引用</strong>捆绑在一起，这个<strong>组合</strong>称为闭包。(下例中<strong>fun函数</strong>和<strong>对fn函数局部作用域的引用</strong>捆绑在一起，产生闭包)</li>
<li>闭包可以实现<span style="color:red">在函数外部访问函数的局部作用域</span>，内层函数称为<strong>闭包函数</strong>。</li>
</ul>
<span id="more"></span>

<br>

<p>js特有的<code>&#39;链式作用域&#39;</code>：</p>
<ul>
<li>子作用域会一级一级地向上寻找（从<strong>定义处</strong>一级一级向上）所有祖先作用域的变量。所以，祖先作用域的所有变量，对后代作用域(子作用域)都是可见的，反之则不成立。</li>
<li>即<code>fn()</code>函数中的局部变量对于<code>fun()</code>函数都是可见的，但是<code>fun()</code>函数的局部变量对于<code>fn()</code>函数不可见</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">var</span> num=<span class="number">1</span>;	<span class="comment">//num是一个局部变量</span></span><br><span class="line">          a = <span class="number">2</span> 	<span class="comment">//a是一个全局变量</span></span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(num);   </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> fun</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> f=fn();</span><br></pre></td></tr></table></figure>

<ul>
<li><code>fun()</code>函数对其<strong>外部作用域</strong>(fn的局部作用域)有引用，<strong>一个函数</strong>与<strong>对其外部作用域的引用</strong>绑定，产生了闭包，<code>fun()</code>为闭包函数。</li>
</ul>
<h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><h3 id="1-在函数外部读取到函数内部的变量值"><a href="#1-在函数外部读取到函数内部的变量值" class="headerlink" title="1.在函数外部读取到函数内部的变量值"></a>1.在函数外部读取到函数内部的变量值</h3><p>即对于上面的代码，当<strong>f函数</strong>在全局环境下执行时，其可以获取<strong>fn函数</strong>中的num局部变量的值</p>
<h3 id="2-延伸变量的作用范围"><a href="#2-延伸变量的作用范围" class="headerlink" title="2.延伸变量的作用范围"></a>2.延伸变量的作用范围</h3><p>即产生闭包后，<code>fn()</code>函数的<span style="color:red">局部变量值始终保存在内存中</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//延申变量的作用范围</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">9</span></span><br><span class="line">    <span class="comment">//add是一个全局变量</span></span><br><span class="line">    add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        num+=<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fun</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = fn()</span><br><span class="line">f() 	<span class="comment">//输出9</span></span><br><span class="line">add()   <span class="comment">//对fn的局部变量num进行加一操作</span></span><br><span class="line">f()		<span class="comment">//输出10//闭包的作用：延伸变量作用范围</span></span><br></pre></td></tr></table></figure>

<p>正常情况下，fn函数执行完后就会销毁其中的局部变量</p>
<p>现在产生了<strong>闭包</strong>，<strong>fun被赋值给一个全局变量，全局变量不回收导致fun会留存在内存中，而fun依赖于fn的局部作用域，所以fn局部作用域的变量也会留存在内存中，即使fn函数执行完，fn中的局部变量也不会被销毁</strong>，<span style="color:red">这样就延伸了变量的作用范围</span></p>
<p>通过下述代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f() 	&#x2F;&#x2F;输出9</span><br><span class="line">add()   &#x2F;&#x2F;对fn的局部变量num进行加一操作</span><br><span class="line">f()		&#x2F;&#x2F;输出10</span><br></pre></td></tr></table></figure>

<p>在fn函数执行完后，使用add方法对fn的局部变量进行加一操作<strong>生效</strong>，说明fn局部变量的作用范围确实延伸了（留在内存中）</p>
<ul>
<li>add全局变量这个匿名函数<strong>实际上也是一个闭包</strong>，可以通过add变量操作fn函数的局部变量</li>
</ul>
<br>

<h3 id="3-使用闭包建立私有数据"><a href="#3-使用闭包建立私有数据" class="headerlink" title="3.使用闭包建立私有数据"></a>3.使用闭包建立私有数据</h3><p>例如下文 cache实例，<strong>data对象是一个私有数据</strong>，仅能通过<code>cache</code>函数返回的<code>get</code>和<code>set</code>方法操作。</p>
<br>

<h2 id="两个判断闭包问题"><a href="#两个判断闭包问题" class="headerlink" title="两个判断闭包问题"></a>两个判断闭包问题</h2><h3 id="第一个"><a href="#第一个" class="headerlink" title="第一个"></a>第一个</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">&quot;Window&quot;</span>;<span class="comment">//定义全局变量name</span></span><br><span class="line">        <span class="comment">//1.第一个</span></span><br><span class="line">        <span class="keyword">var</span> o1=&#123;</span><br><span class="line">            name:<span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">            getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="built_in">console</span>.log(o1.getName()());</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此处o1的方法getName为一个函数</p>
</li>
<li><p>o1.getName方法的返回值为一个匿名函数</p>
<ul>
<li>```js<br>function(){<pre><code>        return this.name;
      &#125;
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;o1.getName()()&#96;即先执行&#96;o1.getName()&#96;，返回一个匿名函数，再执行这个返回的匿名函数</span><br><span class="line"></span><br><span class="line">- 此时执行匿名函数时，函数内部this已经指向window，所以**会输出&#39;Window&#39;**</span><br><span class="line"></span><br><span class="line">- 本问题中**没有闭包产生**</span><br><span class="line"></span><br><span class="line">  - 匿名函数中**使用的变量name为全局环境下的name**，没有使用另一个函数作用域中的变量</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">### 第二个</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">&#x2F;&#x2F;2.第二个</span><br><span class="line">        var o2&#x3D;&#123;</span><br><span class="line">            name:&quot;My Object&quot;,</span><br><span class="line">            getName:function()&#123;</span><br><span class="line">                let that&#x3D;this;  &#x2F;&#x2F;局部变量that指向调用本方法的对象o2</span><br><span class="line">                return function()&#123;</span><br><span class="line">                    return that.name;   &#x2F;&#x2F;此时that&#x3D;o2</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(o2.getName()());&#x2F;&#x2F;输出My Object</span><br><span class="line">        &#x2F;&#x2F;此时getName函数返回值中的匿名函数调用了getName函数作用域中的局部变量that</span><br><span class="line">        &#x2F;&#x2F;所以存在闭包 闭包函数为getName()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>getName方法中使用that变量保存其this指向后，<strong>返回值函数中又调用了that</strong></p>
</li>
<li><p>在函数外部调用返回的匿名函数时，因为<strong>that的作用范围扩大</strong>，此时匿名函数中的that即指向调用getName的对象o2</p>
</li>
<li><p>所以返回’My Object’，匿名函数调用了getName方法中的变量that，<strong>形成闭包</strong></p>
</li>
</ul>
<h2 id="闭包的缺点"><a href="#闭包的缺点" class="headerlink" title="闭包的缺点"></a>闭包的缺点</h2><p>闭包在<strong>处理速度</strong>和<strong>内存消耗方面</strong>对脚本性能具有<strong>负面影响</strong>。</p>
<p><strong>过多的闭包会导致性能下降</strong>（内存空间得不到释放）</p>
<h2 id="消除闭包的缺点带来的影响"><a href="#消除闭包的缺点带来的影响" class="headerlink" title="消除闭包的缺点带来的影响"></a>消除闭包的缺点带来的影响</h2><p>因为闭包会导致<strong>外层函数的局部变量留在内存中得不到释放</strong>，如果脚本中存在大量闭包，会导致大量内存得不到释放而降低性能。</p>
<p><span style="color:red">解决方法是：在退出函数之前，将不使用的局部变量全部删除。(num = undefined)</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//退出函数之前删除不使用的局部变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">9</span></span><br><span class="line">    add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        num+=<span class="number">1</span></span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    del = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        num = <span class="literal">undefined</span>	<span class="comment">//删除局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fun</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = fn()</span><br><span class="line">del()	<span class="comment">//删除局部变量num</span></span><br><span class="line">f()		<span class="comment">//输出undefined</span></span><br></pre></td></tr></table></figure>

<p>可以在函数外部<strong>完成对局部变量num的使用后</strong>调用del函数删除局部变量</p>
<ul>
<li>del函数定义在fn函数中，在调用fn函数后，del函数才被注册为全局函数</li>
</ul>
<br>

<h2 id="闭包的应用场景"><a href="#闭包的应用场景" class="headerlink" title="闭包的应用场景"></a>闭包的应用场景</h2><h3 id="做一个缓存器cache"><a href="#做一个缓存器cache" class="headerlink" title="做一个缓存器cache"></a>做一个缓存器cache</h3><p>把计算结果存储在data对象中，需要再次使用时直接取data中的数据，<strong>避免重复计算</strong></p>
<p><code>cache</code>函数返回一个对象，对象中的<strong>两个方法</strong>为<strong>共享同一个外部作用域的闭包</strong></p>
<ul>
<li><p><code>data</code>数据<strong>在函数外部不能直接访问</strong>，只能通过<strong>返回的两个公共函数</strong>访问。</p>
</li>
<li><p>作用：模拟<strong>类的私有属性/方法</strong>，限制对代码的访问。(限制对<strong>私有属性data</strong>的访问)</p>
</li>
<li><p>多次调用<code>cache</code>方法得到的多个对象，其<strong>数据空间是独立的</strong>。</p>
<ul>
<li>```js<br>var fn = cache()<br>var cn = cache()<br>//fn和cn使用get和set方法操作的是各自独立的data数据<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">function cache()&#123;</span><br><span class="line">    var data&#x3D;&#123;&#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        &#x2F;&#x2F;设置data中的数据</span><br><span class="line">        set:function(key,val)&#123;</span><br><span class="line">            data[key] &#x3D; val</span><br><span class="line">            console.log(&#39;the new data[&#39; + key + &#39;] is &#39;+ data[key]);</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F;获取data中的数据</span><br><span class="line">        get:function(key)&#123;</span><br><span class="line">            console.log(&#39;data[&#39; + key + &#39;]: &#39; + data[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn &#x3D; cache()</span><br><span class="line">fn.set(&#39;name&#39;,&#39;zhangsan&#39;)</span><br><span class="line">console.log(&#39;--------------&#39;);</span><br><span class="line">fn.get(&#39;name&#39;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><img data-src="/images/10-%E9%97%AD%E5%8C%85/image-20211015124318136.png" alt="image-20211015124318136"></p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>隐藏元素方法</title>
    <url>/2022/11/27/10-%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="隐藏元素方法"><a href="#隐藏元素方法" class="headerlink" title="隐藏元素方法"></a>隐藏元素方法</h1><h2 id="visibility-hidden"><a href="#visibility-hidden" class="headerlink" title="visibility=hidden"></a>visibility=hidden</h2><p>visibility=hidden，该元素隐藏起来了，但<strong>不会改变页面布局</strong>，但是<strong>不会触发该元素已经绑定的事件</strong></p>
<h2 id="opacity-0"><a href="#opacity-0" class="headerlink" title="opacity=0"></a>opacity=0</h2><p>该元素隐藏起来了，但<strong>不会改变页面布局</strong>，并且，如果该元素<strong>已经绑定一些事件</strong>，如click事件，那么点击该区域，<strong>也能触发点击事件</strong></p>
<h2 id="display-none"><a href="#display-none" class="headerlink" title="display:none"></a>display:none</h2><p>把元素隐藏起来，并且<strong>会改变页面布局</strong>，可以理解成在页面中把该元素删除掉一样</p>
<ul>
<li>从标准流中移除，不占据位置</li>
</ul>
]]></content>
      <categories>
        <category>HTMLandCss</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>页面事件</title>
    <url>/2022/11/27/10-%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="页面事件"><a href="#页面事件" class="headerlink" title="页面事件"></a>页面事件</h1><h2 id="1-下拉刷新"><a href="#1-下拉刷新" class="headerlink" title="1.下拉刷新"></a>1.下拉刷新</h2><p><img data-src="/images/10-%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6/image-20220220200245428.png" alt="image-20220220200245428"></p>
<span id="more"></span>

<h3 id="1-1-下拉刷新窗口样式"><a href="#1-1-下拉刷新窗口样式" class="headerlink" title="1.1 下拉刷新窗口样式"></a>1.1 下拉刷新窗口样式</h3><p><img data-src="/images/10-%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6/image-20220220200403134.png" alt="image-20220220200403134"></p>
<h3 id="1-2-下拉刷新事件监听"><a href="#1-2-下拉刷新事件监听" class="headerlink" title="1.2 下拉刷新事件监听"></a>1.2 下拉刷新事件监听</h3><p>页面.js文件中，通过<code>onPullDownRefresh()</code>函数监听下拉刷新事件</p>
<h3 id="1-3-手动停止下拉刷新的loading效果"><a href="#1-3-手动停止下拉刷新的loading效果" class="headerlink" title="1.3 手动停止下拉刷新的loading效果"></a>1.3 手动停止下拉刷新的loading效果</h3><p>下拉刷新在真机上有时刷新完后不会自动清除loading效果</p>
<p>通过在<code>onPullDownRefresh()</code>函数中调用<code>wx.stopPullDownRefresh()</code>方法手动关闭loading效果</p>
<br>

<h2 id="2-上拉触底"><a href="#2-上拉触底" class="headerlink" title="2. 上拉触底"></a>2. 上拉触底</h2><p><img data-src="/images/10-%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6/image-20220220201823117.png" alt="image-20220220201823117"></p>
<p>小程序中上拉触底多用于实现分页效果</p>
<p><img data-src="/images/10-%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6/image-20220220202058312.png" alt="image-20220220202058312"></p>
<h3 id="2-1-上拉触底距离配置"><a href="#2-1-上拉触底距离配置" class="headerlink" title="2.1 上拉触底距离配置"></a>2.1 上拉触底距离配置</h3><p><img data-src="/images/10-%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6/image-20220220202520184.png" alt="image-20220220202520184"></p>
<p><code>onReachBottomDistance</code>属性默认单位为px </p>
<h3 id="2-2-案例-上拉触底显示颜色板"><a href="#2-2-案例-上拉触底显示颜色板" class="headerlink" title="2.2 案例:上拉触底显示颜色板"></a>2.2 案例:上拉触底显示颜色板</h3><p><img data-src="/images/10-%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6/image-20220220212832455.png" alt="image-20220220212832455"></p>
<h4 id="2-2-1-获取随机颜色方法"><a href="#2-2-1-获取随机颜色方法" class="headerlink" title="2.2.1 获取随机颜色方法"></a>2.2.1 获取随机颜色方法</h4><p><img data-src="/images/10-%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6/image-20220220213656886.png" alt="image-20220220213656886"></p>
<br>

<h4 id="2-2-2-渲染UI结构"><a href="#2-2-2-渲染UI结构" class="headerlink" title="2.2.2 渲染UI结构"></a>2.2.2 渲染UI结构</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;color-item&quot;</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;colorList&#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;index&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: rgba(&#123;&#123;item&#125;&#125;);&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>colorList</code>的元素动态绑定view组件的背景颜色(<code>rgba</code>)</p>
<p><img data-src="/images/10-%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6/image-20220220214831522.png" alt="image-20220220214831522"></p>
<h4 id="2-2-3-上拉触底处理函数中调用获取颜色方法"><a href="#2-2-3-上拉触底处理函数中调用获取颜色方法" class="headerlink" title="2.2.3 上拉触底处理函数中调用获取颜色方法"></a>2.2.3 上拉触底处理函数中调用获取颜色方法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 页面上拉触底事件的处理函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    onReachBottom: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.getColors()</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-添加loading提示效果"><a href="#2-2-4-添加loading提示效果" class="headerlink" title="2.2.4 添加loading提示效果"></a>2.2.4 添加loading提示效果</h4><p><img data-src="/images/10-%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6/image-20220220215915781.png" alt="image-20220220215915781"></p>
<h4 id="2-2-5-上拉触底节流"><a href="#2-2-5-上拉触底节流" class="headerlink" title="2.2.5 上拉触底节流"></a>2.2.5 上拉触底节流</h4><p>防止用户短时间内多次上拉触底造成<strong>频繁发送请求</strong>的问题</p>
<p><img data-src="/images/10-%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6/image-20220220220517855.png" alt="image-20220220220517855"></p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS新属性</title>
    <url>/2022/11/27/11-CSS3%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="CSS3新增属性"><a href="#CSS3新增属性" class="headerlink" title="CSS3新增属性"></a>CSS3新增属性</h1><h2 id="1-CSS3边框："><a href="#1-CSS3边框：" class="headerlink" title="1.CSS3边框："></a>1.CSS3边框：</h2><ul>
<li><strong>border-radius：CSS3圆角边框</strong>。在 CSS2 中添加圆角矩形需要技巧，我们必须为每个圆角使用不同的图片，在 CSS3 中，创建圆角是非常容易的，在 CSS3 中，border-radius 属性用于创建圆角。border：2px solid;</li>
<li><strong>box-shadow：CSS3边框阴影</strong>。在 CSS3 中，box-shadow 用于向方框添加阴影。box-shadow:10px 10px 5px #888888;</li>
<li><strong>border-image：CSS3边框图片</strong>。通过 CSS3 的 border-image 属性，您可以使用图片来创建边框。border-image：url(border.png) 30 30 round;</li>
</ul>
<span id="more"></span>

<h2 id="2-CSS3背景："><a href="#2-CSS3背景：" class="headerlink" title="2.CSS3背景："></a>2.CSS3背景：</h2><ul>
<li><strong>background-size： 属性规定背景图片的尺寸</strong>。在 CSS3 之前，背景图片的尺寸是由图片的实际尺寸决定的。在 CSS3 中，可以规定背景图片的尺寸，这就允许我们在不同的环境中重复使用背景图片。您能够以像素或百分比规定尺寸。如果以百分比规定尺寸，那么尺寸相对于父元素的宽度和高度。</li>
<li>background-origin ：属性规定背景图片的定位区域。背景图片可以放置于 content-box、padding-box 或 border-box 区域。</li>
</ul>
<h2 id="3-CSS3文字效果："><a href="#3-CSS3文字效果：" class="headerlink" title="3.CSS3文字效果："></a>3.CSS3文字效果：</h2><ul>
<li><strong>text-shadow</strong>：在 CSS3 中，text-shadow 可向<strong>文本应用阴影</strong>。text-shadow:5px 5px 5px #FFFFFF;</li>
<li><strong>word-wrap</strong> :单词太长的话就可能无法超出某个区域，允许<strong>对长单词进行拆分</strong>，并换行到下一行：p{word-wrap:break-word;}</li>
</ul>
<h2 id="4-CSS3-2D转换："><a href="#4-CSS3-2D转换：" class="headerlink" title="4.CSS3 2D转换："></a>4.CSS3 2D转换：</h2><p>　　<strong>transform：通过 CSS3 转换，我们能够对元素进行移动、缩放、转动。</strong></p>
<ul>
<li><p><strong>translate()<strong>：元素</strong>从其当前位置移动</strong>，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数：transform：translate（50px,100px）;值 translate(50px,100px) 把元素从左侧移动 50 像素，从顶端移动 100 像素。</p>
</li>
<li><p><strong>rotate()<strong>：元素</strong>顺时针旋转给定的角度</strong>。允许<strong>负值，元素将逆时针旋转</strong>。transform:rotate(30deg);值 rotate(30deg) 把元素顺时针旋转 30 度。</p>
</li>
<li><p><strong>scale()</strong>:元素的<strong>尺寸会增加或减少</strong>，根据给定的宽度（X 轴）和高度（Y 轴）参数：transform:scale(2,4);值 scale(2,4) 把宽度转换为原始尺寸的 2 倍，把高度转换为原始高度的 4 倍。</p>
</li>
<li><p>skew():元素转动给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数：transform:skew(30deg,20deg);值 skew(30deg,20deg) 围绕 X 轴把元素转动 30 度，围绕 Y 轴转动 20 度。</p>
</li>
<li><p>matrix() :</p>
<p>matrix() 方法把所有 2D 转换方法组合在一起。</p>
<p>matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。</p>
</li>
</ul>
<h2 id="5-CSS3-3D转换："><a href="#5-CSS3-3D转换：" class="headerlink" title="5.CSS3 3D转换："></a>5.CSS3 3D转换：</h2><ul>
<li>rotateX()：元素围绕其 X 轴以给定的度数进行旋转。transform：rotateX(120deg);</li>
<li>rotateY()：元素围绕其 Y 轴以给定的度数进行旋转。transform：rotateY(120deg);</li>
</ul>
<h2 id="6-CSS3-过渡："><a href="#6-CSS3-过渡：" class="headerlink" title="6.CSS3 过渡："></a>6.CSS3 过渡：</h2><p>当元素从一种样式变换为另一种样式时为元素添加效果。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition</span>: <span class="string">&#x27;样式属性&#x27;</span> <span class="string">&#x27;时间&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>给多个样式属性设置过渡时使用<code>’,‘</code>隔开</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">      <span class="attribute">background-color</span>: red;</span><br><span class="line">      <span class="attribute">transition</span>: width <span class="number">2s</span>,height <span class="number">2s</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>鼠标经过时宽度和高度<strong>经过两秒</strong>变为500px</li>
</ul>
<h2 id="7-CSS3动画："><a href="#7-CSS3动画：" class="headerlink" title="7.CSS3动画："></a>7.CSS3动画：</h2><p>通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript。</p>
<h2 id="8-CSS3多列："><a href="#8-CSS3多列：" class="headerlink" title="8.CSS3多列："></a>8.CSS3多列：</h2><ul>
<li>column-count：属性规定元素应该被分隔的列数。</li>
<li>column-gap：属性规定列之间的间隔。</li>
<li>column-rule ：属性设置列之间的宽度、样式和颜色规则。</li>
</ul>
<h2 id="9-CSS3用户界面："><a href="#9-CSS3用户界面：" class="headerlink" title="9.CSS3用户界面："></a>9.CSS3用户界面：</h2><ul>
<li>resize：属性规定是否可由用户调整元素尺寸。</li>
<li><strong>box-sizing</strong>：属性允许您以确切的方式定义适应某个区域的具体内容。<strong>（盒模型）</strong></li>
<li>outline-offset ：属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。</li>
</ul>
]]></content>
      <categories>
        <category>HTMLandCss</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>React原理</title>
    <url>/2022/11/27/11-React%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="React原理"><a href="#React原理" class="headerlink" title="React原理"></a>React原理</h1><h2 id="1-setState-说明"><a href="#1-setState-说明" class="headerlink" title="1.setState()说明"></a>1.<code>setState()</code>说明</h2><p><img data-src="/images/11-React%E5%8E%9F%E7%90%86/image-20220404115410837.png" alt="image-20220404115410837"></p>
<ul>
<li>多次调用setState()方法，只会触发一次重新渲染(<strong>render方法执行一次</strong>)</li>
</ul>
<span id="more"></span>

<br>

<h3 id="推荐语法"><a href="#推荐语法" class="headerlink" title="推荐语法"></a>推荐语法</h3><p><img data-src="/images/11-React%E5%8E%9F%E7%90%86/image-20220404115950459.png" alt="image-20220404115950459"></p>
<ul>
<li>使用这种语法，<code>setState()</code><strong>仍然是异步更新数据</strong>。</li>
<li>这种语法每次得到的<code>state</code>都是<strong>最新的状态</strong>，这使得<span style="color:red;">下一个<code>setState()</code>依赖上一个<code>setState()</code>的写法可行。</span></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点击&#x27;增加&#x27;按钮事件</span></span><br><span class="line">handle = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//异步更新数据 原始语法</span></span><br><span class="line">    <span class="comment">// this.setState(&#123;</span></span><br><span class="line">    <span class="comment">//     count:this.state.count + 1 // 1 + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// this.setState(&#123;</span></span><br><span class="line">    <span class="comment">//     count:this.state.count + 1 // 1 + 1</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// console.log(this.state.count); // 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//推荐语法</span></span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function">(<span class="params">state,props</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            count:state.count + <span class="number">1</span> <span class="comment">// 1 + 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//依赖上一个setState()</span></span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function">(<span class="params">state,props</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//state是当前最新的状态</span></span><br><span class="line">        <span class="built_in">console</span>.log(state); <span class="comment">//&#123;count:2&#125;</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            count:state.count + <span class="number">1</span> <span class="comment">// 2 + 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//因为异步更新所以输出1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.count); <span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="第二个参数"><a href="#第二个参数" class="headerlink" title="第二个参数"></a>第二个参数</h3><p><img data-src="/images/11-React%E5%8E%9F%E7%90%86/image-20220404121757304.png" alt="image-20220404121757304"></p>
<ul>
<li>在<strong>状态更新且页面完成重新渲染后</strong>(render执行后)立即执行的函数，与<code>componentDidUpdate</code>钩子的执行时机相似。</li>
<li>可以在第二个参数中完成一些修改DOM的操作等。</li>
</ul>
<br>

<h2 id="2-JSX语法的转化过程"><a href="#2-JSX语法的转化过程" class="headerlink" title="2. JSX语法的转化过程"></a>2. JSX语法的转化过程</h2><p><img data-src="/images/11-React%E5%8E%9F%E7%90%86/image-20220404122323677.png" alt="image-20220404122323677"></p>
<ul>
<li>最后JSX和<code>createElement</code>创建的均为React元素</li>
</ul>
<p><img data-src="/images/11-React%E5%8E%9F%E7%90%86/image-20220404122512949.png" alt="image-20220404122512949"></p>
<center>打印JSX或createElement创建的React元素，结果相同</center>

<br>

<h2 id="3-组件更新机制"><a href="#3-组件更新机制" class="headerlink" title="3. 组件更新机制"></a>3. 组件更新机制</h2><p><img data-src="/images/11-React%E5%8E%9F%E7%90%86/image-20220404123105188.png" alt="image-20220404123105188"></p>
<center>Parent2更新，Parent2组件子树均更新</center>

<ul>
<li>当前组件被更新(重新渲染)，<strong>其本身</strong>和<strong>其所有子组件</strong>均会更新。<ul>
<li>其<strong>兄弟组件</strong>和<strong>父组件</strong>不受影响。</li>
</ul>
</li>
</ul>
<br>

<h2 id="4-组件性能优化"><a href="#4-组件性能优化" class="headerlink" title="4. 组件性能优化"></a>4. 组件性能优化</h2><h3 id="1-减轻state"><a href="#1-减轻state" class="headerlink" title="1.减轻state"></a>1.减轻state</h3><p><img data-src="/images/11-React%E5%8E%9F%E7%90%86/image-20220404123517847.png" alt="image-20220404123517847"></p>
<ul>
<li>对于<strong>需要在多个方法用到</strong>并且<strong>与组件渲染无关</strong>的数据，放在**this(组件实例)**中。<ul>
<li>例如定时器ID</li>
</ul>
</li>
</ul>
<br>

<h3 id="2-避免不必要的重新渲染"><a href="#2-避免不必要的重新渲染" class="headerlink" title="2.避免不必要的重新渲染"></a>2.避免不必要的重新渲染</h3><p><img data-src="/images/11-React%E5%8E%9F%E7%90%86/image-20220404125623459.png" alt="image-20220404125623459"></p>
<ul>
<li><code>nextProps</code>与<code>nextState</code>两个参数分别表示<strong>最新的props和state</strong></li>
<li>在<code>shouldComponentUpdate</code>钩子中，可以使用<code>this.state</code>获取更新前的状态<ul>
<li><strong>更新前的状态</strong> 与 <strong>最新的state</strong>比较结果，可以作为是否更新组件的依据。</li>
</ul>
</li>
</ul>
<br>

<h3 id="3-随机数性能优化案例"><a href="#3-随机数性能优化案例" class="headerlink" title="3.随机数性能优化案例"></a>3.随机数性能优化案例</h3><p>点击按钮生成随机数显示在页面上，当<strong>新生成的随机数与上次的值相同</strong>则不会重新渲染。</p>
<h4 id="1-利用state判断是否重新渲染"><a href="#1-利用state判断是否重新渲染" class="headerlink" title="1.利用state判断是否重新渲染"></a>1.利用state判断是否重新渲染</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//是否渲染的钩子函数</span></span><br><span class="line"><span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps,nextState</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//打印最新state和当前state</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;最新state:&#x27;</span>+ nextState.number,<span class="string">&#x27;当前state:&#x27;</span>+ <span class="built_in">this</span>.state.number);</span><br><span class="line">        <span class="comment">//相等返回false 不重新渲染</span></span><br><span class="line">        <span class="keyword">return</span> nextState.number !== <span class="built_in">this</span>.state.number </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//渲染方法</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;render&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">            随机值:&#123;<span class="built_in">this</span>.state.number&#125;</span><br><span class="line">            &lt;button onClick=&#123;<span class="built_in">this</span>.handle&#125;&gt;生成随机值&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<center>RandomExample.js</center>

<br>

<h4 id="2-利用props判断是否重新渲染"><a href="#2-利用props判断是否重新渲染" class="headerlink" title="2.利用props判断是否重新渲染"></a>2.利用props判断是否重新渲染</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;render&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">        	&#123;<span class="comment">/* 随机值:&#123;this.state.number */</span>&#125;</span><br><span class="line">        	&#123;<span class="comment">/*使用另一个组件Number显示随机值*/</span>&#125;</span><br><span class="line">        	&lt;<span class="built_in">Number</span> number=&#123;<span class="built_in">this</span>.state.number&#125;/&gt;	</span><br><span class="line">			&lt;button onClick=&#123;<span class="built_in">this</span>.handle&#125;&gt;生成随机值&lt;/button&gt;</span><br><span class="line">		&lt;/div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用一个Number组件渲染显示随机值，随机值<strong>使用props传入Number组件</strong></li>
<li>Number组件的<code>shouldComponentUpdate</code>钩子中<strong>依据更新前后props是否相同</strong>决定是否重新渲染。</li>
</ul>
<br>

<h3 id="4-使用纯组件避免不必要的重新渲染"><a href="#4-使用纯组件避免不必要的重新渲染" class="headerlink" title="4.使用纯组件避免不必要的重新渲染"></a>4.使用纯组件避免不必要的重新渲染</h3><p><strong>纯组件：</strong>使用class创建组件时继承<code>React.PureComponent</code>类。</p>
<ul>
<li>纯组件会<strong>自动检测更新前后的state和props是否改变</strong>(不需要手写<code>shouldComponentUpdate</code>钩子来判断)，如果改变则重新渲染组件，否则不重新渲染。</li>
</ul>
<br>

<h4 id="纯组件内部的比较原理"><a href="#纯组件内部的比较原理" class="headerlink" title="纯组件内部的比较原理"></a>纯组件内部的比较原理</h4><p>纯组件内部对比更新前后props和state采用的是<strong>浅层对比(shallow compare)</strong></p>
<p><strong>浅层对比：</strong></p>
<ul>
<li>对于值类型如(Number等)，比较更新前后的<strong>值内容</strong>。(无需特别注意)</li>
<li>对于<span style="color:red">引用类型(数组、对象等)</span>，比较更新前后的**引用(地址引用)**。</li>
</ul>
<p><strong>问题：</strong>若使用<code>setState()</code>方法<strong>修改引用类型数据时只修改内容</strong>，修改前后<strong>引用地址不变</strong>时，纯组件<strong>比较认为引用数据类型没有发生变化(引用地址相同)而不会重新渲染</strong>。</p>
<p><strong>解决办法：</strong>纯组件中<strong>更新state中的引用类型数据时</strong>，需要<span style="color:red"><strong>创建新数据(新旧引用类型数据的地址不同)</strong></span>再进行赋值。</p>
<ul>
<li>普通组件中也建议在<strong>修改引用类型状态</strong>时<strong>创建新数据</strong>以避免可能出现的问题。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handle = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 错误示范</span></span><br><span class="line">    <span class="comment">// newObj与this.state.obj引用地址相同</span></span><br><span class="line">    <span class="comment">// let newObj = this.state.obj</span></span><br><span class="line">    <span class="comment">// newObj.number = Math.floor(Math.random() * 3)</span></span><br><span class="line">    <span class="comment">// this.setState(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     return &#123;</span></span><br><span class="line">    <span class="comment">//         obj:newObj  //更新前后obj状态引用地址相同(判断时没有变化，不会重新渲染)</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正确示范</span></span><br><span class="line">    <span class="comment">// newObj是使用this.state.obj内容创建的新对象(内存地址不同)</span></span><br><span class="line">    <span class="keyword">let</span> newObj = &#123;...this.state.obj,<span class="attr">number</span>:<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">3</span>)&#125;</span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            obj:newObj   <span class="comment">//内存地址不同(每次更新均重新渲染)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>PureComponent.js</center>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>11-nodejs全局对象global</title>
    <url>/2021/05/10/11-nodejs%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1global/</url>
    <content><![CDATA[<h1 id="nodejs全局对象global"><a href="#nodejs全局对象global" class="headerlink" title="nodejs全局对象global"></a>nodejs全局对象global</h1><p>浏览器BOM中的全局对象是<strong>window</strong></p>
<p>Node中全局对象是<strong>global</strong></p>
<p>Node全局对象global有许多和window对象相同的方法</p>
<p>使用global对象的方法可以省略global</p>
<ul>
<li>console.log() 在控制台输出</li>
<li>setTimeout() 设置定时器(定时触发一次)</li>
<li>clearTimeout() 清除定时器</li>
<li>setInterval() 设置定时器(每经过设定的时间就触发)</li>
<li>等等</li>
</ul>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>11-this指向问题</title>
    <url>/2022/12/04/11-this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h1><h2 id="函数中的this指向问题"><a href="#函数中的this指向问题" class="headerlink" title="函数中的this指向问题"></a>函数中的this指向问题</h2><h3 id="1-普通函数-指向window全局对象"><a href="#1-普通函数-指向window全局对象" class="headerlink" title="1.普通函数 指向window全局对象"></a>1.普通函数 指向window全局对象</h3><p>普通函数的this指向<strong>window</strong>对象（全局对象）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;普通函数this指向&quot;</span>+<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/11-this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/image-20210917184721818.png" alt="image-20210917184721818"></p>
<span id="more"></span>

<h3 id="2-对象的方法-this指向调用方法的对象"><a href="#2-对象的方法-this指向调用方法的对象" class="headerlink" title="2.对象的方法 this指向调用方法的对象"></a>2.对象的方法 this指向调用方法的对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o=&#123;</span><br><span class="line">            say:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">o.say();</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/11-this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/image-20210917184944882.png" alt="image-20210917184944882"></p>
<ul>
<li>输出o对象</li>
</ul>
<h3 id="3-构造函数的this指向"><a href="#3-构造函数的this指向" class="headerlink" title="3.构造函数的this指向"></a>3.构造函数的this指向</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建构造函数Star</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Star</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = a</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Star.prototype.sing=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//创建构造函数prototype上的方法sing</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> Star(<span class="number">123</span>);<span class="comment">//输出this为ldh对象</span></span><br><span class="line">ldh.sing()	<span class="comment">//输出this为ldh对象</span></span><br><span class="line">Star()	<span class="comment">//输出window对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>prototype</code>的方法中的this指向方法的调用者（实例对象）</li>
<li>当直接调用构造函数时（不创建对象实例，相当于调用普通函数），<strong>构造函数的this指向window对象</strong></li>
</ul>
<br>

<h3 id="4-事件绑定的回调函数中this指向"><a href="#4-事件绑定的回调函数中this指向" class="headerlink" title="4. 事件绑定的回调函数中this指向"></a>4. 事件绑定的回调函数中this指向</h3><h4 id="4-1-当回调函数为普通函数时this指向绑定的元素"><a href="#4-1-当回调函数为普通函数时this指向绑定的元素" class="headerlink" title="4.1 当回调函数为普通函数时this指向绑定的元素"></a>4.1 当回调函数为普通函数时this指向绑定的元素</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.querySelector(<span class="string">&quot;button&quot;</span>)</span><br><span class="line">btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;绑定事件调用的this指向&quot;</span>+<span class="built_in">this</span>)	<span class="comment">//this指向btn</span></span><br><span class="line">&#125;;<span class="comment">//点击按钮调用</span></span><br></pre></td></tr></table></figure>

<h4 id="4-2-当回调函数为箭头函数时this指向window"><a href="#4-2-当回调函数为箭头函数时this指向window" class="headerlink" title="4.2 当回调函数为箭头函数时this指向window"></a>4.2 当回调函数为箭头函数时this指向window</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>);	<span class="comment">//this指向window</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>



<h3 id="5-定时器回调函数中this指向window全局对象"><a href="#5-定时器回调函数中this指向window全局对象" class="headerlink" title="5.定时器回调函数中this指向window全局对象"></a>5.定时器回调函数中this指向window全局对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5.定时器函数  this指向window</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;定时器的this指向&quot;</span>+<span class="built_in">this</span>);	<span class="comment">//this指向window</span></span><br><span class="line">&#125;,<span class="number">1000</span>);<span class="comment">//每隔1000ms调用一次</span></span><br></pre></td></tr></table></figure>

<h3 id="6-立即执行函数中的this指向window全局对象"><a href="#6-立即执行函数中的this指向window全局对象" class="headerlink" title="6.立即执行函数中的this指向window全局对象"></a>6.立即执行函数中的this指向window全局对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//6.立即执行函数 与普通函数的this指向一样 都指向window</span></span><br><span class="line"><span class="comment">//立即执行函数前若还有其他函数 则前面的函数末尾要加;号 否则立即执行函数报错</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;立即执行函数的this指向&quot;</span>+ <span class="built_in">this</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">//立即执行 自动调用</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="改变this指向的方法"><a href="#改变this指向的方法" class="headerlink" title="改变this指向的方法"></a>改变this指向的方法</h2><h3 id="1-call-方法"><a href="#1-call-方法" class="headerlink" title="1. call()方法"></a>1. call()方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o=&#123;</span><br><span class="line">    name:<span class="string">&quot;andy&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//输出this</span></span><br><span class="line">    <span class="built_in">console</span>.log(a+b);</span><br><span class="line">&#125;</span><br><span class="line">fn.call(o,<span class="number">1</span>,<span class="number">2</span>)<span class="comment">//this指向改变为对象o 输出对象o和3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>call方法<strong>会调用函数</strong>，同时<strong>改变函数的this指向</strong></li>
<li><code>call()</code> 方法<strong>改变this指向为其第一个参数</strong></li>
<li>后续参数作为<strong>调用call方法的函数的参数传递</strong></li>
</ul>
<br>

<h4 id="call方法可以继承构造函数的属性和方法"><a href="#call方法可以继承构造函数的属性和方法" class="headerlink" title="call方法可以继承构造函数的属性和方法"></a>call方法可以继承构造函数的属性和方法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//call()的主要作用是构造函数继承属性和方法</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">uname,age,sex</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.uname=uname;</span><br><span class="line">            <span class="built_in">this</span>.age=age;</span><br><span class="line">            <span class="built_in">this</span>.sex=sex</span><br><span class="line">            <span class="built_in">this</span>.logname = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.uname);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">uname,age,sex</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//通过调用父构造函数并且将Father中this的指向改为指向Son构造函数的this实现继承属性</span></span><br><span class="line">            Father.call(<span class="built_in">this</span>,uname,age,sex)<span class="comment">//后续传参给Son继承来的属性赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> son=<span class="keyword">new</span> Son(<span class="string">&quot;xiao&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(son);	<span class="comment">//son实例对象中继承了Father构造函数中的属性(uname,age,sex)</span></span><br><span class="line">        son.logname()		<span class="comment">//输出&#x27;xiao&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在子构造函数中<strong>调用父构造函数</strong><ul>
<li><strong>并使用call方法改变其this指向 <strong>为</strong>子构造函数的this指向</strong></li>
<li>同时在call方法中<strong>传递Son构造函数定义的参数</strong></li>
</ul>
</li>
</ul>
<br>

<h3 id="2-apply-方法"><a href="#2-apply-方法" class="headerlink" title="2. apply()方法"></a>2. apply()方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.apply() </span></span><br><span class="line">       <span class="keyword">var</span> o=&#123;</span><br><span class="line">           name:<span class="string">&quot;andy&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//apply()可以调用函数 也可以改变函数this指向(将函数this指向改变为指向第一个参数)</span></span><br><span class="line">       fn.apply(o);<span class="comment">//this指向o对象 输出o对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li>apply()方法将函数的this指向改为其<strong>第一个参数</strong></li>
<li>apply()方法与call()方法的区别在于，apply()方法<strong>传入参数时使用数组</strong><ul>
<li>数组的每一项即为传入函数的一个参数</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用apply传入参数时使用数组格式 </span></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">fn_new</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(arr)<span class="comment">//使用arr只能获取传入数组的第一个元素 arr相当于arguments[0]</span></span><br><span class="line">           <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]);<span class="comment">//使用参数数组arguments可以根据索引获取参数</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//不改变this指向 传入数组参数 </span></span><br><span class="line">       fn_new.apply(fn_new,[<span class="string">&quot;pink&quot;</span>,<span class="string">&quot;black&quot;</span>]);<span class="comment">//输出pink black</span></span><br><span class="line">       fn_new.apply(fn_new,[<span class="number">1</span>,<span class="number">2</span>]);<span class="comment">//输出1 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>接受apply()方法传递的<strong>数组形式的参数</strong>时，可以<strong>定义与数组长度相同数量的形参</strong>来接收<ul>
<li>但这种方法过于繁琐</li>
</ul>
</li>
<li>还可以使用参数数组<strong>arguments</strong>接受参数<ul>
<li>参数数组接受所有的参数并保存为一个数组</li>
<li>通过**arguments[‘下标’]**即可得到对应的参数</li>
</ul>
</li>
</ul>
<h4 id="apply方法应用"><a href="#apply方法应用" class="headerlink" title="apply方法应用"></a>apply方法应用</h4><ul>
<li>可以改变<strong>Math.max方法的this指向为Math或者null</strong>来求数组最值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//apply()应用  常用于跟数组有关操作</span></span><br><span class="line">        <span class="comment">//利用Math.max()和apply()结合可以求数组的最大值</span></span><br><span class="line">        <span class="keyword">var</span> max=<span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>]);</span><br><span class="line">        <span class="built_in">console</span>.log(max);<span class="comment">//输出最大值5</span></span><br><span class="line">        <span class="keyword">var</span> min=<span class="built_in">Math</span>.min.apply(<span class="literal">null</span>,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>]);</span><br><span class="line">        <span class="built_in">console</span>.log(min);<span class="comment">//输出最小值1</span></span><br></pre></td></tr></table></figure>

<h3 id="3-bind-方法"><a href="#3-bind-方法" class="headerlink" title="3.bind()方法"></a>3.bind()方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.bind() 捆绑的意思</span></span><br><span class="line"><span class="keyword">var</span> o=&#123;</span><br><span class="line">    name:<span class="string">&quot;andy&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(a+b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bind()不会调用函数 但是可以改变函数的this指向(也可以传入初始化参数) </span></span><br><span class="line"><span class="keyword">var</span> fn_new=fn.bind(o,<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//bind()返回一个修改this指向并传入初始化参数的新函数</span></span><br><span class="line">fn_new();<span class="comment">//fn_new接受了修改后的新函数 bind()方法还传入了初始化参数(1,2)</span></span><br><span class="line"><span class="comment">//输出对象o 和 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//bind()方法更改函数this指向 但不会调用函数 返回修改后的新函数</span></span><br><span class="line"><span class="comment">//有时我们希望更改函数的this指向但并不希望更改完后立刻执行</span></span><br></pre></td></tr></table></figure>

<ul>
<li>bind方法改变函数的this指向 但<strong>不调用函数</strong><ul>
<li>第一个参数为修改后的this指向</li>
<li>后续可以传入初始化参数</li>
<li>bind方法<strong>返回一个带有初始化参数并修改this指向的新函数</strong></li>
</ul>
</li>
</ul>
<h4 id="bind方法的应用场景"><a href="#bind方法的应用场景" class="headerlink" title="bind方法的应用场景"></a>bind方法的应用场景</h4><ul>
<li>有时我们需要修改函数的this指向但<strong>又不想让其在修改后立即执行</strong>，此时使用bind方法</li>
<li>例如可以使用bind方法修改定时器回调函数的this指向<ul>
<li>使其更改this指向后等待计时结束再执行</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS三栏布局</title>
    <url>/2022/11/27/12-CSS%E5%AE%9E%E7%8E%B03%E5%88%97%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="CSS实现三栏布局"><a href="#CSS实现三栏布局" class="headerlink" title="CSS实现三栏布局"></a>CSS实现三栏布局</h1><p>三栏布局：左右固定宽度，中间自适应宽度</p>
<p>三栏布局是典型的响应式布局</p>
<h2 id="浮动实现"><a href="#浮动实现" class="headerlink" title="浮动实现"></a>浮动实现</h2><ul>
<li>左右两列分别左右浮动</li>
<li>中间列是标准流</li>
<li>清除浮动解决高度塌陷</li>
</ul>
<span id="more"></span>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">            margin: 0px;</span><br><span class="line">            padding: 0px;</span><br><span class="line">        &#125;</span><br><span class="line">        /* 第一种方式 浮动 */</span><br><span class="line">        #left&#123;</span><br><span class="line">            float: left;</span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: brown;</span><br><span class="line">        &#125;</span><br><span class="line">        #right&#123;</span><br><span class="line">            float:right;</span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: chartreuse;</span><br><span class="line">        &#125;</span><br><span class="line">        #center&#123;</span><br><span class="line">            /* 设置margin防止内容过多超出中间列宽度 */</span><br><span class="line">            /* margin-left: 300px;</span><br><span class="line">            margin-right: 300px;</span><br><span class="line">            background-color: aquamarine;</span><br><span class="line">        &#125; </span><br><span class="line">         #main&#123;</span><br><span class="line">             /*清除浮动 解决高度塌陷*/</span><br><span class="line">             overflow: hidden;</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--第一种 使用浮动 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 前两个div左右浮动，最后div标准流 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 中间列宽度继承父元素，高度根据内容变化 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;div id=&quot;main&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;div id=&quot;left&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">        &lt;div id=&quot;right&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">        &lt;div id=&quot;center&quot;&gt;</span></span><br><span class="line"><span class="comment">                nihaowoshihahahahahahhahahahhjaslfksakljfal</span></span><br><span class="line"><span class="comment">        &lt;/div&gt;</span></span><br><span class="line"><span class="comment">    &lt;/div&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="position定位布局实现"><a href="#position定位布局实现" class="headerlink" title="position定位布局实现"></a>position定位布局实现</h2><ul>
<li>父元素设置为<strong>relative相对定位</strong></li>
<li>三列作为子元素使用<strong>absolute绝对定位</strong>脱离文档流实现</li>
</ul>
<h2 id="flex布局实现（中间列动态调整宽度）"><a href="#flex布局实现（中间列动态调整宽度）" class="headerlink" title="flex布局实现（中间列动态调整宽度）"></a>flex布局实现（中间列动态调整宽度）</h2><ul>
<li><p>父元素使用弹性布局<code>display:flex</code></p>
</li>
<li><p>三个子元素作为<strong>弹性项</strong>默认在<strong>主轴方向横向排列</strong></p>
</li>
<li><p>设置中间列<code>flex:auto</code>(弹性项可以<strong>吸收容器空间</strong>或<strong>缩短自身适应容器</strong>)</p>
<ul>
<li>实现中间列的宽度动态变化</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">		#main&#123;</span><br><span class="line">            display: flex;</span><br><span class="line">            width: 1000px;</span><br><span class="line">        &#125;</span><br><span class="line">        #left&#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">            background-color: brown;</span><br><span class="line">        &#125;</span><br><span class="line">        #center&#123;</span><br><span class="line">            /* 设置flex:auto </span><br><span class="line">            此弹性项会吸收 flex 容器中额外的自由空间</span><br><span class="line">            也可以缩短以适应flex容器大小</span><br><span class="line">            */</span><br><span class="line">            flex: auto;</span><br><span class="line">            background-color:aquamarine</span><br><span class="line">        &#125;</span><br><span class="line">        #right&#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">            background-color: chartreuse;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第三种 flex布局--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 弹性容器height取三个弹性项中height最大的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;center&quot;</span>&gt;</span>ihahahahahahha<span class="tag">&lt;<span class="name">br</span>&gt;</span>hahahh<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HTMLandCss</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>12-JS继承</title>
    <url>/2022/12/04/12-js%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="JS继承问题"><a href="#JS继承问题" class="headerlink" title="JS继承问题"></a>JS继承问题</h1><h2 id="1-构造函数继承（使用call-方法完成继承）"><a href="#1-构造函数继承（使用call-方法完成继承）" class="headerlink" title="1.构造函数继承（使用call()方法完成继承）"></a>1.构造函数继承（使用call()方法完成继承）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//call()的主要作用是构造函数继承属性和方法</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">uname,age,sex</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.uname=uname;</span><br><span class="line">            <span class="built_in">this</span>.age=age;</span><br><span class="line">            <span class="built_in">this</span>.sex=sex</span><br><span class="line">            <span class="built_in">this</span>.logname = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.uname);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">uname,age,sex</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//通过调用父构造函数并且将Father中this的指向改为Son构造函数的this，以此实现继承</span></span><br><span class="line">            Father.call(<span class="built_in">this</span>,uname,age,sex)<span class="comment">//调用时向父构造函数传参</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> son=<span class="keyword">new</span> Son(<span class="string">&quot;xiao&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(son);	<span class="comment">//son实例对象中继承了Father构造函数中的属性(uname,age,sex)</span></span><br><span class="line">        son.logname()		<span class="comment">//输出&#x27;xiao&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在子构造函数中<strong>调用父构造函数</strong></p>
<ul>
<li><p><strong>并使用call方法改变其this指向 <strong>为</strong>子构造函数的this指向</strong></p>
</li>
<li><p>同时在<strong>call方法</strong>中<strong>传递父构造函数定义的参数</strong>（需要在继承时传参给Son的实例赋值）</p>
</li>
<li><p>子构造函数继承父构造函数中<strong>所有的属性和方法</strong></p>
</li>
</ul>
<span id="more"></span>

<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a><strong>特点：</strong></h3><ul>
<li>子类构造函数<strong>只继承了父类构造函数上</strong>的属性和方法（<strong>没有继承父类构造函数原型对象(prototype)上的方法</strong>）<ul>
<li>此时<strong>Son实例的原型链</strong>为 <code>son -&gt; Son.prototype -&gt; Object.prototype -&gt; null</code></li>
</ul>
</li>
<li>可以使用多个call方法 继承<strong>多个父类构造函数的属性和方法</strong>（多继承）</li>
<li>创建子类构造函数的实例时，可以<strong>给父类构造函数传参</strong>（创建子实例时给继承的属性赋值）</li>
<li><strong>影响性能</strong>，每个子类实例<strong>都有父类构造函数的副本</strong></li>
</ul>
<br>

<h2 id="2-原型链继承"><a href="#2-原型链继承" class="headerlink" title="2.原型链继承"></a>2.原型链继承</h2><p>继承<strong>父类构造函数</strong>和<strong>父类原型链</strong></p>
<p><strong>Son.prototype=new Father();</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.将Father的实例化对象赋值给Son.prototype(可行)</span></span><br><span class="line">        Son.prototype=<span class="keyword">new</span> Father();</span><br><span class="line">        <span class="keyword">var</span> son_new=<span class="keyword">new</span> Son();</span><br><span class="line">        <span class="built_in">console</span>.log(son_new);<span class="comment">//此时son_new的__proto__指向Father的实例化对象</span></span><br><span class="line">        son_new.money();<span class="comment">//Father的实例化对象的__proto__又指向Father.prototype 所以继承了Father.prototype的money方法</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//之前覆盖丢失了constructor，需要重新添加constructor指向</span></span><br><span class="line">		Son.prototype.constructor = Son;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>修改<strong>子构造函数的原型对象</strong>为<strong>父构造函数的实例对象</strong></p>
<ul>
<li><code>Son.prototype=new Father();</code></li>
</ul>
</li>
<li><p>此时子构造函数Son创建的<strong>实例对象的<code>__proto__</code><strong>指向</strong>Father构造函数的实例对象</strong></p>
</li>
<li><p>而Father构造函数的实例对象的<code>__proto__</code>又指向<code>Father.prototype</code></p>
</li>
<li><p>实际上相当于<strong>将Son构造函数的prototype添加到了Father构造函数的原型链上</strong></p>
<ul>
<li>通过<strong>原型链成员查找机制</strong>，Son构造函数就可以使用Father构造函数及其原型链上的属性和方法</li>
</ul>
</li>
<li><p>此时<code>son_new</code>的原型链为 <code>son_new -&gt; Father实例 -&gt; Father.prototype -&gt; Object.prototype -&gt; null</code></p>
</li>
<li><p>注意：</p>
<ul>
<li><code>Son.prototype=new Father();</code>此代码会将<strong>Son.prototype中的constructor属性删除</strong></li>
<li>因为此代码是对象赋值，而右侧的对象实例中并没有constructor属性</li>
<li>需要<strong>手动</strong>给Son.prototype<strong>添加constructor属性并修改指向为Son构造函数</strong></li>
</ul>
</li>
</ul>
<h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><ul>
<li><p>无法实现多继承：即<strong>只能继承一个父类的<u>原型链</u>和<u>构造函数</u></strong></p>
</li>
<li><p>创建子实例时<strong>无法向父构造函数传参</strong></p>
</li>
<li><p>父类构造函数prototype上的属性和方法<strong>同时被子实例和父实例继承</strong>、</p>
</li>
<li><p><strong>子实例</strong>修改父类<strong>引用类型属性的 内容</strong>时，会影响其他子实例；修改父类<strong>值属性</strong>时，只影响自己。</p>
<ul>
<li>```js<br>function Father(name,age) {<pre><code>this.name = name 
this.age = age || 1
this.change = &#123;
    msg:&#39;变化&#39;
&#125;
</code></pre>
}function Son(name,age) {}//构造函数继承<br>Son.prototype = new Father()<br>Son.prototype.constructor = Sonvar obj = new Son()<br>var obj1 = new Son()//修改父类引用类型属性(change)的内容(msg)<br>obj.change.msg = ‘123’    //修改Son.prototype(new Father())上的change对象<br>console.log(obj.change);    //{msg:’123’}<br>console.log(obj1.change);    //{msg:’123’}//修改父类值属性(name)<br>obj.name = ‘test’ //相当与在obj实例上创建name属性<br>console.log(obj.name);    //‘test’<br>console.log(obj1.name);    //undefined<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">## 3. 组合继承</span><br><span class="line"></span><br><span class="line">即上述1和2**两种方式的结合**</span><br><span class="line"></span><br><span class="line">**核心思想**：</span><br><span class="line"></span><br><span class="line">- 通过调用父类构造函数**使用call方法**，继承**父类的属性**并**保留传参的优点，**</span><br><span class="line">- 然后通过将**父类实例作为子类构造函数的原型对象（prototype）**，实现函数复用</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">&#x2F;&#x2F; 父类</span><br><span class="line">function Father(name)&#123;</span><br><span class="line">    this.fname &#x3D; name</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.logname &#x3D; function()&#123;</span><br><span class="line">    console.log(this.fname);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;1.借用父构造函数继承 2.原型链继承 笔记已有</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3.组合继承 结合1和2的方法</span><br><span class="line">&#x2F;&#x2F; 子构造函数</span><br><span class="line">function Son(name,age)&#123;</span><br><span class="line">    this.age&#x3D;age</span><br><span class="line">    &#x2F;&#x2F; 借用父类构造函数</span><br><span class="line">    Father.call(this,name)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;原型链继承 ：子类prototype 指向 父类实例</span><br><span class="line">Son.prototype &#x3D; new Father()</span><br><span class="line">&#x2F;&#x2F;注意constructor指回子构造函数</span><br><span class="line">Son.prototype.constructor &#x3D; Son</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li>创建子实例可向父构造函数传参（创建子实例时可以给继承的属性赋初值）</li>
<li>可以继承<strong>父类构造函数的原型链</strong></li>
<li>父类<strong>引用数据类型</strong>的属性被继承后，<strong>不会出现</strong>一个子实例修改<strong>引用类型的内容</strong>，其他都被影响的情况</li>
</ul>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟DOM和Diff算法</title>
    <url>/2022/11/27/12-%E8%99%9A%E6%8B%9FDOM%E5%92%8CDiff%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="虚拟DOM和Diff算法"><a href="#虚拟DOM和Diff算法" class="headerlink" title="虚拟DOM和Diff算法"></a>虚拟DOM和Diff算法</h1><p><strong>React更新视图的思想：</strong><code>state</code>状态发生变化就重新渲染视图。</p>
<p><strong>React实际更新思路：</strong>找出需要更新的那些DOM元素，将其重新渲染到页面(局部重新渲染)。</p>
<p>部分更新，只更新变化部分。减少DOM操作，提升性能。</p>
<p>通过<strong>虚拟DOM</strong>和<strong>Diff算法</strong>进行局部更新。</p>
<span id="more"></span>

<br>

<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p><strong>虚拟DOM：</strong>本质是一个js对象，将<strong>DOM元素</strong>抽象为<strong>js对象</strong>表示，描述展示的UI结构。</p>
<p>实际上<strong>React元素</strong>就是<strong>虚拟DOM</strong>元素</p>
<p><img data-src="/images/12-%E8%99%9A%E6%8B%9FDOM%E5%92%8CDiff%E7%AE%97%E6%B3%95/image-20220404143004107.png" alt="image-20220404143004107"></p>
<br>

<h2 id="渲染执行过程"><a href="#渲染执行过程" class="headerlink" title="渲染执行过程"></a>渲染执行过程</h2><p><img data-src="/images/12-%E8%99%9A%E6%8B%9FDOM%E5%92%8CDiff%E7%AE%97%E6%B3%95/image-20220404143244356.png" alt="image-20220404143244356"></p>
<br>

<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>组件的<strong>render()<strong>调用后，根据</strong>状态state</strong>和<strong>JSX结构</strong>生成虚拟DOM对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    	<span class="comment">//el即为根据state和JSX生成的虚拟DOM对象</span></span><br><span class="line">        <span class="keyword">let</span> el = (&lt;div&gt;</span><br><span class="line">            &lt;h1&gt;随机数:&lt;/h1&gt;</span><br><span class="line">            &lt;p&gt;&#123;<span class="built_in">this</span>.state.number&#125;&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="built_in">this</span>.handle&#125;&gt;获取随机数&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;)</span><br><span class="line">        <span class="comment">// 输出虚拟DOM对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(el);</span><br><span class="line">        <span class="keyword">return</span> el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E8%99%9A%E6%8B%9FDOM%E5%92%8CDiff%E7%AE%97%E6%B3%95/image-20220404145132500.png" alt="image-20220404145132500"></p>
<center>虚拟DOM对象el</center>

<ul>
<li><p>点击按钮获取随机数，随机数变化时<strong>只有显示随机数值的p标签被更新</strong>。</p>
</li>
<li><p>render方法调用<strong>不意味着浏览器中的重新渲染</strong>。</p>
<ul>
<li>render方法调用仅仅说明会<strong>使用diff算法比较新旧两个虚拟DOM对象</strong>，找出需要局部更新的DOM元素。</li>
<li>之后<strong>React框架</strong>根据<code>diff</code>算法结果进行浏览器中的局部重新渲染。</li>
</ul>
</li>
</ul>
<br>

<h2 id="虚拟DOM的真正价值"><a href="#虚拟DOM的真正价值" class="headerlink" title="虚拟DOM的真正价值"></a>虚拟DOM的真正价值</h2><ul>
<li><span style="color:red">让React可以脱离浏览器的限制</span><ul>
<li>React核心的<strong>虚拟DOM实际上是一个js对象</strong>，也就是说React可以在任何支持js的环境使用。</li>
<li>将<strong>虚拟DOM与浏览器结合</strong>可以开发web网站应用，<strong>与移动端原生环境结合</strong>可以开发移动端app等等。</li>
<li>React可以在<strong>服务端渲染</strong>也是因为虚拟DOM可以脱离浏览器限制。</li>
</ul>
</li>
<li>虚拟DOM提升DOM树的更新效率只是React功能的其中之一。</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML的script标签</title>
    <url>/2022/11/27/13-HTML%E7%9A%84script%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h1 id="HTML的script标签"><a href="#HTML的script标签" class="headerlink" title="HTML的script标签"></a>HTML的script标签</h1><h2 id="不加属性的普通script标签"><a href="#不加属性的普通script标签" class="headerlink" title="不加属性的普通script标签"></a>不加属性的普通script标签</h2><p>默认情况下浏览器<strong>同步加载script标签</strong></p>
<p>解析器执行到该script标签后<strong>立即开始加载并执行相应脚本</strong>，<span style="color:red">执行时会阻塞DOM文档的加载和执行</span></p>
<span id="more"></span>

<br>

<h2 id="script标签的defer属性-（异步加载）"><a href="#script标签的defer属性-（异步加载）" class="headerlink" title="script标签的defer属性 （异步加载）"></a>script标签的defer属性 （异步加载）</h2><p><strong>defer</strong>属性：异步<strong>加载</strong>js脚本（<span style="color:red">仅加载不执行</span>）（其他文档的<strong>加载与渲染</strong>与该脚本的<strong>加载</strong>并行执行）</p>
<ul>
<li><p><strong>该脚本将在文档完成解析渲染后</strong>，触发 <code>DOMContentLoaded</code> <strong>事件前</strong>执行。</p>
</li>
<li><p>具有 defer 特性的脚本<strong>不会阻塞页面。</strong>(因为在文档完成解析后才<strong>执行</strong>)</p>
</li>
<li><p>可以<strong>确保脚本执行的相对顺序</strong>，多个defer属性的脚本<strong>根据加载顺序决定执行顺序</strong></p>
</li>
</ul>
<br>

<h2 id="script标签的async属性-（异步加载）"><a href="#script标签的async属性-（异步加载）" class="headerlink" title="script标签的async属性 （异步加载）"></a>script标签的async属性 （异步加载）</h2><p><strong>async</strong>属性：异步加载js脚本，<span style="color:red">加载完毕后立即执行</span></p>
<ul>
<li>async属性的脚本会在加载完毕后<strong>阻塞DOM树</strong>的渲染并<strong>立即执行脚本</strong></li>
<li>加载完毕后立即执行，多个有async属性的script标签<strong>不能保证执行顺序</strong></li>
</ul>
]]></content>
      <categories>
        <category>HTMLandCss</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>React路由</title>
    <url>/2022/11/27/13-React%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h1 id="React路由"><a href="#React路由" class="headerlink" title="React路由"></a>React路由</h1><p>现代的前端应用大多是**SPA(单页面应用)**，只有一个HTML页面，通过组件化的开发方式，在单页面中使用不同的组件实现不同视图的显示。可以降低服务器压力，提升用户体验。</p>
<p>为了有效的使用单页面来管理原来多页面的功能，前端路由出现了。</p>
<p><img data-src="/images/13-React%E8%B7%AF%E7%94%B1/image-20220404151837182.png" alt="image-20220404151837182"></p>
<span id="more"></span>

<h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install react-router-dom -S</span><br></pre></td></tr></table></figure>

<h3 id="2-引入"><a href="#2-引入" class="headerlink" title="2.引入"></a>2.引入</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入react-router-dom模块 BrowserRouter起了别名</span></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Route, Link, Routes &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-使用Router组件包裹应用-包裹应用根元素"><a href="#3-使用Router组件包裹应用-包裹应用根元素" class="headerlink" title="3.使用Router组件包裹应用(包裹应用根元素)"></a>3.使用<code>Router</code>组件包裹应用(包裹应用根元素)</h3><h3 id="4-设置Link路由入口"><a href="#4-设置Link路由入口" class="headerlink" title="4.设置Link路由入口"></a>4.设置Link路由入口</h3><p><code>path</code>为<strong>路由路径</strong>，Link组件在浏览器被渲染为a标签，通过点击a标签修改路由的路径来渲染不同组件。</p>
<h3 id="5-设置Route配置路由规则"><a href="#5-设置Route配置路由规则" class="headerlink" title="5.设置Route配置路由规则"></a>5.设置Route配置路由规则</h3><p><code>Route</code>组件被包裹在<code>Routes</code>组件中，<code>path</code>为路径，<code>element</code>为对应渲染的组件</p>
<p><img data-src="/images/13-React%E8%B7%AF%E7%94%B1/image-20220404155537073.png" alt="image-20220404155537073"></p>
<br>

<h2 id="2-常用组件说明"><a href="#2-常用组件说明" class="headerlink" title="2.常用组件说明"></a>2.常用组件说明</h2><h3 id="1-Router组件"><a href="#1-Router组件" class="headerlink" title="1.Router组件"></a>1.Router组件</h3><p><strong>Router组件：</strong>包裹整个应用，一个React应用只需要使用一次</p>
<p>两种常用Router路由方式：</p>
<ul>
<li><strong>HashRouter：</strong>使用URL的hash值实现 (<code>localhost:3000/#/first</code>)<ul>
<li>引入<code>HashRouter</code>组件</li>
</ul>
</li>
<li><strong>(推荐)BrowserRouter：</strong>使用H5的history API实现 (<code>localhost:3000/first</code>)</li>
</ul>
<h3 id="2-Link组件"><a href="#2-Link组件" class="headerlink" title="2.Link组件"></a>2.Link组件</h3><p><strong>Link组件：</strong>用于指定导航链接(浏览器里渲染为a标签)，<code>to属性值</code>渲染为a标签的<code>href属性</code></p>
<ul>
<li>点击Link组件渲染生成的a标签，改变<strong>路由路径</strong>后<strong>渲染对应的组件</strong></li>
</ul>
<h3 id="3-Route组件"><a href="#3-Route组件" class="headerlink" title="3.Route组件"></a>3.Route组件</h3><p><strong>Route组件：</strong>指定路由展示组件相关信息</p>
<ul>
<li>Route组件需要被包裹在<strong>Routes组件</strong>中(<code>react-router-dom</code>模块6.0以上版本修改了语法)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">/* 路由出口 */</span>&#125;</span><br><span class="line">&lt;Routes&gt;</span><br><span class="line">	&lt;Route path=<span class="string">&quot;/first&quot;</span> element=&#123;<span class="xml"><span class="tag">&lt;<span class="name">First</span>/&gt;</span></span>&#125;&gt;&lt;/Route&gt;</span><br><span class="line">&lt;/Routes&gt;</span><br></pre></td></tr></table></figure>

<p><strong>path属性：</strong>路由规则，指定展示组件匹配的路径</p>
<p><strong>element属性：</strong>值为<strong>要展示的组件标签</strong></p>
<p>Route组件的位置就是展示组件渲染到的位置</p>
<br>

<h2 id="3-路由执行过程"><a href="#3-路由执行过程" class="headerlink" title="3.路由执行过程"></a>3.路由执行过程</h2><p><img data-src="/images/13-React%E8%B7%AF%E7%94%B1/image-20220406150734961.png" alt="image-20220406150734961"></p>
<br>

<h2 id="4-编程式导航"><a href="#4-编程式导航" class="headerlink" title="4.编程式导航"></a>4.编程式导航</h2><p><img data-src="/images/13-React%E8%B7%AF%E7%94%B1/image-20220406152825971.png" alt="image-20220406152825971"></p>
<br>

<h2 id="5-默认路由"><a href="#5-默认路由" class="headerlink" title="5.默认路由"></a>5.默认路由</h2><p><img data-src="/images/13-React%E8%B7%AF%E7%94%B1/image-20220406153049882.png" alt="image-20220406153049882"></p>
<br>

<h2 id="6-模糊匹配模式"><a href="#6-模糊匹配模式" class="headerlink" title="6.模糊匹配模式"></a>6.模糊匹配模式</h2><p><img data-src="/images/13-React%E8%B7%AF%E7%94%B1/image-20220406153523345.png" alt="image-20220406153523345"></p>
<br>

<h2 id="7-精确匹配模式"><a href="#7-精确匹配模式" class="headerlink" title="7.精确匹配模式"></a>7.精确匹配模式</h2><p><img data-src="/images/13-React%E8%B7%AF%E7%94%B1/image-20220406153926546.png" alt="image-20220406153926546"></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>13-JS事件循环|宏、微任务</title>
    <url>/2022/12/04/13-eventloop_%E5%AE%8F%E4%BB%BB%E5%8A%A1_%E5%BE%AE%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="EventLoop事件循环、宏任务、微任务、JS单线程"><a href="#EventLoop事件循环、宏任务、微任务、JS单线程" class="headerlink" title="EventLoop事件循环、宏任务、微任务、JS单线程"></a>EventLoop事件循环、宏任务、微任务、JS单线程</h1><p>首先看下方代码的输出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//使用resolve()手动更改其状态为成功（即已经返回结果）</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure>

<center>代码段1</center>

<p><img data-src="/images/13-eventloop_%E5%AE%8F%E4%BB%BB%E5%8A%A1_%E5%BE%AE%E4%BB%BB%E5%8A%A1/image-20210918131010165.png" alt="image-20210918131010165"></p>
<center>图1</center>

<span id="more"></span>

<p>之所以输出如此，就是因为<strong>事件循环中同步任务和异步任务（宏任务、微任务）执行的过程导致</strong></p>
<p>首先讲解JS的单线程</p>
<h2 id="JS单线程"><a href="#JS单线程" class="headerlink" title="JS单线程"></a>JS单线程</h2><p>单线程模型指的是，<strong>JavaScript 只在一个线程上运行</strong>。也就是说，JavaScript <strong>同时只能执行一个任务</strong>，其他任务都必须在后面排队等待。</p>
<ul>
<li>JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，<strong>JavaScript 引擎有多个线程</strong>，<strong>单个脚本只能在一个线程上运行（称为主线程）</strong>，其他线程都是在后台配合。</li>
<li>即<strong>JavaScript引擎中</strong>负责<strong>解释和执行JavaScript代码的线程只有一个</strong></li>
</ul>
<p>JavaScript 从<strong>诞生起就是单线程</strong>，原因是<strong>不想让浏览器变得太复杂</strong>，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了</p>
<ul>
<li>JavaScript 一开始就是<strong>单线程</strong>，这已经成了<strong>这门语言的核心特征，将来也不会改变。</strong></li>
</ul>
<h3 id="单线程的优点"><a href="#单线程的优点" class="headerlink" title="单线程的优点"></a>单线程的优点</h3><p>实现起来比较简单，执行环境相对单纯</p>
<h3 id="单线程的缺点"><a href="#单线程的缺点" class="headerlink" title="单线程的缺点"></a>单线程的缺点</h3><p>只要有一个任务耗时很长，后面的任务都必须<strong>排队等着</strong>，会<strong>拖延整个程序的执行</strong></p>
<ul>
<li>JavaScript 语言本身并不慢，<strong>慢的是读写外部数据</strong>，比如等待 同步Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会<strong>导致脚本的长时间停滞</strong></li>
</ul>
<br>

<h3 id="同步的JS为什么需要异步"><a href="#同步的JS为什么需要异步" class="headerlink" title="同步的JS为什么需要异步"></a>同步的JS为什么需要异步</h3><ul>
<li>js是同步的？<ul>
<li>是的，单线程，那肯定只能同步(排队)执行</li>
</ul>
</li>
<li>js为什么需要异步?<ul>
<li>如果JS中不存在异步,只能自上而下执行,万一上一行解析时间很长,那么下面的代码就会被阻塞。对于用户而言,阻塞就意味着”卡死”,这样就导致了很差的用户体验。需要使用异步操作来减少 ‘卡死’ 的情况。</li>
</ul>
</li>
</ul>
<br>

<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>因为读写外部数据的IO操作过慢而阻塞时，<strong>此时CPU是空闲的</strong>，这时 CPU 完全可以不管 IO 操作，<strong>挂起处于等待中的任务(异步任务)<strong>，</strong>先运行排在后面的任务</strong>。等到 <strong>IO 操作返回了结果</strong>，<strong>再回过头，把挂起的任务继续执行下去</strong>。这种机制就是 JavaScript 内部采用的<strong>“事件循环”机制（Event Loop）</strong>。</p>
<ul>
<li>所有的任务分为两种，一种是同步任务，一种是异步任务</li>
</ul>
<h3 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h3><p>在<strong>主线程上排队执行的任务</strong>，只有前一个任务执行完毕，才能执行后一个任务</p>
<h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><p>不进入主线程、而<strong>进入任务队列（task queue</strong>）的任务，只有<strong>等主线程任务执行完毕</strong>，”任务队列”在异步任务<strong>返回结果后</strong>开始通知主线程，请求执行任务，该<u>异步任务 (任务的回调函数)</u> <strong>才会进入主线程执行</strong></p>
<ul>
<li>排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务<strong>不具有“堵塞”效应</strong><ul>
<li>这就解释了为什么<u>代码段1</u>中的<strong>定时器回调函数的输出排在后面</strong></li>
</ul>
</li>
</ul>
<p>举例来说，Ajax 操作<strong>可以当作同步任务处理</strong>，<strong>也可以当作异步任务处理</strong>，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。</p>
<h3 id="任务队列（task-queue）"><a href="#任务队列（task-queue）" class="headerlink" title="任务队列（task queue）"></a>任务队列（task queue）</h3><p>JavaScript 运行时，除了一个正在运行的<strong>主线程</strong>，引擎还提供一个<strong>任务队列（task queue）</strong>，里面是各种需要当前程序处理的**异步任务(异步任务的回调)**。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）</p>
<h3 id="主线程任务执行顺序"><a href="#主线程任务执行顺序" class="headerlink" title="主线程任务执行顺序"></a>主线程任务执行顺序</h3><ol>
<li><p>首先，主线程会去<strong>执行所有的同步任务</strong>。等到同步任务<strong>全部执行完</strong>，就会去<strong>看任务队列里面的异步任务</strong>。</p>
</li>
<li><p>如果<strong>满足条件（异步任务返回结果等）</strong>，那么<strong>异步任务的回调就进入主线程开始执行</strong>，这时异步任务的回调做为同步任务执行。</p>
</li>
<li><p>等到执行完，<strong>下一个返回结果的异步任务再进入主线程开始执行</strong>。一旦<strong>任务队列（task queue）清空，程序就结束执行。</strong></p>
</li>
</ol>
<p>异步任务的<strong>处理通常使用回调函数</strong>。在<strong>主线程为空</strong>的情况下，一旦<strong>异步任务返回结果</strong>，就会<strong>将其对应的回调函数放入主线程执行</strong>。如果一个异步任务<strong>没有回调函数</strong>，就<strong>不会进入任务队列</strong>，也就是说，<strong>不会重新进入主线程</strong>，因为没有用回调函数指定下一步的操作。</p>
<p>JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是<strong>引擎在不停地检查</strong>，一遍又一遍，只要<strong>同步任务全部执行完了，引擎就会去检查那些挂起来的异步任务</strong>，是不是可以进入主线程了(是否返回结果)。将一个异步任务送入主线程执行完毕后，引擎<strong>继续检查挂起的剩余异步任务</strong>。</p>
<ul>
<li>这种<strong>循环检查的机制，就叫做事件循环（Event Loop）</strong></li>
</ul>
<h3 id="异步操作的常见形式"><a href="#异步操作的常见形式" class="headerlink" title="异步操作的常见形式"></a>异步操作的常见形式</h3><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>回调函数是异步操作最基本的方法。</p>
<p>例如一个函数<strong>f1是异步任务</strong>，跟在它之后的<strong>f2是同步任务</strong>，此时想<strong>让f1执行完后再执行f2</strong></p>
<ul>
<li>如果将其写成两个顺序普通函数，<strong>明显同步任务f2不会等待异步任务f1返回结果</strong></li>
<li>此时<strong>将f2作为f1的回调函数</strong>，当f1异步任务执行完毕后，f2才能执行</li>
</ul>
<h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p>另一种思路是采用事件驱动模式。异步任务的执行<strong>不取决于代码的顺序</strong>，而<strong>取决于某个事件是否发生</strong>。</p>
<p>同样拿f1和f2举例，此时f1和f2<strong>均为异步任务</strong></p>
<ul>
<li>当f1异步任务执行返回结果后 触发对应事件 此时f2才可以执行</li>
</ul>
<br>

<h2 id="宏任务（task）和微任务（microtask）"><a href="#宏任务（task）和微任务（microtask）" class="headerlink" title="宏任务（task）和微任务（microtask）"></a>宏任务（task）和微任务（microtask）</h2><p>前面提到所有的任务分为<strong>同步任务和异步任务</strong>，那么宏任务和微任务又是什么呢？</p>
<ul>
<li><strong>宏任务：</strong>每次<strong>执行栈执行的代码段</strong>就是一个宏任务(包括从任务队列(task queue)获取并放入执行栈的<strong>回调函数</strong>)</li>
<li><strong>微任务：</strong>在当前事件循环的宏任务执行完后立刻执行的任务。</li>
</ul>
<p><strong>常见的宏任务</strong>：<strong>整体代码段script</strong>，<strong>setTimeout</strong>，<strong>setInterval</strong></p>
<p><strong>常见的微任务</strong>：Promise使用resolve()改变状态为成功后的 <strong>.then()</strong> 方法（此时promise已经返回结果，.then直接加入<strong>当前事件循环的</strong>微任务队列）</p>
<ul>
<li>对一个已经有了结果的promise调用<code>.then(yey, nay)</code>会立即产生一个微任务</li>
<li>微任务通常来说就是需要在当前 <strong>宏任务（task）</strong> 执行结束后立即执行的任务</li>
<li>执行顺序为 <code>task -&gt; microtask -&gt; task -&gt; ....</code>依此循环</li>
</ul>
<br>

<ul>
<li>本轮事件循环的微任务会<strong>直接添加到本轮事件的微任务队列</strong>中，所以本轮事件循环的微任务一定会比下一轮事件循环的宏任务先执行</li>
</ul>
<br>

<h3 id="对于代码段1的执行进行如下分析"><a href="#对于代码段1的执行进行如下分析" class="headerlink" title="对于代码段1的执行进行如下分析"></a>对于代码段1的执行进行如下分析</h3><ol>
<li>第一轮事件循环，首先<strong>进入整体代码script</strong>，执行其中的<strong>所有同步任务</strong></li>
</ol>
<ul>
<li><code>console.log(&#39;script start&#39;);</code> <strong>输出’script start’</strong></li>
<li><code>console.log(&#39;script end&#39;);</code> <strong>输出’script end’</strong></li>
</ul>
<ol start="2">
<li>接着为定时器SetTimeout<strong>创建一个宏任务(在下一轮事件循环)<strong>，把返回结果的promise的两个.then送入</strong>当前事件循环的微任务队列</strong></li>
<li>本轮宏任务（script整体代码）执行完，<strong>执行微任务队列</strong>（宏/微任务交替执行）</li>
</ol>
<ul>
<li>执行两个.then</li>
<li><strong>输出promise1和promise2</strong></li>
</ul>
<ol start="4">
<li>接着执行下一轮事件循环的宏任务（即SetTimeout定时器）</li>
</ol>
<ul>
<li><strong>输出setTimeout</strong></li>
</ul>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>13-用户信息增删改查实例</title>
    <url>/2021/05/24/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="用户信息增删改查实例"><a href="#用户信息增删改查实例" class="headerlink" title="用户信息增删改查实例"></a>用户信息增删改查实例</h1><h2 id="项目目的"><a href="#项目目的" class="headerlink" title="项目目的"></a>项目目的</h2><p><img data-src="/images/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/image-20210524204826501.png" alt="image-20210524204826501"></p>
<span id="more"></span>

<h2 id="1-搭建网站服务器"><a href="#1-搭建网站服务器" class="headerlink" title="1.搭建网站服务器"></a>1.搭建网站服务器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入http模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务器</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器请求事件</span></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="keyword">async</span> (req,res) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口</span></span><br><span class="line">server.listen(<span class="string">&#x27;3000&#x27;</span>,<span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;服务器开启成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h2 id="2-连接数据库，创建用户集合-users"><a href="#2-连接数据库，创建用户集合-users" class="headerlink" title="2.连接数据库，创建用户集合(users)"></a>2.连接数据库，创建用户集合(users)</h2><p>这部分采用模块化的编程思想：</p>
<p>​    将连接数据库代码写在<strong>index.js模块</strong>中</p>
<p>​    将创建用户集合代码写在<strong>user.js模块</strong>中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入mongoose模块</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接数据库</span></span><br><span class="line">mongoose.connect(<span class="string">&#x27;mongodb://localhost/user09&#x27;</span>,&#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> ,<span class="attr">useUnifiedTopology</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;数据库连接成功&#x27;</span>)&#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;数据库连接失败&#x27;</span>,err)&#125;)</span><br></pre></td></tr></table></figure>

<center>index.js代码</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建集合规则</span></span><br><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        required:<span class="literal">true</span>,</span><br><span class="line">        minlength:<span class="number">2</span>,</span><br><span class="line">        maxlength:<span class="number">5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age:&#123;</span><br><span class="line">        type:<span class="built_in">Number</span>,</span><br><span class="line">        min:<span class="number">18</span>,</span><br><span class="line">        max:<span class="number">80</span></span><br><span class="line">    &#125;,</span><br><span class="line">    password: <span class="built_in">String</span>,</span><br><span class="line">    email:<span class="built_in">String</span>,</span><br><span class="line">    <span class="comment">//代表值为一个数组，元素为String类型</span></span><br><span class="line">    hobbies:[<span class="built_in">String</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建集合</span></span><br><span class="line"><span class="keyword">const</span> User = mongoose.model(<span class="string">&#x27;User&#x27;</span>,userSchema)</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出集合构造函数User供server.js使用</span></span><br><span class="line"><span class="built_in">module</span>.exports = User</span><br></pre></td></tr></table></figure>

<center>user.js代码</center>

<br>

<h2 id="3-客户端访问-list时，将所有用户信息查询出来"><a href="#3-客户端访问-list时，将所有用户信息查询出来" class="headerlink" title="3.客户端访问/list时，将所有用户信息查询出来"></a>3.客户端访问/list时，将所有用户信息查询出来</h2><p>此处因为还没有学习模板引擎，所以采用<strong>直接在server.js文件中进行字符串拼接</strong>的方式给客户端响应数据</p>
<p>在<code>server.on()</code>函数中书写代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此代码在server.on()函数下书写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//请求方式</span></span><br><span class="line"><span class="keyword">const</span> method = req.method</span><br><span class="line"><span class="comment">//请求地址和请求参数获取</span></span><br><span class="line"><span class="keyword">const</span> &#123; pathname,query &#125; = url.parse(req.url,<span class="literal">true</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(method == <span class="string">&#x27;GET&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pathname == <span class="string">&#x27;/list&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> users = <span class="keyword">await</span> User.find()</span><br><span class="line">            <span class="keyword">let</span> list = <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">            &lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;head&gt;</span></span><br><span class="line"><span class="string">                &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;title&gt;用户列表&lt;/title&gt;</span></span><br><span class="line"><span class="string">                &lt;style&gt;css样式省略&lt;/style&gt;</span></span><br><span class="line"><span class="string">            &lt;/head&gt;</span></span><br><span class="line"><span class="string">            &lt;body&gt;</span></span><br><span class="line"><span class="string">                &lt;div&gt;</span></span><br><span class="line"><span class="string">                    &lt;span&gt;&lt;a href=&quot;http://localhost:3000/add&quot;&gt;添加用户&lt;/a&gt;&lt;/span&gt;</span></span><br><span class="line"><span class="string">                    &lt;br/&gt;</span></span><br><span class="line"><span class="string">                    &lt;br&gt;</span></span><br><span class="line"><span class="string">                    &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;</span></span><br><span class="line"><span class="string">                    &lt;tr&gt;</span></span><br><span class="line"><span class="string">                        &lt;td&gt;姓名&lt;/td&gt;</span></span><br><span class="line"><span class="string">                        &lt;td&gt;年龄&lt;/td&gt;</span></span><br><span class="line"><span class="string">                        &lt;td&gt;email&lt;/td&gt;</span></span><br><span class="line"><span class="string">                        &lt;td&gt;爱好&lt;/td&gt;</span></span><br><span class="line"><span class="string">                        &lt;td&gt;操作&lt;/td&gt;</span></span><br><span class="line"><span class="string">                    &lt;/tr&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<center>代码块1</center>

<ul>
<li><p>上述代码块中使用<code>let users = await User.find()</code>代码将users集合中所有文档提取出来存入users数组</p>
</li>
<li><p>使用list变量进行响应的html代码数据拼接</p>
</li>
<li><p>html代码放在<strong>模板字符串</strong>中(``中)</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">users.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">               list+=<span class="string">`</span></span><br><span class="line"><span class="string">               &lt;tr&gt;</span></span><br><span class="line"><span class="string">                   &lt;td&gt;<span class="subst">$&#123;item.name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">                   &lt;td&gt;<span class="subst">$&#123;item.age&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">                   &lt;td&gt;<span class="subst">$&#123;item.email&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">                   &lt;td&gt;</span></span><br><span class="line"><span class="string">               `</span></span><br><span class="line">               <span class="comment">//爱好信息添加</span></span><br><span class="line">               item.hobbies.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                   list+=<span class="string">`</span></span><br><span class="line"><span class="string">                   <span class="subst">$&#123;item&#125;</span></span></span><br><span class="line"><span class="string">               `</span></span><br><span class="line">               &#125;)</span><br><span class="line">               </span><br><span class="line">               list+=<span class="string">`</span></span><br><span class="line"><span class="string">                   &lt;/td&gt;</span></span><br><span class="line"><span class="string">                   &lt;td&gt; </span></span><br><span class="line"><span class="string">                       &lt;span class=&quot;del&quot;&gt;&lt;a href=&quot;/del?id=<span class="subst">$&#123;item._id&#125;</span>&quot;&gt;删除&lt;/a&gt;&lt;/span&gt;</span></span><br><span class="line"><span class="string">                       &lt;span class=&quot;change&quot;&gt;&lt;a href=&quot;/modify?id=<span class="subst">$&#123;item._id&#125;</span>&quot;&gt;修改&lt;/a&gt;&lt;/span&gt;</span></span><br><span class="line"><span class="string">                   &lt;/td&gt;</span></span><br><span class="line"><span class="string">               &lt;/tr&gt;</span></span><br><span class="line"><span class="string">               `</span></span><br><span class="line">           &#125;)</span><br><span class="line">           </span><br><span class="line">           list+=<span class="string">` &lt;/table&gt;</span></span><br><span class="line"><span class="string">           &lt;/body&gt;</span></span><br><span class="line"><span class="string">           &lt;/html&gt;`</span></span><br><span class="line">           res.end(list);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<center>代码块2</center>

<p>代码块2接着代码块1</p>
<ul>
<li>使用users的<code>forEach()</code>方法<strong>遍历数组中所有的文档</strong><ul>
<li>按照每一个文档的信息生成表格中的一行</li>
<li>每一个item即为一个文档的JSON对象</li>
</ul>
</li>
<li>对于文档的hobbies字段(hobbies字段为一个数组)<ul>
<li>使用hobbies.forEach()方法<strong>遍历每一个爱好</strong>并添加到表格中</li>
</ul>
</li>
<li>最后添加删除和修改两个按钮<ul>
<li>按钮提前设置好超链接</li>
<li>为修改和删除跳转做准备</li>
</ul>
</li>
<li><code>res.end(list)</code>语句将list变量存储的html代码响应给客户端</li>
</ul>
<p><img data-src="/images/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/image-20210525214248992.png" alt="将每一个文档信息生成为表格的一行(/list页面)"></p>
<br>

<h2 id="4-添加用户功能-访问-add"><a href="#4-添加用户功能-访问-add" class="headerlink" title="4.添加用户功能(访问/add)"></a>4.添加用户功能(访问/add)</h2><ul>
<li><p>用户可以通过直接访问<code>localhost:3000/add</code>的方式访问添加用户页面</p>
</li>
<li><p>还可以点击/list页面上的添加用户按钮跳转到/add页面进行添加用户操作</p>
<ul>
<li>代码段1中已经设置好添加按钮的跳转路径</li>
</ul>
</li>
<li><p>上述两种访问/add页面的方式<strong>均为GET请求方式</strong></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pathname == <span class="string">&#x27;/add&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> add=<span class="string">`</span></span><br><span class="line"><span class="string">            &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">            &lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;head&gt;</span></span><br><span class="line"><span class="string">                &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;title&gt;添加用户&lt;/title&gt;</span></span><br><span class="line"><span class="string">                &lt;style&gt;</span></span><br><span class="line"><span class="string">                    div&#123;</span></span><br><span class="line"><span class="string">                        margin: 0 auto;</span></span><br><span class="line"><span class="string">                        width: 1000px;</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string">                &lt;/style&gt;</span></span><br><span class="line"><span class="string">            &lt;/head&gt;</span></span><br><span class="line"><span class="string">            &lt;body&gt;</span></span><br><span class="line"><span class="string">                &lt;div&gt;</span></span><br><span class="line"><span class="string">                    &lt;h3&gt;添加用户&lt;/h3&gt;</span></span><br><span class="line"><span class="string">                    &lt;form action=&quot;/add&quot; method=&quot;POST&quot;&gt;</span></span><br><span class="line"><span class="string">                        &lt;label&gt;用户名：&lt;/label&gt;</span></span><br><span class="line"><span class="string">                        &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">                        &lt;label&gt;密码：&lt;/label&gt;</span></span><br><span class="line"><span class="string">                        &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">                        &lt;label&gt;年龄：&lt;/label&gt;</span></span><br><span class="line"><span class="string">                        &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">                        &lt;label&gt;email：&lt;/label&gt;</span></span><br><span class="line"><span class="string">                        &lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">                        &lt;span&gt;爱好:&lt;/span&gt;&lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">                        &lt;label for=&quot;&quot;&gt;吃饭&lt;/label&gt;</span></span><br><span class="line"><span class="string">                        &lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot; value=&quot;吃饭&quot;&gt;</span></span><br><span class="line"><span class="string">                        &lt;label for=&quot;&quot;&gt;睡觉&lt;/label&gt;</span></span><br><span class="line"><span class="string">                        &lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot; value=&quot;睡觉&quot;&gt;</span></span><br><span class="line"><span class="string">                        &lt;label for=&quot;&quot;&gt;打豆豆&lt;/label&gt;</span></span><br><span class="line"><span class="string">                        &lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot; value=&quot;打豆豆&quot;&gt;</span></span><br><span class="line"><span class="string">                        &lt;label for=&quot;&quot;&gt;写代码&lt;/label&gt;</span></span><br><span class="line"><span class="string">                        &lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot; value=&quot;写代码&quot;&gt;&lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">                        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span></span><br><span class="line"><span class="string">                    &lt;/form&gt;</span></span><br><span class="line"><span class="string">                &lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;/body&gt;</span></span><br><span class="line"><span class="string">            &lt;/html&gt;</span></span><br><span class="line"><span class="string">            `</span></span><br><span class="line">            res.end(add)</span><br></pre></td></tr></table></figure>

<center>代码段3</center>

<p>将添加用户的表单信息以POST方式提交给localhost:3000/add</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;/add&quot;</span> method=<span class="string">&quot;POST&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>/add 即为 localhost:3000/add</p>
<p>/add 的 ‘/‘即为服务器URL：localhost:3000/</p>
<p><img data-src="/images/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/image-20210525215640354.png" alt="添加用户页面如下"></p>
<br>

<p><strong>服务器端接收到URL为localhost:3000/add的POST请求</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本代码段代码在server.on()函数下</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(method == <span class="string">&#x27;POST&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pathname == <span class="string">&#x27;/add&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> formData = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="comment">//请求参数传送触发</span></span><br><span class="line">            req.on(<span class="string">&#x27;data&#x27;</span>,<span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">                formData+=param</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">//请求参数传送完毕触发</span></span><br><span class="line">            req.on(<span class="string">&#x27;end&#x27;</span>,<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> userinf = queryString.parse(formData)</span><br><span class="line">                <span class="keyword">await</span> User.create(userinf)</span><br><span class="line">                <span class="comment">//请求重定向到</span></span><br><span class="line">                res.writeHead(<span class="number">301</span>,&#123;</span><br><span class="line">                    Location:<span class="string">&#x27;/list&#x27;</span></span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//重定向完 结束本次响应</span></span><br><span class="line">                res.end()</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<center>代码块4</center>

<ul>
<li><p>使用formData变量接收POST请求参数</p>
<ul>
<li>使用queryString模块的parse方法将字符串格式的formData变量转换为<strong>JSON对象格式的userinf变量</strong></li>
<li>/add页面中input标签的<strong>name属性</strong>与数据库文档中的<strong>相应字段名</strong>统一<ul>
<li>这样接收的请求参数转换为JSON对象后就可以直接添加到数据库</li>
</ul>
</li>
</ul>
</li>
<li><p>调用User集合构造函数的create()方法将新用户信息(userinf变量)添加到数据库</p>
</li>
<li><p>在异步函数中使用await关键字<strong>等待异步API返回结果后再继续执行</strong></p>
<ul>
<li><p><code>req.on(&#39;end&#39;,async ()=&gt;&#123;&#125;)</code>方法的回调函数使用async关键字变为异步函数</p>
</li>
<li><p><code>await User.create(userinf)</code></p>
</li>
<li><p>如果不等待，<strong>可能后续的响应操作会先于创建文档执行</strong></p>
</li>
</ul>
</li>
<li><p>响应时将请求重定向到/list页面</p>
<ul>
<li>直接从/list页面查看添加用户的结果</li>
</ul>
</li>
</ul>
<br>

<h2 id="5-修改用户信息功能-modify"><a href="#5-修改用户信息功能-modify" class="headerlink" title="5.修改用户信息功能(/modify)"></a>5.修改用户信息功能(/modify)</h2><ul>
<li><p>通过/list页面的修改按钮进入修改页面</p>
<p><img data-src="/images/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/image-20210525221836885.png" alt="修改按钮"></p>
</li>
<li><p>/modify页面在/add页面的基础上修改而来</p>
</li>
<li><p>点击哪一个用户信息的修改按钮，跳转到的修改页面就会呈现对应用户的信息</p>
</li>
</ul>
<p><img data-src="/images/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/image-20210525221743719.png" alt="点击张三用户信息的修改按钮后跳转"></p>
<ul>
<li>跳转页面显示对应用户的信息是<strong>通过传递相应用户信息文档的_id字段值</strong>实现的</li>
</ul>
<p><img data-src="/images/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/image-20210525222016451.png" alt="数据库中张三信息文档的_id"></p>
<ul>
<li>在响应给客户端的/list页面的html代码中<ul>
<li>将_id字段的值放入修改按钮的<strong>a标签</strong>中</li>
<li>_id字段的值作为<strong>GET请求的请求参数</strong>传递给服务器</li>
</ul>
</li>
</ul>
<p><img data-src="/images/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/image-20210525222621352.png" alt="点击修改按钮时_id的值传递给服务器"></p>
<ul>
<li><p>服务器端从接收到的请求参数中提取_id值，并将相应用户的信息填入文本框中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取JSON对象格式的请求参数</span></span><br><span class="line"><span class="keyword">let</span> reqinf = url.parse(req.url,<span class="literal">true</span>).query</span><br><span class="line"><span class="comment">//在数据库中查找相应用户信息文档</span></span><br><span class="line"><span class="keyword">let</span> user=<span class="keyword">await</span> User.findOne(&#123;<span class="attr">_id</span>:reqinf.id&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在修改页面的单行文本输入框中填入相应用户的信息</span></span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> value=$&#123;user.name&#125; name=<span class="string">&quot;name&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>效果如上图</p>
</li>
<li><p>修改页面的表单提交时以POST方式发送请求给/modify</p>
<ul>
<li>同样将_id字段值当作请求参数传递给服务端</li>
<li>以便服务端根据_id值更新数据库信息</li>
<li>POST方式的请求也可以使用GET请求方式的方法来传递请求参数(放在地址栏中)</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;/modify?id=$&#123;user._id&#125;&quot;</span> method=<span class="string">&quot;POST&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>服务器端接收到POST请求时将根据_id值更新对应用户信息文档</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用await关键字等待异步API返回结果后再接着执行</span></span><br><span class="line"><span class="keyword">await</span> User.updateOne(&#123;<span class="attr">_id</span>:reqinf.id&#125;,userinf)</span><br></pre></td></tr></table></figure>

<ul>
<li>更新数据库文档信息后请求重定向到/list页面<ul>
<li>直接在/list页面体现修改结果</li>
</ul>
</li>
</ul>
<p><img data-src="/images/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/image-20210525224319251.png" alt="将张三修改为张三123"></p>
<p><img data-src="/images/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/image-20210525224343590.png" alt="修改后结果"></p>
<br>

<h2 id="6-删除用户信息功能-del"><a href="#6-删除用户信息功能-del" class="headerlink" title="6.删除用户信息功能(/del)"></a>6.删除用户信息功能(/del)</h2><ul>
<li>通过/list页面的删除按钮进入删除页面</li>
<li>点击相应数据行的删除按钮会将该文档的_id字段值作为GET请求参数发送给服务器</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;del&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/del?id=$&#123;item._id&#125;&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>发送到<code>http://localhost:3000/del</code></p>
<ul>
<li>服务器接收到请求后</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pathname == <span class="string">&#x27;/del&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">await</span> User.findOneAndDelete(&#123;<span class="attr">_id</span>:query.id&#125;)</span><br><span class="line">            res.writeHead(<span class="number">301</span>,&#123;</span><br><span class="line">                Location:<span class="string">&#x27;/list&#x27;</span></span><br><span class="line">            &#125;)</span><br><span class="line">            res.end()</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>调用<strong>集合构造函数的findOneAndDelete()方法</strong>按照_id字段值删除数据库中相应文档</p>
<p>然后将请求重定向到/list页面，在/list页面就可以看到删除后的效果</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Mongodb数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5新内容</title>
    <url>/2022/11/27/14-HTML5%E6%96%B0%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h1 id="HTML5新内容"><a href="#HTML5新内容" class="headerlink" title="HTML5新内容"></a>HTML5新内容</h1><h2 id="1-新增语义化标签"><a href="#1-新增语义化标签" class="headerlink" title="1. 新增语义化标签"></a>1. 新增语义化标签</h2><p>HTML5新增了</p>
<ul>
<li>语义化标签、</li>
<li>表单控件、(比如数字、日期、时间、日历和滑块。)</li>
<li>强大的图像支持、( <code>&lt;canvas&gt;</code> 和 <code>&lt;svg&gt;</code>)</li>
<li>强大的多媒体支持和强大的API  (加入WebStorage替代Cookie)<ul>
<li>WebStorage：LoaclStrorage和SessionStorage</li>
</ul>
</li>
</ul>
<span id="more"></span>

<p>语义化标签</p>
<table>
<thead>
<tr>
<th><code>&lt;article&gt;</code></th>
<th>定义文档内的文章。</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;aside&gt;</code></td>
<td>定义页面内容之外的内容。</td>
</tr>
<tr>
<td><code>&lt;bdi&gt;</code></td>
<td>定义与其他文本不同的文本方向。</td>
</tr>
<tr>
<td><code>&lt;details&gt;</code></td>
<td>定义用户可查看或隐藏的额外细节。</td>
</tr>
<tr>
<td><code>&lt;dialog&gt;</code></td>
<td>定义对话框或窗口。</td>
</tr>
<tr>
<td><code>&lt;figcaption&gt;</code></td>
<td>定义<code>&lt;figure&gt;</code>元素的标题。</td>
</tr>
<tr>
<td><code>&lt;figure&gt;</code></td>
<td>定义自包含内容，比如图示、图表、照片、代码清单等等。</td>
</tr>
<tr>
<td><code>&lt;footer&gt;</code></td>
<td>定义文档或节的页脚。</td>
</tr>
<tr>
<td><code>&lt;header&gt;</code></td>
<td>定义文档或节的页眉。</td>
</tr>
<tr>
<td><code>&lt;main&gt;</code></td>
<td>定义文档的主内容。</td>
</tr>
<tr>
<td><code>&lt;mark&gt;</code></td>
<td>定义重要或强调的内容。</td>
</tr>
<tr>
<td><code>&lt;menuitem&gt;</code></td>
<td>定义用户能够从弹出菜单调用的命令/菜单项目。</td>
</tr>
<tr>
<td><code>&lt;meter&gt;</code></td>
<td>定义已知范围（尺度）内的标量测量。</td>
</tr>
<tr>
<td><code>&lt;nav&gt;</code></td>
<td>定义文档内的导航链接。</td>
</tr>
<tr>
<td><code>&lt;progress&gt;</code></td>
<td>定义任务进度。</td>
</tr>
<tr>
<td><code>&lt;rp&gt;</code></td>
<td>定义在不支持 ruby 注释的浏览器中显示什么。</td>
</tr>
<tr>
<td><code>&lt;rt&gt;</code></td>
<td>定义关于字符的解释/发音（用于东亚字体）。</td>
</tr>
<tr>
<td><code>&lt;ruby&gt;</code></td>
<td>定义 ruby 注释（用于东亚字体）。</td>
</tr>
<tr>
<td><code>&lt;section&gt;</code></td>
<td><strong>定义文档中的节。</strong></td>
</tr>
<tr>
<td><code>&lt;summary&gt;</code></td>
<td>定义 <code>&lt;details&gt;</code> 元素的可见标题。</td>
</tr>
<tr>
<td><code>&lt;time&gt;</code></td>
<td>定义日期/时间。</td>
</tr>
<tr>
<td><code>&lt;wbr&gt;</code></td>
<td>定义可能的折行（line-break）。</td>
</tr>
</tbody></table>
<h2 id="2-删除一些标签"><a href="#2-删除一些标签" class="headerlink" title="2. 删除一些标签"></a>2. 删除一些标签</h2><ul>
<li>```HTML <acronym>
 <applet>
 <basefont>
 <big>
 <center>
 <dir>
 <font>
 <frame>
 <frameset>
 <noframes>
 <strike>
 <tt>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在HTML5中使用CSS样式完成这些标签的作用</span><br><span class="line"></span><br><span class="line">## 3. 简化Doctype声明等一系列细微优化</span><br><span class="line"></span><br><span class="line">只需要写&#96;&lt;!doctype html&gt;&#96;就行了</span><br><span class="line"></span><br><span class="line">## 4. HTML5 是跨平台的</span><br><span class="line"></span><br><span class="line">被设计为在不同类型的硬件：</span><br><span class="line"></span><br><span class="line">- PC、</span><br><span class="line">- 平板、</span><br><span class="line">- 手机、</span><br><span class="line">- 电视机等等）之上运行。</span><br><span class="line"></span><br><span class="line">## 5. HTML5应用程序缓存</span><br><span class="line"></span><br><span class="line">HTML5 引入了应用程序缓存（Application Cache），这意味着可**对 web 应用进行缓存**，并可在没有因特网连接时进行访问。</span><br><span class="line"></span><br><span class="line">应用程序缓存为应用带来三个优势：</span><br><span class="line"></span><br><span class="line">1. **离线浏览** - 用户可在应用离线时使用它们</span><br><span class="line">2. **速度** - 已缓存资源加载得更快</span><br><span class="line">3. **减少服务器负载** - 浏览器将只从服务器下载更新过或更改过的资源</span><br><span class="line"></span><br><span class="line">强缓存和协商缓存之分</span><br><span class="line"></span><br><span class="line">## 6. HTML5跨文档消息传输</span><br><span class="line"></span><br><span class="line">h5提供了网页文档之间发送信息和互相接收的功能。</span><br><span class="line"></span><br><span class="line">使用这个功能，只要**获得网页窗口所在对象的实例**，</span><br><span class="line"></span><br><span class="line">- 即可以**同域**（协议+端口号+域名）相互通信，</span><br><span class="line">- **跨域也可以相互通信**。</span><br><span class="line"></span><br><span class="line">### 6.1 接收其他窗口向本窗口发送的消息</span><br><span class="line"></span><br><span class="line">接受从其他的窗口那里发送的消息，**对窗口对象的message事件进行监听**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">window.addEventListener(&quot;message&quot;,function(event)&#123;</span><br><span class="line">    console.log(event.data)</span><br><span class="line">&#125;,false)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>event.data</code>：事件对象的data属性即为其他窗口发送来的消息</p>
<h3 id="6-2-向其他窗口发送消息"><a href="#6-2-向其他窗口发送消息" class="headerlink" title="6.2 向其他窗口发送消息"></a>6.2 向其他窗口发送消息</h3><p>使用<strong>其他窗口window对象的postMessage方法</strong>向其他窗口发送消息，其方法定义如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">otherWindow.postMessage(message,targetOrigin)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>otherWindow</strong>：目标窗口的引用(其他窗口的window对象)</p>
</li>
<li><p>第一个参数为所<strong>发送的消息文本</strong></p>
</li>
<li><p>第二个参数为<strong>接收消息的窗口的URL地址</strong></p>
</li>
</ul>
<p>例子：<img data-src="/images/14-HTML5%E6%96%B0%E5%86%85%E5%AE%B9/image-20211020174037417.png" alt="image-20211020174037417"></p>
<p>父页面向内嵌页面发送消息</p>
]]></content>
      <categories>
        <category>HTMLandCss</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>14-Promise对象</title>
    <url>/2022/12/04/14-promise%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="promise对象"><a href="#promise对象" class="headerlink" title="promise对象"></a>promise对象</h1><p>通过<code>13-eventloop_宏任务_微任务</code>我们得知</p>
<ul>
<li>虽然JavaScript是单线程的</li>
<li>但是在js中<strong>使用异步编程是必须的</strong></li>
</ul>
<p>首先提出一个异步编程使用过程中可能会出现的<strong>回调地狱的问题</strong></p>
<span id="more"></span>

<h2 id="回调地狱问题"><a href="#回调地狱问题" class="headerlink" title="回调地狱问题"></a>回调地狱问题</h2><p>例如要顺序使用node中的<code>fs.readFile()</code>方法打开三个文件</p>
<p><code>fs.readFile()</code>是一个js的<strong>异步API</strong>，想要顺序打开三个文件可以<strong>使用回调函数嵌套的方法</strong></p>
<ul>
<li>即在打开第一个文件的<code>fs.readFile()</code>方法的<strong>回调函数中打开第二个文件</strong></li>
<li>在打开第二个文件的API<strong>回调函数中打开第三个文件</strong></li>
</ul>
<p>代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;./1.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">err , data1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data1);</span><br><span class="line">    <span class="comment">//嵌套在上一个readFile API的回调函数中</span></span><br><span class="line">    fs.readFile(<span class="string">&#x27;./2.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">err , data2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data2);</span><br><span class="line">        fs.readFile(<span class="string">&#x27;./3.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">err , data3</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(data3);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用这种方式确实可以解决<strong>顺序调用异步API的问题</strong></li>
<li>但是又引入了新的问题<ul>
<li>嵌套层数过多导致<strong>维护困难</strong></li>
<li>多个异步API通过回调函数嵌套被称为<strong>回调地狱</strong></li>
</ul>
</li>
</ul>
<p>而promise对象出现的目的就是<strong>解决这种回调地狱问题</strong></p>
<br>

<h2 id="Promise对象定义"><a href="#Promise对象定义" class="headerlink" title="Promise对象定义"></a>Promise对象定义</h2><p>promise并<strong>没有提供新的功能</strong>，它是一种异步编程<strong>语法上的改进</strong>（一种解决方案），可以将异步API的<strong>执行</strong>和<strong>结果的处理</strong>进行分离。</p>
<p>Promise 的设计思想是，所有异步任务都<strong>返回一个 Promise 实例</strong>。Promise 实例有一个<code>then</code>方法，<strong>用来指定下一步的回调函数。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line">step1(<span class="function"><span class="keyword">function</span> (<span class="params">value1</span>) </span>&#123;</span><br><span class="line">  step2(value1, <span class="function"><span class="keyword">function</span>(<span class="params">value2</span>) </span>&#123;</span><br><span class="line">    step3(value2, <span class="function"><span class="keyword">function</span>(<span class="params">value3</span>) </span>&#123;</span><br><span class="line">      step4(value3, <span class="function"><span class="keyword">function</span>(<span class="params">value4</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise 的写法</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Promise</span>(step1))</span><br><span class="line">  .then(step2)</span><br><span class="line">  .then(step3)</span><br><span class="line">  .then(step4);</span><br></pre></td></tr></table></figure>

<ul>
<li>从上面代码就可以看出，promise对象<strong>使用then方法链式调用的方式</strong>代替了传统的回调嵌套方式<ul>
<li>代码的可读性提高</li>
<li>对于需要多层嵌套的回调函数处理更加方便</li>
</ul>
</li>
</ul>
<br>

<h2 id="Promise对象的状态"><a href="#Promise对象的状态" class="headerlink" title="Promise对象的状态"></a>Promise对象的状态</h2><p>Promise 对象通过自身的<strong>状态</strong>，来控制异步操作。Promise 实例具有三种状态。</p>
<ul>
<li>异步操作未完成（pending）</li>
<li>异步操作成功（fulfilled）</li>
<li>异步操作失败（rejected）</li>
</ul>
<p>上面三种状态里面，<code>fulfilled</code>和<code>rejected</code>合在一起称为<code>resolved</code>（已定型）</p>
<p>这三种的状态的变化途径只有两种。</p>
<ul>
<li>从“未完成”到“成功”</li>
<li>从“未完成”到“失败”</li>
</ul>
<p>一旦状态发生变化，就凝固了，<strong>不会再有新的状态变化</strong>。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，<strong>Promise 实例的状态变化只可能发生一次。</strong></p>
<p>Promise 的最终结果只有两种。</p>
<ul>
<li>异步操作成功，Promise 实例传回一个值（value），状态变为<code>fulfilled</code>。</li>
<li>异步操作失败，Promise 实例抛出一个错误（error），状态变为<code>rejected</code>。</li>
</ul>
<br>

<h2 id="Promise基本使用"><a href="#Promise基本使用" class="headerlink" title="Promise基本使用"></a>Promise基本使用</h2><p>promise构造函数是<strong>同步执行</strong>，<code>.then</code>方法是异步执行</p>
<p>promise是一种对象，也是一种构造函数，使用时需要new 生成对象实例</p>
<p><code>new Promise()</code>中传入匿名函数<code>(resolve,reject) =&gt; &#123;&#125;</code></p>
<p>匿名函数的两个<strong>固定的</strong>参数函数<strong>resolve，reject</strong></p>
<ul>
<li>resolve 函数：当异步API执行成功时手动调用这个函数</li>
<li>reject 函数：异步API执行失败时手动调用这个函数</li>
</ul>
<p>在匿名函数<code>(resolve,reject) =&gt; &#123;&#125;</code>中书写异步API代码</p>
<ul>
<li><strong>在匿名函数中完成异步API的执行</strong></li>
<li>利用resolve和reject这两个参数函数，在Promise实例对象<strong>外部处理异步API的结果和错误</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Promise实例对象</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve , reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//匿名函数中书写异步API代码</span></span><br><span class="line">    fs.readFile(<span class="string">&#x27;./1.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">err , data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(err != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//文件打开失败调用reject函数</span></span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//成功</span></span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Promise实例对象外部处理异步API的结果</span></span><br><span class="line"><span class="comment">//在promise实例对象内部调用resolve函数即将成功执行的结果作为参数传递给then()中的回调函数</span></span><br><span class="line">promise.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//调用reject函数即为将错误信息作为参数传递给catch()中的回调函数(错误处理函数)</span></span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="Promise-portotype-then-方法"><a href="#Promise-portotype-then-方法" class="headerlink" title="Promise.portotype.then()方法"></a>Promise.portotype.then()方法</h3><p>Promise实例对象的方法，用来添加处理异步API结果的回调函数</p>
<p><strong>返回值：</strong>返回一个promise对象(可以链式调用<code>.then</code>的原理)</p>
<p><code>then</code>方法可以接受两个回调函数作为参数：</p>
<ul>
<li>第一个是<strong>异步操作成功</strong>时（变为<code>fulfilled</code>状态）的回调函数（接收resolve(‘参数’)方法的参数）</li>
<li>第二个是<strong>异步操作失败</strong>（变为<code>rejected</code>）时的回调函数（该参数可以省略）。(接受reject(‘参数’)方法的参数)</li>
<li>一旦状态改变，就调用相应的回调函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="built_in">console</span>.log, <span class="built_in">console</span>.error);</span><br><span class="line"><span class="comment">// 输出&quot;成功&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;失败&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="built_in">console</span>.log, <span class="built_in">console</span>.error);</span><br><span class="line"><span class="comment">// 输出Error: 失败</span></span><br></pre></td></tr></table></figure>

<h3 id="Promise-prototype-catch-方法"><a href="#Promise-prototype-catch-方法" class="headerlink" title="Promise.prototype.catch()方法"></a>Promise.prototype.catch()方法</h3><p>Promise实例对象的方法，添加<strong>异步操作失败时</strong>的<strong>回调函数</strong></p>
<h3 id="then链式调用的问题"><a href="#then链式调用的问题" class="headerlink" title=".then链式调用的问题"></a>.then链式调用的问题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p1</span><br><span class="line">  .then(step1)</span><br><span class="line">  .then(step2)</span><br><span class="line">  .then(step3)</span><br><span class="line">  .then(</span><br><span class="line">    <span class="built_in">console</span>.log,</span><br><span class="line">    <span class="built_in">console</span>.error</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<ul>
<li><code>console.log</code>这个回调函数当step3这一层的状态变为<code>fulfilled</code>成功时调用</li>
<li>对于<code>console.error</code>，若step1这一层发生错误后，后续.then中的<strong>成功回调函数都不会执行</strong><ul>
<li>此时会寻找从step1开始的<strong>错误回调函数</strong>，如果<code>console.error</code>为链式中唯一的错误回调函数</li>
<li>就会执行这个错误回调函数</li>
<li>Promise 对象的<strong>报错具有传递性</strong></li>
</ul>
</li>
</ul>
<h3 id="then-用法辨析"><a href="#then-用法辨析" class="headerlink" title="then()用法辨析"></a>then()用法辨析</h3><p>上一个then方法的<strong>返回值</strong>作为下一个then方法<strong>回调函数的参数</strong></p>
<h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f2();</span><br><span class="line">&#125;).then(f3);</span><br></pre></td></tr></table></figure>

<p>f3回调函数的参数为f2()的结果</p>
<h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  f2();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;).then(f3);</span><br></pre></td></tr></table></figure>

<p>f3回调函数的参数为undefined</p>
<br>

<h2 id="Promise构造函数的静态方法"><a href="#Promise构造函数的静态方法" class="headerlink" title="Promise构造函数的静态方法"></a>Promise构造函数的静态方法</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"><code>Promise.all(iterable)</code></a></p>
<p>Promise.all方法常被用于<strong>处理多个promise对象的状态集合</strong>。</p>
<ul>
<li><p><strong>参数<code>iterable</code>：</strong>是一个<strong>promise对象组成的序列</strong>（数组等）</p>
</li>
<li><p><strong>返回值：</strong>一个<strong>新的promise对象</strong></p>
<ul>
<li><strong>新promise对象正确返回(成功)：</strong>当<code>iterable</code>参数里所有的promise对象<strong>都成功</strong>的时候，<ul>
<li>将<u><strong>包含iterable里所有promise对象成功返回值的数组</strong></u>作为<strong>新promise对象成功回调函数</strong>(then方法的第一个回调函数)的<u><strong>参数</strong></u></li>
</ul>
</li>
<li><strong>新promise对象触发失败：</strong><code>iterable</code>里面的<strong>任一promise对象失败则立即触发该新promise对象的失败</strong>。<ul>
<li>新的promise对象触发了失败状态，它会把<code>iterable</code>里<strong>第一个触发失败的promise对象</strong>的错误信息<strong>作为它的失败错误信息</strong>（即catch方法中回调函数的参数）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a、b、c、d函数均返回一个promise对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;你好&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;你好2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;你好3&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    reject(<span class="string">&#x27;错误d&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将包含a函数和b函数的数组作为all方法的参数</span></span><br><span class="line"><span class="comment">//a和b函数均正确返回，所以新promise对象正确返回</span></span><br><span class="line"><span class="comment">//成功回调函数参数x即为包含两个promise对象返回值的数组</span></span><br><span class="line"><span class="built_in">Promise</span>.all([a(),b()]).then(<span class="function">(<span class="params">x</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//c正确返回，d错误</span></span><br><span class="line"><span class="comment">//新promise对象失败，第一个错误promise对象的错误信息作为新promise对象错误回调函数的参数err</span></span><br><span class="line"><span class="built_in">Promise</span>.all([c(),d()]).catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any"><code>Promise.any(iterable)</code></a></p>
<p>接收一个Promise对象的集合（数组等），</p>
<ul>
<li>当其中的一个 promise 成功，就立即返回那个成功的promise。</li>
<li>如果所有传入的 <code>promise</code> 都失败, <code>Promise.any</code> 将返回异步失败，和一个 <code>AggregateError</code> 对象，它继承自 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error">Error</a>，有一个 <code>error</code> 属性，属性值是<strong>由所有失败值填充的数组。</strong></li>
</ul>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>14-模板引擎基础</title>
    <url>/2021/05/31/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="模板引擎基础"><a href="#模板引擎基础" class="headerlink" title="模板引擎基础"></a>模板引擎基础</h1><p>文章<a href="https://templar136.github.io/2021/05/24/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/">13-用户信息增删改查实例</a>中服务器响应html代码的方式为直接在服务器代码中进行<strong>字符串拼接</strong></p>
<p>这种方式比较<strong>繁琐</strong>，而且<strong>难以维护</strong></p>
<p>使用模板引擎可以简化操作，便于维护</p>
<p><strong>模板引擎</strong></p>
<ul>
<li>实际上是nodejs的<strong>第三方模块</strong></li>
<li>主要用于提高字符串拼接的效率，便于维护</li>
</ul>
<span id="more"></span>

<h2 id="1-模板引擎art-template"><a href="#1-模板引擎art-template" class="headerlink" title="1.模板引擎art-template"></a>1.模板引擎art-template</h2><p>art-template是腾讯公司的模板引擎，应用广泛</p>
<h3 id="1-1安装art-template模板引擎"><a href="#1-1安装art-template模板引擎" class="headerlink" title="1.1安装art-template模板引擎"></a>1.1安装art-template模板引擎</h3><p><code>npm install art-template</code></p>
<h3 id="1-2使用art-template"><a href="#1-2使用art-template" class="headerlink" title="1.2使用art-template"></a>1.2使用art-template</h3><p>引入模板引擎第三方模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> template = <span class="built_in">require</span>(<span class="string">&#x27;art-template&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>返回的template为一个方法</p>
<p><code>const html = template(&quot;模板的路径&quot;,&quot;待拼接的数据&quot;)</code></p>
<ul>
<li><p>模板的路径：模板存放的<strong>绝对路径</strong></p>
<ul>
<li>模板一般存放在views文件夹(views是约定俗成的命名)中，模板文件的后缀一般为.art</li>
<li>如果要拼接html模板，则在.art文件中写入html代码</li>
</ul>
</li>
<li><p>待拼接的数据：<strong>对象格式</strong>的数据</p>
</li>
<li><p>html变量保存拼接完成后的html代码</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拼接路径 __dirname:当前文件所在目录</span></span><br><span class="line"><span class="keyword">let</span> viewpath = path.join(__dirname,<span class="string">&#x27;views&#x27;</span>,<span class="string">&#x27;index.art&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存拼接后的html代码</span></span><br><span class="line"><span class="keyword">const</span> html = template(viewpath,&#123;</span><br><span class="line">    name:<span class="string">&quot;yang&quot;</span>,</span><br><span class="line">    age:<span class="number">20</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="built_in">console</span>.log(html);</span><br></pre></td></tr></table></figure>

<center>app.js代码</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123;age&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<center>Index.art代码</center>

<p>在index.art模板文件中使用<code>&#123;&#123;"属性名"&#125;&#125;</code>将template方法中<code>待拼接的数据</code>拼接到html代码中</p>
<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210531203434078.png" alt="拼接完成后打印html变量"></p>
<p>待拼接的数据已经拼接到html代码中</p>
<br>

<h2 id="2-模板引擎art-template语法"><a href="#2-模板引擎art-template语法" class="headerlink" title="2.模板引擎art-template语法"></a>2.模板引擎art-template语法</h2><p>art-template支持两种语法：<strong>标准语法</strong> 和 <strong>原始语法</strong></p>
<ul>
<li>标准语法：让模板更易读写</li>
<li>原始语法：具有强大的逻辑处理能力</li>
</ul>
<p>标准输出语法：</p>
<p>原始输出语法：&lt;%= 数据 %&gt;</p>
<p>原始语法的输出格式类似于<strong>JSP表达式</strong></p>
<h3 id="2-1输出"><a href="#2-1输出" class="headerlink" title="2.1输出"></a>2.1输出</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 标准语法 --&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123;<span class="number">1</span> + <span class="number">1</span>&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123;<span class="number">1</span> + <span class="number">1</span> == <span class="number">2</span> ? <span class="string">&quot;正确&quot;</span> : <span class="string">&quot;错误&quot;</span>&#125;&#125;&lt;/p&gt;</span><br><span class="line">    </span><br><span class="line">&lt;!-- 原始语法 --&gt;</span><br><span class="line">&lt;p&gt;&lt;%= name %&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;%= <span class="number">1</span>+<span class="number">1</span> %&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;%= <span class="number">1</span>?<span class="string">&quot;正确&quot;</span>:<span class="string">&quot;错误&quot;</span> %&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>数据可以是template方法<strong>第二个参数中的数据</strong></p>
</li>
<li><p>可以是<strong>数字</strong>和<strong>普通字符串</strong></p>
</li>
<li><p>可以<strong>使用运算符操作</strong></p>
</li>
</ul>
<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210531205514506.png" alt="拼接后的html代码"></p>
<br>

<h3 id="2-2原文输出"><a href="#2-2原文输出" class="headerlink" title="2.2原文输出"></a>2.2原文输出</h3><h4 id="2-2-1-模板引擎默认将HTML标签当作普通字符串拼接"><a href="#2-2-1-模板引擎默认将HTML标签当作普通字符串拼接" class="headerlink" title="2.2.1 模板引擎默认将HTML标签当作普通字符串拼接"></a>2.2.1 模板引擎默认将HTML标签当作普通字符串拼接</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> html = template(viewpath,&#123;</span><br><span class="line">    name:<span class="string">&quot;yang&quot;</span>,</span><br><span class="line">    age:<span class="number">20</span>,</span><br><span class="line">    content:<span class="string">&quot;&lt;h1&gt;你好&lt;/h1&gt;&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>01.js</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123;content&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;%= content %&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<center>01.art</center>

<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210531210107038.png" alt="拼接后代码"></p>
<p>输出的html代码中h1标签被当作普通字符串输出</p>
<p>浏览器不会解析这个h1标签</p>
<br>

<h4 id="2-2-2原文输出解析HTML标签"><a href="#2-2-2原文输出解析HTML标签" class="headerlink" title="2.2.2原文输出解析HTML标签"></a>2.2.2原文输出解析HTML标签</h4><p>如果数据中带HTML标签，可以使用原文输出的方式来解析标签</p>
<p>标准语法：<code>&#123;&#123; @数据 &#125;&#125;</code></p>
<p>原始语法：<code>&lt;%- 数据 %&gt;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123;@content&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;%- content %&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>此时输出html代码如下</p>
<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210531211207051.png" alt="输出html代码"></p>
<p>此时拼接的HTML代码中的h1标签<strong>会被浏览器自动解析</strong></p>
<br>

<h3 id="2-3条件判断"><a href="#2-3条件判断" class="headerlink" title="2.3条件判断"></a>2.3条件判断</h3><p>模板中可以根据条件决定显示哪块HTML代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    标准语法	--&gt;</span></span><br><span class="line">    &#123;&#123;if 条件&#125;&#125;...&#123;&#123;/if&#125;&#125;</span><br><span class="line">    &#123;&#123;if 条件&#125;&#125;...&#123;&#123;else if 条件&#125;&#125;...&#123;&#123;/if&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    原始语法	--&gt;</span></span><br><span class="line">	&lt;% if (value) &#123; %&gt;...&lt;% &#125; %&gt;</span><br><span class="line">	&lt;% if (value) &#123; %&gt;...&lt;% &#125; else if (value) &#123; %&gt;...&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<p><strong>标准语法</strong>：将判断条件语句写在<code>&#123;&#123;&#125;&#125;`中，两个`&#123;&#123;&#125;&#125;</code>中的…即为满足条件时显示的HTML代码，以<code>&#123;&#123;/if&#125;&#125;</code>结束</p>
<p><strong>原始语法</strong>：将判断条件语句写在<code>&lt;% %&gt;</code>中，…即为满足条件时显示的HTML代码</p>
<ul>
<li>原始语法格式的<code>&lt;% %&gt;</code><strong>类似于</strong>JSP中的java代码块</li>
<li>在模板的<code>&lt;% %&gt;</code>中可以写<strong>任何原生js代码</strong></li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&#123;&#123;if age&gt;18&#125;&#125;</span><br><span class="line">    年龄大于18</span><br><span class="line">&#123;&#123;else if age &lt; 15&#125;&#125;</span><br><span class="line">    年龄小于15</span><br><span class="line">&#123;&#123;/if&#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;% if (age&gt;18) &#123; %&gt;</span><br><span class="line">    年龄大于18</span><br><span class="line">&lt;% &#125; else if (age &lt; 15) &#123; %&gt;</span><br><span class="line">    年龄小于15</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<center>03.art</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> html = template(viewpath,&#123;</span><br><span class="line">    name:<span class="string">&quot;yang&quot;</span>,</span><br><span class="line">    age:<span class="number">20</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>03.js</center>

<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210531214406700.png" alt="03.js运行后输出HTML代码"></p>
<p>20大于18，输出<code>年龄大于18</code></p>
<br>

<h3 id="2-4循环"><a href="#2-4循环" class="headerlink" title="2.4循环"></a>2.4循环</h3><p>当template()方法的第二个参数中有存放在数组中的数据时，就需要通过循环依次拿出数组中的数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/标准语法</span><br><span class="line">&#123;&#123;each 数据&#125;&#125;</span><br><span class="line">       &#123;&#123;$index&#125;&#125;</span><br><span class="line">       &#123;&#123;$value&#125;&#125;</span><br><span class="line">&#123;&#123;/each&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>数据：要循环输出的数组(一般为template()方法第二个参数中的数据)</p>
<p>$index：每次循环的索引，从0开始</p>
<p>$value：每次循环的数据(数组中的元素)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原始语法</span></span><br><span class="line">&lt;% <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; 数据.length; i++) &#123; %&gt;</span><br><span class="line">   &lt;%= 数据[i].属性名 %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<p>数据：要循环输出的数组</p>
<p>数据[i]：即为数组中的第i个元素</p>
<p>数据[i].属性名：数组中元素的属性(元素为对象)</p>
<p>&lt;% %&gt;标签中写的为原生js的循环语句</p>
<p>通过原始语法的输出标签&lt;%= %&gt;进行输出</p>
<br>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> html = template(viewpath,&#123;</span><br><span class="line">    users:[</span><br><span class="line">        &#123;</span><br><span class="line">            name:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">            age:<span class="number">20</span>,</span><br><span class="line">            sex:<span class="string">&quot;男&quot;</span></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            name:<span class="string">&quot;李四&quot;</span>,</span><br><span class="line">            age:<span class="number">18</span>,</span><br><span class="line">            sex:<span class="string">&quot;女&quot;</span></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            name:<span class="string">&quot;王五&quot;</span>,</span><br><span class="line">            age:<span class="number">22</span>,</span><br><span class="line">            sex:<span class="string">&quot;男&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>04.js</center>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//标准语法</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;&#123;each users&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">            &#123;&#123;$index&#125;&#125;</span><br><span class="line">            &#123;&#123;$value.name&#125;&#125;</span><br><span class="line">            &#123;&#123;$value.age&#125;&#125;</span><br><span class="line">            &#123;&#123;$value.sex&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;&#123;/each&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//原始语法</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &lt;% for(var i = 0; i &lt; users.length; i++) &#123; %&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">            &lt;%= i %&gt;</span><br><span class="line">            &lt;%= users[i].name %&gt;</span><br><span class="line">            &lt;%= users[i].age %&gt;</span><br><span class="line">            &lt;%= users[i].sex %&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<center>04.art</center>

<p>使用循环在ul标签中根据数组元素的个数生成li标签并在li标签中显示数组元素的属性</p>
<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210601211958346.png" alt="循环语句执行结果"></p>
<br>

<h3 id="2-5子模版"><a href="#2-5子模版" class="headerlink" title="2.5子模版"></a>2.5子模版</h3><p>通常一个网站的数个网页有公共的头部和底部，将这些公共代码提取出来后，可以使用模板引擎的<strong>子模版语法</strong>将这些公共代码在所有需要的网页中进行引入。</p>
<p><strong>标准语法</strong>：</p>
<p>子模版语法使用单标签，没有结束标签</p>
<p>标准语法的include 是关键字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123;include <span class="string">&#x27;公共代码模板文件的相对路径&#x27;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原始语法</strong>：</p>
<p>原始语法的include是方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;% include(<span class="string">&#x27;公共代码模板文件的相对路径&#x27;</span>)%&gt;</span><br></pre></td></tr></table></figure>

<br>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;include &#x27;./05common/header.art&#x27;&#125;&#125;</span><br><span class="line">&lt;% include(&#x27;./05common/header.art&#x27;)%&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;&#123;include &#x27;./05common/footer.art&#x27;&#125;&#125;</span><br><span class="line">&lt;% include(&#x27;./05common/footer.art&#x27;)%&gt;</span><br></pre></td></tr></table></figure>

<center>05.art</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//header.art文件</span></span><br><span class="line">这是头部</span><br><span class="line"></span><br><span class="line"><span class="comment">//footer.art文件</span></span><br><span class="line">这是底部</span><br><span class="line"></span><br><span class="line"><span class="comment">//05.js文件</span></span><br><span class="line"><span class="keyword">const</span> html = template(viewpath,&#123;</span><br><span class="line">    msg:<span class="string">&quot;子模版演示&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210601213402446.png" alt="引入公共代码模板文件header.art和footer.art"></p>
<br>

<h3 id="2-6模板继承"><a href="#2-6模板继承" class="headerlink" title="2.6模板继承"></a>2.6模板继承</h3><ul>
<li><p>在网页中不仅只有头部和底部属于公共代码，页面的HTML骨架(html,body标签等)也属于公共代码</p>
</li>
<li><p>可以<strong>将HTML骨架也提取为公共代码模板文件</strong>，然后通过<strong>模板继承</strong>的方式引入HTML骨架</p>
</li>
<li><p>不同的页面继承HTML骨架后需要<strong>对骨架进行差异化修改</strong></p>
</li>
</ul>
<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210601221400538.png" alt="模板继承和引入/包含子模版"></p>
<h4 id="HTML骨架模板的差异化修改"><a href="#HTML骨架模板的差异化修改" class="headerlink" title="HTML骨架模板的差异化修改"></a>HTML骨架模板的差异化修改</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML骨架模板 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123;block &#x27;title&#x27;&#125;&#125;&#123;&#123;/block&#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    &#123;&#123;block &#x27;link&#x27;&#125;&#125;&#123;&#123;/block&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;&#123;block &#x27;content&#x27;&#125;&#125;&#123;&#123;/block&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<center>HTML骨架文件layout.art</center>

<p>差异化修改需要用到<strong>双标签block</strong></p>
<p>将block标签放在骨架模板的各个位置，后续页面进行继承时就可以<strong>替换这些block标签</strong>以达到<strong>差异化修改</strong>的目的</p>
<p><code>&#123;&#123;block '名字'&#125;&#125;&#123;&#123;/block&#125;&#125;</code></p>
<p>名字：自定义的每个block的<strong>标识</strong>，继承骨架的页面可以通过名字对block标签进行替换</p>
<br>

<h4 id="继承HTML骨架文件并替换block标签"><a href="#继承HTML骨架文件并替换block标签" class="headerlink" title="继承HTML骨架文件并替换block标签"></a>继承HTML骨架文件并替换block标签</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//继承骨架</span><br><span class="line">&#123;&#123;extend &#x27;./common/layout.art&#x27;&#125;&#125;</span><br><span class="line"></span><br><span class="line">//替换相应block标签</span><br><span class="line">&#123;&#123;block &#x27;title&#x27;&#125;&#125;首页&#123;&#123;/block&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;block &#x27;link&#x27;&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;main.css&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;/block&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;block &#x27;content&#x27;&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;&#123;/block&#125;&#125;</span><br></pre></td></tr></table></figure>

<center>继承HTML骨架的06.art</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> html = template(viewpath,&#123;</span><br><span class="line">    msg:<span class="string">&quot;模版继承演示&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>06.js</center>

<p><strong>继承骨架文件</strong></p>
<p><code>&#123;&#123;extend 'HTML骨架文件的路径'&#125;&#125;</code></p>
<p><strong>替换block标签</strong></p>
<p><code>&#123;&#123;block '名字'&#125;&#125;...&#123;&#123;/block&#125;&#125;</code></p>
<p>使用名字定位要替换的block标签</p>
<p>…代表的内容将替换骨架中的相应block标签</p>
<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210601220333675.png" alt="继承骨架模板并差异化修改"></p>
<p>红框即为block标签被替换后的效果</p>
<br>

<h3 id="2-7-模板配置"><a href="#2-7-模板配置" class="headerlink" title="2.7 模板配置"></a>2.7 模板配置</h3><h4 id="2-7-1-向模板中导入变量"><a href="#2-7-1-向模板中导入变量" class="headerlink" title="2.7.1 向模板中导入变量"></a>2.7.1 向模板中导入变量</h4><p> <code>template.defaults.imports.变量名 = 变量值</code></p>
<ul>
<li><p>此语句写在js文件中，变量值为js文件中引入的模块。</p>
</li>
<li><p>变量名自定义，可以使用<strong>自定义的变量名</strong>在模板文件(.art)中使用导入的变量</p>
</li>
</ul>
<br>

<h5 id="模板中格式化时间的实例"><a href="#模板中格式化时间的实例" class="headerlink" title="模板中格式化时间的实例"></a>模板中格式化时间的实例</h5><p>使用<code>dateformat</code> <a href="https://www.npmjs.com/package/dateformat">npm包</a></p>
<p><code>npm install dateformat</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dateformat = <span class="built_in">require</span>(<span class="string">&#x27;dateformat&#x27;</span>)</span><br><span class="line"><span class="comment">//导入模板变量</span></span><br><span class="line"><span class="comment">//将dateformat方法作为变量导入模板</span></span><br><span class="line">template.defaults.imports.dateformat = dateformat</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> viewpath = path.join(__dirname,<span class="string">&#x27;views&#x27;</span>,<span class="string">&#x27;07.art&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> html = template(viewpath,&#123;</span><br><span class="line">    time:<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(html);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<center>07.js</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123;dateformat(time,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure>

<center>07.art</center>

<p>使用自定义的变量名(dateformat)在模板文件中调用导入的变量(dateformat模块方法)将时间格式化为年月日表示</p>
<p>运行07.js效果如下</p>
<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210622165807460.png" alt="直接输出time变量"></p>
<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210622165830082.png" alt="对time变量使用dateformat方法格式化后输出"></p>
<br>

<h4 id="2-7-2-设置模板根目录和默认后缀"><a href="#2-7-2-设置模板根目录和默认后缀" class="headerlink" title="2.7.2 设置模板根目录和默认后缀"></a>2.7.2 设置模板根目录和默认后缀</h4><p><strong>设置模板根目录</strong></p>
<p><code>template.defaults.root = 路径</code></p>
<p>设置模板根目录后，template方法执行时会将模板根目录与<strong>第一个参数</strong>(路径)进行拼接</p>
<p><strong>设置模板默认后缀</strong></p>
<p><code>template.defaults.extname = 后缀</code></p>
<ul>
<li><p>当template方法第一个参数(路径)中的文件<strong>没有</strong>后缀时会<strong>自动添加设置的默认后缀</strong></p>
</li>
<li><p>当template方法第一个参数(路径)中的文件<strong>有</strong>后缀时<strong>不做操作</strong></p>
</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> template = <span class="built_in">require</span>(<span class="string">&#x27;art-template&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> dateformat = <span class="built_in">require</span>(<span class="string">&#x27;dateformat&#x27;</span>)</span><br><span class="line">template.defaults.imports.dateformat = dateformat</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置模板根目录</span></span><br><span class="line"><span class="comment">//根目录为当前目录下的views文件夹</span></span><br><span class="line">template.defaults.root = path.join(__dirname,<span class="string">&#x27;views&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置模板默认后缀</span></span><br><span class="line"><span class="comment">//默认后缀设置为.art</span></span><br><span class="line">template.defaults.extname = <span class="string">&#x27;.art&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当前打开的模板文件路径为__dirname/views/07.art</span></span><br><span class="line"><span class="keyword">const</span> html = template(<span class="string">&#x27;07&#x27;</span>,&#123;</span><br><span class="line">    time:<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(html);</span><br></pre></td></tr></table></figure>

<center>07.js</center>

<p>可以打开并输出07.art模板的内容</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Web Worker</title>
    <url>/2022/11/27/15-HTML5%20WebWorker/</url>
    <content><![CDATA[<h1 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h1><p>Web worker 是运行在<strong>后台</strong>的 JavaScript，<strong>不会影响页面的性能</strong>。</p>
<p>Web worker 是运行在后台的 JavaScript，<strong>独立于其他脚本</strong>，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 运行在后台。</p>
<span id="more"></span>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Count numbers: <span class="tag">&lt;<span class="name">output</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">output</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;startWorker()&quot;</span>&gt;</span>Start Worker<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;stopWorker()&quot;</span>&gt;</span>Stop Worker<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> w;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">startWorker</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(<span class="keyword">typeof</span>(Worker) !== <span class="string">&quot;undefined&quot;</span>) &#123;	<span class="comment">//检查是否支持webWorker</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(<span class="keyword">typeof</span>(w) == <span class="string">&quot;undefined&quot;</span>) &#123;		<span class="comment">//worker对象不存在则创建</span></span></span><br><span class="line"><span class="javascript">            w = <span class="keyword">new</span> Worker(<span class="string">&quot;demo_workers.js&quot;</span>);	<span class="comment">//参数为js文件URL</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        w.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;		<span class="comment">//webworker传递数据时触发</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">&quot;result&quot;</span>).innerHTML = event.data;</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">//不支持worker</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;result&quot;</span>).innerHTML = <span class="string">&quot;Sorry! No Web Worker support.&quot;</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">stopWorker</span>(<span class="params"></span>) </span>&#123; </span></span><br><span class="line"><span class="javascript">    w.terminate();	<span class="comment">//终止worker对象</span></span></span><br><span class="line"><span class="javascript">    w = <span class="literal">undefined</span>;	<span class="comment">//复用 Web Worker	</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timedCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line">    postMessage(i);	<span class="comment">//向页面传递数据</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="string">&quot;timedCount()&quot;</span>,<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timedCount();</span><br></pre></td></tr></table></figure>

<center>demo_workers.js文件</center>

<p>注意：</p>
<ul>
<li><strong>webworker用于耗费 CPU 资源较大的任务</strong></li>
</ul>
<br>

<ul>
<li>复用web worker代码， <strong>终止w后再执行<code>w = undefined;</code><strong>，之后</strong>再次调用<code>startWorker()</code>仍然生效</strong>（复用）</li>
<li>若<strong>只终止w但没有赋值为undefined</strong>，之后再次调用<code>startWorker()</code><strong>无效</strong></li>
</ul>
<h2 id="Web-Worker-和-DOM"><a href="#Web-Worker-和-DOM" class="headerlink" title="Web Worker 和 DOM"></a>Web Worker 和 DOM</h2><p>由于 web worker 位于外部文件中，它们无法访问下例 JavaScript 对象：</p>
<ul>
<li>window 对象</li>
<li>document 对象</li>
</ul>
]]></content>
      <categories>
        <category>HTMLandCss</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>15-async和await</title>
    <url>/2022/12/04/15-async%E5%92%8Cawait/</url>
    <content><![CDATA[<h1 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h1><p><code>async </code>和<code>await</code> 关键字是最近添加到JavaScript语言里面的。它们是ECMAScript 2017 JavaScript版的一部分</p>
<p>可以使异步代码更易于编写和阅读</p>
<p>是异步编程的更进一步解决方案</p>
<span id="more"></span>

<h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><ul>
<li>在函数声明的前方加上<strong>async</strong>关键字 可以让函数变为<strong>异步函数</strong></li>
<li>异步函数的返回值为一个promise对象<ul>
<li>对于非promise对象会将其包裹为promise对象后返回</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a());	<span class="comment">//hello</span></span><br><span class="line"><span class="built_in">console</span>.log(b());	<span class="comment">//Promise&#123;&#x27;hello&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/15-async%E5%92%8Cawait/image-20210918171312422.png" alt="image-20210918171312422"></p>
<ul>
<li>异步函数中的<code>return</code>即代替了promise对象中的resolve()方法</li>
<li>异步函数中的<code>throw</code>即代替了promise对象中的reject()方法</li>
</ul>
<h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><ul>
<li><strong>await 只在异步函数里面才起作用</strong>。</li>
<li><code>await promise</code>可以<strong>暂停异步函数的执行</strong>，等待promise对象返回结果后再继续执行<ul>
<li>保证多个异步操作顺序执行</li>
</ul>
</li>
<li>await可以<strong>直接获取promise对象中异步操作成功时的结果</strong>(调用<code>resolve()</code>的参数)</li>
<li>当await 后的promise对象状态变为错误时，程序报错停止运行</li>
</ul>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>15-学生信息管理系统实例</title>
    <url>/2021/07/29/15-%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="15-学生信息管理系统实例"><a href="#15-学生信息管理系统实例" class="headerlink" title="15-学生信息管理系统实例"></a>15-学生信息管理系统实例</h1><p><img data-src="/images/15-%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B/image-20210729094611957.png" alt="image-20210729094611957"></p>
<h2 id="4-创建路由并实现页面模板呈递"><a href="#4-创建路由并实现页面模板呈递" class="headerlink" title="4.创建路由并实现页面模板呈递"></a>4.创建路由并实现页面模板呈递</h2><p>之前通过请求方式和请求URL来区分请求的方式较繁琐</p>
<p>使用<strong>第三方模块router</strong>简化路由</p>
<span id="more"></span>

<h3 id="第三方模块router"><a href="#第三方模块router" class="headerlink" title="第三方模块router"></a>第三方模块router</h3><p>功能：简便的实现路由，易于维护</p>
<p><code>npm install router</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入模块</span></span><br><span class="line"><span class="keyword">const</span> getRouter = <span class="built_in">require</span>(<span class="string">&#x27;router&#x27;</span>)</span><br><span class="line"><span class="comment">//获取路由对象router</span></span><br><span class="line"><span class="keyword">const</span> router = getRouter()</span><br><span class="line"><span class="comment">//使用router的get或post方法处理相应请求</span></span><br><span class="line">	<span class="comment">//第一个参数为请求URL</span></span><br><span class="line">	<span class="comment">//第二个参数为处理的回调函数</span></span><br><span class="line">router.get(<span class="string">&#x27;/add&#x27;</span>,<span class="function">(<span class="params"> req,res </span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">router.get(<span class="string">&#x27;/list&#x27;</span>,<span class="function">(<span class="params"> req,res </span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">&#x27;list&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//调用router对象启用路由</span></span><br><span class="line"><span class="comment">//router对象的第三个参数是回调函数(必需)</span></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    router(req,res,<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="5-实现静态资源访问"><a href="#5-实现静态资源访问" class="headerlink" title="5.实现静态资源访问"></a>5.实现静态资源访问</h2><p>静态资源：css，图片等</p>
<p>使用<strong>第三方模块serve-static</strong></p>
<h3 id="第三方模块serve-static"><a href="#第三方模块serve-static" class="headerlink" title="第三方模块serve-static"></a>第三方模块serve-static</h3><p>功能：实现静态资源访问服务</p>
<p><code>npm install serve-static</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.引入模块</span></span><br><span class="line"><span class="keyword">const</span> serveStatic = <span class="built_in">require</span>(<span class="string">&#x27;serve-static&#x27;</span>)</span><br><span class="line"><span class="comment">//2.设定静态资源存放目录</span></span><br><span class="line"><span class="keyword">const</span> serve = serveStatic(path.join(__dirname,<span class="string">&#x27;public&#x27;</span>))</span><br><span class="line"><span class="comment">//在server.on()方法中调用serve方法（当服务器接收到请求时判断是否为静态资源请求从而做出反应）</span></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    router(req , res, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">    <span class="comment">//3.serve方法启动静态资源访问服务</span></span><br><span class="line">    	<span class="comment">//第三个参数是必需的回调函数</span></span><br><span class="line">    serve(req , res , <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h2 id="7-实现学生信息展示功能"><a href="#7-实现学生信息展示功能" class="headerlink" title="7.实现学生信息展示功能"></a>7.实现学生信息展示功能</h2><h3 id="第三方模块dateformat"><a href="#第三方模块dateformat" class="headerlink" title="第三方模块dateformat"></a>第三方模块dateformat</h3><p><a href="https://templar136.github.io/2021/05/31/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/">14-模板引擎基础中提到过</a></p>
<br>

<h2 id="8-进一步将实例模块化"><a href="#8-进一步将实例模块化" class="headerlink" title="8.进一步将实例模块化"></a>8.进一步将实例模块化</h2><p>注意到<strong>router路由</strong>的代码可以独立出来</p>
<p>所以创建route文件夹下的index.js文件，将与router路由有关的代码放入</p>
<p>然后使用require将这个模块引入主模块app.js</p>
<p><img data-src="/images/15-%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B/image-20210805115329922.png" alt="route文件夹下的index.js文件"></p>
<p>将router路由代码提出时要注意<strong>需要的依赖模块</strong></p>
<p>app.js文件中只保留<strong>第三方、用户自定义模块的引入</strong>，<strong>路径拼接</strong>，<strong>服务器创建</strong>和<strong>模板配置</strong>等代码</p>
<p>这样的代码更接近于实际开发的模块化格式</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>16-Express框架</title>
    <url>/2021/08/11/16-Express%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="16-Express框架"><a href="#16-Express框架" class="headerlink" title="16-Express框架"></a>16-Express框架</h1><ul>
<li><p>Express是基于Node平台的<strong>web应用开发框架</strong></p>
</li>
<li><p>是Node的第三方模块</p>
</li>
</ul>
<p>使用<code>npm install express</code>下载</p>
<p>Express框架简化了创建web应用的过程</p>
<span id="more"></span>

<h2 id="1-Express框架特性"><a href="#1-Express框架特性" class="headerlink" title="1.Express框架特性"></a>1.Express框架特性</h2><ul>
<li>方便简洁的路由定义方式（router模块就来源于Express框架）</li>
<li>获取HTTP请求参数进行简化处理</li>
<li>对模板引擎支持度高，方便渲染动态HTML页面</li>
<li>提供了<strong>中间件机制</strong>有效控制HTTP请求</li>
<li>拥有大量<strong>第三方中间件</strong>对功能进行扩展</li>
</ul>
<h3 id="1-1简单样例"><a href="#1-1简单样例" class="headerlink" title="1.1简单样例"></a>1.1简单样例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入express框架</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">//创建网站服务器</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="comment">//设置路由</span></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">&#x27;网站主页&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/list&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(&#123;<span class="attr">mes</span>:<span class="string">&#x27;这是list页面&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;yang&#x27;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="string">&#x27;3000&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;服务器开启成功&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>express框架可以直接<strong>使用express()方法创建网站服务器</strong></li>
<li>app网站服务器对象可以使用<strong>get和post方法</strong>处理相应的HTTP请求</li>
<li>使用**res.send()**可以向客户端发送响应<ul>
<li>send方法内部会自动检测响应内容的类型</li>
<li>send方法会自动设置http状态码</li>
<li>send方法会<strong>自动设置响应内容类型和编码</strong></li>
<li>send方法可以直接向客户端<strong>响应对象</strong>，end方法不能直接响应对象</li>
</ul>
</li>
<li>express框架创建的网站服务器在访问不存在的路由时会显示<code>Cannot Get ‘目的路由’</code><ul>
<li>原生js创建的网站服务器访问不存在的路由时会显示页面不存在</li>
</ul>
</li>
</ul>
<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210811155312569.png" alt="send方法自动设置响应内容类型和编码格式"></p>
<br>

<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210811155427958.png" alt="send方法响应的对象"></p>
<h2 id="2-中间件"><a href="#2-中间件" class="headerlink" title="2.中间件"></a>2.中间件</h2><p>中间件就是<strong>一堆方法</strong>，可以<strong>接受客户端发来的请求</strong>、对<strong>请求做出响应</strong>，也可以<strong>将请求发给下一个中间件处理</strong></p>
<p>常见的Express框架中间件有<strong>app.get    app.post    app.use</strong></p>
<p><strong>中间件函数</strong>放在中间件中使用</p>
<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210817163003090.png" alt="image-20210817163003090"></p>
<h3 id="2-1中间件构成"><a href="#2-1中间件构成" class="headerlink" title="2.1中间件构成"></a>2.1中间件构成</h3><p>中间件主要由两部分构成</p>
<ul>
<li>Express框架提供的接受请求的<strong>中间件方法</strong></li>
<li>开发人员提供的<strong>请求处理函数</strong></li>
</ul>
<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210817163707714.png" alt="两个中间件"></p>
<p>app.get/post方法就是中间件方法</p>
<p>‘处理函数’就是请求处理函数</p>
<br>

<h3 id="2-2中间件将请求传递"><a href="#2-2中间件将请求传递" class="headerlink" title="2.2中间件将请求传递"></a>2.2中间件将请求传递</h3><p>可以针对同一个请求设置多个中间件，对同一个请求进行多次处理</p>
<p>默认情况，请求从上到下<strong>匹配到第一个中间件就终止</strong></p>
<p>调用next方法可以将请求的控制权交给下一个中间件，直到遇到结束请求的中间件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求处理函数中加入next参数</span></span><br><span class="line">app.get(<span class="string">&#x27;/request&#x27;</span>,<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//给请求对象添加name属性</span></span><br><span class="line">    req.name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">    <span class="comment">//调用next方法传递请求</span></span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/request&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(req.name)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="string">&#x27;3000&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;服务器开启成功&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="2-3-app-use中间件"><a href="#2-3-app-use中间件" class="headerlink" title="2.3 app.use中间件"></a>2.3 app.use中间件</h3><p>app.use中间件可以匹配<strong>任意请求方式(GET/POST)<strong>的</strong>特定或全部路径的请求</strong></p>
<p>app.use方法直接传入请求处理函数，代表接受<strong>任意路径</strong>的GET/POST请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;所有请求经过&#x27;</span>)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>app.use方法传入请求路径和请求处理函数，代表接受**特定请求路径(包括以这个字符串开头的请求路径)**的GET/POST请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">&#x27;/request&#x27;</span>,<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求地址为/request的请求经过app.use&#x27;</span>)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="2-4中间件的应用"><a href="#2-4中间件的应用" class="headerlink" title="2.4中间件的应用"></a>2.4中间件的应用</h3><p>1.路由保护，客户端访问需要登陆的页面时，先使用中间件判断用户登陆状态，根据登陆状态做出不同响应</p>
<p>2.网站维护公告，在所有路由最上层定义接受所有请求的中间件，直接为客户端做出正在维护的响应</p>
<p>3.自定义404页面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最后一个接受所有请求的中间件实现自定义404页面</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//res.status()设置响应的状态码</span></span><br><span class="line">    <span class="comment">//可以链式编程</span></span><br><span class="line">    res.status(<span class="number">404</span>).send(<span class="string">&#x27;访问的页面不存在&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>如果不使用res.status()手动设置404的状态码，Express框架会自动设置为200</li>
</ul>
<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210819165416631.png" alt="自定义404页面"></p>
<br>

<h3 id="2-5错误处理中间件"><a href="#2-5错误处理中间件" class="headerlink" title="2.5错误处理中间件"></a>2.5错误处理中间件</h3><p>程序执行过程中会出现一些无法预料的错误，比如文件读取失败，数据库链接失败等等</p>
<p>错误处理中间件可以集中处理此类问题，避免程序因为突发的不可预料错误崩溃</p>
<p><strong>同步代码和异步代码发生错误时的处理方式不同</strong></p>
<ul>
<li>错误处理中间件的处理函数有<strong>err错误对象</strong>作为参数</li>
<li>当<strong>同步代码</strong>执行发生错误时会自动进入错误处理中间件</li>
<li>使用<strong>throw关键字</strong>手动抛出错误模拟突发错误</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">&#x27;/index&#x27;</span>,<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//手动抛出错误</span></span><br><span class="line">    <span class="comment">//此代码执行后会自动进入错误处理中间件</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;程序执行出错&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误处理中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//err.message即为错误对象的信息（&#x27;程序执行出错&#x27;）</span></span><br><span class="line">    res.status(<span class="number">500</span>).send(err.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>同步代码发生错误</center>

<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210820152012585.png" alt="同步代码出错时客户端结果"></p>
<br>

<ul>
<li><strong>异步代码</strong>发生错误时<strong>不会自动进入错误处理中间件</strong></li>
<li>异步代码发生错误需要<strong>手动触发</strong>错误处理中间件<ul>
<li>手动触发：发生错误时<strong>调用next方法</strong>并将<strong>错误对象</strong>作为参数传递</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">&#x27;/index&#x27;</span>,<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//打开一个不存在的文件造成异步代码出错</span></span><br><span class="line">    fs.readFile(<span class="string">&#x27;./demo.txt&#x27;</span>,<span class="function">(<span class="params">err,result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="comment">//若出错则手动触发错误处理中间件</span></span><br><span class="line">            next(err)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.send(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>异步代码出错</center>

<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210820152603090.png" alt="异步代码出错客户端响应结果"></p>
<p>客户端显示错误信息，没有此文件或目录</p>
<br>

<h3 id="2-6异步函数的错误捕获"><a href="#2-6异步函数的错误捕获" class="headerlink" title="2.6异步函数的错误捕获"></a>2.6异步函数的错误捕获</h3><p>在Node.js中，异步API的错误信息通过回调函数获取，支持Promise对象的异步API发生错误可以通过catch方法获取</p>
<p><strong>try catch</strong> 可以捕获<strong>异步函数</strong>以及其他<strong>同步代码在</strong>执行过程中发生的错误，但是<strong>不能捕获其他类型API发生的错误</strong></p>
<ul>
<li><strong>例如：不能捕获回调函数和promise对象的错误</strong></li>
</ul>
<p>此处读取一个不存在的文件模拟错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promisify = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>).promisify</span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/index&#x27;</span>,<span class="keyword">async</span> (req,res,next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//尝试执行</span></span><br><span class="line">        <span class="keyword">await</span> readFile(<span class="string">&#x27;/demo.txt&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="comment">//发生错误时手动触发错误处理中间件</span></span><br><span class="line">        next(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>程序会尝试执行try中的代码，若成功执行则跳过catch执行之后的代码</li>
<li>如果try中的代码发生错误，则会进入catch中执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不使用try catch</span></span><br><span class="line">app.get(<span class="string">&#x27;/index&#x27;</span>,<span class="keyword">async</span> (req,res,next) =&gt; &#123;</span><br><span class="line">	<span class="comment">//异步函数执行出错后程序一直等待响应</span></span><br><span class="line">    <span class="keyword">await</span> readFile(<span class="string">&#x27;/demo.txt&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>不使用try catch时，若异步函数出错则<strong>报错并停止运行</strong></li>
</ul>
<br>

<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210821154102258.png" alt="使用try catch后的执行结果"></p>
<ul>
<li>使用try catch时，错误处理中间件向客户端响应错误信息</li>
<li>服务器后台不再报错，<strong>程序可以继续执行</strong>，这增加了程序的健壮性</li>
</ul>
<br>

<h3 id="2-7构建模块化路由"><a href="#2-7构建模块化路由" class="headerlink" title="2.7构建模块化路由"></a>2.7构建模块化路由</h3><p>将所有的路由写在一个文件中会导致维护困难，代码繁琐。</p>
<p>构建网站时，通常将路由分类，把<strong>一类路由写在一个模块中</strong>。</p>
<p>构建模块化路由需要用到<strong>express框架下的创建路由对象方法</strong></p>
<p><code>express.Router()</code></p>
<h4 id="2-7-1模块化路由基础代码"><a href="#2-7-1模块化路由基础代码" class="headerlink" title="2.7.1模块化路由基础代码"></a>2.7.1模块化路由基础代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建路由对象home</span></span><br><span class="line"><span class="keyword">const</span> home = express.Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">//将请求路径和路由对象匹配</span></span><br><span class="line">app.use(<span class="string">&#x27;/home&#x27;</span>,home)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在home路由下继续创建二级路由</span></span><br><span class="line"><span class="comment">//访问/home/index得到响应</span></span><br><span class="line">home.get(<span class="string">&#x27;/index&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">&#x27;欢迎来到首页&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>路由对象home下也有get和post方法，用来创建二级路由实现路由分类</p>
<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210821160838792.png" alt="访问二级路由"></p>
<h4 id="2-7-2模块化路由实例"><a href="#2-7-2模块化路由实例" class="headerlink" title="2.7.2模块化路由实例"></a>2.7.2模块化路由实例</h4><p>将两个不同的路由home和admin写成两个路由模块</p>
<p>在主模块中引入这两个路由模块实现模块化路由</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> admin = express.Router()</span><br><span class="line"></span><br><span class="line">admin.get(<span class="string">&#x27;/index&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">&#x27;欢迎来到管理首页&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = admin</span><br></pre></td></tr></table></figure>

<center>admin.js</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> home = express.Router()</span><br><span class="line"></span><br><span class="line">home.get(<span class="string">&#x27;/index&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">&#x27;欢迎来到主站首页&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = home</span><br></pre></td></tr></table></figure>

<center>home.js</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">&#x27;./route/home&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> admin = <span class="built_in">require</span>(<span class="string">&#x27;./route/admin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&#x27;/home&#x27;</span>,home)</span><br><span class="line">app.use(<span class="string">&#x27;/admin&#x27;</span>,admin)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;服务器开启成功&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>app.js</center>

<br>

<h2 id="3-Express模块请求处理"><a href="#3-Express模块请求处理" class="headerlink" title="3.Express模块请求处理"></a>3.Express模块请求处理</h2><h3 id="3-1获取get请求参数"><a href="#3-1获取get请求参数" class="headerlink" title="3.1获取get请求参数"></a>3.1获取get请求参数</h3><p>使用<code>req.query</code>获取</p>
<ul>
<li>此方法会返回对象形式的GET请求参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&#x27;/index&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(req.query)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;服务器开启&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="3-2获取POST请求参数"><a href="#3-2获取POST请求参数" class="headerlink" title="3.2获取POST请求参数"></a>3.2获取POST请求参数</h3><p>使用第三方模块<code>body-parser</code>下的<code>urlencoded</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//拦截所有请求提取POST请求参数</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123;<span class="attr">extended</span>:<span class="literal">false</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理POST请求参数</span></span><br><span class="line">app.post(<span class="string">&#x27;/add&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span>&#123;</span><br><span class="line">    res.send(req.body)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;服务器开启&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用body-parser模块下的urlendoded方法获取POST请求参数</p>
<ul>
<li>自动在req对象下创建<strong>body属性</strong>存放对象格式的POST请求参数</li>
</ul>
</li>
<li><p>urlencoded方法有一个必填属性<code>extended: true/false</code></p>
<ul>
<li>false：使用系统模块<strong>queryString</strong>将POST请求参数格式化为对象格式</li>
<li>true：使用第三方模块<strong>qs</strong>将POST请求参数格式化为对象格式</li>
</ul>
</li>
</ul>
<br>

<h3 id="3-3app-use中间件作为参数的处理函数"><a href="#3-3app-use中间件作为参数的处理函数" class="headerlink" title="3.3app.use中间件作为参数的处理函数"></a>3.3app.use中间件作为参数的处理函数</h3><p>获取POST请求参数中直接将<code>bodyParser.urlencoded(&#123;extended:false&#125;)</code>方法作为处理函数传入app.use中间件中</p>
<p>实际上<code>bodyParser.urlencoded</code>方法的<strong>返回值就是一个函数</strong>，作为处理函数传入没有问题</p>
<br>

<ul>
<li>将一个<strong>返回值为函数的函数</strong>作为app.use中间件的处理函数传入有一点好处<ul>
<li>这样可以<strong>在外层函数传入额外的参数</strong>来更灵活的操作内部的请求处理函数</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(fn(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//请求处理函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">req,res,next</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.a == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(req.url)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(req.method)</span><br><span class="line">        &#125;</span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：这里在外层函数传入了一个对象作为参数，内部请求处理函数可以根据这个参数的值做出一些判断等操作</p>
<br>

<h3 id="3-4-express框架路由参数"><a href="#3-4-express框架路由参数" class="headerlink" title="3.4 express框架路由参数"></a>3.4 express框架路由参数</h3><p>不同于上述获取GET请求参数的方法，express框架还有一种方式可以<strong>获取GET请求参数</strong></p>
<p>这种方式规定了要传入的参数，使请求更加容易理解</p>
<ul>
<li>直接在<code>app.get()</code>中间件的请求路径中指定要传入的参数<ul>
<li>此时参数格式不再是 ?  &amp; 格式，<strong>改为请求路径规定的格式</strong></li>
<li>此时请求路径<strong>规定的参数必须全部传入</strong>才能正常访问</li>
<li>使用<strong>req.params</strong>属性接受传入的GET参数</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//:id即代表要传入一个名为id的参数</span></span><br><span class="line"><span class="comment">//规定多个参数时使用/分隔</span></span><br><span class="line">app.get(<span class="string">&#x27;/index/:id&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span>&#123;</span><br><span class="line">    res.send(req.params)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>访问<strong>localhost:3000/index/123</strong></p>
<p>此处的123即为 <strong>:id</strong></p>
<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210829163716879.png" alt="返回对象格式的GET请求参数"></p>
<br>

<h3 id="3-5-静态资源的处理"><a href="#3-5-静态资源的处理" class="headerlink" title="3.5 静态资源的处理"></a>3.5 静态资源的处理</h3><p>通过express框架内置的<strong>express.static</strong>方法实现静态文件的请求处理</p>
<p><code>app.use(express.static(&#39;public&#39;))</code></p>
<p>此时将静态文件放在public文件夹下就可以访问</p>
<ul>
<li>请求被app.use中间件拦截后会由express.static方法判断<strong>请求的是否为静态资源文件</strong><ul>
<li>是，直接在public目录下找到该静态资源文件并响应给客户端后结束请求</li>
<li>否，将控制权移交下一个中间件</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拦截请求后判读是否请求静态资源文件</span></span><br><span class="line">app.use(express.static(path.join(__dirname,<span class="string">&#x27;public&#x27;</span>)))</span><br></pre></td></tr></table></figure>

<p>访问<strong>localhost:3000/css/1.css</strong></p>
<p>即找到public/css/1.css文件并响应</p>
<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210829170305061.png" alt="1.css文件响应"></p>
<p>还可以设置一个虚拟路径标识静态资源</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(express.static(<span class="string">&#x27;static&#x27;</span>,path.join(__dirname,<span class="string">&#x27;public&#x27;</span>)))</span><br></pre></td></tr></table></figure>

<p>此时访问路径变为<strong>localhost:3000/static/css/1.css</strong></p>
<br>

<h3 id="3-6-express-art-template模板引擎"><a href="#3-6-express-art-template模板引擎" class="headerlink" title="3.6 express-art-template模板引擎"></a>3.6 express-art-template模板引擎</h3><p>art-template模板引擎为了更好的支持express框架而封装了express-art-template</p>
<p>使用时要同时安装art-template和express-art-template模块</p>
<p>使用：</p>
<ul>
<li>指定渲染某种后缀的模板时使用什么模板引擎<ul>
<li>app.engine中间件</li>
</ul>
</li>
<li>指定模板存放目录<ul>
<li>app.set中间件配置</li>
<li>第一个参数views是express框架固定的写法</li>
<li>第二个参数是模板存放目录的绝对路径</li>
</ul>
</li>
<li>指定模板的默认后缀<ul>
<li>第一个参数view engine也是固定写法</li>
</ul>
</li>
<li>使用<strong>res.render</strong>方法完成模板的渲染和响应<ul>
<li>第一个参数写模板路径，方法会自动拼接默认后缀</li>
<li>第二个参数为要拼接的数据</li>
<li>方法将拼接后的模板<strong>直接响应给客户端</strong></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当渲染后缀为art的模板时使用express-art-template模板引擎</span></span><br><span class="line">app.engine(<span class="string">&#x27;art&#x27;</span>,<span class="built_in">require</span>(<span class="string">&#x27;express-art-template&#x27;</span>))</span><br><span class="line"><span class="comment">//指定模板存放目录</span></span><br><span class="line">app.set(<span class="string">&#x27;views&#x27;</span>,path.join(__dirname,<span class="string">&#x27;views&#x27;</span>))</span><br><span class="line"><span class="comment">//指定默认后缀为art(即不写后缀时默认拼接的后缀)</span></span><br><span class="line">app.set(<span class="string">&#x27;view engine&#x27;</span>,<span class="string">&#x27;art&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/index&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//渲染模板并向客户端返回</span></span><br><span class="line">    res.render(<span class="string">&#x27;index&#x27;</span>,&#123;</span><br><span class="line">        msg:<span class="string">&#x27;123&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="3-7-app-locals对象下添加模板公共数据"><a href="#3-7-app-locals对象下添加模板公共数据" class="headerlink" title="3.7 app.locals对象下添加模板公共数据"></a>3.7 app.locals对象下添加模板公共数据</h3><p>有时<strong>多个模板需要使用同样的数据</strong>，如果在每个模板拼接时都加入这些重复数据，会导致产生大量冗余代码</p>
<p>将多个模板需要使用的<strong>公共数据作为变量写在app.locals对象下</strong>，这样所有的模板都可以使用这些公共数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在app.locals下添加公共数据users</span></span><br><span class="line">app.locals.users = [&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;,</span><br><span class="line">                    &#123;<span class="attr">name</span>:<span class="string">&#x27;lisi&#x27;</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;</span><br><span class="line">                   ]</span><br><span class="line">app.get(<span class="string">&#x27;/list&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//渲染模板并向客户端返回</span></span><br><span class="line">    res.render(<span class="string">&#x27;list&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;&#123;each users&#125;&#125;</span><br><span class="line">        &lt;li&gt;&#123;&#123;$value.name&#125;&#125;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&#123;&#123;$value.age&#125;&#125;&lt;/li&gt;</span><br><span class="line">    &#123;&#123;/each&#125;&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<center>模板中使用公共数据</center>

<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210830131510961.png" alt="拼接公共数据后响应"></p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>17-正则表达式</title>
    <url>/2022/12/04/17-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式是用于匹配字符串中字符组合的模式</p>
<p>在JS中,正则表达式也是<strong>对象</strong>（对RegExp构造函数的实例使用typeof操作符结果为<strong>’Object’</strong>）</p>
<h2 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h2><ul>
<li>使用RegExp构造函数创建正则表达式对象</li>
<li>使用字面量</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建正则表达式</span></span><br><span class="line"><span class="comment">//1.使用RegExp构造函数创建</span></span><br><span class="line"><span class="keyword">var</span> RE=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/123/</span>); <span class="comment">//正则表达式包裹在//中</span></span><br><span class="line"><span class="built_in">console</span>.log(RE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用字面量创建 </span></span><br><span class="line"><span class="keyword">var</span> re=<span class="regexp">/123/</span>; <span class="comment">//正则表达式包裹在//中</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="正则表达式特殊字符"><a href="#正则表达式特殊字符" class="headerlink" title="正则表达式特殊字符"></a>正则表达式特殊字符</h2><h3 id="边界符"><a href="#边界符" class="headerlink" title="边界符"></a>边界符</h3><p><code>^</code>和<code>$</code>是边界符 分别界定正则表达式以什么开头 以什么结尾</p>
<ul>
<li>[]中写上<code>&quot;^&quot;</code>代表[]中的选择取反(即不选择写出的字符)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg1=<span class="regexp">/abc/</span>; 		<span class="comment">//包含abc的字符串都满足规范</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rg2=<span class="regexp">/^abc/</span>; 	<span class="comment">//以abc开头的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rg3=<span class="regexp">/abc$/</span>; 	<span class="comment">//以abc结尾的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rg4=<span class="regexp">/^abc$/</span>;     <span class="comment">//精确匹配，只有字符串&quot;abc&quot;才满足规范 </span></span><br></pre></td></tr></table></figure>

<h3 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h3><p>限定某个字符出现次数(重复次数)</p>
<ul>
<li>*：相当于出现0或无数次</li>
<li>+：相当于出现1次或无数次</li>
<li>？：相当与出现1次或0次</li>
<li>{n}：出现n次</li>
<li>{n,}：出现n次或者大于n次</li>
<li>{n,m}：出现次数大于等于n次小于等于m次(包括n和m)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg1=<span class="regexp">/^a*$/</span>; <span class="comment">//a出现0或无数次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rg2=<span class="regexp">/^a+$/</span>; <span class="comment">//a出现1或无数次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rg3=<span class="regexp">/^a?$/</span>; <span class="comment">//a出现1或0次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rg4=<span class="regexp">/^a&#123;3&#125;$/</span>; <span class="comment">//a出现3次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rg5=<span class="regexp">/^a&#123;3,&#125;$/</span>; <span class="comment">//a出现3次或大于3次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rg6=<span class="regexp">/^a&#123;3,6&#125;$/</span>; <span class="comment">//a出现次数大于等于3 小于等于6</span></span><br></pre></td></tr></table></figure>

<h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><ul>
<li>大括号 {}：量词符中出现</li>
<li>中括号 []：代表其中的字符多选一</li>
<li>小括号 ()：代表优先级</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg1=<span class="regexp">/^abc&#123;3&#125;$/</span>;   <span class="comment">//c重复3次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rg2=<span class="regexp">/^[abc]$/</span>;		<span class="comment">//abc三选一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rg3=<span class="regexp">/^(abc)&#123;3&#125;$/</span>;   <span class="comment">//abc重复出现3次</span></span><br></pre></td></tr></table></figure>

<h3 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h3><ul>
<li>\d：匹配数字 相当于<code>[0-9]</code></li>
<li>\D：相当于<code>[^0-9]</code>除数字0-9之外</li>
<li>\w：匹配任意字母、数字和下划线 相当于<code>[a-zA-Z0-9_]</code></li>
<li>\W：<code>[^a-zA-Z0-9_]</code></li>
<li>\s：匹配<strong>空格</strong>(包括换行符、制表符、空格符等)  相当于<code>[\t\r\n\v\f]</code></li>
<li>\S：<code>[^\t\r\n\v\f]</code></li>
</ul>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>正则表达式后可以跟修饰符 <code>/正则表达式/[switch]</code> <strong>[]代表可省略的意思</strong></p>
<p>switch可取值为</p>
<ul>
<li><strong>g全局</strong>(整个字符串都进行搜索替换) </li>
<li><strong>i不区分大小写</strong> </li>
<li><strong>qi全局且不区分大小写</strong></li>
</ul>
<h2 id="正则表达式对象的方法"><a href="#正则表达式对象的方法" class="headerlink" title="正则表达式对象的方法"></a>正则表达式对象的方法</h2><h3 id="test-方法"><a href="#test-方法" class="headerlink" title="test()方法"></a>test()方法</h3><p>用来检测输入字符串是否满足规范(返回true或false)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re=<span class="regexp">/123/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="number">123</span>));  <span class="comment">//123满足正则表达式re的规范 返回true console.log(re.test(&quot;abc&quot;));//&quot;abc&quot;不满足re的规范 返回false</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>18-JS模块化规范</title>
    <url>/2022/12/04/18-JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="JavaScript模块化规范"><a href="#JavaScript模块化规范" class="headerlink" title="JavaScript模块化规范"></a>JavaScript模块化规范</h1><p>逐步演化：</p>
<p><strong>AMD -&gt; CMD -&gt; CommonJs -&gt; UMD -&gt; ES6</strong></p>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><ul>
<li>异步模块定义规范（Asynchronous Module Definition），人如其名，是<strong>异步加载的</strong></li>
<li>是<strong>运行于浏览器之上的</strong><u>(异步加载可防止加载模块时间过长导致浏览器假死)</u></li>
<li>此规范只有一个 API，即 define 函数：<code>define(id?, dependencies?, factory);</code></li>
<li><strong>requireJs</strong> 就是它的实现</li>
</ul>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><ul>
<li>通用模块定义规范（Common Module Definiton）</li>
<li>更简单，异步加载脚本，<strong>兼容 Nodejs</strong></li>
<li>定义格式: <code>define(factory);</code></li>
<li><strong>SeaJS</strong> 是它的实现</li>
</ul>
<h2 id="CommonJs-（重要）"><a href="#CommonJs-（重要）" class="headerlink" title="CommonJs （重要）"></a>CommonJs （重要）</h2><ul>
<li>通常用于<strong>服务端的 Nodejs 中</strong></li>
<li><strong>同步加载模块</strong></li>
<li><strong>每一个文件就是一个模块</strong></li>
<li><code>module</code> 代表当前模块，<code>module.exports</code> 是对外的接口; <code>require</code> 方法用于加载模块</li>
</ul>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><ul>
<li>ES6 终于从<strong>语言层面</strong>定义了模块化规范</li>
<li>通用：浏览器和服务器</li>
<li><code>import</code> 加载模块，<code>export</code> 导出模块成员</li>
</ul>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>19-JS标准内置对象</title>
    <url>/2022/12/04/19-JavaScript%E6%A0%87%E5%87%86%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="JavaScript标准内置对象"><a href="#JavaScript标准内置对象" class="headerlink" title="JavaScript标准内置对象"></a>JavaScript标准内置对象</h1><h2 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a>全局函数</h2><p>全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval"><code>eval()</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/uneval"><code>uneval()</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isFinite"><code>isFinite()</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN"><code>isNaN()</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseFloat"><code>parseFloat()</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt"><code>parseInt()</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/decodeURI"><code>decodeURI()</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent"><code>decodeURIComponent()</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI"><code>encodeURI()</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent"><code>encodeURIComponent()</code></a></li>
<li>已废弃<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/escape"><code>escape()</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/unescape"><code>unescape()</code></a></li>
</ul>
</li>
</ul>
<h2 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h2><p>这些全局属性返回一个简单值，这些值没有自己的属性和方法。</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Infinity"><code>Infinity</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/globalThis"><code>globalThis</code></a></li>
</ul>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>20-JS对浏览器同源政策的处理</title>
    <url>/2022/12/04/20-JavaScript%E4%B8%AD%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="浏览器中的同源政策"><a href="#浏览器中的同源政策" class="headerlink" title="浏览器中的同源政策"></a>浏览器中的同源政策</h1><p>同源指的是<strong>三个相同</strong></p>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
<p>当两个网页的URL中<strong>上述任意一个不同</strong>，则两个网页<strong>不同源</strong></p>
<ul>
<li>不同源的网页被限制不能访问修改对方网页，即<strong>不同源的网页不能通信</strong></li>
</ul>
<p>浏览器安全的基石是<strong>“同源政策”</strong></p>
<span id="more"></span>

<h2 id="同源的目的"><a href="#同源的目的" class="headerlink" title="同源的目的"></a>同源的目的</h2><p>同源政策的目的：是为了保证用户信息的安全，<strong>防止恶意的网站窃取数据。</strong></p>
<p>例如：用户访问A网站后A网站设置了一个cookie，接着用户访问B网页，如果没有同源政策限制，B网站就可以获取A网站设置的cookie，<strong>从而冒充用户</strong>（cookie一般保存用户的登录信息）</p>
<p>由此可见同源政策对于防止其他恶意网站是必须的</p>
<h2 id="非同源时的限制"><a href="#非同源时的限制" class="headerlink" title="非同源时的限制"></a>非同源时的限制</h2><p>非同源时<strong>三种行为受到限制</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">（1） 无法读取非同源网页的 Cookie、LocalStorage </span><br><span class="line"></span><br><span class="line">（2） 无法接触非同源网页的 DOM。</span><br><span class="line"></span><br><span class="line">（3） 无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。</span><br></pre></td></tr></table></figure>

<p>同源策略虽然可以防止恶意网站窃取数据</p>
<ul>
<li>但一些<strong>合理的跨域操作</strong>也会因为同源策略而失败</li>
<li>例如：需要<strong>使用AJAX请求一个不同源URL所指定的资源</strong>时会因为浏览器同源策略的限制而失败</li>
</ul>
<h2 id="跨源-域-通信的方法"><a href="#跨源-域-通信的方法" class="headerlink" title="跨源(域)通信的方法"></a>跨源(域)通信的方法</h2><p>浏览器同源政策会<strong>限制所有的非同源通信</strong></p>
<p>而<strong>合理的非同源通信需要跨域进行通信</strong></p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP 是服务器与客户端<strong>跨源通信的常用方法</strong>。最大特点就是<strong>简单适用</strong>，老式浏览器全部支持，服务端改造非常小。</p>
<p>它的<strong>基本思想是</strong>：</p>
<ul>
<li>网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器<strong>请求 JSON 数据</strong>，这种做法不受同源政策限制；</li>
<li>服务器返回的数据在script标签的<code>url</code>属性中设置的回调函数中处理</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScriptTag</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//动态添加一个script标签</span></span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.setAttribute(<span class="string">&quot;type&quot;</span>,<span class="string">&quot;text/javascript&quot;</span>);</span><br><span class="line">  <span class="comment">//src为服务器端URL，以此发送请求</span></span><br><span class="line">  script.src = src;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//URL最后的参数使用一个回调函数foo接受服务器返回的数据</span></span><br><span class="line">  addScriptTag(<span class="string">&#x27;http://example.com/ip?callback=foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//data参数即为服务器响应的JSON数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Your public IP address is: &#x27;</span> + data.ip);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//foo(&#123;</span></span><br><span class="line">  <span class="comment">//&quot;ip&quot;: &quot;8.8.8.8&quot;</span></span><br><span class="line"><span class="comment">//&#125;);</span></span><br></pre></td></tr></table></figure>

<ul>
<li>动态的script标签<strong>执行后立即调用回调函数foo</strong></li>
<li>回调函数foo的<strong>参数data即为服务器返回的JSON数据</strong></li>
<li>JSON数据直接被视为<strong>JavaScript对象</strong></li>
</ul>
<p>缺点：JSONP只能发送<strong>GET请求</strong></p>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS 是<strong>跨源资源分享</strong>（Cross-Origin Resource Sharing）的缩写。</p>
<p>允许浏览器向跨域的服务器，发出<code>XMLHttpRequest</code>请求，从而<strong>克服了AJAX只能同源使用的限制</strong>。</p>
<ul>
<li>它是 W3C 标准</li>
<li>属于<strong>跨源 AJAX 请求的根本解决方法</strong>。</li>
<li>相比 JSONP 只能发<code>GET</code>请求，<strong>CORS 允许任何类型的请求。</strong></li>
</ul>
<p>实现 CORS 通信的关键是服务器。只要<strong>服务器实现了 CORS 接口</strong>，就可以跨域通信。</p>
<p>需要<strong>服务端指定许可的URL</strong>（发送方的URL）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//api.bob.com</span></span><br></pre></td></tr></table></figure>

<ul>
<li>允许<code>http://api.bob.com</code>向服务器发送跨域请求</li>
</ul>
<h2 id="两种CORS请求"><a href="#两种CORS请求" class="headerlink" title="两种CORS请求"></a>两种CORS请求</h2><p>简单请求 和 非简单请求</p>
<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>只要<strong>同时满足以下两大条件</strong>，就属于简单请求。</p>
<p>（1）请求方法是以下三种方法之一。</p>
<blockquote>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
</blockquote>
<p>（2）HTTP 的头信息不超出以下几种字段。</p>
<blockquote>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
</blockquote>
<p>凡是不同时满足上面两个条件，就属于<strong>非简单请求</strong>。一句话，简单请求就是简单的 HTTP 方法与简单的 HTTP 头信息的结合。</p>
<ul>
<li>表单在历史上一直可以跨域发出请求。表单请求就是简单请求</li>
</ul>
<h3 id="简单请求发送"><a href="#简单请求发送" class="headerlink" title="简单请求发送"></a>简单请求发送</h3><p>简单请求，浏览器<strong>直接发出 CORS 请求</strong>。</p>
<p>具体来说，就是在头信息之中，<span style='color:red;'>增加一个<code>Origin</code>字段。</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GET /cors HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: http:<span class="comment">//api.bob.com	//请求头增加一个origin字段</span></span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure>

<p>Origin字段说明<strong>本次请求来自哪个域（协议+域名+端口）</strong></p>
<ul>
<li>如果<code>Origin</code>指定的源，不在服务器许可范围内，服务器会返回一个正常的 HTTP 回应。但这个回应的头信息<span style='color:red;'>没有包含<code>Access-Control-Allow-Origin</code>字段</span></li>
</ul>
<p>浏览器发现回应中少了<code>Access-Control-Allow-Origin</code>字段，就会拒绝接收而<strong>报错</strong></p>
<BR>

<ul>
<li>如果<code>Origin</code>指定的域名<strong>在许可范围内</strong>，服务器返回的响应，会多出几个头信息字段。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多出的信息字段</span></span><br><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line"></span><br><span class="line">Content-Type: text/html; charset=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>上面的头信息之中，有三个与 CORS 请求相关的字段，都以<code>Access-Control-</code>开头。</p>
<p><strong>（1）<code>Access-Control-Allow-Origin</code></strong></p>
<p>该字段是必须的。<strong>服务器端手动设置</strong>。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>
<p><strong>（2）<code>Access-Control-Allow-Credentials</code></strong></p>
<p>该字段可选。它的值是一个布尔值，表示<strong>是否允许发送 Cookie</strong>。默认情况下，Cookie 不包括在 CORS 请求之中。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送 Cookie，不加入该字段即可。</p>
<ul>
<li>允许发送Cookie时，开发者必须在 AJAX 请求中<span style='color:red'>打开<code>withCredentials</code>属性。</span></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials &#x3D; true;</span><br></pre></td></tr></table></figure>

<p>否则，即使服务器要求发送 Cookie，浏览器<strong>也不会发送</strong>。或者，服务器要求设置 Cookie，浏览器也不会处理。</p>
<p><strong>（3）<code>Access-Control-Expose-Headers</code></strong></p>
<p>该字段可选。</p>
<p>CORS 请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到<strong>6个服务器返回的基本字段</strong>：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。</p>
<p>如果想<strong>拿到其他字段</strong>，就必须在<strong>响应头</strong><code>Access-Control-Expose-Headers</code>里面指定。</p>
<p>上面的例子指定，可以返回<code>FooBar</code>字段的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">&#x27;/index&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//设置响应头 跨域(允许接收任意url发来的跨域请求)</span></span><br><span class="line">    res.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>,<span class="string">&quot;*&quot;</span>)</span><br><span class="line">    <span class="comment">//设置允许xhr访问的响应头(Etag,Date)</span></span><br><span class="line">    res.setHeader(<span class="string">&#x27;Access-Control-Expose-Headers&#x27;</span>,<span class="string">&quot;ETag,Date&quot;</span>)</span><br><span class="line">    res.send(&#123;</span><br><span class="line">        msg:<span class="string">&#x27;成功&#x27;</span>,</span><br><span class="line">        status:<span class="number">200</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>跨域简单请求响应的服务端代码</center>

<h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3>]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>21-JS手写发布订阅类</title>
    <url>/2022/12/04/21-%E6%89%8B%E5%86%99%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="手写发布订阅类"><a href="#手写发布订阅类" class="headerlink" title="手写发布订阅类"></a>手写发布订阅类</h1><p>发布-订阅模式其实是一种<strong>对象间一对多的依赖关系</strong></p>
<p>当一个对象的状态发生改变时，所有依赖于它的对象都将得到状态改变的通知。</p>
<p>订阅者（Watch）<strong>把想订阅的事件的回调函数注册（Subscribe）到调度中心</strong>（Event Channel），当发布者（Publisher）发布该事件（Publish Event）到调度中心时，也就是<strong>该事件触发时</strong>，由调度中心统一<strong>执行订阅者注册到调度中心的回调函数</strong>。</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span></span>&#123;</span><br><span class="line">    <span class="comment">// 用来存放注册事件的回调数组</span></span><br><span class="line">    <span class="built_in">this</span>._events = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//绑定事件</span></span><br><span class="line">    <span class="function"><span class="title">on</span>(<span class="params">eventName, callback</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 由于一个事件可能注册多个回调函数，所以使用数组来存储回调函数队列</span></span><br><span class="line">        <span class="keyword">const</span> callbacks = <span class="built_in">this</span>._events[eventName] || [];</span><br><span class="line">        callbacks.push(callback);</span><br><span class="line">        <span class="built_in">this</span>._events[eventName] = callbacks</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...args 用于收集发布事件时传递的参数</span></span><br><span class="line">    <span class="function"><span class="title">emit</span>(<span class="params">eventName, ...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> callbacks = <span class="built_in">this</span>._events[eventName] || [];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>._events[eventName] == [])&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;事件未注册&#x27;</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            callbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(...args))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//解绑事件</span></span><br><span class="line">	<span class="function"><span class="title">off</span>(<span class="params">eventName, callback</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> callbacks = <span class="built_in">this</span>._events[eventName] || []</span><br><span class="line">        <span class="keyword">const</span> newCallbacks = callbacks.filter(<span class="function"><span class="params">fn</span> =&gt;</span> fn != callback )</span><br><span class="line">        <span class="built_in">this</span>._events[eventName] = newCallbacks;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>this._events = &#123;&#125;;</code><ul>
<li>对象中属性名为对应事件名</li>
<li>对象中的属性值均为<strong>对应事件的回调函数数组</strong></li>
</ul>
</li>
<li>绑定事件时<code>on()</code>，将新回调函数加入<code>this._events</code>中对应的事件回调数组</li>
<li>解绑事件时<code>off()</code>，通过对事件回调数组<strong>调用filter方法过滤解绑事件的回调函数（删除解绑事件的回调函数）</strong></li>
<li>发布（触发）事件时<code>emit()</code>，根据传递的<code>eventName</code>找到对应的事件回调数组，依次执行其中的回调函数(使用…args接收传递的其他参数)</li>
</ul>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>22-JS事件委托</title>
    <url>/2022/12/04/22-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><p><strong>事件委托：将自己的事件交给别人（父级元素）来实现</strong></p>
<p>事件委托基于事件冒泡</p>
<h2 id="事件冒泡的一个例子"><a href="#事件冒泡的一个例子" class="headerlink" title="事件冒泡的一个例子"></a>事件冒泡的一个例子</h2><p>在事件冒泡中，子元素<strong>没有绑定click点击事件</strong>，父元素绑定了click点击事件</p>
<p>此时点击子元素，<strong>仍然可以通过事件冒泡触发父元素的click点击事件</strong></p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;parent&quot;</span>&gt;</span><br><span class="line">    &lt;p&gt;父元素&lt;/p&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;child&quot;</span>&gt;子元素&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> parent = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#parent&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> child = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#child&#x27;</span>)</span><br><span class="line">    parent.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;父元素点击事件触发&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>上述代码没有给child元素绑定事件，但是点击child元素后控制台输出<code>父元素点击事件触发</code></p>
<h2 id="事件委托使用实例"><a href="#事件委托使用实例" class="headerlink" title="事件委托使用实例"></a>事件委托使用实例</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果需要对上述div中每个a标签添加点击事件，阻止它们的默认行为(跳转)并输出href属性，可以通过<strong>遍历所有的a标签添加点击事件</strong>。这种方法会带来<strong>两个弊端</strong>：</p>
<ol>
<li><strong>频繁操作DOM</strong>：当需要遍历的元素很多时，影响性能</li>
<li>动态增加的新a标签不能绑定点击事件</li>
</ol>
<br>

<p>使用事件委托解决上述两个问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> parent = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#parent&#x27;</span>)</span><br><span class="line">    parent.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//event.target触发事件的 源元素</span></span><br><span class="line">      <span class="keyword">var</span> target = event.target</span><br><span class="line">      <span class="comment">//输出a标签的href属性</span></span><br><span class="line">      <span class="built_in">console</span>.log(target.getAttribute(<span class="string">&#x27;href&#x27;</span>));</span><br><span class="line">      <span class="comment">//阻止默认事件</span></span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//新增a标签</span></span><br><span class="line">    <span class="keyword">var</span> newa = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    newa.innerText = <span class="string">&#x27;新增a标签&#x27;</span></span><br><span class="line">    newa.setAttribute(<span class="string">&#x27;href&#x27;</span>,<span class="string">&#x27;http://www.yang.com&#x27;</span>)</span><br><span class="line">    parent.appendChild(newa)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>event.target</code>是触发事件的 源元素</p>
</li>
<li><p>若点击a标签导致触发parent元素的点击事件，则<code>event.target</code>为点击的a标签</p>
</li>
<li><p>动态新增的a标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.yang.com&quot;</span>&gt;</span>新增a标签<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>仍然可以通过事件委托，输出自己的href属性并阻止默认事件</p>
</li>
</ul>
<br>

<p>通过事件委托</p>
<ul>
<li>减少了DOM操作次数</li>
<li>解决了动态添加的元素的事件绑定问题</li>
</ul>
<p>如果需要对子元素绑定不同的事件，可以在子元素<strong>设置自定义属性</strong>，根据<code>e.target</code>的自定义属性<strong>区分不同的子元素</strong></p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>23-JS字符串常用方法</title>
    <url>/2022/12/04/23-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h1><h2 id="charAt-方法"><a href="#charAt-方法" class="headerlink" title="charAt()方法"></a>charAt()方法</h2><p><strong>charAt()</strong> 方法从一个字符串<strong>根据索引</strong>返回<strong>指定的字符</strong>。</p>
<h2 id="includes-方法"><a href="#includes-方法" class="headerlink" title="includes()方法"></a>includes()方法</h2><p><strong><code>includes()</code></strong> 方法用于<strong>判断一个字符串是否包含在另一个字符串中</strong>，根据情况返回 true 或 false。</p>
<p>两个参数</p>
<ul>
<li><p><code>searchString</code></p>
<p>要在此字符串中搜索的字符串。</p>
</li>
<li><p><code> position</code> 可选</p>
<p>从当前字符串的哪个索引位置开始搜寻子字符串，默认值为 <code>0</code></p>
</li>
</ul>
<span id="more"></span>

<h2 id="concat-方法"><a href="#concat-方法" class="headerlink" title="concat()方法"></a>concat()方法</h2><p><strong><code>concat()</code></strong> 方法将一个或多个字符串与原字符串连接合并，形成一个<strong>新的字符串并返回</strong>。</p>
<p><code>str.concat(str1[,str2,...,strn])</code></p>
<h2 id="indexOf-方法"><a href="#indexOf-方法" class="headerlink" title="indexOf()方法"></a>indexOf()方法</h2><p><code>indexOf()</code> 方法返回调用它的 <code>String</code> 对象中<strong>指定值或子串第一次出现的索引</strong></p>
<p>从 <code>fromIndex</code> 处进行搜索。如果<strong>未找到该值或子串，则返回 -1。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.indexOf(searchValue [, fromIndex])</span><br></pre></td></tr></table></figure>

<p><code>fromIndex</code>默认值为0</p>
<h2 id="match-方法-匹配正则"><a href="#match-方法-匹配正则" class="headerlink" title="match()方法 匹配正则"></a>match()方法 匹配正则</h2><p> <strong><code>match()</code></strong> 方法检索字符串</p>
<p><strong>以数组形式返回该字符串匹配正则表达式的结果。</strong></p>
<p>如果你没有给出任何参数并直接使用match() 方法 ，你将会得到一 个包含空字符串的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a> ：[“”] 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="regexp">/[a-z]/g</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;123456ab&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = str.match(arr)</span><br><span class="line"><span class="built_in">console</span>.log(res);	<span class="comment">//输出[&#x27;a&#x27;,&#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2 id="substring-方法"><a href="#substring-方法" class="headerlink" title="substring()方法"></a>substring()方法</h2><p><strong><code>substring() </code><strong>方法</strong>返回</strong>一个字符串在开始索引到结束索引之间的<strong>一个子串</strong>, 或从开始索引直到字符串的末尾的一个子集。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.substring(indexStart[, indexEnd])</span><br></pre></td></tr></table></figure>

<ul>
<li>包含开始索引，不包含结束索引</li>
</ul>
<h2 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace()方法"></a>replace()方法</h2><p>将给定<strong>模式</strong>匹配的子串替换为<strong>新字符串</strong></p>
<p>返回值：替换后的<strong>新字符串</strong>，<strong>不修改</strong>原字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">str.replace(regexp|substr, newSubStr|<span class="function"><span class="keyword">function</span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>regexp(模式)：正则表达式<strong>字面量</strong> 或 正则表达式<strong>对象</strong></p>
</li>
<li><p>substr(模式)：一个字符串(str中被替换的子串)</p>
</li>
<li><p>newSubstr(替换值)：新字符串</p>
</li>
<li><p>function(替换值)：该函数的返回值作为替换值</p>
</li>
</ul>
<p>当模式使用regexp时，<strong>所有匹配的子串</strong>都会被替换</p>
<p>当模式使用substr时，只有<strong>满足的第一个子串</strong>被替换</p>
<h2 id="split-方法"><a href="#split-方法" class="headerlink" title="split()方法"></a>split()方法</h2><p>将字符串以给定字符为分隔，分隔为数组</p>
<p><strong>返回值：</strong>分隔后的数组，不修改原字符串</p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>24-JS数组常用方法</title>
    <url>/2022/12/04/24-%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h1><h2 id="forEach-callback"><a href="#forEach-callback" class="headerlink" title="forEach(callback)"></a>forEach(callback)</h2><p>遍历数组，对数组每个元素执行forEach方法的回调函数</p>
<h2 id="slice-方法"><a href="#slice-方法" class="headerlink" title="slice()方法"></a>slice()方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array.slice(begin,end)</span><br></pre></td></tr></table></figure>

<p><code>slice()</code> 方法<strong>返回一个新的数组对象</strong>，</p>
<p>这一对象是一个由 <code>begin</code> 和 <code>end</code> 决定的原数组的<strong>浅拷贝</strong>（包括 <code>begin</code>，不包括<code>end</code>）。</p>
<p>原始数组<strong>不会被改变。</strong></p>
<ul>
<li>end省略时，<strong>从begin开启浅拷贝后面的所有数组元素</strong></li>
</ul>
<span id="more"></span>

<p><span style="color:red">注意：使用slice方法进行浅拷贝时</span></p>
<ol>
<li>对于原数组中的<strong>Number和String和Boolean</strong>类型数据进行完全拷贝<ul>
<li>修改新数组的<code>Number或String或Boolean</code>类型数据<strong>不会影响原数组</strong></li>
</ul>
</li>
<li>对于原数组中的<strong>对象引用或者对象或者数组</strong>，拷贝引用到新数组中<ul>
<li>修改该对象或数组，原数组和新数组<strong>均受到影响</strong></li>
<li>通过新数组中拷贝的引用修改对象或数组，两个数组<strong>均受到影响</strong></li>
</ul>
</li>
<li>向两个数组任一添加新元素，另一个<strong>不会收到影响</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">     name:<span class="string">&#x27;yang&#x27;</span>,</span><br><span class="line">     age:<span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,obj]	<span class="comment">//a[3] = obj为对象引用</span></span><br><span class="line"><span class="keyword">var</span> b = a.slice()</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">4</span>			<span class="comment">//新数组修改三种基本数据类型，不会影响原数组</span></span><br><span class="line">obj.name = <span class="string">&#x27;xiao&#x27;</span>	<span class="comment">//修改obj对象，同时影响a和b数组</span></span><br><span class="line"><span class="built_in">console</span>.log(a);		<span class="comment">//输出[ 1, 2, 3, &#123; name: &#x27;xiao&#x27;, age: 20 &#125; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);		<span class="comment">//输出[ 1, 4, 3, &#123; name: &#x27;xiao&#x27;, age: 20 &#125; ]</span></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;<span class="attr">name</span>:<span class="string">&#x27;yang&#x27;</span>&#125;]	<span class="comment">//a[3]为对象</span></span><br><span class="line"><span class="keyword">var</span> b = a.slice()</span><br><span class="line">b[<span class="number">3</span>].name = <span class="string">&#x27;xiao&#x27;</span>		<span class="comment">//通过新数组中的对象引用修改对象影响两个数组</span></span><br><span class="line"><span class="built_in">console</span>.log(a);			<span class="comment">//[ 1, 2, 3, &#123; name: &#x27;xiao&#x27; &#125; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);			<span class="comment">//[ 1, 2, 3, &#123; name: &#x27;xiao&#x27; &#125; ]</span></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,arr]	<span class="comment">//数组本质也是对象，与拷贝对象同理</span></span><br><span class="line"><span class="keyword">var</span> b = a.slice()</span><br><span class="line">b[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">9</span>			<span class="comment">//通过新数组的引用修改arr数组，会影响两个数组</span></span><br><span class="line"><span class="built_in">console</span>.log(a);		<span class="comment">//[ 1, 2, 3, [ 4, 9, 6 ] ]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);		<span class="comment">//[ 1, 2, 3, [ 4, 9, 6 ] ]</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="splice-方法"><a href="#splice-方法" class="headerlink" title="splice()方法"></a>splice()方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array.splice(start[, deleteCount[, item1[, item2[, ...]]]])</span><br></pre></td></tr></table></figure>

<ul>
<li><p>从<strong>start索引开始删除deleteCount个元素</strong>，并添加 item1，item2等元素</p>
</li>
<li><p>若deleteCount为0，则不移除元素，在start索引位置开始添加元素，原start索引的元素后移</p>
</li>
<li><p>会<strong>修改原数组</strong>，</p>
</li>
<li><p><span style="color:red">返回值：返回删除元素组成的数组，没有删除元素则返回空数组</span></p>
</li>
</ul>
<h2 id="reduce-方法"><a href="#reduce-方法" class="headerlink" title="reduce()方法"></a>reduce()方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</span><br></pre></td></tr></table></figure>

<p><span style="color:red">返回累加后的结果</span></p>
<p>参数：</p>
<p><code>callback</code> 累计器回调函数</p>
<p>数组中每个值执行的回调函数，包含四个参数：</p>
<ul>
<li><p><code>accumulator</code></p>
<p>累计值： 它是上一次调用回调时的返回值，或<code>initialValue</code>（见于下方）。</p>
</li>
<li><p><code>currentValue</code></p>
<p>数组中正在处理的元素。</p>
</li>
<li><p><code>index</code> 可选</p>
<p>数组中正在处理的当前元素的索引。 如果提供了<code>initialValue</code>，则起始索引号为0，<strong>否则从索引1起始</strong>。</p>
</li>
<li><p><code>array</code>可选</p>
<p>调用<code>reduce()</code>的数组</p>
</li>
</ul>
<br>

<p><code>initialValue</code>可选</p>
<ul>
<li><p>不省略：作为第一次调用 <code>callback</code>函数时的<code>accumulator</code>（<strong>累计起始值</strong>），<strong>index从0开始</strong>。 </p>
</li>
<li><p>省略：则<strong>累加起始值</strong>默认为数组的第一个元素，<strong>index从1开始</strong>。</p>
</li>
</ul>
<p>空数组调用且未指定<code>initialValue</code>时，<code>reduce</code><strong>报错</strong></p>
<p>空数组调用但指定<code>initialValue</code>时，返回<code>initialValue</code></p>
<br>

<h2 id="map-方法"><a href="#map-方法" class="headerlink" title="map()方法"></a>map()方法</h2><p><code>map()</code> 方法返回一个新数组，其元素是<strong>调用者数组</strong>中的每个元素经回调函数处理后的返回值。</p>
<p><span style="color:red">返回一个新数组</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> new_array = arr.map(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[, index[, array]]</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// Return element for new_array </span></span><br><span class="line">&#125;[, thisArg])</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<p><code>callback</code></p>
<p>生成新数组元素的函数，使用三个参数：</p>
<ul>
<li><p><code>currentValue</code></p>
<p><code>callback</code> 数组中正在处理的当前元素。</p>
</li>
<li><p><code>index</code>可选</p>
<p><code>callback</code> 数组中正在处理的当前元素的索引。</p>
</li>
<li><p><code>array</code>可选</p>
<p><code>map</code> 方法调用者数组。</p>
</li>
</ul>
<p><code>thisArg</code>可选</p>
<p>执行 <code>callback</code> 函数时值被用作<code>this</code>。</p>
<h2 id="shift-方法"><a href="#shift-方法" class="headerlink" title="shift()方法"></a>shift()方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">array.shift()</span><br></pre></td></tr></table></figure>

<p>将数组首元素移出</p>
<p><span style="color:red">返回移出的元素</span></p>
<p>会<strong>修改原数组</strong></p>
<h2 id="unshift-方法"><a href="#unshift-方法" class="headerlink" title="unshift()方法"></a>unshift()方法</h2><p>在数组头部加入一个新元素</p>
<p>修改原数组</p>
<p><span style="color:red">返回数组长度</span></p>
<h2 id="pop-方法"><a href="#pop-方法" class="headerlink" title="pop()方法"></a>pop()方法</h2><p>删除数组尾元素</p>
<p><span style="color:red">返回删除的元素</span></p>
<h2 id="filter-方法"><a href="#filter-方法" class="headerlink" title="filter()方法"></a>filter()方法</h2><p><code>Array.filter(callback())</code></p>
<p>对<strong>调用者数组的每个元素</strong>执行回调函数，通过回调函数<code>(return true)</code>的元素加入新数组</p>
<p><span style="color:red">返回生成的新数组 (通过过滤的元素形成的新数组)</span></p>
<p>不修改原数组</p>
<p>callback回调函数中三个参数</p>
<ul>
<li><p><code>currentValue</code></p>
<p><code>callback</code> 数组中正在处理的当前元素。</p>
</li>
<li><p><code>index</code>可选</p>
<p><code>callback</code> 数组中正在处理的当前元素的索引。</p>
</li>
<li><p><code>array</code>可选</p>
<p><code>filter</code>方法调用者数组。</p>
</li>
</ul>
<h2 id="concat-方法"><a href="#concat-方法" class="headerlink" title="concat()方法"></a>concat()方法</h2><p>连接两个数组 </p>
<p><code>arr.concat(arr1)</code>连接数组arr和arr1</p>
<p><span style="color:red">返回生成的新数组</span></p>
<p>不修改原数组</p>
<h2 id="every-方法"><a href="#every-方法" class="headerlink" title="every()方法"></a>every()方法</h2><p>数组元素<strong>全部都满足回调函数</strong>，返回<code>true</code></p>
<p>否则返回<code>false</code></p>
<h2 id="some方法"><a href="#some方法" class="headerlink" title="some方法"></a>some方法</h2><p>数组元素<strong>至少有一个</strong>满足回调函数，返回<code>true</code></p>
<p>否则返回<code>false</code></p>
<h2 id="join-方法-数组转字符串"><a href="#join-方法-数组转字符串" class="headerlink" title="join()方法 数组转字符串"></a>join()方法 数组转字符串</h2><p><span style="color:red">返回转换后的字符串</span></p>
<p>不修改原数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> res = arr.join(<span class="string">&#x27;&#x27;</span>)	<span class="comment">//&#x27;134&#x27;</span></span><br><span class="line"><span class="keyword">var</span> res1 = arr.join()	<span class="comment">//&#x27;1,3,4&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>方法传入<strong>空字符串</strong>作为参数，将数组每个元素直接拼接为字符串</li>
<li>不传参时，将<strong>中括号里的内容</strong>转换为字符串</li>
</ul>
<h2 id="includes-方法"><a href="#includes-方法" class="headerlink" title="includes()方法"></a>includes()方法</h2><p>判断一个数组是否包含一个指定的值，如果包含则返回 <code>true</code>，否则返回 <code>false</code>。</p>
<br>

<h2 id="sort-方法"><a href="#sort-方法" class="headerlink" title="sort()方法"></a>sort()方法</h2><p>根据<code>Array.sort(compareFunction)</code>的 <strong>compareFunction</strong>函数确定排序规则</p>
<p><code>compareFunction(a,b)</code></p>
<ul>
<li><strong>a和b</strong>为比较的两个元素</li>
<li>函数返回值 &lt; 0 时，a放在b前</li>
<li>函数返回值 &gt; 0 时，b放在a前</li>
<li>函数返回值 = 0 时，ab位置不变</li>
</ul>
<br>

<p><span style="color:red">返回排序后的数组</span>。（注意：数组已原地排序，并且不进行复制。）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nums.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123; <span class="keyword">return</span> a-b &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>对于<strong>数字数组nums</strong>，进行升序排序，<strong>修改原数组</strong>，返回排序后的数组</li>
</ul>
<br>



]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>25-JS形参与传入实参的关系</title>
    <url>/2022/12/04/25-js%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%8F%82%E4%B8%8E%E4%BC%A0%E5%85%A5%E5%AE%9E%E5%8F%82%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="JS函数的形参与传入实参的关系"><a href="#JS函数的形参与传入实参的关系" class="headerlink" title="JS函数的形参与传入实参的关系"></a>JS函数的形参与传入实参的关系</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    arr.splice(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(arr);   <span class="comment">//[1]</span></span><br><span class="line">    arr = arr.concat([<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">    arr.push(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a(num));    <span class="comment">//[1,2,3,0]</span></span><br><span class="line"><span class="built_in">console</span>.log(num);       <span class="comment">//[1]</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/Untitled/image-20211102231301965.png" alt="image-20211102231301965"></p>
<ul>
<li>函数中红框所示赋值语句及其之后的操作均为对<strong>函数局部变量arr</strong>的修改<ul>
<li><code>concat</code>方法返回一个<strong>新的数组对象</strong>，执行此语句时及其之后的<strong>局部变量arr</strong>与<strong>全局变量num</strong>没有关系</li>
</ul>
</li>
<li>红框所示语句之前对<strong>局部变量arr</strong>的操作均会对<strong>num全局变量</strong>造成影响</li>
<li><strong>引用数据类型</strong>做为函数的参数传递时，实际传递的是<span style="color:red;">数据的地址引用</span></li>
</ul>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>26-JS的iterator迭代器</title>
    <url>/2022/12/04/26-iterator%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h1 id="iterator迭代器"><a href="#iterator迭代器" class="headerlink" title="iterator迭代器"></a>iterator迭代器</h1><p>遍历对象的方式有两种，</p>
<ul>
<li>一种是通过索引进行遍历(例如数组的下标)</li>
<li>另一种是<strong>通过迭代器进行遍历</strong></li>
</ul>
<span id="more"></span>

<h2 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h2><p><strong>Symbol.iterator</strong> 为每一个对象定义了默认的迭代器。(<strong>Symbol.iterator</strong> 是一个<strong>属性</strong>)</p>
<p>该迭代器可以被 <code>for...of</code> 循环使用。</p>
<p><code>for ...of</code>循环是通过迭代器进行的</p>
<br>

<p>一些内置类型有默认的迭代器，位于其prototype上</p>
<ul>
<li>Array</li>
<li>String</li>
<li>Set</li>
<li>Map</li>
</ul>
<p><img data-src="/images/Untitled/image-20211104212318997.png" alt="image-20211104212318997"></p>
<p>而其他一些对象(如Object)没有默认的迭代器</p>
<p>对于没有默认迭代器的对象，如果不手动设置迭代器，则使用<code>for ...of</code>循环时报错</p>
<br>

<h2 id="对Object原型编程手动添加迭代器"><a href="#对Object原型编程手动添加迭代器" class="headerlink" title="对Object原型编程手动添加迭代器"></a>对Object原型编程手动添加迭代器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(<span class="built_in">this</span>)	<span class="comment">//获取对象键名数组</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="comment">//根据键名获取对应键值作为迭代器循环时的值</span></span><br><span class="line">                value: _this[keys[index++]],</span><br><span class="line">                <span class="comment">//done为遍历结束的标志，当done代表的表达式返回true时遍历结束</span></span><br><span class="line">                done: index &gt; keys.length</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在Object的prototype上添加<code>Symbol.iterator</code>属性，属性值为函数</p>
</li>
<li><p>该函数返回一个迭代器对象</p>
<ul>
<li><p>迭代器对象结构必须如下</p>
</li>
<li><p>```js<br>{</p>
<pre><code>next: function() &#123;
    return &#123;
        value: any, //每次迭代的结果
        done: boolean //迭代结束标识
    &#125;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">手动在&#96;Object.prototype&#96;上添加迭代器后，所有Object实例都可以使用&#96;for of&#96;进行循环</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">            a:1,</span><br><span class="line">            b:2,</span><br><span class="line">            c:4</span><br><span class="line">        &#125;</span><br><span class="line">        for (let i of obj)&#123;</span><br><span class="line">        	console.log(i);	&#x2F;&#x2F;1 2 4</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>27-JS的for in|for of|Object.keys区别</title>
    <url>/2022/12/04/27-for%20in%E5%92%8Cfor%20of%E5%92%8CObject.keys%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="for-in、for-of和Object-keys的区别"><a href="#for-in、for-of和Object-keys的区别" class="headerlink" title="for in、for of和Object.keys的区别"></a>for in、for of和Object.keys的区别</h1><h2 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h2><p>遍历<strong>数组的下标</strong>或者<strong>对象的键名</strong></p>
<h2 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h2><p>使用<strong>迭代器iterator</strong>遍历对象</p>
<p>Array、Map、Set、String是默认拥有迭代器的内置对象</p>
<p>对于没有迭代器的对象(如Object)，需要手动添加迭代器后才能使用for of遍历</p>
<p>for of遍历<strong>键值</strong>或者<strong>数组的元素</strong></p>
<span id="more"></span>

<h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys"></a>Object.keys</h2><p><code>Object.keys()</code> 方法会返回一个给定对象的<strong>可枚举属性的键名组成的数组</strong></p>
<p>数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。</p>
<ul>
<li>对于数组返回其<strong>下标组成的数组</strong></li>
<li>对于对象返回其<strong>可枚举键名组成的数组</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// simple array</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(arr)); <span class="comment">// console: [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// console: [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object with random key ordering</span></span><br><span class="line"><span class="keyword">var</span> anObj = &#123; <span class="number">100</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(anObj)); <span class="comment">// console: [&#x27;2&#x27;, &#x27;7&#x27;, &#x27;100&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getFoo 是一个不可枚举的属性</span></span><br><span class="line"><span class="keyword">var</span> myObj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;</span><br><span class="line">  getFoo: &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.foo; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">myObj.foo = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(myObj)); <span class="comment">// console: [&#x27;foo&#x27;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上述第三个<code>Object.keys()</code>输出的可枚举键名组成的数组<strong>自动进行升序排序</strong></li>
<li>上述第四个对象的getFoo属性是一个函数(不可枚举)，所以Object.keys()输出<code>[&#39;foo&#39;]</code></li>
</ul>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>28-JS纯函数</title>
    <url>/2022/12/04/28-js%E7%BA%AF%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="js纯函数"><a href="#js纯函数" class="headerlink" title="js纯函数"></a>js纯函数</h1><p>纯函数：</p>
<ul>
<li>函数的返回值<strong>只依赖于它的参数</strong></li>
<li>函数没有<strong>副作用</strong><ul>
<li>一个函数执行过程产生了<strong>外部可观察的变化</strong>称为有副作用</li>
</ul>
</li>
</ul>
<span id="more"></span>

<br>

<h2 id="返回值只依赖于它的参数"><a href="#返回值只依赖于它的参数" class="headerlink" title="返回值只依赖于它的参数"></a>返回值只依赖于它的参数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">x, b</span>) =&gt;</span> x + b</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>

<p>上述代码，foo函数的返回值只依赖于参数x和b（满足纯函数的第一个条件）</p>
<br>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">b</span>) =&gt;</span> a + b</span><br><span class="line">foo(<span class="number">2</span>) <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>

<p>上述代码，foo函数的返回值除了b还依赖于<strong>函数外部的a变量</strong>（不满足第一个条件）</p>
<br>

<h2 id="函数执行没有副作用"><a href="#函数执行没有副作用" class="headerlink" title="函数执行没有副作用"></a>函数执行没有副作用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">obj, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> obj.x + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> counter = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line">foo(counter, <span class="number">2</span>) <span class="comment">// =&gt; 3</span></span><br><span class="line">counter.x <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>

<p>上述代码，</p>
<ul>
<li><p>满足纯函数的第一个条件</p>
</li>
<li><p>并且没有对函数外部的counter对象产生可观察的变化（函数没有副作用）</p>
<ul>
<li>counter对象在函数执行前后没有变化</li>
</ul>
</li>
<li><p><span style="color:red">这个foo函数为纯函数</span></p>
</li>
</ul>
<br>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function">(<span class="params">obj, b</span>) =&gt;</span> &#123;</span><br><span class="line">  obj.x = <span class="number">2</span>			<span class="comment">//修改obj函数产生了副作用</span></span><br><span class="line">  <span class="keyword">return</span> obj.x + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> counter = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line">foo(counter, <span class="number">2</span>) <span class="comment">// =&gt; 4</span></span><br><span class="line">counter.x <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure>

<p>上述代码，</p>
<ul>
<li><p>在foo函数内部修改obj对象的x属性，同样也会反映在全局对象counter上</p>
<ul>
<li>函数传参对于引用数据类型是<strong>地址引用</strong></li>
</ul>
</li>
<li><p>函数外的counter对象在函数执行中产生了可观察变化，产生了副作用</p>
</li>
<li><p>注意：<strong>对于函数内部定义的变量进行修改不会产生副作用</strong>，因为作用域链的原因，函数外部观察不到函数内部变量的变化</p>
</li>
</ul>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>29-es6的proxy对象</title>
    <url>/2022/12/04/29-es6%E7%9A%84proxy/</url>
    <content><![CDATA[<h1 id="Proxy对象"><a href="#Proxy对象" class="headerlink" title="Proxy对象"></a>Proxy对象</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">MDN教程</a></p>
<p><strong>Proxy</strong> 对象用于<strong>创建一个对象的代理</strong>，从而实现基本操作的<strong>拦截和自定义</strong>（如属性查找、赋值、枚举、函数调用等）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>target</code></li>
</ul>
<p>要使用 <code>Proxy</code> 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</p>
<ul>
<li><code>handler</code></li>
</ul>
<p>一个通常<strong>以函数作为属性值的对象</strong>，各属性的函数分别定义了在执行各种操作时代理 <code>p</code> 的行为。</p>
<span id="more"></span>

<h2 id="handler对象的方法"><a href="#handler对象的方法" class="headerlink" title="handler对象的方法"></a>handler对象的方法</h2><p><code>handler</code> 对象是一个容纳一批特定属性的占位符对象。它包含有 <code>Proxy</code> 的各个捕获器（trap）。</p>
<p>所有的捕捉器是可选的。如果没有定义某个捕捉器，那么就会保留源对象的默认行为。</p>
<ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getPrototypeOf"><code>handler.getPrototypeOf()</code></a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf"><code>Object.getPrototypeOf</code></a> 方法的捕捉器。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/setPrototypeOf"><code>handler.setPrototypeOf()</code></a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"><code>Object.setPrototypeOf</code></a> 方法的捕捉器。</p>
</li>
<li><p><span style='color:red'><code>handler.defineProperty()</code></span></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty</code></a> 方法的捕捉器。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/has"><code>handler.has()</code></a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in"><code>in</code></a> 操作符的捕捉器。</p>
</li>
<li><p><span style='color:red'><code>handler.get()</code></span></p>
<p>属性读取操作的捕捉器。</p>
</li>
<li><p><span style='color:red'><code>handler.set()</code></span></p>
<p>属性设置操作的捕捉器。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/apply"><code>handler.apply()</code></a></p>
<p>函数调用操作的捕捉器。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/construct"><code>handler.construct()</code></a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new"><code>new</code></a> 操作符的捕捉器。</p>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在以下简单的例子中，当对象中不存在属性名时，默认返回值为 <code>37</code>。</p>
<p>下面的代码以此展示了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/get"><code>get</code></a> handler 的使用场景。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="comment">//obj:被代理的对象，prop:被操作的属性</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params">obj, prop</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prop <span class="keyword">in</span> obj ? obj[prop] : <span class="number">37</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">p.a = <span class="number">1</span>;</span><br><span class="line">p.b = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.a, p.b);      <span class="comment">// 1, undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;c&#x27;</span> <span class="keyword">in</span> p, p.c); <span class="comment">// false, 37</span></span><br></pre></td></tr></table></figure>

<br>

<p>在以下例子中，我们使用了一个原生 JavaScript 对象。</p>
<p>代理会将所有<strong>应用到它的操作</strong>转发到<strong>代理的对象上</strong>并<strong>通过捕捉器处理</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">p.a = <span class="number">37</span>;   <span class="comment">// 操作转发到目标</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target.a);    <span class="comment">// 37. 操作已经被正确地转发</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>30-JS代码实现instanceof操作符</title>
    <url>/2022/12/04/30-js%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0instanceof%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="js代码实现instanceof操作符"><a href="#js代码实现instanceof操作符" class="headerlink" title="js代码实现instanceof操作符"></a>js代码实现instanceof操作符</h1><p>instanceof 是通过原型链判断的，</p>
<p>A instanceof B：<strong>在A的原型链中层层查找，是否有原型等于B.prototype</strong>，如果一直找到A的原型链的顶端null,仍然不等于B.prototype，那么返回false，否则返回true.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">      left=left.__proto__</span><br><span class="line">      right=right.prototype</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(left==<span class="literal">null</span>)		<span class="comment">//原型链查找到null，返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">if</span>(left===right) 	<span class="comment">//原型链上找到B.prototype，返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           left=left.__proto__	<span class="comment">//沿着原型链层层查找</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>);	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance(arr,<span class="built_in">Array</span>));	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>31-JS中的隐式转换</title>
    <url>/2022/12/04/31-js%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="js中的隐式转换"><a href="#js中的隐式转换" class="headerlink" title="js中的隐式转换"></a>js中的隐式转换</h1><p>在js中，运算符在运算时，如果两边数据不统一，CPU就无法计算，这时我们<strong>编译器会自动将运算符两边的数据做一个数据类型转换</strong>，转成一样的数据类型再计算</p>
<p>这种无需程序员手动转换，而<strong>由编译器自动转换的方式就称为隐式转换</strong></p>
<span id="more"></span>

<h2 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h2><ol>
<li>转成string类型： <ul>
<li>+（字符串连接符）</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span> + <span class="literal">true</span>);	<span class="comment">//&#x27;1true&#x27; 将true转换为String类型</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>转成number类型：</p>
<ul>
<li><p><code>++ --</code> (自增自减运算符) </p>
</li>
<li><p> <code>+ - * / %</code>  (算术运算符)</p>
</li>
<li><p><code>&gt; &lt; &gt;= &lt;= == != === !===</code>  (关系运算符)</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">false</span></span><br><span class="line"><span class="built_in">console</span>.log(++a);	<span class="comment">//1	将false转换为Number类型的0</span></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">false</span></span><br><span class="line"><span class="built_in">console</span>.log(b + <span class="number">3</span>);	<span class="comment">//3</span></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span> &gt; <span class="number">10</span>) <span class="comment">//false 将&#x27;2&#x27;转换为Number类型 Number(&#x27;2&#x27;) &gt; 10</span></span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span> &gt; <span class="string">&#x27;1&#x27;</span>)<span class="comment">//true</span></span><br><span class="line"><span class="comment">//关系运算符两边均为字符串时，将每一位转换为unicode编码后依次比较</span></span><br><span class="line"><span class="comment">// &#x27;2&#x27; &gt; &#x27;1&#x27;  转换为&#x27;2&#x27;.charCodeAt() &gt; &#x27;1&#x27;.charCodeAt()</span></span><br><span class="line"><span class="comment">//50 &gt; 49 输出true</span></span><br><span class="line"><span class="comment">//多个字符如&#x27;ab&#x27; &gt; &#x27;bac&#x27;返回false 从左往右依次比较Unicode编码，</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>转成boolean类型：!（逻辑非运算符）</li>
</ol>
<br>

<h2 id="对于引用数据类型的隐式转换"><a href="#对于引用数据类型的隐式转换" class="headerlink" title="对于引用数据类型的隐式转换"></a>对于引用数据类型的隐式转换</h2><p>引用数据类型：<strong>数组</strong>或者<strong>对象</strong></p>
<p>所有对象和数组在<strong>使用关系运算符时</strong>遵循以下转换规则</p>
<ul>
<li>如果obj为原始值，直接返回；**(原始值：五种值数据类型(不含symbol))**</li>
<li>否则调用 <code>obj.valueOf()</code>，如果执行结果<strong>是原始值且不为NaN</strong>，返回之；</li>
<li>否则调用<code>obj.toString()</code>，如果执行结果<strong>是原始值</strong>，返回之；</li>
<li>否则抛异常。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">&#x27;y&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> val = obj.valueOf()</span><br><span class="line"><span class="built_in">console</span>.log(val);			<span class="comment">//输出&#123;name: &#x27;y&#x27;&#125; 类型为Object</span></span><br><span class="line"><span class="keyword">var</span> str = obj.toString()	<span class="comment">//&#x27;[object Object]&#x27; 类型为String</span></span><br><span class="line"><span class="built_in">console</span>.log(str &gt; <span class="string">&#x27;[O]&#x27;</span>);	<span class="comment">//&#x27;[object Object]&#x27; &gt; &#x27;[O]&#x27; 输出true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj &gt; <span class="string">&#x27;[O]&#x27;</span>);	<span class="comment">//输出true 转换为obj.toString() &gt; &#x27;[O]&#x27;</span></span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> da = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="built_in">console</span>.log(da,<span class="keyword">typeof</span> da);  </span><br><span class="line"><span class="comment">//格林威治时间 object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(da.valueOf(),<span class="keyword">typeof</span> da.valueOf());  </span><br><span class="line"><span class="comment">//从1970年1月1日0时0分0秒（UTC，即协调世界时）到当前日期的毫秒数。 number</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(da.toString(), <span class="keyword">typeof</span> da.toString());</span><br><span class="line"><span class="comment">//返回表示当地时间的字符串</span></span><br><span class="line"><span class="comment">//Thu Nov 18 2021 13:46:40 GMT+0800 (中国标准时间) string</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(da &gt; <span class="number">1111</span>); </span><br><span class="line"><span class="comment">// 毫秒数 &gt; 1111 输出true</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>32-JS中valueOf和toString区别</title>
    <url>/2022/12/04/32-valueOf%E5%92%8CtoString/</url>
    <content><![CDATA[<h1 id="valueOf和toString方法"><a href="#valueOf和toString方法" class="headerlink" title="valueOf和toString方法"></a>valueOf和toString方法</h1><h2 id="valueOf方法"><a href="#valueOf方法" class="headerlink" title="valueOf方法"></a>valueOf方法</h2><p>返回指定对象的<strong>原始值</strong></p>
<p><img data-src="/images/32-valueOf%E5%92%8CtoString/image-20211118142429095.png" alt="image-20211118142429095"></p>
<span id="more"></span>

<h2 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h2><p>返回一个表示该对象的<strong>字符串</strong></p>
<ul>
<li><p><code>object.toString()</code>：默认返回<code>’[object type]‘</code>，<code>type</code>为对象的类型，取值为<code>Date、Object</code>等</p>
<ul>
<li><p>可以覆写对象的<code>toString()</code>方法来返回其他值</p>
</li>
<li><p>```js<br>function Dog(name) {<br>  this.name = name;<br>}</p>
<p>const dog1 = new Dog(‘Gabby’);</p>
<p>Dog.prototype.toString = function dogToString() {<br>  return this.name;<br>};</p>
<p>console.log(dog1.toString());<br>// expected output: “Gabby”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;Array.toString()&#96;：返回**所有数组元素**调用toString()方法的返回值组成的**字符串**</span><br><span class="line"></span><br><span class="line">  - **空数组**调用toString()方法返回**空字符串**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">var arr &#x3D; [1,2,3]</span><br><span class="line">var arr1 &#x3D; [1,2,&#123;name:&#39;yang&#39;&#125;]</span><br><span class="line">console.log(arr.toString());	&#x2F;&#x2F;输出 &#39;1,2,3&#39; 类型为String</span><br><span class="line">console.log(arr1.toString());	&#x2F;&#x2F;输出 &#39;1,2,[object Object]&#39; 类型为String</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>Date.toString()</code>：返回时间对象<strong>在当前时区的字符串格式表示</strong></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> da = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="built_in">console</span>.log(da.toString()); <span class="comment">//输出Thu Nov 18 2021 14:30:27 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="利用toString-检测对象类型"><a href="#利用toString-检测对象类型" class="headerlink" title="利用toString()检测对象类型"></a>利用toString()检测对象类型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> toString = <span class="built_in">Object</span>.prototype.toString</span><br><span class="line"><span class="comment">//通过改变this指向的方式调用来判断对象类型</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="keyword">new</span> <span class="built_in">Object</span>()));</span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="keyword">new</span> <span class="built_in">Array</span>()));</span><br><span class="line"><span class="built_in">console</span>.log(toString.apply(<span class="keyword">new</span> <span class="built_in">Date</span>()));</span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="string">&#x27;1&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/32-valueOf%E5%92%8CtoString/image-20220406212658839.png" alt="image-20220406212658839"></p>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>33-JS的delete操作符</title>
    <url>/2022/12/04/33-delete%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="delete操作符"><a href="#delete操作符" class="headerlink" title="delete操作符"></a>delete操作符</h1><p>用于删除<strong>对象的属性</strong></p>
<p>返回值：</p>
<ul>
<li><p>删除成功或失败(属性不存在情况下)均返回true</p>
</li>
<li><p>在<strong>不能删除</strong>的情况下返回false</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	a:<span class="number">1</span>,</span><br><span class="line">	b:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> obj.a	<span class="comment">//删除obj的a属性</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">//&#123;b:2&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不能删除<strong>全局作用域下的属性和方法</strong>(<code>window.x</code>等)</li>
<li>不能删除<strong>函数作用域中</strong>声明的变量和方法</li>
</ul>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>JS执行机制(同步异步)</title>
    <url>/2021/04/13/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6(%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5)/</url>
    <content><![CDATA[<h1 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h1><h2 id="1-JS是单线程"><a href="#1-JS是单线程" class="headerlink" title="1.JS是单线程"></a>1.JS是单线程</h2><ul>
<li>JavaScript语言的一大特点就是<strong>单线程</strong>，同一时间只能做一件事。</li>
</ul>
<p>这是因为JavaScript诞生的目的所致——JavaScript是为了处理页面中用户的交互，以及操作DOM而诞生的。</p>
<p>我们对一个DOM元素进行操作时，<strong>不能同时进行多种操作</strong>，而只能先添加，再修改，然后删除。</p>
<ul>
<li>单线程意味着任务需要排队，前一个任务结束，后一个任务才开始。这样如果JS的执行时间过长就会导致页面渲染不连贯。导致页面渲染呈现阻塞的感觉。</li>
</ul>
<span id="more"></span>

<h2 id="2-同步和异步"><a href="#2-同步和异步" class="headerlink" title="2.同步和异步"></a>2.同步和异步</h2><ul>
<li>为了解决JS单线程导致的任务排队问题，利用多核CPU的计算能力，H5提出了Web Worker标准，允许JavaScript脚本<strong>创建多个线程</strong>。于是JS中出现了<strong>同步</strong>和<strong>异步</strong>。</li>
</ul>
<p><img data-src="/images/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6(%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5)/image-20210408185914871.png" alt="image-20210408185914871"></p>
<p>上面这段代码按照单线程的思路：先输出1 等待1s后输出2 再输出3，如果定时器等待时间过长就会出现渲染阻塞的感觉。</p>
<p>而允许JavaScript创建多个线程后，输出顺序变成了先输出1和3，等待1s后再输出2</p>
<ul>
<li>同步异步的<strong>本质区别</strong>：各个流程的执行顺序不同。</li>
</ul>
<h3 id="2-1同步"><a href="#2-1同步" class="headerlink" title="2.1同步"></a>2.1同步</h3><ul>
<li>同步：<strong>前一个任务执行完毕再开始执行下一个任务</strong>，程序的执行顺序与任务的排列顺序是一致的、同步的。</li>
</ul>
<h3 id="2-2异步"><a href="#2-2异步" class="headerlink" title="2.2异步"></a>2.2异步</h3><ul>
<li>异步：同时可以执行多个任务，下一个任务不必等待上一个任务执行完。</li>
</ul>
<h3 id="2-3同步任务和异步任务"><a href="#2-3同步任务和异步任务" class="headerlink" title="2.3同步任务和异步任务"></a>2.3同步任务和异步任务</h3><ul>
<li><p>同步任务：同步任务都在<strong>主线程</strong>上执行，形成一个执行栈</p>
</li>
<li><p>异步任务：JS的异步是通过回调函数实现的</p>
<ul>
<li>常见的异步任务有以下几类</li>
</ul>
<ol>
<li><strong>普通事件</strong>中的回调函数，如click、resize等事件中的回调函数</li>
<li><strong>资源加载</strong>中的回调函数，如load、error等事件中的回调函数</li>
<li><strong>定时器</strong>中的回调函数，如setTimeout、setInterval等定时器中的回调函数</li>
</ol>
<ul>
<li>异步任务相关的<strong>回调函数</strong>添加到<strong>回调函数队列</strong>(消息队列)中</li>
</ul>
</li>
</ul>
<p><img data-src="/images/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6(%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5)/image-20210408205300165.png" alt="image-20210408205300165"></p>
<p>上图的<code>console.log(1)</code>和<code>console.log(2)</code>都是<strong>同步任务</strong></p>
<p>定时器setTimeout()属于<strong>异步任务</strong></p>
<p>定时器中的回调函数即<code>function()&#123;console.log(3)&#125;</code> 要在<strong>异步任务队列</strong>中的定时器代码被执行时加入<strong>回调函数队列</strong></p>
<p><img data-src="/images/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6(%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5)/image-20210428214905524.png" alt="image-20210428214905524"></p>
<h3 id="2-4JS执行机制"><a href="#2-4JS执行机制" class="headerlink" title="2.4JS执行机制"></a>2.4JS执行机制</h3><ol>
<li><p>先按顺序执行代码，<strong>同步任务放入同步代码执行区中执行</strong></p>
</li>
<li><p>将遇到的异步任务放入异步代码执行区中，此时<strong>不执行异步任务</strong>(等待同步任务执行完后开始执行)</p>
<ul>
<li>此处将setTimeout定时器代码放入异步代码执行区中</li>
<li>然后继续执行下面的同步任务</li>
</ul>
</li>
<li><p>一旦同步代码执行区中的同步任务执行完毕后，系统就会进入异步代码执行区开始执行异步任务</p>
<ul>
<li>此处设定0s的定时器并将回调函数放入回调函数队列中</li>
</ul>
</li>
<li><p>当回调函数队列中的回调函数满足条件后就调入同步代码执行区执行</p>
<ul>
<li>此处经过0s后将<code>console.log(3)</code>回调函数调入同步代码执行区执行</li>
</ul>
</li>
<li><p>当前同步任务和异步任务都执行完毕后，通过<strong>事件循环</strong>继续查看任务队列，若有新的异步任务就继续执行</p>
<p>上图的输出次序为1、2、3</p>
</li>
</ol>
<ul>
<li><strong>事件循环</strong>(event loop)：同步代码执行区不断的重复获取任务、执行任务、再获取任务、再执行，这种循环<strong>机制</strong>被称为事件循环</li>
</ul>
<h4 id="2-4-1有多个异步任务时的执行机制"><a href="#2-4-1有多个异步任务时的执行机制" class="headerlink" title="2.4.1有多个异步任务时的执行机制"></a>2.4.1有多个异步任务时的执行机制</h4><p><img data-src="/images/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6(%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5)/image-20210428215837351.png" alt="image-20210428215837351"></p>
<p>此时有两个同步任务</p>
<ol>
<li>console.log(1);</li>
<li>console.log(2);</li>
</ol>
<p>两个异步任务</p>
<ol>
<li>onclick</li>
<li>setTimeout</li>
</ol>
<ul>
<li>第1个异步任务的回调函数只有当<strong>点击事件发生时</strong>，才被调入同步代码执行区执行</li>
<li>第2个异步任务的回调函数，<strong>等经过3s后</strong>才被调入同步任务执行区执行</li>
<li>这两个异步任务的回调函数<strong>执行顺序取决于点击事件发生的时间</strong></li>
<li>同步代码执行区中的同步任务执行完后，会通过事件循环不断地查看异步代码执行区是否有新的异步任务，有就继续执行异步任务。<ul>
<li>例如在当前所有同步、异步任务执行完毕后，又触发了一次点击事件，此时通过事件循环发现任务队列中有一个等待的异步任务，就将这个异步任务的回调函数放入回调函数队列中并直接调入同步代码执行区执行。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>http核心模块构建简单WEB服务器</title>
    <url>/2021/04/13/http%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E6%9E%84%E5%BB%BA%E7%AE%80%E5%8D%95WEB%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="1-http核心模块构建简单WEB服务器"><a href="#1-http核心模块构建简单WEB服务器" class="headerlink" title="1.http核心模块构建简单WEB服务器"></a>1.http核心模块构建简单WEB服务器</h1><span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Node中有一个核心模块：http</span></span><br><span class="line"><span class="comment">//这个模块就是用来创建编写服务器的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器</span></span><br><span class="line">    <span class="comment">//接受请求</span></span><br><span class="line">    <span class="comment">//处理请求</span></span><br><span class="line">    <span class="comment">//给出响应(反馈)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.引入核心模块http</span></span><br><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用http.createServer()创建一个WEB服务器</span></span><br><span class="line"><span class="comment">//      方法返回一个Server实例</span></span><br><span class="line"><span class="keyword">var</span> server=http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.注册request请求事件，当浏览器请求发向服务器时触发</span></span><br><span class="line"><span class="comment">//第二个参数是事件处理函数</span></span><br><span class="line">    <span class="comment">//请求处理函数中接收两个参数</span></span><br><span class="line">        <span class="comment">//Request   请求对象</span></span><br><span class="line">            <span class="comment">//获取客户端的一些请求信息，例如请求路径</span></span><br><span class="line">        <span class="comment">//Response  响应对象</span></span><br><span class="line">            <span class="comment">//用来给客户端发送响应信息</span></span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//服务器接收到客户端请求后就在后台输出 请求的url(路径)</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;接受到请求，请求路径为：&quot;</span>+request.url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//response对象的write()方法可以给客户端发送响应数据</span></span><br><span class="line">        <span class="comment">//此时客户端访问http://127.0.0.1/3000/ 时会返回hello nodejs</span></span><br><span class="line">    response.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    response.write(<span class="string">&quot; nodejs&quot;</span>);</span><br><span class="line">    <span class="comment">//可以有多个write()但最后必须有一个end()结束响应 否则客户端会一直等待</span></span><br><span class="line">    response.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.绑定端口号，启动服务器</span></span><br><span class="line"><span class="comment">//第二个参数的函数在服务器启动时执行(起日志作用)</span></span><br><span class="line">server.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//在3000端口启动服务器</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;服务器启动成功，可以通过http://127.0.0.1:3000/访问&quot;</span>);</span><br><span class="line">    <span class="comment">//127.0.0.1也可以换成localhost</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="1-1搭建服务器时的IP和端口号简单解释"><a href="#1-1搭建服务器时的IP和端口号简单解释" class="headerlink" title="1.1搭建服务器时的IP和端口号简单解释"></a>1.1搭建服务器时的IP和端口号简单解释</h2><p>在端口3000上打开服务器</p>
<p>IP标识一台计算机</p>
<p>端口标识一个应用程序</p>
<p>IP:端口号 可以<strong>唯一标识一台计算机上的一个应用程序</strong></p>
<p>这里localhost:3000即为本机上的由<code>nodejs</code>搭建的服务器应用程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.listen(3000,function()&#123;  </span><br><span class="line">    console.log(&quot;服务器启动成功，可以通过http:&#x2F;&#x2F;127.0.0.1&#x2F;3000&#x2F;访问&quot;);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="1-2中文乱码的解决方法"><a href="#1-2中文乱码的解决方法" class="headerlink" title="1.2中文乱码的解决方法"></a>1.2中文乱码的解决方法</h2><p>​    加上头部让浏览器明确以utf-8编码格式解析</p>
<ul>
<li><p>第一种方法</p>
<p>通过meta元数据声明当前文本的编码格式为utf-8</p>
<p>加上<code>response.write(&#39;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;/head&gt;&#39;);</code></p>
</li>
<li><p>第二种方法</p>
<p>加上<code>response.setHeader(&quot;Content-Type&quot;,&quot;text/plain; charset=utf-8&quot;)</code></p>
<p><strong>不同响应内容对应的响应类型是不一样的</strong> 例如text/plain 或 text/html</p>
<p>第二种方法加上的头部可以在浏览器中查看</p>
<p>F12 Network下查看</p>
<p><img data-src="/images/http%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E6%9E%84%E5%BB%BA%E7%AE%80%E5%8D%95WEB%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20210412202501529.png" alt="image-20210412202501529"></p>
<p><img data-src="/images/http%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E6%9E%84%E5%BB%BA%E7%AE%80%E5%8D%95WEB%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20210412202544524.png" alt="image-20210412202544524"></p>
</li>
</ul>
<h2 id="1-3-setHeader-方法"><a href="#1-3-setHeader-方法" class="headerlink" title="1.3 setHeader()方法"></a>1.3 setHeader()方法</h2><p>在响应头部添加响应类型字段</p>
<p><code>res.setHeader(&quot;Content-Type&quot;,&quot;text/plain; charset=utf-8&quot;)</code></p>
<ul>
<li><p>Content-Type，<strong>响应内容类型</strong></p>
<ul>
<li><p>不同的响应内容要填入不同的类型(text/plain、text/html等)</p>
</li>
<li><p>text/plain，为响应数据的格式，text/plain为普通文本，响应的数据会被当作<strong>普通文本</strong>处理(html标签也会被当作普通文本)</p>
</li>
<li><p>text/html，为<strong>html文本</strong>，响应数据中的<strong>html标签会被浏览器自动识别并解释执行</strong></p>
</li>
</ul>
</li>
<li><p>charset=utf-8，指明返回的数据是utf-8格式编码，解决中文乱码问题 </p>
</li>
</ul>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>web服务器响应文件中的数据</title>
    <url>/2021/04/13/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="1-web服务器响应文件中的数据"><a href="#1-web服务器响应文件中的数据" class="headerlink" title="1.web服务器响应文件中的数据"></a>1.web服务器响应文件中的数据</h1><h2 id="1-1Nodejs构建web服务器代码如下"><a href="#1-1Nodejs构建web服务器代码如下" class="headerlink" title="1.1Nodejs构建web服务器代码如下"></a>1.1Nodejs构建web服务器代码如下</h2><span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入核心模块http和fs</span></span><br><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs=<span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务器</span></span><br><span class="line"><span class="keyword">var</span> server=http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> url=req.url;</span><br><span class="line">    <span class="keyword">if</span>(url==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//请求时响应html文件</span></span><br><span class="line">        fs.readFile(<span class="string">&quot;todoList.html&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//请求失败时响应普通文本</span></span><br><span class="line">                res.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/plain; charset=utf-8&quot;</span>) </span><br><span class="line">                res.end(<span class="string">&quot;文件读取失败&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//请求成功时响应html文本</span></span><br><span class="line">                res.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/html; charset=utf-8&quot;</span>) </span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//因为html文件中引用了jQuery.js文件，所以要手动添加这个文件的访问路径</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(url==<span class="string">&quot;/jQuery.js&quot;</span>)&#123;</span><br><span class="line">        fs.readFile(<span class="string">&quot;jQuery.js&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)</span><br><span class="line">            &#123;</span><br><span class="line">                res.end(<span class="string">&quot;load faild&quot;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">&quot;3000&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;服务器启动成功,可以访问3000端口&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打开文件中的数据使用fs核心模块的<code>fs.readFile()</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">&quot;todoList.html&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>nodejs将文件中的<strong>数据</strong>响应给浏览器</p>
<p>将<code>fs.readFile</code>返回的文件中数据data用res.end(data)响应给浏览器并加上相应格式的响应类型Content-Type</p>
<p><strong>注意这里的data直接响应给浏览器解释执行，不需要呈现出来查看，所以不需要toString()方法转换为可识别字符串</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/html; charset=utf-8&quot;</span>) </span><br><span class="line">res.end(data);</span><br></pre></td></tr></table></figure>

<p>在浏览器中访问如下</p>
<p><img data-src="/images/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/image-20210412223931130.png" alt="image-20210412223931130"></p>
<h2 id="1-2如果响应的html文件中有外部引入的文件如css样式或者js文件，则需要手动添加到这些文件的请求url"><a href="#1-2如果响应的html文件中有外部引入的文件如css样式或者js文件，则需要手动添加到这些文件的请求url" class="headerlink" title="1.2如果响应的html文件中有外部引入的文件如css样式或者js文件，则需要手动添加到这些文件的请求url"></a>1.2如果响应的html文件中有外部引入的文件如css样式或者js文件，则需要手动添加到这些文件的请求url</h2><p><img data-src="/images/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/image-20210412223645626.png" alt="image-20210412223645626"></p>
<p>例如html文件中有外部引入的jQuery.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;./jQuery.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>则需要手动添加到jQuery.js文件的请求url</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(url==<span class="string">&quot;/jQuery.js&quot;</span>)&#123;</span><br><span class="line">        fs.readFile(<span class="string">&quot;jQuery.js&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)</span><br><span class="line">            &#123;</span><br><span class="line">                res.end(<span class="string">&quot;load faild&quot;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-Content-Type内容类型"><a href="#2-Content-Type内容类型" class="headerlink" title="2.Content-Type内容类型"></a>2.Content-Type内容类型</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/plain; charset=utf-8&quot;</span>) </span><br></pre></td></tr></table></figure>

<p>不同的响应内容要填入不同的类型(text/plain、text/html等)</p>
<p><a href="http://tool.oschina.net/commons">http://tool.oschina.net/commons</a></p>
<p>上面的网址可以查看不同类型的数据使用什么响应类型</p>
<h1 id="3-服务器根据不同的请求URL可以返回不同的数据"><a href="#3-服务器根据不同的请求URL可以返回不同的数据" class="headerlink" title="3.服务器根据不同的请求URL可以返回不同的数据"></a>3.服务器根据不同的请求URL可以返回不同的数据</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.on(<span class="string">&quot;request&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;接受到请求，请求路径为：&quot;</span>+request.url);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> url=request.url;</span><br><span class="line">    <span class="comment">//判断url不同 响应不同的数据</span></span><br><span class="line">    <span class="keyword">if</span>(url==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//可以使用end()直接响应数据后结束</span></span><br><span class="line">            <span class="comment">//响应内容只能是 字符串和二进制数串</span></span><br><span class="line">            <span class="comment">//数字，布尔值，数组，对象等需要使用JSON转换成字符串</span></span><br><span class="line">        response.end(<span class="string">&quot;hello nodejs&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当url为&quot;/login&quot;时</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(url==<span class="string">&quot;/login&quot;</span>)&#123;</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/plain; charset=utf-8&quot;</span>)</span><br><span class="line">        response.end(<span class="string">&quot;登陆页面&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当url为&quot;/shuzu&quot;时</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(url==<span class="string">&quot;/shuzu&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">        <span class="comment">//响应经过JSON转换后的字符串&quot;[1,2,3,4]&quot;</span></span><br><span class="line">        response.end(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当url为&quot;/html&quot;时</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(url==<span class="string">&quot;/html&quot;</span>)&#123;</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/html; charset=utf-8&quot;</span>) </span><br><span class="line">        response.end(<span class="string">&quot;&lt;p&gt;你好&lt;a href=&#x27;#&#x27;&gt;点击超链接&lt;/a&gt;&lt;/p&gt;&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//其他url返回&quot;404 Not Found.&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        response.end(<span class="string">&quot;404 Not Found.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>URL为/html时</p>
<p><img data-src="/images/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/image-20210414200745087.png" alt="image-20210414200745087"></p>
<p>URL为/login时</p>
<p><img data-src="/images/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/image-20210414200823281.png" alt="image-20210414200823281"></p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>03-Vue组件化开发</title>
    <url>/2021/09/20/03-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="Vue组件化开发"><a href="#Vue组件化开发" class="headerlink" title="Vue组件化开发"></a>Vue组件化开发</h1><h2 id="1-组件化开发思想"><a href="#1-组件化开发思想" class="headerlink" title="1. 组件化开发思想"></a>1. 组件化开发思想</h2><ul>
<li>标准：多个组件最后要进行结合生成完整的程序，统一的标准的必不可少的</li>
<li>分治：将大问题，化解为多个小问题，即多个组件</li>
<li>重用：一个组件可以被多次使用，提升开发效率</li>
<li>组合</li>
</ul>
<p>对于应用程序开发来说，将应用的<strong>多个功能封装为多个组件</strong>，最后通过这些<strong>组件的结合形成完整的应用</strong></p>
<span id="more"></span>

<p><img data-src="/images/03-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20210920184832329.png" alt="组件示例"></p>
<center>图一</center>

<ul>
<li>对于图一左侧的页面，可以将其中<strong>不同的元素（功能）</strong>分为多个组件</li>
<li>右侧的绿色盒子即为<strong>多个组件之间的关系</strong><ul>
<li>兄弟组件</li>
<li>父子组件</li>
</ul>
</li>
</ul>
<h3 id="1-1-组件化规范"><a href="#1-1-组件化规范" class="headerlink" title="1.1 组件化规范"></a>1.1 组件化规范</h3><p>使用组件化思想进行开发如果没有统一的标准会产生许多问题：</p>
<ul>
<li>自定义组件不太容易（HTML,CSS,JS的组合）</li>
<li>多次使用组件可能导致冲突</li>
</ul>
<p><strong>组件化规范：Web Components</strong></p>
<ul>
<li><p><strong>Web Components</strong>通过创建<strong>封装好功能的定制元素</strong>解决组件化思想开发的问题</p>
</li>
<li><p>但是目前这个规范<strong>还没有被浏览器广泛的支持</strong></p>
</li>
</ul>
<p><strong>Vue的组件化</strong>已经部分实现了<strong>Web Components</strong>的规则</p>
<br>

<h2 id="2-组件注册"><a href="#2-组件注册" class="headerlink" title="2. 组件注册"></a>2. 组件注册</h2><p>使用Vue的API <code>Vue.component()</code>进行组件的<span style="color:red">全局注册</span></p>
<ul>
<li>第一个参数为<strong>组件名称</strong></li>
<li>第二个参数为一个<strong>配置对象</strong>（与创建Vue根实例的配置对象相同）<ul>
<li>对象中data属性为<strong>组件的数据</strong><ul>
<li>data属性的值为一个<strong>函数</strong>(为组件重用考虑，<strong>数据互不影响</strong>)，函数的返回值为一个对象，<strong>在该对象中定义组件数据</strong></li>
</ul>
</li>
<li>对象中template属性为<strong>组件模板内容</strong><ul>
<li>一个封装好功能的定制DOM元素</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img data-src="/images/03-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20210920190235276.png" alt="组件注册实例"></p>
<center>图二</center>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">template:&quot;<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;count++&#x27;</span>&gt;</span>点击了&#123;&#123;count&#125;&#125;次<span class="tag">&lt;/<span class="name">button</span>&gt;</span>&quot;,</span><br></pre></td></tr></table></figure>

<p>上述代码段即<strong>创建了一个封装好功能的定制DOM元素</strong><code>&lt;button-counter&gt;&lt;/button-counter&gt;</code>（组件使用的方式——<strong>组件名标签</strong>）</p>
<p>实际上<strong>Vue根实例也是一个组件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">        &lt;button-counter&gt;&lt;/button-counter&gt;</span><br><span class="line">        &lt;button-counter&gt;&lt;/button-counter&gt;</span><br><span class="line">        &lt;button-counter&gt;&lt;/button-counter&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>当Vue根实例绑定id为app的元素时，<code>&lt;button-counter&gt;</code>组件实际上是Vue根实例的<strong>子组件</strong></li>
</ul>
<h3 id="2-1-组件的使用"><a href="#2-1-组件的使用" class="headerlink" title="2.1 组件的使用"></a>2.1 组件的使用</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>对于图二注册的组件，直接<strong>在html文档中使用该组件名的标签（元素）即可</strong></p>
</li>
<li><p>组件的<strong>template模板</strong>会覆盖<code>&lt;button-counter&gt;&lt;/button-counter&gt;</code>标签</p>
</li>
</ul>
<p><img data-src="/images/03-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20210920190813282.png" alt="&lt;button-counter&gt;组件"></p>
<center>图三</center>

<p><img data-src="/images/03-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20210920193503791.png" alt="image-20210920193503791"></p>
<center>图四</center>

<ul>
<li>图三即为组件在页面中实际显示效果，每点击一次，按钮中的数字就会加一</li>
<li>count即为data中定义的组件数据</li>
</ul>
<h4 id="2-1-1-组件占位符标签"><a href="#2-1-1-组件占位符标签" class="headerlink" title="2.1.1 组件占位符标签"></a>2.1.1 组件占位符标签</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;&#x27;组件名&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用component标签并<strong>绑定属性is</strong>，is属性的值为组件名（字符串格式的组件名）</li>
<li>对应的组件template模板将<strong>覆盖component标签</strong></li>
</ul>
<h3 id="2-2-组件的重用"><a href="#2-2-组件的重用" class="headerlink" title="2.2 组件的重用"></a>2.2 组件的重用</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述组件<strong>使用了三次</strong>，在html文档中会<strong>创建三个元素</strong></p>
<p><u>并且上述三个组件的数据是独立的，它们都对count进行加一操作，但是各自的值互不影响</u></p>
<p>因为配置对象中的<strong>data属性为函数</strong>，所以每个组件实例的<strong>数据互相独立</strong></p>
<p><img data-src="/images/03-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20210920191643212.png" alt="image-20210920191643212"></p>
<center>图五</center>

<ul>
<li>图五中3个组件操作的均为count数据，但是三个组件中都使用独立的count数据，所以互不影响</li>
</ul>
<br>

<h3 id="2-3-组件注册注意事项"><a href="#2-3-组件注册注意事项" class="headerlink" title="2.3 组件注册注意事项"></a>2.3 组件注册注意事项</h3><h4 id="2-3-1-data的值为一个函数"><a href="#2-3-1-data的值为一个函数" class="headerlink" title="2.3.1 data的值为一个函数"></a>2.3.1 data的值为一个函数</h4><p>data的值为一个函数是为了<strong>保证每个组件的数据相互独立</strong></p>
<ul>
<li>相当于形成了<strong>闭包</strong></li>
</ul>
<p>注册组件时，当data的值不为函数时，浏览器会报错</p>
<h4 id="2-3-2-组件的模板内容template必须包含在一个根元素中"><a href="#2-3-2-组件的模板内容template必须包含在一个根元素中" class="headerlink" title="2.3.2 组件的模板内容template必须包含在一个根元素中"></a>2.3.2 组件的模板内容template必须包含在一个根元素中</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">template:<span class="string">&quot;&lt;button @click=&#x27;count++&#x27;&gt;点击了&#123;&#123;count&#125;&#125;次&lt;/button&gt;&lt;button&gt;测试&lt;/button&gt;&quot;</span>,</span><br></pre></td></tr></table></figure>

<p>如果template的内容如上，在浏览器会报错</p>
<ul>
<li>此时两个button为兄弟关系，没有包含在一个根元素中</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">template:<span class="string">&quot;&lt;div&gt;&lt;button @click=&#x27;count++&#x27;&gt;点击了&#123;&#123;count&#125;&#125;次&lt;/button&gt;&lt;button&gt;测试&lt;/button&gt;&lt;/div&gt;&quot;</span>,</span><br></pre></td></tr></table></figure>

<ul>
<li>此时使用div标签将两个button包裹，此时模板内容包含在一个根元素（div）中，不会报错</li>
</ul>
<br>

<p>对于Vue根实例来说，它的模板内容也是包含在一个根元素(<code>id=app</code>)中</p>
<p><img data-src="/images/03-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20210920193257616.png" alt="image-20210920193257616"></p>
<center>图六</center>

<ul>
<li>图六红框的el属性即指示Vue实例绑定的根元素，<strong>该Vue根实例模板内容都要写在该id值为app的根元素内部</strong></li>
</ul>
<br>

<h4 id="2-3-3-组件的模板内容可以使用模板字符串"><a href="#2-3-3-组件的模板内容可以使用模板字符串" class="headerlink" title="2.3.3 组件的模板内容可以使用模板字符串"></a>2.3.3 组件的模板内容可以使用模板字符串</h4><p>当template字段的内容过多时，一行长代码会降低代码的可读性</p>
<p>使用ES6的模板字符串可以<strong>实现字符串的换行</strong>，提高代码可读性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">template:<span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">                     &lt;button @click=&#x27;count++&#x27;&gt;点击了&#123;&#123;count&#125;&#125;次&lt;/button&gt;</span></span><br><span class="line"><span class="string">                     &lt;button&gt;测试&lt;/button&gt;</span></span><br><span class="line"><span class="string">                   &lt;/div&gt;`</span>,</span><br></pre></td></tr></table></figure>

<h4 id="2-3-4-组件template模板绑定事件时可以使用处理函数"><a href="#2-3-4-组件template模板绑定事件时可以使用处理函数" class="headerlink" title="2.3.4 组件template模板绑定事件时可以使用处理函数"></a>2.3.4 组件template模板绑定事件时可以使用处理函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&#x27;count++&#x27;</span>&gt;点击了&#123;&#123;count&#125;&#125;次&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>上述click点击事件的处理函数直接<strong>使用表达式替代</strong></p>
<ul>
<li>但处理内容多时，使用处理函数是更好的方式</li>
</ul>
<p>组件注册时，第二个参数中除了data和template字段外，还可以使用methods字段定义方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">template:<span class="string">&quot;&lt;button @click=&#x27;add&#x27;&gt;点击了&#123;&#123;count&#125;&#125;次&lt;/button&gt;&quot;</span>,</span><br><span class="line">methods:&#123;</span><br><span class="line">               add:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                   <span class="built_in">this</span>.count++</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述代码就是用了methods字段中定义的add函数作为处理函数</li>
<li>注意在函数中使用组件数据时加上this指向</li>
</ul>
<br>

<h4 id="2-3-5-组件命名方式"><a href="#2-3-5-组件命名方式" class="headerlink" title="2.3.5 组件命名方式"></a>2.3.5 组件命名方式</h4><p>组件的命名方式有两种：</p>
<ul>
<li><strong>驼峰式</strong>：例如<code>HelloWorld</code></li>
<li><strong>短横线方式</strong>：例如<code>hello-world</code></li>
</ul>
<p><strong>驼峰式</strong>命名的组件直接在<strong>html文档</strong>中使用会报错，例如<code>&lt;helloWorld&gt;&lt;/helloWorld&gt;</code>会报错。</p>
<p><strong>短横线</strong>方式既可以在HTML文档中使用，也可以在组件template模板字符串中使用(作为嵌套组件使用)</p>
<ul>
<li>推荐组件都以<strong>短横线</strong>的方式命名</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HelloWorld组件</span></span><br><span class="line">      Vue.component(<span class="string">&#x27;HelloWorld&#x27;</span>,&#123;</span><br><span class="line">          data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> &#123;</span><br><span class="line">                  msg:<span class="string">&#x27;helloworld&#x27;</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          template:<span class="string">`&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">//button-counter组件</span></span><br><span class="line">      Vue.component(<span class="string">&#x27;button-counter&#x27;</span>,&#123;</span><br><span class="line">          data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> &#123;</span><br><span class="line">                  count:<span class="number">0</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          template:<span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">                      &lt;button @click=&#x27;count++&#x27;&gt;点击了&#123;&#123;count&#125;&#125;次&lt;/button&gt;</span></span><br><span class="line"><span class="string">                      &lt;button&gt;测试&lt;/button&gt;</span></span><br><span class="line"><span class="string">                      &lt;HelloWorld&gt;&lt;/HelloWorld&gt;</span></span><br><span class="line"><span class="string">                    &lt;/div&gt;`</span></span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述代码中，<code>button-counter</code>组件注册中的template字段使用了<code>HelloWorld</code>组件</p>
<ul>
<li><p>因为<code>HelloWorld</code>组件作为<strong>全局组件定义</strong>，所以可以在其他组件中使用</p>
</li>
<li><p>此时驼峰命名的<code>HelloWorld</code>组件在模板内容字符串中使用，可以正常使用</p>
</li>
</ul>
</li>
</ul>
<p><img data-src="/images/03-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20210920195440768.png" alt="image-20210920195440768"></p>
<center>图七</center>

<br>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 报错 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;HelloWorld&gt;&lt;/HelloWorld&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 正常显示 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hello-world</span>&gt;</span><span class="tag">&lt;/<span class="name">hello-world</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>当直接在HTML文档中使用驼峰命名的组件时会<strong>报错</strong></p>
</li>
<li><p>使用短横线命名的组件<strong>正常</strong></p>
<ul>
<li><p>组件<strong>以驼峰命名方式注册时</strong>，在<strong>HTML文档中也可以用短横线方式使用</strong></p>
</li>
<li><p>注册时名为<code>HelloWorld</code>,使用时<code>&lt;hello-world&gt;</code>也可以匹配到<code>HelloWorld</code>组件</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-4-局部组件注册"><a href="#2-4-局部组件注册" class="headerlink" title="2.4 局部组件注册"></a>2.4 局部组件注册</h3><p>组件注册分为局部组件和全局组件，上面使用<code>Vue.component()</code>方法注册的为全局组件</p>
<br>

<p>局部组件在另一个组件的<code>components</code>字段中注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;  </span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;&#125;,</span><br><span class="line"><span class="comment">//注册局部组件</span></span><br><span class="line">components:&#123;</span><br><span class="line">                <span class="string">&#x27;组件名&#x27;</span>:<span class="string">&#x27;组件配置对象&#x27;</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>组件名即为短横线方式的组件名</li>
<li>组件配置对象与<code>Vue.component()</code>全局注册方法的<strong>第二个参数相同</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">        &lt;hello-world&gt;&lt;/hello-world&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组件配置对象</span></span><br><span class="line"><span class="keyword">var</span> HelloWorld = &#123;</span><br><span class="line">            template:<span class="string">`&lt;div&gt;test&lt;/div&gt;`</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">            data:&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;,</span><br><span class="line">    		<span class="comment">//定义局部组件</span></span><br><span class="line">            components:&#123;</span><br><span class="line">                <span class="comment">//组件名：组件配置对象</span></span><br><span class="line">                <span class="string">&#x27;hello-world&#x27;</span>:HelloWorld</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>当前名为<code>hello-world</code>的组件注册在<strong>组件vm（Vue根实例）</strong>中，此时<code>hello-world</code>组件<strong>只能在vm组件中使用</strong></li>
</ul>
<br>

<ul>
<li>当<code>hello-world</code>组件的<strong>父组件非vm时报错</strong>（超出局部组件使用范围）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;test-com&#x27;</span>,&#123;</span><br><span class="line">           <span class="comment">//hello-world作为test-com的子组件使用报错</span></span><br><span class="line">           template:<span class="string">`&lt;div&gt;&lt;hello-world&gt;&lt;/hello-world&gt;&lt;/div&gt;`</span></span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>上述代码<code>hello-world</code>局部组件超出使用范围（作为全局组件test-com的子组件使用）报错</li>
</ul>
<p><img data-src="/images/03-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20210920204314281.png" alt="image-20210920204314281"></p>
<center>图八</center>

<h2 id="3-Vue调试工具"><a href="#3-Vue调试工具" class="headerlink" title="3. Vue调试工具"></a>3. Vue调试工具</h2><p>Vue组件使用后在浏览器控制台<strong>默认</strong>只能看到<strong>最后的结果</strong>（原生的DOM元素），不利于调试</p>
<p>在Chrome网上应用商店下载<code>Vue.js devtools</code>扩展程序</p>
<p><img data-src="/images/03-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20210920213313849.png" alt="image-20210920213313849"></p>
<center>图九</center>

<p><img data-src="/images/03-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20210920213358876.png" alt="image-20210920213358876"></p>
<center>图十</center>

<ul>
<li>在详情中开启红框所示选项</li>
</ul>
<p><img data-src="/images/03-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20210920213501628.png" alt="image-20210920213501628"></p>
<center>图十一</center>

<ul>
<li>现在浏览器控制台出现Vue选项，选项中<strong>清晰的列出了Vue组件的层次结构</strong></li>
</ul>
<br>

<h2 id="4-组件间数据传递"><a href="#4-组件间数据传递" class="headerlink" title="4. 组件间数据传递"></a>4. 组件间数据传递</h2><h3 id="4-1-父组件向子组件传递数据"><a href="#4-1-父组件向子组件传递数据" class="headerlink" title="4.1 父组件向子组件传递数据"></a>4.1 父组件向子组件传递数据</h3><ol>
<li>父组件通过<strong>在子组件的HTML标签上设置属性</strong>进行数据传递（设置多个属性则传递多条数据）</li>
<li>子组件通过<code>props</code>字段接收父组件传递的数据<ul>
<li><code>props</code>字段<strong>值为一个数组</strong>，其中元素为<strong>父组件设置的属性名</strong></li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">        &lt;item-menu title=<span class="string">&#x27;父组件传递给子组件数据&#x27;</span> :name=<span class="string">&#x27;name&#x27;</span>&gt;&lt;/item-menu&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">&#x27;item-menu&#x27;</span>,&#123;</span><br><span class="line">            props:[<span class="string">&#x27;title&#x27;</span>,<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">            data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    msg:<span class="string">&#x27;子组件本身数据&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            template:<span class="string">`&lt;div&gt;&#123;&#123;msg + &#x27;---&#x27; + title + &#x27;---&#x27; + name&#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">            data:&#123;</span><br><span class="line">                name:<span class="string">&#x27;父组件name数据&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>item-menu</code>作为vm组件的子组件</p>
</li>
<li><p>```<br><item-menu title='父组件传递给子组件数据' :name='name'></item-menu></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - &#96;title&#x3D;&#39;父组件传递给子组件数据&#39;&#96;和&#96;:name&#x3D;&#39;name&#39;&#96;即为vm组件向子组件传递的数据</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;js</span><br><span class="line">  props:[&#39;title&#39;,&#39;name&#39;]</span><br><span class="line">  template:&#96;&lt;div&gt;&#123;&#123;msg + &#39;---&#39; + title + &#39;---&#39; + name&#125;&#125;&lt;&#x2F;div&gt;&#96;</span><br></pre></td></tr></table></figure>

<ul>
<li>子组件通过<code>props</code>字段接收数据后在template使用</li>
</ul>
</li>
</ul>
<p><img data-src="/images/03-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20210920215504245.png" alt="image-20210920215504245"></p>
<center>图十二</center>

<h4 id="4-1-1-传递静态数据"><a href="#4-1-1-传递静态数据" class="headerlink" title="4.1.1 传递静态数据"></a>4.1.1 传递静态数据</h4><p><code>title=&#39;父组件传递给子组件数据&#39;</code></p>
<h4 id="4-1-2-传递动态数据"><a href="#4-1-2-传递动态数据" class="headerlink" title="4.1.2 传递动态数据"></a>4.1.2 传递动态数据</h4><p><code>:name=&#39;name&#39;</code></p>
<ul>
<li><p>通过给子组件HTML标签进行<strong>属性绑定</strong>动态传递数据</p>
</li>
<li><p>name即为vm组件的<strong>模板数据</strong></p>
<ul>
<li>```js<pre><code>    data:&#123;
            name:&#39;父组件name数据&#39;
        &#125;
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">#### 4.1.3 props字段命名规则</span><br><span class="line"></span><br><span class="line">1. 当**子组件标签在HTML文档中**，此时向子组件传递数据时**属性使用短横线命名方式**，子组件**仍使用驼峰接收**数据</span><br><span class="line">   - 浏览器**对于属性名大小写并不区分**</span><br><span class="line"></span><br><span class="line">2. 当子组件标签**在template字段的字符串中使用时**，使用驼峰命名没有影响</span><br><span class="line">   - 字符串中区分属性名大小写</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;u&gt;子组件标签在HTML文档中&lt;&#x2F;u&gt;</span><br><span class="line"></span><br><span class="line">- 向子组件传递数据时属性**使用短横线命名方式**</span><br><span class="line">- 子组件**接收时仍使用驼峰命名接收**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line"> &lt;!-- 子组件标签在HTML文档时使用驼峰命名属性名容易导致错误 --&gt;</span><br><span class="line">&lt;item-menu titleOne&#x3D;&#39;父组件传递给子组件数据&#39;&gt;&lt;&#x2F;item-menu&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;接收驼峰命名的属性</span><br><span class="line">props:[&#39;titleOne&#39;],</span><br><span class="line">&#x2F;&#x2F;使用时titleOne为undefined，浏览器显示警告</span><br><span class="line">template:&#96;&lt;div&gt;&#123;&#123;msg + &#39;---&#39; + titleOne &#125;&#125;&lt;&#x2F;div&gt;&#96;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><img data-src="/images/03-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20210920221950937.png" alt="image-20210920221950937"></p>
<center>图十三</center>

<ul>
<li>因为浏览器不区分标签的大小写，<code>titleOne</code>的属性名被转换为<code>titleone</code>，接收出错</li>
</ul>
<br>

<p><u>子组件标签在template字段字符串中</u></p>
<ul>
<li>使用驼峰命名属性没有影响</li>
</ul>
<br>

<h4 id="4-1-4-props字段属性值类型"><a href="#4-1-4-props字段属性值类型" class="headerlink" title="4.1.4 props字段属性值类型"></a>4.1.4 props字段属性值类型</h4><p>父组件向子组件传递的<strong>数据类型有</strong>：</p>
<ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Array</li>
<li>Object</li>
</ul>
<p>当父组件向子组件传递数据时<strong>不使用属性绑定</strong>，则传递的<strong>任何数据都被接受为字符串String</strong></p>
<p><strong>使用属性绑定</strong>，传递的数据<strong>保持原有类型</strong></p>
<br>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;item-menu title-msg=<span class="string">&#x27;&#123;name:&quot;yang&quot;&#125;&#x27;</span>&gt;&lt;/item-menu&gt;</span><br><span class="line">template:<span class="string">`&lt;div&gt;&#123;&#123;msg + &#x27;---&#x27; + typeof titleMsg &#125;&#125;&lt;/div&gt;`</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不使用属性绑定，传递的数据<code>titleMsg</code>被接受为字符串String</li>
</ul>
<br>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;item-menu :title-msg=<span class="string">&#x27;title&#x27;</span>&gt;&lt;/item-menu&gt;</span><br><span class="line">template:<span class="string">`&lt;div&gt;&#123;&#123;msg + &#x27;---&#x27; + typeof titleMsg &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line"> <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">            data:&#123;</span><br><span class="line">                title:&#123;<span class="attr">name</span>:<span class="string">&quot;yang&quot;</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用属性绑定，<code>titleMsg</code>接受后仍为对象类型Object<ul>
<li><code>title</code>为vm组件的模板数据</li>
</ul>
</li>
</ul>
<br>

<h3 id="4-2-子组件向父组件传递数据"><a href="#4-2-子组件向父组件传递数据" class="headerlink" title="4.2 子组件向父组件传递数据"></a>4.2 子组件向父组件传递数据</h3><p>props字段的原则为<strong>单向数据传递</strong>，只能接受父组件给子组件传递的数据</p>
<br>

<h4 id="4-2-1-使用自定义事件"><a href="#4-2-1-使用自定义事件" class="headerlink" title="4.2.1 使用自定义事件"></a>4.2.1 使用自定义事件</h4><ul>
<li>子组件<strong>触发自定义事件</strong><ul>
<li><code>@click=&quot;$emit(&#39;change-font&#39;)&quot;</code> 点击后触发change-font事件</li>
<li><code>$emit()</code>触发自定义事件<ul>
<li><strong>第一个参数即为事件名</strong></li>
</ul>
</li>
</ul>
</li>
<li>父组件监听该<strong>自定义事件</strong>，使用处理函数获取子组件传递的值<ul>
<li>监听自定义事件<code>@change-font=&#39;change&#39;</code></li>
<li><code>change-font</code>事件触发时执行<code>change</code>处理函数</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span> style=<span class="string">&quot;font-size: 0px;&quot;</span>&gt;</span><br><span class="line">        &lt;div :style=<span class="string">&quot;&#123;fontSize:fontSize + &#x27;px&#x27;&#125;&quot;</span>&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">		&lt;!-- 监听自定义事件change-font的发生 --&gt;</span><br><span class="line">        &lt;item-menu :title-msg=<span class="string">&#x27;msg&#x27;</span> @change-font=<span class="string">&#x27;change&#x27;</span>&gt;&lt;/item-menu&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Vue.component(<span class="string">&#x27;item-menu&#x27;</span>,&#123;</span><br><span class="line">            props:[<span class="string">&#x27;titleMsg&#x27;</span>],</span><br><span class="line">            data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    msg:<span class="string">&#x27;子组件本身数据&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            template:<span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">                        &#123;&#123;msg&#125;&#125;</span></span><br><span class="line"><span class="string">						//设定自定义事件change-font</span></span><br><span class="line"><span class="string">                        &lt;button @click=&quot;$emit(&#x27;change-font&#x27;)&quot;&gt;修改父组件fontSize&lt;/button&gt;</span></span><br><span class="line"><span class="string">                    &lt;/div&gt;`</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line">                change:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="comment">//字体增大</span></span><br><span class="line">                    vm.fontSize+=<span class="number">5</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每单击一次按钮，父组件第一个div中的字体就增大5px</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>HTML标签的style属性<strong>进行属性绑定时</strong>，值采取如下格式（对象）</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">:style=&quot;&#123;fontSize:fontSize + &#x27;px&#x27;&#125;&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>font-size采取驼峰表示法为fontSize</li>
</ul>
<h4 id="4-2-2-子组件使用自定义事件传递数据"><a href="#4-2-2-子组件使用自定义事件传递数据" class="headerlink" title="4.2.2 子组件使用自定义事件传递数据"></a>4.2.2 子组件使用自定义事件传递数据</h4><ul>
<li><code>$emit()</code>方法的<strong>第二个参数</strong>即为<strong>子组件向父组件传递的数据</strong>(Number,String,Object等)</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- $emit()第二个参数num即为子组件传递的数据--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$emit(&#x27;change-font&#x27;,num)&quot;</span>&gt;</span>修改父组件fontSize<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 父组件使用事件处理函数参数的形式接受子组件数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item-menu</span> <span class="attr">:title-msg</span>=<span class="string">&#x27;msg&#x27;</span> @<span class="attr">change-font</span>=<span class="string">&#x27;change($event)&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">item-menu</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>@change-font=&#39;change($event)</code><ul>
<li><code>$event</code>为固定写法(<strong>只能接收一个参数</strong>)</li>
<li><code>$event</code>即为子组件传递来的数据</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">change:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                   vm.fontSize+=val</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接受子组件传递的数据后修改父组件fontSize数据值</li>
</ul>
<br>

<h3 id="4-3-兄弟组件间传值"><a href="#4-3-兄弟组件间传值" class="headerlink" title="4.3 兄弟组件间传值"></a>4.3 兄弟组件间传值</h3><p>使用<strong>事件中心</strong>（一个Vue实例）的方式传值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//事件中心</span></span><br><span class="line"><span class="keyword">var</span> hub = <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure>

<ul>
<li>事件中心实际就是一个<strong>全局的Vue实例组件</strong></li>
</ul>
<p><img data-src="/images/03-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20210922103557235.png" alt="image-20210922103557235"></p>
<center>图十四</center>

<ul>
<li><p>通过<span style="color:red;">事件中心hub</span>进行<strong>自定义事件</strong>的监听和触发</p>
</li>
<li><p><strong>监听</strong>($on)：在接收数据的组件的<code>mounted</code>函数中使用</p>
<ul>
<li>```js<br>//在处理函数中接受兄弟组件传递的值<br>$on(‘自定义事件’,’处理函数’)        //注册（监听）事件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **触发**($emit)：在传递数据的组件中调用(通过&#96;@click&#96;的回调调用等)</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;</span><br><span class="line">    $emit(&#39;自定义事件&#39;,&#39;传递的值&#39;)	&#x2F;&#x2F;触发自定义事件</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<br>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">template:<span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">                      &#123;&#123;num&#125;&#125;</span></span><br><span class="line"><span class="string">                      &lt;button @click=&#x27;handle&#x27;&gt;点击&lt;/button&gt;</span></span><br><span class="line"><span class="string">                  &lt;/div&gt;`</span>,</span><br><span class="line">          methods:&#123;</span><br><span class="line">              handle:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                  <span class="comment">//点击时触发自定义事件并传值</span></span><br><span class="line">                  hub.$emit(<span class="string">&#x27;two-change&#x27;</span>,<span class="number">2</span>)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          mounted:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          	<span class="comment">//初始化完成后开始监听事件</span></span><br><span class="line">              hub.$on(<span class="string">&#x27;one-change&#x27;</span>,<span class="function">(<span class="params">val</span>)=&gt;</span>&#123;</span><br><span class="line">                  <span class="built_in">this</span>.num += val</span><br><span class="line">              &#125;)</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述代码为兄弟组件<code>item-one</code>的部分代码，在被点击时触发向<code>item-two</code>兄弟组件传值的事件<code>two-change</code></li>
<li>并在自己的mounted函数中监听<code>item-two</code>兄弟组件触发的自定义事件<code>one-change</code></li>
</ul>
<br>

<p>自定义事件通过<code>$off(&#39;自定义事件名&#39;)</code>进行销毁</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">des:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                  hub.$off(<span class="string">&#x27;two-change&#x27;</span>)</span><br><span class="line">                  hub.$off(<span class="string">&#x27;one-change&#x27;</span>)</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行上述函数即销毁了两个传值的自定义函数</li>
</ul>
<br>

<h3 id="4-4-组件插槽"><a href="#4-4-组件插槽" class="headerlink" title="4.4 组件插槽"></a>4.4 组件插槽</h3><p>组件插槽(<code>slot</code>)可以<strong>接收组件使用时传递来的值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    	<span class="comment">//使用时传递的值 &#x27;一个错误&#x27;</span></span><br><span class="line">        &lt;alert-box&gt;一个错误&lt;/alert-box&gt;</span><br><span class="line">        &lt;alert-box&gt;一个警告&lt;/alert-box&gt;</span><br><span class="line">        &lt;alert-box&gt;&lt;/alert-box&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">&#x27;alert-box&#x27;</span>,&#123;</span><br><span class="line">    		<span class="comment">//slot即为插槽 &#x27;一个错误&#x27;等内容会覆盖对应的slot插槽</span></span><br><span class="line">            template:<span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">                        &lt;strong&gt;Error:&lt;/strong&gt;</span></span><br><span class="line"><span class="string">                        &lt;slot&gt;默认内容&lt;/slot&gt;</span></span><br><span class="line"><span class="string">                    &lt;/div&gt;`</span>,</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用子组件时，在<strong>子组件标签中填充内容</strong></li>
<li>填充的内容会被<strong>子组件模板中的固定标签slot接受</strong>（覆盖slot标签）</li>
<li>slot标签就称为<strong>组件插槽</strong>，可以接受向子组件标签填充的内容<ul>
<li>当<strong>有填充内容</strong>时，slot标签中<strong>原本的内容被覆盖</strong></li>
<li>若<strong>没有填充内容</strong>，则<strong>显示slot标签原本的内容</strong></li>
</ul>
</li>
</ul>
<p><img data-src="/images/03-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20210922105448642.png" alt="image-20210922105448642"></p>
<center>图十五</center>

<h4 id="4-4-1-具名插槽用法"><a href="#4-4-1-具名插槽用法" class="headerlink" title="4.4.1 具名插槽用法"></a>4.4.1 具名插槽用法</h4><p>向子组件填充插槽内容时，可以<strong>使用slot属性指定插入哪个插槽中</strong></p>
<p>子组件给slot标签设定name属性可以<strong>定义多个具名插槽</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &lt;alert-box&gt;</span><br><span class="line">            &lt;p slot=<span class="string">&#x27;header&#x27;</span>&gt;header&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;main&lt;/p&gt;</span><br><span class="line">            &lt;p slot=<span class="string">&#x27;footer&#x27;</span>&gt;footer&lt;/p&gt;</span><br><span class="line">&lt;/alert-box&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		template:<span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">                        &lt;header&gt;</span></span><br><span class="line"><span class="string">                            &lt;slot name=&#x27;header&#x27;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">                        &lt;/header&gt;</span></span><br><span class="line"><span class="string">                        &lt;main&gt;</span></span><br><span class="line"><span class="string">                            &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">                        &lt;/main&gt;</span></span><br><span class="line"><span class="string">                        &lt;footer&gt;    </span></span><br><span class="line"><span class="string">                            &lt;slot name=&#x27;footer&#x27;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">                        &lt;/footer&gt;</span></span><br><span class="line"><span class="string">                    &lt;/div&gt;`</span>,</span><br></pre></td></tr></table></figure>

<p><code>&lt;p slot=&#39;header&#39;&gt;header&lt;/p&gt;</code>即用这个p标签<strong>覆盖name为header的slot插槽</strong></p>
<p>当填充插槽时<strong>不使用slot属性指定名称</strong>，则<strong>覆盖默认的slot标签</strong></p>
<p><img data-src="/images/03-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20210922111030038.png" alt="image-20210922111030038"></p>
<center>图十六</center>

<br>

<p>使用<code>template</code>标签<strong>包裹填充内容</strong>可以<strong>向一个插槽填充多条内容</strong></p>
<p><span style="color:red">注意：</span>使用template时，<strong>即使template内容为空</strong>，<strong>slot插槽也不会显示默认内容(此时以空白填充slot)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;alert-box&gt;</span><br><span class="line">          &lt;template slot=<span class="string">&quot;header&quot;</span>&gt;</span><br><span class="line">              &lt;p&gt;header1&lt;/p&gt;</span><br><span class="line">              &lt;p&gt;header2&lt;/p&gt;</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">          </span><br><span class="line">          &lt;p&gt;main&lt;/p&gt;</span><br><span class="line">          &lt;p slot=<span class="string">&#x27;footer&#x27;</span>&gt;footer&lt;/p&gt;</span><br><span class="line">      &lt;/alert-box&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;template slot=&quot;header&quot;&gt;</code> ：将此标签中的内容填充到name为header的插槽中</p>
<ul>
<li><strong>一次填充两个p标签</strong>到name为header的插槽中</li>
</ul>
<p><img data-src="/images/03-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20210922111546791.png" alt="image-20210922111546791"></p>
<center>图十七</center>

<br>

<h4 id="4-4-2-作用域插槽"><a href="#4-4-2-作用域插槽" class="headerlink" title="4.4.2 作用域插槽"></a>4.4.2 作用域插槽</h4><p><strong>插槽工作原理：</strong>将<code>template</code>的内容插入到<code>slot</code>处 (使用<code>template</code>的内容来覆盖<code>slot</code>)</p>
<p><strong>作用域插槽：</strong><code>slot</code>可以向<code>template</code>传值(<code>slot</code>标签通过属性绑定传值，<code>template</code>标签通过<code>slot-scope</code>接收)</p>
<ul>
<li>目的：<span style="color:red;">根据slot插槽传递的值自定义template填充内容</span></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alert-box</span> <span class="attr">:list</span>=<span class="string">&#x27;list&#x27;</span>&gt;</span></span><br><span class="line">    		//slot-scope接收slot传递的对象</span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&#x27;slotinfo&#x27;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 向传递info.id = 1的slot插槽填充strong标签 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">strong</span> <span class="attr">v-if</span>=<span class="string">&#x27;slotinfo.info.id == 1&#x27;</span> <span class="attr">class</span>=<span class="string">&quot;current&quot;</span>&gt;</span>&#123;&#123;slotinfo.info.name&#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 向其他slot插槽填充span标签 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123;slotinfo.info.name&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">alert-box</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//子组件模板</span><br><span class="line">template:`<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span> <span class="attr">:key</span>=<span class="string">&#x27;item.id&#x27;</span> <span class="attr">v-for</span>=<span class="string">&#x27;item in list&#x27;</span>&gt;</span></span><br><span class="line">                    //向template传递一个名为info的值 所有值被统一包裹为对象后传递</span><br><span class="line">					<span class="tag">&lt;<span class="name">slot</span> <span class="attr">:info</span>=<span class="string">&#x27;item&#x27;</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span><br><span class="line"></span><br><span class="line">	//父组件数据</span><br><span class="line">	data:&#123;</span><br><span class="line">                list:[&#123;</span><br><span class="line">                    id:1,</span><br><span class="line">                    name:&#x27;apple&#x27;</span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    id:2,</span><br><span class="line">                    name:&#x27;pear&#x27;</span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    id:3,</span><br><span class="line">                    name:&#x27;orange&#x27;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;,</span><br></pre></td></tr></table></figure>

<p><code>&lt;slot :info=&#39;item&#39;&gt;&#123;&#123;item.name&#125;&#125;&lt;/slot&gt;</code></p>
<ul>
<li>slot插槽将<span style="color:red"><code>&#123;info:item&#125;</code></span>传递给<code>template</code></li>
</ul>
<p><code>&lt;template slot-scope=&#39;slotinfo&#39;&gt;</code></p>
<ul>
<li>template接收传递的值，<code>slotinfo = &#123;info:item&#125;</code></li>
</ul>
<br>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&#x27;slotinfo&#x27;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">strong</span> <span class="attr">v-if</span>=<span class="string">&#x27;slotinfo.info.id == 1&#x27;</span> <span class="attr">class</span>=<span class="string">&quot;current&quot;</span>&gt;</span></span><br><span class="line">                    &#123;&#123;slotinfo.info.name&#125;&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>父组件通过template标签的 <strong>固定属性</strong><code>slot-scope</code>接受<code>slot</code>传递的值</p>
</li>
<li><p>上述<code>template</code>中对于<code>slot</code>传递来的item数据</p>
<ul>
<li><p>若<code>item.id === 1</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 向传递info.id = 1的slot插槽填充strong标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span> <span class="attr">class</span>=<span class="string">&quot;current&quot;</span>&gt;</span></span><br><span class="line">	&#123;&#123;slotinfo.info.name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>则上述标签覆盖到slot插槽处</p>
</li>
<li><p>若<code>item.id !== 1</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 向其他slot插槽填充span标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123;slotinfo.info.name&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将上述标签覆盖到slot处</p>
</li>
</ul>
<br></li>
</ul>
<p><img data-src="/images/03-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/image-20220423230723538.png" alt="image-20220423230723538"></p>
<center>图十八</center>

<ul>
<li>第一个<code>li</code>中的插槽由<code>template</code>内容覆盖，<strong>字体加粗颜色为红色</strong>。</li>
<li>后续<code>li</code>中的插槽显示<code>item.name</code></li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>05-Vue前后端交互</title>
    <url>/2021/09/20/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<h1 id="Vue前后端交互"><a href="#Vue前后端交互" class="headerlink" title="Vue前后端交互"></a>Vue前后端交互</h1><p>浏览器通过<strong>调用后台接口获取数据</strong>后<strong>在前端进行渲染</strong></p>
<h2 id="1-接口调用方式"><a href="#1-接口调用方式" class="headerlink" title="1. 接口调用方式"></a>1. 接口调用方式</h2><p>向服务器<strong>发起请求的方式</strong></p>
<ul>
<li>原生<code>ajax</code></li>
<li><code>jQuery</code>的<code>ajax</code></li>
<li><code>fetch</code>：标准化组织制定的新规则，可以理解为<code>ajax</code>的升级版</li>
<li><code>axios</code>：第三方库，基于<code>ajax</code>，更加方便的调用接口</li>
</ul>
<span id="more"></span>

<p><img data-src="/images/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210923153138393.png" alt="image-20210923153138393"></p>
<center>图一</center>

<h2 id="2-URL地址格式"><a href="#2-URL地址格式" class="headerlink" title="2. URL地址格式"></a>2. URL地址格式</h2><p><img data-src="/images/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210923153350428.png" alt="image-20210923153350428"></p>
<center>图二</center>

<p><img data-src="/images/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210923153441636.png" alt="image-20210923153441636"></p>
<center>图三</center>

<ul>
<li>Restful形式的URL<strong>与请求方式密切相关</strong>（同样的URL，不同的请求方式，是两个请求）</li>
<li>Restful形式的URL，请求参数<strong>直接以’/‘分隔后加在url末尾</strong></li>
<li><code>nodejs</code>在后台接收 Restful URL的请求时，用<code>req.params.&#39;属性名&#39;</code>获取请求参数</li>
</ul>
<h2 id="3-Promise对象"><a href="#3-Promise对象" class="headerlink" title="3. Promise对象"></a>3. Promise对象</h2><p>多次异步编程，<strong>不能保证结果返回的顺序</strong></p>
<p>如果要求顺序，就要使用<strong>回调函数嵌套的方式</strong></p>
<p>这种方式嵌套层数多时，会导致代码可读性下降，维护困难，造成<strong>回调地狱的问题</strong></p>
<br>

<p><strong>Promise的提出就是为了解决上述回调地狱问题</strong></p>
<ul>
<li><p>Promise是异步编程的一种解决方案</p>
</li>
<li><p>Promise是一个对象，有简洁的API来控制异步操作，获取结果和处理错误等</p>
</li>
</ul>
<h2 id="4-基于Promise对象处理Ajax请求"><a href="#4-基于Promise对象处理Ajax请求" class="headerlink" title="4. 基于Promise对象处理Ajax请求"></a>4. 基于Promise对象处理Ajax请求</h2><p>原本的Ajax请求是异步操作，若需要多个异步AJax请求顺序返回结果，使用回调函数嵌套会<strong>引起回调地狱问题</strong></p>
<p>使用Promise对象包裹异步Ajax请求，使用Promise的<code>.then</code>方法按顺序发起ajax请求</p>
<ul>
<li>这样在多个ajax请求需要顺序执行时，可以<strong>链式调用.then方法</strong>，避免了回调地狱，提升程序可读性</li>
</ul>
<br>

<h3 id="4-1-promise对象处理一个ajax请求"><a href="#4-1-promise对象处理一个ajax请求" class="headerlink" title="4.1 promise对象处理一个ajax请求"></a>4.1 promise对象处理一个ajax请求</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseAjax</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//返回一个Promise对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//在promise对象中进行异步AJAX请求</span></span><br><span class="line">                <span class="keyword">var</span> XHR = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">                XHR.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(XHR.readyState != <span class="number">4</span>) <span class="keyword">return</span></span><br><span class="line">                    <span class="keyword">if</span>(XHR.status == <span class="number">200</span>)&#123;</span><br><span class="line">                        resolve(XHR.responseText)	<span class="comment">//成功</span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        reject(<span class="string">&#x27;出错&#x27;</span>)	<span class="comment">//失败</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                XHR.open(<span class="string">&#x27;get&#x27;</span>,url)</span><br><span class="line">                XHR.send(<span class="literal">null</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过promise对象的.then方法处理异步AJAX请求的结果或者错误信息</span></span><br><span class="line">        promiseAjax(<span class="string">&#x27;http://localhost/data&#x27;</span>)</span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);</span><br><span class="line">            &#125;,<span class="function">(<span class="params">info</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(info);</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>promiseAjax函数返回一个promise对象，</p>
<ul>
<li><p>该promise对象<strong>状态变为成功时</strong>（调用resolve函数），成功回调函数<strong>接受服务器端传来的数据并处理</strong></p>
</li>
<li><p>该promise对象<strong>状态变为失败时</strong>（调用reject函数），失败回调函数<strong>接受错误信息并处理</strong></p>
</li>
</ul>
</li>
<li><p><code>.then</code>方法的第一个参数为成功回调函数，第二个参数为失败回调函数</p>
</li>
</ul>
<p><img data-src="/images/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210924111144099.png" alt="image-20210924111144099"></p>
<center>图四</center>

<ul>
<li>图四即为服务器端将状态码手动设置为404时，<ul>
<li>promise对象调用<code>reject(&#39;错误&#39;)</code>后<strong>经错误回调函数处理后的结果</strong></li>
</ul>
</li>
</ul>
<h3 id="4-2-promise对象处理多个AJAX请求顺序返回结果"><a href="#4-2-promise对象处理多个AJAX请求顺序返回结果" class="headerlink" title="4.2 promise对象处理多个AJAX请求顺序返回结果"></a>4.2 promise对象处理多个AJAX请求顺序返回结果</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promiseAjax(<span class="string">&#x27;http://localhost/data&#x27;</span>)</span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);	<span class="comment">//hello data</span></span><br><span class="line">                <span class="keyword">return</span> promiseAjax(<span class="string">&#x27;http://localhost/data1&#x27;</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">			<span class="comment">//对上一个.then方法返回的promise对象调用.then方法</span></span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);	<span class="comment">//hello data1</span></span><br><span class="line">                <span class="keyword">return</span> promiseAjax(<span class="string">&#x27;http://localhost/data2&#x27;</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);	<span class="comment">//hello data2</span></span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此处删除了错误回调函数方便观察</p>
</li>
<li><p>在上一个<code>.then</code>方法的成功回调函数中<strong>再次调用promiseAjax函数并将其返回值return</strong></p>
</li>
<li><p>下一个<code>.then</code>方法对前面返回的promise对象调用(处理第二个ajax请求的结果)</p>
</li>
<li><p>这样通过<strong>3个.then方法链式调用</strong>就完成了三个ajax请求顺序返回结果</p>
</li>
</ul>
<p style="color:red;">将回调函数嵌套转换为.then方法的链式调用</p>

<p><img data-src="/images/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210924112213973.png" alt="image-20210924112213973"></p>
<center>图五</center>

<p>图五即为三个ajax请求顺序返回结果</p>
<br>

<h2 id="5-promise对象-then方法返回值问题"><a href="#5-promise对象-then方法返回值问题" class="headerlink" title="5. promise对象.then方法返回值问题"></a>5. promise对象.then方法返回值问题</h2><p>.then方法可以有两种返回值：</p>
<ul>
<li>promise对象</li>
<li>普通数据类型</li>
</ul>
<h3 id="5-1-上一个-then返回promise对象"><a href="#5-1-上一个-then返回promise对象" class="headerlink" title="5.1 上一个.then返回promise对象"></a>5.1 上一个.then返回promise对象</h3><p>此时<strong>下一个.then就在返回的promise对象上调用</strong>，处理该promise对象中异步操作的结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promiseAjax(<span class="string">&#x27;http://localhost/data&#x27;</span>)</span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);	</span><br><span class="line">                <span class="keyword">return</span> promiseAjax(<span class="string">&#x27;http://localhost/data1&#x27;</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">			<span class="comment">//对上一个.then方法返回的promise对象调用.then方法</span></span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;	<span class="comment">//data即为上一个返回的promise对象中异步操作的结果</span></span><br><span class="line">                <span class="built_in">console</span>.log(data);	</span><br><span class="line">                <span class="keyword">return</span> promiseAjax(<span class="string">&#x27;http://localhost/data2&#x27;</span>)</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>上述代码<strong>第二个.then</strong>中成功回调函数的参数<strong>data</strong><ul>
<li>即为上一个返回的promise对象（<code>promiseAjax(&#39;http://localhost/data1&#39;)</code>）中异步操作的结果</li>
</ul>
</li>
</ul>
<h3 id="5-2-上一个-then返回普通数据类型"><a href="#5-2-上一个-then返回普通数据类型" class="headerlink" title="5.2 上一个.then返回普通数据类型"></a>5.2 上一个.then返回普通数据类型</h3><p>此时下一个.then方法会<strong>将这个普通数据类型包裹为promise对象</strong>并在其上调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promiseAjax(<span class="string">&#x27;http://localhost/data&#x27;</span>)</span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);	<span class="comment">//hello data</span></span><br><span class="line">                <span class="keyword">return</span> promiseAjax(<span class="string">&#x27;http://localhost/data1&#x27;</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);	<span class="comment">//hello data1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">123</span>	<span class="comment">//返回普通数据类型</span></span><br><span class="line">            &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;	<span class="comment">//data即为上个.then返回的普通数据类型</span></span><br><span class="line">                <span class="built_in">console</span>.log(data); <span class="comment">//123</span></span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>上述第二个.then返回普通数据类型 <code>123</code></li>
<li>第三个.then在<strong>被promise对象包裹的 123</strong> 上调用，此时成功回调函数的<strong>参数data即接收 普通数据类型</strong> <code>123</code></li>
</ul>
<p><img data-src="/images/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210924113915375.png" alt="image-20210924113915375"></p>
<center>图六</center>

<h2 id="6-promise对象常用API-实例方法"><a href="#6-promise对象常用API-实例方法" class="headerlink" title="6. promise对象常用API (实例方法)"></a>6. promise对象常用API (实例方法)</h2><p>首先使用<code>console.dir(Promise)</code>查看Promise对象</p>
<p><img data-src="/images/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210924150401787.png" alt="image-20210924150401787"></p>
<center>图七</center>

<p>红框标注的方法在<code>Promise.prototype</code>下，属于Promise<strong>对象实例的方法</strong></p>
<br>

<ul>
<li><strong>then</strong>：获取异步操作的<strong>正确结果或者错误信息</strong><ul>
<li>第一个参数为成功回调函数</li>
<li>第二个参数为失败回调函数（可选）</li>
</ul>
</li>
<li><strong>catch</strong>：获取异步操作的<strong>错误信息</strong><ul>
<li>参数为失败回调函数（与then方法第二个参数相同）</li>
</ul>
</li>
<li><strong>finally</strong>：无论成功与否都会执行<ul>
<li>promise对象<strong>无论成功与否</strong>，都会在最后执行finally方法的回调函数</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseAjax</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="comment">//返回一个Promise对象</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">               <span class="comment">//延时1s后返回promise对象结果</span></span><br><span class="line">               <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                   <span class="comment">// resolve(&#x27;123&#x27;)	//成功时异步操作结果为&#x27;123&#x27;</span></span><br><span class="line">                   reject(<span class="string">&#x27;Error&#x27;</span>)		<span class="comment">//失败时错误信息为&#x27;Error&#x27;</span></span><br><span class="line">               &#125;, <span class="number">1000</span>)</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;</span><br><span class="line">       promiseAjax()</span><br><span class="line">           .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">               <span class="built_in">console</span>.log(data);	<span class="comment">//输出成功时的结果 &#x27;123&#x27;</span></span><br><span class="line">           &#125;)</span><br><span class="line">           .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">               <span class="built_in">console</span>.log(err);	<span class="comment">//输出错误信息&#x27;Error&#x27;</span></span><br><span class="line">           &#125;)</span><br><span class="line">           .finally(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">               <span class="built_in">console</span>.log(<span class="string">&#x27;finished&#x27;</span>);	<span class="comment">//无论成功与否都会输出&#x27;finished&#x27;</span></span><br><span class="line">           &#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210924132853216.png" alt="image-20210924132853216"></p>
<center>图八</center>

<ul>
<li>图七即为异步操作失败后<strong>调用catch方法输出 ‘Error’</strong> </li>
<li>然后<strong>调用finally方法输出 ‘finished’</strong></li>
</ul>
<br>

<h2 id="7-Promise对象常用API（对象方法）"><a href="#7-Promise对象常用API（对象方法）" class="headerlink" title="7. Promise对象常用API（对象方法）"></a>7. Promise对象常用API（对象方法）</h2><p><img data-src="/images/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210924150617500.png" alt="image-20210924150617500"></p>
<center>图九</center>

<p>红框标注的<code>all</code>和<code>race</code>方法都是<strong>Promise对象</strong>下的方法</p>
<p>这样的方法称为<strong>对象方法（静态方法）</strong></p>
<p>直接使用Promise对象调用</p>
<h3 id="7-1-all方法"><a href="#7-1-all方法" class="headerlink" title="7.1 all方法"></a>7.1 all方法</h3><p><code>Promise.all(&#39;Array&#39;)</code>    并发处理多个异步任务</p>
<ul>
<li>参数为一个<strong>元素为Promise实例对象的数组</strong></li>
<li>返回值为一个新的Promise对象</li>
<li>当数组中<strong>所有promise实例都返回正确结果时</strong>，all方法返回的新promise对象<strong>状态变为成功</strong><ul>
<li>新Promise对象then方法的成功回调函数<strong>接受一个数组作为参数</strong></li>
<li>数组元素为<strong>每一个promise实例的正确结果</strong>（顺序与Array中相同）</li>
</ul>
</li>
<li>当数组中有一个promise对象错误，则新promise对象状态变为错误，并将数组中首个出错promise对象的错误信息作为自己的错误信息</li>
</ul>
<h3 id="7-2-race方法"><a href="#7-2-race方法" class="headerlink" title="7.2 race方法"></a>7.2 race方法</h3><p><code>Promise.race(&#39;Array&#39;)</code>    并发处理多个异步任务</p>
<ul>
<li>参数与all方法相同</li>
<li>当数组中<strong>有一个promise实例成功时，新promise对象立即成功</strong>，并将首个成功promise实例的结果作为新promise对象成功的结果</li>
<li>当数组有一个promise实例错误时，与all方法执行同样操作</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              resolve(<span class="string">&#x27;HelloWorld&#x27;</span>)</span><br><span class="line">          &#125;, <span class="number">1000</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              resolve(<span class="string">&#x27;Hello Tom&#x27;</span>)</span><br><span class="line">          &#125;, <span class="number">2000</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              resolve(<span class="string">&#x27;Hello Jerry&#x27;</span>)</span><br><span class="line">          &#125;, <span class="number">3000</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">//所有promise对象都返回结果后 新promise成功</span></span><br><span class="line">      <span class="built_in">Promise</span>.all([p1,p2,p3])</span><br><span class="line">          .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(data);	</span><br><span class="line">          &#125;)</span><br><span class="line"><span class="comment">//只要有一个成功返回 新pormise实例立即成功</span></span><br><span class="line">      <span class="built_in">Promise</span>.race([p1,p2,p3])</span><br><span class="line">          .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(data);</span><br><span class="line">          &#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210924150819517.png" alt="image-20210924150819517"></p>
<center>图十</center>

<ul>
<li>因为race方法返回的promise实例在第数组一个实例成功后就立即成功</li>
<li>所以race方法结果打印在all方法之前</li>
</ul>
<br>

<h2 id="8-fetch-API-接口调用"><a href="#8-fetch-API-接口调用" class="headerlink" title="8. fetch API 接口调用"></a>8. fetch API 接口调用</h2><h3 id="8-1-fetch-API概述"><a href="#8-1-fetch-API概述" class="headerlink" title="8.1 fetch API概述"></a>8.1 fetch API概述</h3><ul>
<li><strong>提供了一个获取资源的接口</strong>：更加简单的数据获取方式，功能更强大，更灵活，可以看作是<strong>普通Ajax的升级版</strong></li>
<li><strong>基于Promise实现</strong></li>
<li>标准化组织制定的新规则，<strong>内置对象</strong></li>
<li>返回值为promise对象</li>
</ul>
<h3 id="8-2-语法结构"><a href="#8-2-语法结构" class="headerlink" title="8.2 语法结构"></a>8.2 语法结构</h3><p><img data-src="/images/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210924153158556.png" alt="image-20210924153158556"></p>
<center>图十一</center>

<h3 id="8-3-使用fetch-API-简单实例"><a href="#8-3-使用fetch-API-简单实例" class="headerlink" title="8.3 使用fetch API 简单实例"></a>8.3 使用fetch API 简单实例</h3><p><code>fetch(&#39;url&#39;).then().catch()</code></p>
<ul>
<li>传入一个url作为参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;http://localhost/fetchdata&#x27;</span>)</span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> data.text()</span><br><span class="line">            &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    			<span class="comment">//获取服务器传来的数据</span></span><br><span class="line">                <span class="built_in">console</span>.log(data);	<span class="comment">//hello fetch</span></span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述代码向<code>&#39;http://localhost/fetchdata&#39;</code>发送请求</p>
</li>
<li><p>第一个then方法中data并不是获取的数据，<code>data.text()</code>方法返回一个promise实例</p>
<ul>
<li>text()方法是<strong>属于fetch的方法</strong></li>
</ul>
</li>
<li><p>第二个then方法才能获取到服务器发来的数据</p>
</li>
</ul>
<p><img data-src="/images/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210924153543646.png" alt="image-20210924153543646"></p>
<center>图十二</center>

<br>

<h3 id="8-4-fetch-配置选项"><a href="#8-4-fetch-配置选项" class="headerlink" title="8.4 fetch 配置选项"></a>8.4 fetch 配置选项</h3><p><img data-src="/images/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210924154338161.png" alt="image-20210924154338161"></p>
<center>图十三</center>

<ul>
<li>fetch方法的第二个参数为一个对象，<strong>对象中属性为配置项</strong></li>
</ul>
<h3 id="8-5-fetch-请求参数"><a href="#8-5-fetch-请求参数" class="headerlink" title="8.5 fetch 请求参数"></a>8.5 fetch 请求参数</h3><h4 id="8-5-1-GET-请求参数"><a href="#8-5-1-GET-请求参数" class="headerlink" title="8.5.1 GET 请求参数"></a>8.5.1 GET 请求参数</h4><p><strong>使用传统url方式传参</strong></p>
<ul>
<li>请求参数直接使用<code>?</code>接在URL后面</li>
<li>服务器后台程序接受参数使用<code>req.query.&#39;参数名&#39;</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;http://localhost/fetchdata?id=123&#x27;</span>,&#123;</span><br><span class="line">            method:<span class="string">&#x27;get&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> data.text()</span><br><span class="line">            &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/fetchdata&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;传统URL传参:&#x27;</span>+ req.query.id)	<span class="comment">//传统URL传参:123</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<p><strong>使用Restful url方式传参</strong></p>
<ul>
<li>请求参数以<code>&#39;/&#39;</code>隔开接在URL后面（不需要设定参数名字）</li>
<li>接受请求参数时在中间件地址参数最后加上 <code>/:&#39;参数名&#39;</code><ul>
<li>参数名自定义</li>
<li>使用<code>req.params.&#39;参数名&#39;</code>获取对应请求参数</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;http://localhost/fetchdata/456&#x27;</span>,&#123;</span><br><span class="line">            method:<span class="string">&#x27;get&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> data.text()</span><br><span class="line">            &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/fetchdata/:id&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">        res.send(<span class="string">&#x27;Restful URL传参:&#x27;</span>+ req.params.id)	<span class="comment">//Restful URL传参:456</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<br>

<h4 id="8-5-2-DELETE-请求参数"><a href="#8-5-2-DELETE-请求参数" class="headerlink" title="8.5.2 DELETE 请求参数"></a>8.5.2 DELETE 请求参数</h4><p>DELETE是删除请求</p>
<p>DELETE请求方式传参与GET方式类似</p>
<ul>
<li>仍使用restful URL传参 (传统URL传参方式与GET请求也相同)</li>
<li>method配置项设置为<code>&#39;delete&#39;</code></li>
<li>接受时使用<code>app.delete()</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;http://localhost/fetchdata/789&#x27;</span>,&#123;</span><br><span class="line">            method:<span class="string">&#x27;delete&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> data.text()</span><br><span class="line">            &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);</span><br><span class="line">            &#125;)</span><br><span class="line">            </span><br><span class="line">app.delete(<span class="string">&#x27;/fetchdata/:id&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;DELETE请求传参:&#x27;</span>+ req.params.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="8-5-3-POST请求参数"><a href="#8-5-3-POST请求参数" class="headerlink" title="8.5.3 POST请求参数"></a>8.5.3 POST请求参数</h4><ul>
<li>post请求参数写在body配置项中</li>
<li>请求参数的格式可以为<ul>
<li>普通字符串    <code>&quot;name=zhangsan&amp;age=20&quot;</code></li>
<li>JSON对象   <code>&#123;name:&#39;lisi&#39;,age:30&#125;</code><ul>
<li>JSON对象格式的参数在传递时要转换为JSON字符串传送</li>
</ul>
</li>
</ul>
</li>
<li>post请求使用body配置项传递参数时，<strong>必须</strong>使用headers配置项<strong>设定content-type请求头字段</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//POST请求 普通字符串传参</span></span><br><span class="line">      fetch(<span class="string">&#x27;http://localhost/fetchdata&#x27;</span>,&#123;</span><br><span class="line">          method:<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">          <span class="comment">//普通字符串参数</span></span><br><span class="line">          body:<span class="string">&quot;uname=zhagsan&amp;age=20&quot;</span>,</span><br><span class="line">          headers:&#123;</span><br><span class="line">              <span class="comment">//设定请求头content-type字段</span></span><br><span class="line">              <span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> data.text()</span><br><span class="line">          &#125;)</span><br><span class="line">          .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(data);</span><br><span class="line">          &#125;)</span><br></pre></td></tr></table></figure>

<br>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//POST请求 JSON对象传参</span></span><br><span class="line">        fetch(<span class="string">&#x27;http://localhost/fetchdata&#x27;</span>,&#123;</span><br><span class="line">            method:<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">            <span class="comment">//传递时转化为JSON字符串</span></span><br><span class="line">            body:<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">                uname:<span class="string">&#x27;lisi&#x27;</span>,</span><br><span class="line">                age:<span class="number">30</span></span><br><span class="line">            &#125;),</span><br><span class="line">            headers:&#123;</span><br><span class="line">                <span class="comment">//content-type字段设置为json</span></span><br><span class="line">                <span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> data.text()</span><br><span class="line">            &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<br>

<p>服务端接受请求参数时使用 node的<code>第三方模块 body-parser</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收以json格式和普通字符串格式传递的post参数</span></span><br><span class="line">app.use(bodyParser.json())</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;<span class="attr">extended</span>:<span class="literal">false</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用req.body.&#x27;参数名&#x27; 接受POST请求参数</span></span><br><span class="line">app.post(<span class="string">&#x27;/fetchdata&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;POST请求传参:&#x27;</span>+ req.body.uname + <span class="string">&#x27;-------&#x27;</span> + req.body.age)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h4 id="8-5-4-PUT-请求参数"><a href="#8-5-4-PUT-请求参数" class="headerlink" title="8.5.4 PUT 请求参数"></a>8.5.4 PUT 请求参数</h4><p>PUT是修改请求</p>
<p>PUT请求参数的设置方式与POST类似</p>
<ul>
<li>唯一不同的是PUT请求是<strong>修改请求</strong>，需要传递<strong>修改数据的id</strong></li>
<li>id可以通过URL传递</li>
<li>服务端接受body配置项的参数时，也可以接受url中的参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PUT修改请求 需要传递待修改数据的id</span></span><br><span class="line">        fetch(<span class="string">&#x27;http://localhost/fetchdata/?id=1&#x27;</span>,&#123;	<span class="comment">//id=1</span></span><br><span class="line">            method:<span class="string">&#x27;put&#x27;</span>,</span><br><span class="line">            body:<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">                uname:<span class="string">&#x27;lisi&#x27;</span>,</span><br><span class="line">                age:<span class="number">30</span></span><br><span class="line">            &#125;),</span><br><span class="line">            headers:&#123;</span><br><span class="line">                <span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> data.text()</span><br><span class="line">            &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="8-6-fetch-响应结果"><a href="#8-6-fetch-响应结果" class="headerlink" title="8.6 fetch 响应结果"></a>8.6 fetch 响应结果</h3><p>使用fetch API向后台发送请求时</p>
<ul>
<li>后台可以返回<strong>普通字符串</strong>或者<strong>JSON对象格式</strong>的数据</li>
<li>fetch API使用<code>.then</code>方法处理后台响应的数据时<ul>
<li><code>text()</code>方法将数据转换为<strong>普通字符串</strong></li>
<li><code>json()</code>方法将数据转换为<strong>JSON对象格式</strong>（相当于使用<code>JSON.parse()</code>）</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">        fetch(<span class="string">&#x27;http://localhost/fetchResponse&#x27;</span>,&#123;</span><br><span class="line">            method:<span class="string">&#x27;get&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> data.text()  <span class="comment">//将响应数据转换为字符串类型</span></span><br><span class="line">            	<span class="comment">//return data.json() //将响应数据转换为JSON对象类型</span></span><br><span class="line">            &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);			<span class="comment">//&quot;&#123;name:&#x27;yang&#x27;,age:20&#125;&quot; 或 &#123;name:&#x27;yang&#x27;,age:20&#125;</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">typeof</span> data);   <span class="comment">//String 或 Object</span></span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/fetchResponse&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//服务器响应JSON对象格式数据，传送时转换为JSON字符串传送</span></span><br><span class="line">    res.send(&#123;</span><br><span class="line">        name:<span class="string">&#x27;yang&#x27;</span>,</span><br><span class="line">        age:<span class="number">20</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210924170522698.png" alt="image-20210924170522698"></p>
<center>图十四</center>

<ul>
<li>图十四即为将响应数据使用<code>text()</code>方法<strong>转换为字符串后的输出结果</strong></li>
</ul>
<br>

<h2 id="9-axios-API接口调用"><a href="#9-axios-API接口调用" class="headerlink" title="9. axios API接口调用"></a>9. axios API接口调用</h2><p>axios是一个基于Promise对象 用于浏览器和node.js的HTTP客户端</p>
<p>第三方库 通过<code>script</code>标签引入，比fetch的功能更强大</p>
<p>特征：</p>
<ul>
<li>支持<strong>浏览器和Nodejs</strong></li>
<li><strong>基于promise</strong></li>
<li>能拦截请求和响应</li>
<li>自动转换JSON数据</li>
<li>返回值为promise对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入axios库</span></span><br><span class="line">&lt;script src=<span class="string">&quot;./js/axios.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用axios API发送GET请求</span></span><br><span class="line">axios.get(<span class="string">&#x27;http://localhost/axiosdata&#x27;</span>)</span><br><span class="line">			<span class="comment">//使用then方法处理异步操作结果</span></span><br><span class="line">            .then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res);</span><br><span class="line">                <span class="built_in">console</span>.log(res.data);</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210924200701733.png" alt="image-20210924200701733"></p>
<center>图十五</center>

<ul>
<li><code>axios API</code> 异步操作成功时结果为<strong>一个对象（res）</strong>（对象中记录了请求和响应的相关信息）</li>
<li>对象中的<strong>data属性</strong>为服务端返回的数据</li>
</ul>
<br>

<h3 id="9-1-axios-请求参数传递"><a href="#9-1-axios-请求参数传递" class="headerlink" title="9.1 axios 请求参数传递"></a>9.1 axios 请求参数传递</h3><p>axios有四个常用API，分别对应四种HTTP请求方式</p>
<ul>
<li><code>axios.get()</code></li>
<li><code>axios.delete()</code></li>
<li><code>axios.post()</code></li>
<li><code>axios.put()</code></li>
</ul>
<h4 id="9-1-1-GET和DELETE请求参数传递"><a href="#9-1-1-GET和DELETE请求参数传递" class="headerlink" title="9.1.1 GET和DELETE请求参数传递"></a>9.1.1 GET和DELETE请求参数传递</h4><p>GET和DELETE请求参数传递方法类似</p>
<ul>
<li>使用URL传递：与<strong>fetch API的传递方式相同</strong><ul>
<li>传统URL</li>
<li>Restful URL</li>
</ul>
</li>
</ul>
<br>

<ul>
<li>使用<code>params</code>配置项传递<ul>
<li><code>axios.get</code>方法<strong>第二个参数配置对象</strong>中使用<strong>params属性</strong>传递GET或DELETE请求参数</li>
<li>服务端接受<code>params</code>配置项传递的参数使用<code>req.query.&#39;属性名&#39;</code></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;http://localhost/axiosdata&#x27;</span>,&#123;</span><br><span class="line">			<span class="comment">//params配置项传递参数</span></span><br><span class="line">            params:&#123;</span><br><span class="line">                name:<span class="string">&#x27;yang&#x27;</span>,</span><br><span class="line">                age:<span class="number">20</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res);</span><br><span class="line">                <span class="built_in">console</span>.log(res.data);</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/axiosdata&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;GET请求参数:&#x27;</span>+req.query.name+<span class="string">&#x27;----&#x27;</span>+req.query.age)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210924204045271.png" alt="image-20210924204045271"></p>
<center>图十六</center>

<br>

<h4 id="9-1-2-POST和PUT请求参数传递"><a href="#9-1-2-POST和PUT请求参数传递" class="headerlink" title="9.1.2 POST和PUT请求参数传递"></a>9.1.2 POST和PUT请求参数传递</h4><p>POST和PUT请求参数传递方法<strong>类似</strong></p>
<p>post请求参数有<strong>两种方式传递</strong></p>
<ul>
<li><p>使用对象传递参数：通过<code>axios.post()</code>方法第二个参数传递</p>
<ul>
<li>第二个参数<strong>对象中直接写请求参数</strong></li>
<li>这种方法传递的是<strong>JSON对象格式的请求参数</strong><ul>
<li>服务端需要提前设置接受JSON对象格式的参数</li>
</ul>
</li>
</ul>
</li>
<li><p>通过<code>URLSearchParams</code>对象的实例对象传递</p>
<ul>
<li>向实例中添加属性（属性即为请求参数）</li>
<li>最后将实例作为<code>axios.post()</code>的第二个参数</li>
<li>传递的是<strong>字符串类型的请求参数</strong></li>
</ul>
</li>
</ul>
<p>服务器端使用<code>req.body.&#39;属性名&#39;</code>接受请求参数()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.使用选项传递参数</span></span><br><span class="line">axios.post(<span class="string">&#x27;http://localhost/axiosdata&#x27;</span>,&#123;	<span class="comment">//第二个参数对象中直接写请求参数</span></span><br><span class="line">                name:<span class="string">&#x27;yang&#x27;</span>,</span><br><span class="line">                age:<span class="number">20</span></span><br><span class="line">        &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res);</span><br><span class="line">                <span class="built_in">console</span>.log(res.data);</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用URLSearchParams对象的实例对象传递</span></span><br><span class="line">		<span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams()</span><br><span class="line">        <span class="comment">//给params实例添加属性（请求参数）</span></span><br><span class="line">        params.append(<span class="string">&#x27;name&#x27;</span>,<span class="string">&quot;xiao&quot;</span>)</span><br><span class="line">        params.append(<span class="string">&#x27;age&#x27;</span>,<span class="number">30</span>)</span><br><span class="line">		<span class="comment">//params作为API第二个参数</span></span><br><span class="line">        axios.post(<span class="string">&#x27;http://localhost/axiosdata&#x27;</span>,params)</span><br><span class="line">            .then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res);</span><br><span class="line">                <span class="built_in">console</span>.log(res.data);</span><br><span class="line">            &#125;)    </span><br><span class="line"></span><br><span class="line">app.post(<span class="string">&#x27;/axiosdata&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;POST请求参数:&#x27;</span>+req.body.name+<span class="string">&#x27;----&#x27;</span>+req.body.age)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210924210152233.png" alt="image-20210924210152233"></p>
<center>图十七</center>

<p>图十七，使用原生对象方式传递post请求参数时<strong>格式为JSON对象</strong></p>
<br>

<h3 id="9-2-axios响应结果"><a href="#9-2-axios响应结果" class="headerlink" title="9.2 axios响应结果"></a>9.2 axios响应结果</h3><p><img data-src="/images/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210924210639384.png" alt="image-20210924210639384"></p>
<center>图十八</center>

<p><code>axios API</code> 接受服务器响应数据为一个对象，对象中常用属性如下</p>
<ul>
<li><strong>data</strong>：服务器返回的数据</li>
<li><strong>status</strong>：HTTP响应状态码</li>
<li><strong>headers</strong>：响应头中的字段</li>
<li><strong>statusText</strong>：响应状态码文字说明</li>
</ul>
<p>当服务端响应的数据为JSON对象格式时，axios会<strong>自动进行格式转换</strong>（不需要手动将JSON字符串转换为JSON对象）</p>
<p>接受的data属性即为JS对象，可以直接获取对象中的属性</p>
<p><img data-src="/images/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210924211334446.png" alt="image-20210924211334446"></p>
<center>图十九</center>

<h3 id="9-3-axios的全局配置"><a href="#9-3-axios的全局配置" class="headerlink" title="9.3 axios的全局配置"></a>9.3 axios的全局配置</h3><ul>
<li><p><code>axios.defaults.timeout = &#39;时间&#39;</code></p>
<ul>
<li>超出设定的时间服务器还没有响应就认为请求出错</li>
</ul>
</li>
<li><p><code>axios.defaults.baseURL = &#39;url&#39;</code></p>
<ul>
<li>设置默认基准URL</li>
<li>调用axios方法发送请求时，第一个参数(url)<strong>若简写</strong>，则会<strong>自动在前方拼接基准URL</strong></li>
</ul>
</li>
<li><p><code>axios.defaults.headers[&#39;请求头名&#39;] = ’值‘</code></p>
<ul>
<li>设定请求头中的字段</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置基准URL</span></span><br><span class="line">      axios.defaults.baseURL = <span class="string">&#x27;http://localhost/&#x27;</span></span><br><span class="line">      <span class="comment">//添加请求头字段</span></span><br><span class="line">      axios.defaults.headers[<span class="string">&#x27;mytoken&#x27;</span>] = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">//简写URL 自动拼接基准URL</span></span><br><span class="line">      axios.get(<span class="string">&#x27;axiosdata&#x27;</span>)</span><br><span class="line">          .then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(res.data);</span><br><span class="line">          &#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210924212353264.png" alt="image-20210924212353264"></p>
<center>图二十</center>

<ul>
<li>图二十红框即为添加的请求头字段<ul>
<li>添加请求头字段时若请求发生跨域，要允许新增的请求头字段跨域</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//允许mytoken请求头字段跨域传送</span></span><br><span class="line">res.header(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>,<span class="string">&#x27;mytoken&#x27;</span>)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="9-4-axios拦截器"><a href="#9-4-axios拦截器" class="headerlink" title="9.4 axios拦截器"></a>9.4 axios拦截器</h3><p>axios拦截器分为两种</p>
<ul>
<li><strong>请求拦截器</strong>：在请求发送前修改请求</li>
<li><strong>响应拦截器</strong>：在客户端接受响应数据前修改数据</li>
</ul>
<p><img data-src="/images/05-Vue%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/image-20210924213909471.png" alt="image-20210924213909471"></p>
<center>图二十一</center>

<ul>
<li>图二十一为请求拦截器图示，响应拦截器类似</li>
</ul>
<br>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//处理请求</span></span><br><span class="line">	<span class="keyword">return</span> config</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>上述方法定义axios请求拦截器，响应拦截器将 <code>request</code> 换成 <code>response</code><ul>
<li>方法传递<strong>两个函数作为参数</strong><ul>
<li>第一个函数中处理请求或者响应数据（参数即为请求或者响应对象）<ul>
<li>第一个函数最后要<strong>将处理后的请求或数据返回</strong></li>
<li>返回值才是<code>axios API</code><strong>真正发送的请求或者接受的数据</strong></li>
</ul>
</li>
<li>第二个函数为错误处理函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求拦截器 在请求发送前进行操作</span></span><br><span class="line">      axios.interceptors.request.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">          <span class="comment">//输出url</span></span><br><span class="line">          <span class="built_in">console</span>.log(config.url);</span><br><span class="line">          <span class="comment">//增加请求头字段</span></span><br><span class="line">          config.headers[<span class="string">&#x27;mytoken&#x27;</span>] = <span class="string">&#x27;nihao&#x27;</span></span><br><span class="line">          <span class="comment">//return 后修改生效</span></span><br><span class="line">          <span class="keyword">return</span> config</span><br><span class="line">      &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//响应拦截器</span></span><br><span class="line">      axios.interceptors.response.use(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">          <span class="comment">//在客户端接受响应数据前 提取出响应对象中的data</span></span><br><span class="line">          <span class="keyword">return</span> res.data</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      axios.get(<span class="string">&#x27;http://localhost/axiosdata&#x27;</span>)</span><br><span class="line">          .then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(res);	<span class="comment">//直接输出响应数据（响应拦截器提取了数据）</span></span><br><span class="line">          &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>拦截器相对于全局配置可以<strong>更方便</strong>的对于<strong>特定请求或者响应</strong>进行处理</li>
</ul>
<br>

<h2 id="10-async-await-接口调用"><a href="#10-async-await-接口调用" class="headerlink" title="10. async/await 接口调用"></a>10. async/await 接口调用</h2><p>async/await 是ES7提出的异步编程<strong>进一步的解决方案</strong></p>
<p>相对于promise对象可以更加方便的处理异步操作</p>
<ul>
<li>await会<span style="color:red">阻塞当前的异步函数</span>，等待await后的promise正确返回或者发生错误再继续执行<ul>
<li>保证多个异步操作的执行顺序</li>
</ul>
</li>
</ul>
<p><strong>可以将异步操作写成同步的形式</strong></p>
<ul>
<li>异步函数返回值为promise对象<ul>
<li><strong>当retrun一个非promise对象时，会被包裹为promise对象返回</strong></li>
</ul>
</li>
<li>await只能在异步函数中使用<ul>
<li>await 后跟一个promise对象时<ul>
<li>若promise状态变为成功，则<strong>提取</strong>promise对象中异步操作的<strong>正确结果</strong></li>
<li>若promise状态变为错误，则<strong>程序终止报错</strong> 错误信息为promise对象的错误信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接在异步函数中处理异步操作结果</span></span><br><span class="line">      <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">          <span class="comment">//直接获取promise对象中异步操作成功的结果</span></span><br><span class="line">          <span class="comment">//res即为服务端响应的数据对象</span></span><br><span class="line">          <span class="keyword">let</span> res = <span class="keyword">await</span> axios.get(url)</span><br><span class="line">          <span class="built_in">console</span>.log(res);</span><br><span class="line">          <span class="built_in">console</span>.log(res.data);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将异步操作的结果返回 使用then方法处理结果</span></span><br><span class="line">      <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">let</span> res = <span class="keyword">await</span> axios.get(url)</span><br><span class="line">          <span class="keyword">return</span> res	<span class="comment">//res被包裹为promise对象</span></span><br><span class="line">      &#125;</span><br><span class="line">      send(<span class="string">&#x27;http://localhost/axiosdata&#x27;</span>)</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(res.data);</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>07-Vue前端路由</title>
    <url>/2021/09/20/07-Vue%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h1 id="Vue前端路由"><a href="#Vue前端路由" class="headerlink" title="Vue前端路由"></a>Vue前端路由</h1><h2 id="1-路由"><a href="#1-路由" class="headerlink" title="1. 路由"></a>1. 路由</h2><p>路由的本质是<strong>对应关系</strong></p>
<p>路由分为<strong>前端路由</strong>和<strong>后端路由</strong></p>
<h3 id="1-1-后端路由"><a href="#1-1-后端路由" class="headerlink" title="1.1 后端路由"></a>1.1 后端路由</h3><p>后端路由：根据不同的请求URL，服务器端返回不同的资源</p>
<p><strong>本质</strong>：<strong>URL请求地址</strong>与<strong>服务器资源</strong>的对应关系</p>
<span id="more"></span>

<p><img data-src="/images/07-Vue%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/image-20210926161658262.png" alt="image-20210926161658262"></p>
<center>图一</center>

<h3 id="1-2-SPA"><a href="#1-2-SPA" class="headerlink" title="1.2 SPA"></a>1.2 SPA</h3><ul>
<li><strong>后端渲染</strong>：使用后端路由进行<strong>后端渲染</strong>存在<strong>性能问题</strong>：频繁提交表单时，页面会频繁刷新影响用户体验</li>
<li><strong>Ajax前端渲染</strong>：可以局部刷新页面，提高了性能（但是不支持浏览器前进后退操作）</li>
</ul>
<p><strong>SPA</strong>(<u>Single Page Application</u>)：单页面应用程序，<strong>整个网站只有一个页面</strong>，内容变化通过前端路由<strong>切换组件</strong>实现，同时支持浏览器的前进后退操作。(解决了Ajax前端渲染的缺点)</p>
<ul>
<li>SPA路由实现原理之一：<span style="color:red">基于URL地址的hash值路由（锚链接）</span><ul>
<li>hash的变化会导致浏览器<strong>访问历史的变化</strong>，但是<strong>不会触发新HTTP请求</strong></li>
</ul>
</li>
<li>SPA核心的技术点就是<strong>前端路由</strong><ul>
<li><u>基于URL地址的hash</u> 是<strong>最常见的前端路由实现方案</strong></li>
<li>另一个前端路由方案：基于H5 <code>historyAPI</code>的路由</li>
</ul>
</li>
</ul>
<br>

<h3 id="1-3-前端路由"><a href="#1-3-前端路由" class="headerlink" title="1.3 前端路由"></a>1.3 前端路由</h3><ul>
<li>单页面应用中<strong>对于多个组件切换管理的需求</strong>催生了<strong>前端路由</strong></li>
</ul>
<p><strong>前端路由：</strong>根据不同用户事件<strong>修改路由路径</strong>，显示不同的页面内容(通过<strong>切换组件</strong>显示不同的视图)</p>
<p>本质：<strong>路由路径</strong>与<strong>组件</strong>的对应关系</p>
<ul>
<li>通过用户事件修改路径，根据路径渲染不同的组件</li>
</ul>
<p><img data-src="/images/07-Vue%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/image-20210926162728869.png" alt="image-20210926162728869"></p>
<center>图二</center>

<ul>
<li>前端路由负责事件监听，触发事件后通过事件处理函数<strong>修改路径以渲染不同组件内容</strong></li>
</ul>
<br>

<h3 id="1-4-Vue前端路由简单使用"><a href="#1-4-Vue前端路由简单使用" class="headerlink" title="1.4 Vue前端路由简单使用"></a>1.4 Vue前端路由简单使用</h3><p>使用<strong>基于URL地址的hash</strong>实现前端路由</p>
<ul>
<li>通过点击4个a标签修改hash值</li>
<li>hash值改变触发<code>window.onhashchange</code>事件</li>
<li>在事件处理函数中根据hash值修改html页面中使用的<strong>组件</strong>，以此实现页面局部刷新</li>
</ul>
<p><code>location.hash</code>可以获取当前的hash值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!-- #/zhuye即为hash值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/zhuye&quot;</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/caijing&quot;</span>&gt;</span>财经<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/tiyu&quot;</span>&gt;</span>体育<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/junshi&quot;</span>&gt;</span>军事<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- comName为存储组件名的变量 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&#x27;comName&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">            data:&#123;</span><br><span class="line">                comName:<span class="string">&#x27;zhuye&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            components:&#123;</span><br><span class="line">                zhuye,</span><br><span class="line">                caijing,</span><br><span class="line">                tiyu,</span><br><span class="line">                junshi</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">		<span class="comment">//hash值改变事件</span></span><br><span class="line">        <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//打印hash值</span></span><br><span class="line">            <span class="built_in">console</span>.log(location.hash);</span><br><span class="line">            <span class="comment">//获取hash值</span></span><br><span class="line">            <span class="keyword">let</span> hash = location.hash</span><br><span class="line">            <span class="keyword">switch</span>(hash.slice(<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/zhuye&#x27;</span>:</span><br><span class="line">                    <span class="comment">//修改comName数据的值</span></span><br><span class="line">                    vm.comName = <span class="string">&#x27;zhuye&#x27;</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/caijing&#x27;</span>:</span><br><span class="line">                    vm.comName = <span class="string">&#x27;caijing&#x27;</span></span><br><span class="line">                    <span class="keyword">break</span>    </span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/tiyu&#x27;</span>:</span><br><span class="line">                    vm.comName = <span class="string">&#x27;tiyu&#x27;</span></span><br><span class="line">                    <span class="keyword">break</span>   </span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/junshi&#x27;</span>:</span><br><span class="line">                    vm.comName = <span class="string">&#x27;junshi&#x27;</span></span><br><span class="line">                <span class="keyword">break</span>   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/07-Vue%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/image-20210926170719277.png" alt="image-20210926170719277"></p>
<center>图三</center>

<p>图三中<strong>红框即为hash值(锚链接)</strong></p>
<br>

<h2 id="2-Vue-Router"><a href="#2-Vue-Router" class="headerlink" title="2. Vue Router"></a>2. Vue Router</h2><p>Vue Router是Vue.js<strong>官方的路由管理器</strong></p>
<p>可以方便的应用于SPA应用程序的开发</p>
<h3 id="2-1-功能"><a href="#2-1-功能" class="headerlink" title="2.1 功能"></a>2.1 功能</h3><ul>
<li><p>支持HTML5历史模式(<code>history API</code>)和<u>hash模式(锚链接)</u></p>
</li>
<li><p>支持嵌套路由</p>
</li>
<li><p>支持路由参数</p>
</li>
<li><p>支持编程式路由</p>
</li>
<li><p>支持命名路由</p>
</li>
</ul>
<h3 id="2-2-基本使用样例"><a href="#2-2-基本使用样例" class="headerlink" title="2.2 基本使用样例"></a>2.2 基本使用样例</h3><p><strong>使用步骤：</strong></p>
<ul>
<li>引入<code>vue-router.js</code>库文件</li>
<li>添加路由链接 (router-link)</li>
<li>添加路由填充位（router-view）</li>
<li>配置路由规则并创建路由实例（<code>new VueRouter</code>）</li>
<li>把路由实例挂载在Vue根实例中</li>
</ul>
<br>

<h4 id="2-2-1-引入库文件"><a href="#2-2-1-引入库文件" class="headerlink" title="2.2.1 引入库文件"></a>2.2.1 引入库文件</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Vue router 在 vue后引入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/js/vue-router.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Vue Router依赖于Vue.js</li>
</ul>
<br>

<h4 id="2-2-2-添加路由链接和填充位"><a href="#2-2-2-添加路由链接和填充位" class="headerlink" title="2.2.2 添加路由链接和填充位"></a>2.2.2 添加路由链接和填充位</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">        &lt;!-- 添加路由链接 --&gt;</span><br><span class="line">        &lt;router-link to=<span class="string">&#x27;/user&#x27;</span>&gt;User&lt;/router-link&gt;</span><br><span class="line">        &lt;router-link to=<span class="string">&#x27;/register&#x27;</span>&gt;Register&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 添加路由填充位 --&gt;</span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<center>添加路由链接和填充位</center>

<ul>
<li><p>路由链接使用<code>&lt;router-link&gt;</code>标签，此标签在解析时会<strong>被解析为a标签</strong>，<strong>to属性会被解析为href属性</strong></p>
<ul>
<li>to属性的值即为URL中的锚链接（解析为href属性后**自动在前方拼接”#”**）</li>
</ul>
</li>
<li><p>路由占位符<code>&lt;route-view&gt;</code>在对应路由触发时会<strong>被组件template字段覆盖</strong></p>
</li>
</ul>
<p><img data-src="/images/07-Vue%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/image-20210926195654336.png" alt="image-20210926195654336"></p>
<center>图四</center>

<br>

<h4 id="2-2-3-创建组件-创建路由实例并配置路由规则"><a href="#2-2-3-创建组件-创建路由实例并配置路由规则" class="headerlink" title="2.2.3 创建组件 创建路由实例并配置路由规则"></a>2.2.3 创建组件 创建路由实例并配置路由规则</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建路由组件</span></span><br><span class="line">      <span class="keyword">var</span> user = &#123;</span><br><span class="line">          template:<span class="string">&#x27;&lt;h1&gt;User&lt;/h1&gt;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> register = &#123;</span><br><span class="line">          template:<span class="string">&#x27;&lt;h1&gt;Register&lt;/h1&gt;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//创建路由实例配置路由规则</span></span><br><span class="line">      <span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">          routes:[&#123;</span><br><span class="line">              path:<span class="string">&#x27;/user&#x27;</span>,<span class="attr">component</span>:user</span><br><span class="line">          &#125;,&#123;</span><br><span class="line">              path:<span class="string">&#x27;/register&#x27;</span>,<span class="attr">component</span>:register</span><br><span class="line">          &#125;]</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>路由组件中包含将要填充到<code>&lt;router-view&gt;</code>的html代码段</li>
<li>创建路由实例使用<code>Vue-Router.js</code>提供的构造函数 <code>VueRouter</code><ul>
<li><code>VueRouter</code>构造函数<strong>接受一个对象</strong>作为配置项</li>
<li>配置对象中routes为配置数组<ul>
<li>数组中每个对象即为一条<strong>路由规则</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>路由规则</strong>对象两个属性：</p>
<ul>
<li>path：<strong>锚链接(hash)<strong>或者</strong>history 路径</strong></li>
<li>component：路由组件</li>
</ul>
<br>

<h4 id="2-2-4-路由实例挂载在Vue根实例中"><a href="#2-2-4-路由实例挂载在Vue根实例中" class="headerlink" title="2.2.4 路由实例挂载在Vue根实例中"></a>2.2.4 路由实例挂载在Vue根实例中</h4><p>路由实例挂载与data同级</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">            data:&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;,</span><br><span class="line">    		<span class="comment">//挂载路由实例	</span></span><br><span class="line">            router:router</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>在Vue根实例的<strong>router选项上挂载</strong></li>
</ul>
<p><img data-src="/images/07-Vue%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/image-20210926200606243.png" alt="image-20210926200606243"></p>
<center>图五</center>

<p>图五即为最终效果，点击User或者Register <strong>a标签</strong>，下方的标题文字变换</p>
<br>

<h3 id="2-3-路由重定向"><a href="#2-3-路由重定向" class="headerlink" title="2.3 路由重定向"></a>2.3 路由重定向</h3><p>页面打开时默认的锚链接为**#/**</p>
<p><img data-src="/images/07-Vue%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/image-20210926201046355.png" alt="image-20210926201046355"></p>
<p>路由重定向：在访问一个路由时<strong>强制跳转到另一个路由</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建路由实例配置路由规则</span></span><br><span class="line">        <span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">            routes:[&#123;</span><br><span class="line">                <span class="comment">//路由重定向</span></span><br><span class="line">                path:<span class="string">&#x27;/&#x27;</span>,<span class="attr">redirect</span>:<span class="string">&#x27;/user&#x27;</span></span><br><span class="line">            &#125;,&#123;</span><br><span class="line">                path:<span class="string">&#x27;/user&#x27;</span>,<span class="attr">component</span>:user</span><br><span class="line">            &#125;,&#123;</span><br><span class="line">                path:<span class="string">&#x27;/register&#x27;</span>,<span class="attr">component</span>:register</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>在<strong>routes路由规则中</strong>添加路由重定向规则</p>
<p><code>path</code>即为访问的原路由，<code>redirect</code>为重定向到的路由</p>
<p>此时页面打开时默认访问<code>#/</code>路由后重定向到<code>#/user</code>路由</p>
<br>

<h3 id="2-4-路由嵌套"><a href="#2-4-路由嵌套" class="headerlink" title="2.4 路由嵌套"></a>2.4 路由嵌套</h3><p>在<strong>父级组件中</strong>可以<strong>设置路由占位符</strong>实现路由嵌套</p>
<ul>
<li>在register<strong>父级组件的template字段</strong>中进行<strong>子级路由链接和填充位的设置</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> register = &#123;</span><br><span class="line">           template:<span class="string">`</span></span><br><span class="line"><span class="string">               &lt;div&gt;</span></span><br><span class="line"><span class="string">                   &lt;h1&gt;Register&lt;/h1&gt;</span></span><br><span class="line"><span class="string">                   &lt;hr/&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                   &lt;router-link to=&#x27;/register/tab1&#x27;&gt;tab1&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">                   &lt;router-link to=&#x27;/register/tab2&#x27;&gt;tab2&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">                   &lt;br&gt;</span></span><br><span class="line"><span class="string">                   &lt;router-view/&gt;</span></span><br><span class="line"><span class="string">               &lt;/div&gt;    </span></span><br><span class="line"><span class="string">               `</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建子路由匹配的组件</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子路由组件</span></span><br><span class="line">        <span class="keyword">var</span> tab1 = &#123;</span><br><span class="line">            template:<span class="string">&#x27;&lt;span&gt;tab1&lt;/span&gt;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> tab2 = &#123;</span><br><span class="line">            template:<span class="string">&#x27;&lt;span&gt;tab2&lt;/span&gt;&#x27;</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>子路由规则在父路由规则对象的<code>children</code>属性数组中定义</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">            routes:[&#123;</span><br><span class="line">                path:<span class="string">&#x27;/&#x27;</span>,<span class="attr">redirect</span>:<span class="string">&#x27;/user&#x27;</span></span><br><span class="line">            &#125;,&#123;</span><br><span class="line">                path:<span class="string">&#x27;/user&#x27;</span>,<span class="attr">component</span>:user</span><br><span class="line">            &#125;,&#123;</span><br><span class="line">                <span class="comment">//子路由规则在父路由规则的children数组中设置</span></span><br><span class="line">                path:<span class="string">&#x27;/register&#x27;</span>,<span class="attr">component</span>:register,<span class="attr">children</span>:[&#123;</span><br><span class="line">                    <span class="comment">//子路由path要拼接父路由path</span></span><br><span class="line">                    path:<span class="string">&#x27;/register/tab1&#x27;</span>,<span class="attr">component</span>:tab1</span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    path:<span class="string">&#x27;/register/tab2&#x27;</span>,<span class="attr">component</span>:tab2</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/07-Vue%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/image-20210926202914732.png" alt="image-20210926202914732"></p>
<center>图六</center>

<ul>
<li>图六红框即为register父级路由中的子路由组件渲染结果</li>
</ul>
<br>

<h3 id="2-5-动态路由匹配"><a href="#2-5-动态路由匹配" class="headerlink" title="2.5 动态路由匹配"></a>2.5 动态路由匹配</h3><p>当有多个相似路由时（例如多个路由有一部分相同，id值动态变化），此时一条条设定路由规则明显不合适</p>
<p>可以使用<strong>路由参数</strong>完成动态路由匹配</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!--三条部分相同的路由链接--&gt;</span><br><span class="line">&lt;router-link to=<span class="string">&#x27;/user/1&#x27;</span>&gt;User1&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=<span class="string">&#x27;/user/2&#x27;</span>&gt;User2&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=<span class="string">&#x27;/user/3&#x27;</span>&gt;User3&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//路由规则中使用路由参数动态匹配</span></span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">&#x27;/user/:id&#x27;</span>,<span class="attr">component</span>:user&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//路由组件中获取路由参数</span></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">            template:<span class="string">&#x27;&lt;h1&gt;User----id:&#123;&#123;$route.params.id&#125;&#125;&lt;/h1&gt;&#x27;</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>路由参数</strong>：在路由规则对象的path属性末尾加上 <code>/:&#39;参数名&#39;</code></p>
<ul>
<li><p>参数名自定义 </p>
</li>
<li><p>上述代码的<code>/user/1 or 2 or 3</code>三条路由链接都将会匹配这条规则<code>&#123;path:&#39;/user/:id&#39;,component:user&#125;</code></p>
</li>
<li><p>在路由组件中可以通过<code>$route.params.’参数名‘</code>，<strong>获取路由中的参数值</strong></p>
</li>
</ul>
<p><img data-src="/images/07-Vue%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/image-20210926205305355.png" alt="image-20210926205305355"></p>
<center>图七</center>

<br>

<h3 id="2-6-向路由组件传递参数"><a href="#2-6-向路由组件传递参数" class="headerlink" title="2.6 向路由组件传递参数"></a>2.6 向路由组件传递参数</h3><p>2.5中可以使用<code>$route</code>将动态路由参数传递给路由组件</p>
<p>但是这种方式不够灵活，只能传递动态的路由参数，不能传递静态参数</p>
<p><strong>使用props属性可以更灵活的进行参数传递</strong></p>
<ul>
<li><strong>路由规则</strong>中使用<strong>props属性定义要传递的参数</strong></li>
<li><strong>路由组件</strong>中使用<strong>props属性数组接受参数</strong></li>
</ul>
<br>

<h4 id="2-6-1-props属性值为布尔值"><a href="#2-6-1-props属性值为布尔值" class="headerlink" title="2.6.1 props属性值为布尔值"></a>2.6.1 props属性值为布尔值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> user = &#123;</span><br><span class="line">        	<span class="comment">//路由组件使用props属性接受params参数</span></span><br><span class="line">            props:[<span class="string">&#x27;id&#x27;</span>],</span><br><span class="line">            template:<span class="string">&#x27;&lt;h1&gt;User----id:&#123;&#123;id&#125;&#125;&lt;/h1&gt;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//true代表将params参数传递给路由对应组件的props 此处id为params参数</span></span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">&#x27;/user/:id&#x27;</span>,<span class="attr">component</span>:user,<span class="attr">props</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以更方便的传递<code>params</code>参数，组件中使用<code>props</code>获取<code>params</code>参数</li>
<li>(替代了<code>$route.params.&#39;...&#39;</code>的方式)</li>
</ul>
<br>

<h4 id="2-6-2-props属性为对象"><a href="#2-6-2-props属性为对象" class="headerlink" title="2.6.2 props属性为对象"></a>2.6.2 props属性为对象</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> props:[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>],</span><br><span class="line"> template:<span class="string">&#x27;&lt;h1&gt;User----name:&#123;&#123;name&#125;&#125;----age:&#123;&#123;age&#125;&#125;&lt;/h1&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//props为对象</span></span><br><span class="line">path:<span class="string">&#x27;/user/:id&#x27;</span>,<span class="attr">component</span>:user,<span class="attr">props</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>组件通过<code>props</code>接收路由规则设置的参数name和age</li>
<li>组件接收<strong>动态参数id</strong>时仍然使用<code>$route.params.id</code></li>
</ul>
<br>

<h4 id="2-6-3-props属性为函数"><a href="#2-6-3-props属性为函数" class="headerlink" title="2.6.3 props属性为函数"></a>2.6.3 props属性为函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props:[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;id&#x27;</span>],</span><br><span class="line">template:<span class="string">&#x27;&lt;h1&gt;User----name:&#123;&#123;name&#125;&#125;----age:&#123;&#123;age&#125;&#125;----id:&#123;&#123;id&#125;&#125;&lt;/h1&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//props属性为函数</span></span><br><span class="line">path:<span class="string">&#x27;/user/:id&#x27;</span>,<span class="attr">component</span>:user,<span class="attr">props</span>: <span class="function"><span class="params">route</span> =&gt;</span> (&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>,<span class="attr">age</span>:<span class="number">20</span>,<span class="attr">id</span>:route.params.id&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>props属性为<strong>函数</strong><ul>
<li>接收<code>$route</code>作为参数，<code>$route.params</code> 和 <code>$route.query</code>可以接收<code>params</code>和<code>query</code>类型的参数</li>
</ul>
</li>
<li>函数返回一个对象，<strong>该对象即为传递给组件props的数据</strong><ul>
<li><p style="color:red;">该对象使用`()`包裹</p></li>
</ul>
</li>
<li>这种方式既可以传递<strong>静态路由参数</strong>(name,age)还可以传递<strong>动态路由参数(id等)</strong></li>
</ul>
<br>

<h4 id="2-6-4-路由传参的几种方式"><a href="#2-6-4-路由传参的几种方式" class="headerlink" title="2.6.4 路由传参的几种方式"></a>2.6.4 路由传参的几种方式</h4><p><strong>1. router-link标签的to属性通过<code>restfulURL</code>传参</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//路由规则</span></span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">&#x27;/user/:id&#x27;</span>,<span class="attr">component</span>:user&#125;</span><br><span class="line"><span class="comment">//路由链接 传递id = 1 id为params参数</span></span><br><span class="line">&lt;router-link to=<span class="string">&#x27;/user/1&#x27;</span>&gt;User1&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<p><strong>2. 通过在路由规则设置对象类型的props传参</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//props即为参数 此处为静态参数</span></span><br><span class="line">&#123;<span class="attr">path</span>:<span class="string">&#x27;/user/:id&#x27;</span>,<span class="attr">component</span>:user,<span class="attr">props</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;yx&#x27;</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">    		<span class="comment">//prop接收参数name,age </span></span><br><span class="line">    		<span class="comment">//$route.params.id接收id参数</span></span><br><span class="line">            props: [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>],</span><br><span class="line">            template: <span class="string">&#x27;&lt;h1&gt;name:&#123;&#123;name&#125;&#125; age:&#123;&#123;age&#125;&#125;&lt;/h1&gt;&#x27;</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. router-link标签to属性为对象 在对象中设置参数(params,query)和path或者name</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用params和query传递两类参数 注意to属性绑定 path和params同时出现时params失效</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123;name:&#x27;user&#x27;,params:&#123;id:4&#125;,query:&#123;qid:5&#125;&#125;&quot;</span>&gt;命名路由传参&lt;/router-link&gt;</span><br><span class="line"><span class="comment">//$route.params/query.&#x27;...&#x27;获取参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//路由规则</span></span><br><span class="line">&#123;<span class="attr">name</span>:<span class="string">&#x27;user&#x27;</span>, <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>, <span class="attr">component</span>: user, <span class="attr">props</span>: <span class="function"><span class="params">route</span> =&gt;</span> (&#123; <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>, <span class="attr">id</span>:route.params.id &#125;)&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="2-7-命名路由"><a href="#2-7-命名路由" class="headerlink" title="2.7 命名路由"></a>2.7 命名路由</h3><p><strong>命名路由</strong>：给<strong>路由规则</strong>起一个别名，可以更加方便的匹配路由规则</p>
<p>路由链接<code>&lt;router-link&gt;</code>可以使用命名路由进行<strong>路由匹配和参数传递</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &lt;!-- 匹配命名路由并传参 --&gt;</span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123;name:&#x27;user&#x27;,params:&#123;id:3&#125;&#125;&quot;</span>&gt;User3&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">//命名路由</span></span><br><span class="line">                name:<span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">                path:<span class="string">&#x27;/user/:id&#x27;</span>,</span><br><span class="line">                component:user</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在路由规则对象中<strong>使用name属性给规则起一个别名</strong></li>
<li>路由链接匹配命名路由时<ul>
<li>属性绑定to</li>
<li>to的值为一个对象<ul>
<li><strong>name属性</strong>，路由规则别名（使用名字代替锚链接）</li>
<li><strong>params属性</strong>(值为对象)，传递给组件的动态参数  (组件中接收动态参数使用<code>$route.params.&#39;参数名&#39;</code>)</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>

<h3 id="2-8-Vue-Router编程式导航"><a href="#2-8-Vue-Router编程式导航" class="headerlink" title="2.8 Vue-Router编程式导航"></a>2.8 Vue-Router编程式导航</h3><p>页面导航的两种方式：<strong>声明式</strong>导航和<strong>编程式</strong>导航</p>
<h4 id="2-8-1声明式导航"><a href="#2-8-1声明式导航" class="headerlink" title="2.8.1声明式导航"></a>2.8.1声明式导航</h4><p><strong>声明式导航：</strong>通过点击链接进行导航跳转</p>
<p>使用页面中的<strong>a标签</strong>或者Vue中的**路由链接(router-link)**实现导航</p>
<p>导航通过点击声明好的标签进行</p>
<br>

<h4 id="2-8-2-编程式导航"><a href="#2-8-2-编程式导航" class="headerlink" title="2.8.2 编程式导航"></a>2.8.2 编程式导航</h4><p><strong>编程式导航：</strong>调用<code>JavaScript</code>的API进行导航</p>
<p>例如：通过<code>location.href()</code>进行页面导航跳转</p>
<br>

<h4 id="2-8-3-Vue-Router编程式导航的方式"><a href="#2-8-3-Vue-Router编程式导航的方式" class="headerlink" title="2.8.3 Vue-Router编程式导航的方式"></a>2.8.3 Vue-Router编程式导航的方式</h4><ul>
<li><p><code>this.$router.push()</code></p>
</li>
<li><p><code>this.$router.go()</code></p>
</li>
<li><p style="color:red;">注意：此处的`$router`与组件中接受参数的`$route`不同</p></li>
</ul>
<br>

<p>通过push方法可以<strong>根据hash值进行路由跳转</strong>和<strong>参数传递</strong></p>
<p>通过go方法可以实现<strong>页面在历史中前进和后退</strong>（类似于<code>history.go()</code>方法）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点击按钮后返回上一级页面</span></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">          template:<span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">                  &lt;h1&gt;User&lt;/h1&gt;</span></span><br><span class="line"><span class="string">                  &lt;button @click=&#x27;back&#x27;&gt;返回上一个页面&lt;/button&gt;</span></span><br><span class="line"><span class="string">              &lt;/div&gt;`</span>,</span><br><span class="line">              methods:&#123;</span><br><span class="line">                  back:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                      <span class="comment">//返回</span></span><br><span class="line">                      <span class="built_in">this</span>.$router.go(-<span class="number">1</span>)</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              </span><br><span class="line">      &#125;</span><br><span class="line">  	<span class="comment">//点击按钮后跳转到/user路由</span></span><br><span class="line">      <span class="keyword">var</span> register = &#123;</span><br><span class="line">          template:<span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">                  &lt;h1&gt;Register&lt;/h1&gt;</span></span><br><span class="line"><span class="string">                  &lt;button @click=&#x27;go&#x27;&gt;跳转到user&lt;/button&gt;</span></span><br><span class="line"><span class="string">              &lt;/div&gt;`</span>,</span><br><span class="line">          methods:&#123;</span><br><span class="line">              go:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                  <span class="comment">//跳转</span></span><br><span class="line">                  <span class="comment">//this指向register组件</span></span><br><span class="line">                  <span class="built_in">this</span>.$router.push(<span class="string">&#x27;/user&#x27;</span>)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<br>

<h5 id="router-push-方法的参数规则"><a href="#router-push-方法的参数规则" class="headerlink" title="$router.push()方法的参数规则"></a><code>$router.push()</code>方法的参数规则</h5><p><img data-src="/images/07-Vue%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/image-20210926214049337.png" alt="image-20210926214049337"></p>
<ol>
<li>使用<code>params</code>向路由组件传值</li>
</ol>
<ul>
<li>params与path<strong>同时使用时params不生效</strong>，利用<strong>命名路由</strong></li>
<li>组件中使用<code>$route.params.&#39;参数名&#39;</code>获取参数值</li>
</ul>
<ol start="2">
<li>使用<code>query</code>向路由组件传值</li>
</ol>
<ul>
<li>组件中使用<code>$route.query.&#39;参数名&#39;</code>获取参数值</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>12-数据库相关概念</title>
    <url>/2021/05/11/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h1><h2 id="1-使用MongoDB数据库"><a href="#1-使用MongoDB数据库" class="headerlink" title="1.使用MongoDB数据库"></a>1.使用MongoDB数据库</h2><p>MongoDB数据库<strong>可以使用js语法操作</strong>，前端开发人员更容易上手学习</p>
<p>MongoDB数据库是典型的<strong>非关系型数据库</strong>，数据可以使用<strong>JSON文件</strong>进行导入</p>
<p>MySQL则是典型的<strong>关系型数据库</strong>，数据被组织成<strong>表的形式</strong>存储</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511201521744.png" alt="image-20210511201521744"></p>
<span id="more"></span>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511201756252.png" alt="image-20210511201756252"></p>
<ul>
<li><p>此处页面中的admin和api等都是database</p>
<ul>
<li>Mongedb数据库软件中有三个默认的数据库：<strong>config，admin，local</strong></li>
</ul>
</li>
<li><p>roles是collection，一组数据的集合</p>
</li>
<li><p>右边显示的三条数据即为roles这个集合中的具体数据——<strong>文档document</strong></p>
<ul>
<li>每个文档实际上就是一个<strong>JSON对象</strong></li>
</ul>
</li>
<li><p>此处显示的文档中有三个<strong>字段field</strong></p>
</li>
</ul>
<h2 id="2-Nodejs操作数据库"><a href="#2-Nodejs操作数据库" class="headerlink" title="2.Nodejs操作数据库"></a>2.Nodejs操作数据库</h2><p>nodejs操作数据库需要第三方模块 <strong>mongoose模块</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//安装第三方模块</span></span><br><span class="line">npm install mongoose</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入mongoose模块</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-1打开数据库"><a href="#2-1打开数据库" class="headerlink" title="2.1打开数据库"></a>2.1打开数据库</h3><p>Mongodb数据库软件在安装时选择<strong>作为服务</strong>安装</p>
<p>可以直接通过打开服务的方式打开Mongodb数据库软件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">net start mongodb<span class="comment">//打开数据库</span></span><br><span class="line">net stop mongodb<span class="comment">//关闭数据库</span></span><br></pre></td></tr></table></figure>

<p>以管理员身份在CMD中开启关闭服务</p>
<h3 id="2-2数据库连接"><a href="#2-2数据库连接" class="headerlink" title="2.2数据库连接"></a>2.2数据库连接</h3><p>nodejs使用mongoose模块的<code>connect()</code>方法连接数据库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>)</span><br><span class="line"></span><br><span class="line">mongoose.connect(<span class="string">&#x27;mongodb://localhost/test&#x27;</span>)</span><br><span class="line">    .then(<span class="built_in">console</span>.log(<span class="string">&#x27;数据库开启成功&#x27;</span>))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;数据库开启失败&#x27;</span>,err))</span><br></pre></td></tr></table></figure>

<p>connect()方法返回一个<strong>promise对象</strong>，使用promise对象的**then()<strong>和</strong>catch()**方法接收结果和处理错误</p>
<p>connect()方法的参数为一个URL</p>
<ul>
<li>这个URL使用mongodb作为协议名</li>
<li>localhost即为主机的名字(IP/域名)，此处因为数据库运行在本机所以使用localhost</li>
<li>/test即为数据库名字(mongodb数据库会<strong>自动创建不存在的数据库</strong>，所以不需要显式的创建数据库)</li>
</ul>
<center>运行这个js文件显示如下</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511205146851.png" alt="image-20210511205146851"></p>
<p>将<code>&#123;useNewUrlParser:true,useUnifiedTopology:true&#125;</code>作为connect()方法的第二个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mongoose.connect(<span class="string">&#x27;mongodb://localhost/test&#x27;</span>,&#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> ,<span class="attr">useUnifiedTopology</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511205344686.png" alt="image-20210511205344686"></p>
<h3 id="2-3创建数据库"><a href="#2-3创建数据库" class="headerlink" title="2.3创建数据库"></a>2.3创建数据库</h3><p>MongoDB中不需要显式的创建数据库，打开数据库时<strong>不存在的数据库会被自动创建</strong></p>
<h3 id="2-4数据库的增添"><a href="#2-4数据库的增添" class="headerlink" title="2.4数据库的增添"></a>2.4数据库的增添</h3><h4 id="2-4-1创建集合"><a href="#2-4-1创建集合" class="headerlink" title="2.4.1创建集合"></a>2.4.1创建集合</h4><p>创建集合分两步</p>
<ul>
<li>1.设定集合规则</li>
<li>2.应用集合规则创建集合</li>
</ul>
<p><strong>设定集合规则</strong></p>
<p>使用<code>mongoose.Schema()</code><strong>构造函数</strong>创建实例对象来设定集合规则</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数传入一个JSON对象做为参数</span></span><br><span class="line"><span class="comment">//JSON对象中的属性即为文档中字段的名字和类型</span></span><br><span class="line"><span class="keyword">const</span> courseSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    teacher:<span class="built_in">String</span>,</span><br><span class="line">    isPublished:<span class="built_in">Boolean</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>创建的集合中的文档有三个字段</p>
<ul>
<li>name字段，数据类型为String</li>
<li>teacher字段，数据类型为String</li>
<li>isPublished字段，数据类型为Boolean</li>
</ul>
<p><strong>创建集合</strong></p>
<p>使用<code>mongoose.model()</code>方法创建集合</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个参数为集合名称</span></span><br><span class="line">    <span class="comment">//集合名称首字母大写</span></span><br><span class="line">    <span class="comment">//集合在数据库中实际的名称为courses</span></span><br><span class="line"><span class="comment">//第二个参数为应用的集合规则</span></span><br><span class="line"><span class="keyword">const</span> Course = mongoose.model(<span class="string">&#x27;Course&#x27;</span>,courseSchema);</span><br></pre></td></tr></table></figure>

<p>集合名称为Course，在数据库中实际创建的集合名称为<strong>courses</strong></p>
<p> <code>mongoose.model()</code>方法返回当前集合的构造函数</p>
<p>即上述代码的Course即为<strong>集合的构造函数</strong></p>
<p>集合的构造函数中的方法可以操作集合</p>
<p><strong>创建的新数据库如果没有文档数据，MongoDB中是不会创建这个数据库的，compass可视化软件中自然也看不到新数据库</strong></p>
<h4 id="2-4-2创建文档"><a href="#2-4-2创建文档" class="headerlink" title="2.4.2创建文档"></a>2.4.2创建文档</h4><p>创建文档向集合中插入数据分两步</p>
<ul>
<li>创建集合实例，写入新文档的数据</li>
<li>调用集合实例对象的save方法将文档保存在数据库中</li>
</ul>
<br>

<p><strong>创建集合实例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建集合的实例对象</span></span><br><span class="line"><span class="comment">//作为参数的JSON对象的属性即为文档中的字段和值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> courseDoc = <span class="keyword">new</span> Course(&#123;</span><br><span class="line">  name : <span class="string">&#x27;Node.js&#x27;</span>,</span><br><span class="line">  teacher:<span class="string">&#x27;黑马讲师&#x27;</span>,</span><br><span class="line">  isPublished: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>创建了一个集合实例(<strong>文档</strong>)</p>
<ul>
<li><p>name字段值为：’Node.js’</p>
</li>
<li><p>teacher字段值为：’黑马讲师’</p>
</li>
<li><p>isPublished字段值为：true</p>
<br></li>
</ul>
<p><strong>将集合保存到数据库</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保存数据到数据库</span></span><br><span class="line">courseDoc.save()</span><br></pre></td></tr></table></figure>

<p>调用创建的集合实例的save方法将新建的文档保存到数据库</p>
<br>

<center>在compass可视化软件中查看</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511214047191.png" alt="image-20210511214047191"></p>
<p>test数据库下的courses集合中有一个文档</p>
<p>_id字段是MongoDB数据库为每一个文档自动添加的唯一标识ID，类型为ObjectId</p>
<h4 id="2-4-3创建文档的另一种方式"><a href="#2-4-3创建文档的另一种方式" class="headerlink" title="2.4.3创建文档的另一种方式"></a>2.4.3创建文档的另一种方式</h4><p>使用集合构造函数的create()方法创建文档</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用集合构造函数的creat方法创建文档</span></span><br><span class="line"><span class="comment">//第一个参数为新建文档数据的JSON对象表示</span></span><br><span class="line"><span class="comment">//第二个参数为回调函数</span></span><br><span class="line">Course.create(&#123;<span class="attr">name</span>:<span class="string">&#x27;Javascript&#x27;</span>, <span class="attr">teacher</span>:<span class="string">&#x27;黑马讲师&#x27;</span>,<span class="attr">isPublished</span>:<span class="literal">false</span>&#125;, <span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>成功添加文档</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511215734414.png" alt="image-20210511215734414"></p>
<br>

<h5 id="Nodejs中对数据库的所有操作都是异步操作"><a href="#Nodejs中对数据库的所有操作都是异步操作" class="headerlink" title="Nodejs中对数据库的所有操作都是异步操作"></a>Nodejs中对数据库的所有操作都是异步操作</h5><ul>
<li><p>包括连接数据库，创建数据库和创建文档都是<strong>异步API</strong></p>
</li>
<li><p>其中返回promise对象的异步API可以应用<strong>异步函数</strong>编程的方法</p>
<br></li>
</ul>
<p>create()方法获取异步API结果的方式有两种</p>
<ul>
<li><p>利用<strong>回调函数</strong>得到，形如上述2.4.3代码</p>
</li>
<li><p>create()方法返回<strong>promise对象</strong>，使用promise对象的then()和catch()方法获取结果和处理错误信息</p>
<br></li>
</ul>
<p><strong>利用create()方法返回的promise对象来获取异步API结果</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用promise对象获取异步API的结果</span></span><br><span class="line"><span class="comment">//链式编程</span></span><br><span class="line">Course.create(&#123;<span class="attr">name</span>:<span class="string">&#x27;Javascript123&#x27;</span>, <span class="attr">teacher</span>:<span class="string">&#x27;黑马讲师&#x27;</span>,<span class="attr">isPublished</span>:<span class="literal">false</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure>

<center>后台返回数据</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511220815270.png" alt="image-20210511220815270"></p>
<center>compass显示</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511220907741.png" alt="image-20210511220907741"></p>
<h4 id="2-4-4MongoDB数据库导入数据"><a href="#2-4-4MongoDB数据库导入数据" class="headerlink" title="2.4.4MongoDB数据库导入数据"></a>2.4.4MongoDB数据库导入数据</h4><p>使用MongoDB提供的<code>mongoimport</code>命令导入文件中数据</p>
<p><code>mongoimport -d &#39;数据库名称&#39; -c &#39;集合名称&#39; --file &#39;要导入的文件路径&#39;</code></p>
<p><code>mongoimport -d &#39;数据库名称&#39; -c &#39;集合名称&#39; --jsonArray &#39;要导入的文件路径&#39;</code></p>
<br>

<p>因为mongoimport.exe这个文件路径不在系统环境变量的路径中</p>
<p><strong>需要我们手动添加文件的路径</strong></p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511231654210.png" alt="image-20210511231654210"></p>
<p>我在本机MongoDB安装目录下的bin文件夹中没有找到mongoimport.exe这个文件</p>
<p>所以在<a href="https://www.mongodb.com/try/download/database-tools?tck=docs_databasetools">MongoDB官网下载Tools</a></p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511231935779.png" alt="image-20210511231935779"></p>
<p>将压缩包中的<code>命令.exe</code>文件复制到环境变量设置的目录下，就可以使用这些命令</p>
<br>

<p><strong>导入user.json文件中的数据</strong></p>
<p>此处test数据库中不存在users集合</p>
<p>使用mongoimport命令会<strong>自动创建users集合</strong></p>
<ul>
<li>集合规则根据json文件中的json对象设置</li>
</ul>
<p>此处json文件中是一个包含三个json对象作为元素的数组</p>
<ul>
<li>所以使用<code>--jsonArray</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mongoimport -d test -c users --jsonArray .\要导入的文件\user.json</span><br></pre></td></tr></table></figure>

<center>.json文件内容</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511233918423.png" alt="image-20210511233918423"></p>
<center>导入成功</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511234355272.png" alt="image-20210511234355272"></p>
<center>compass软件</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511234514655.png" alt="image-20210511234514655"></p>
<p>test数据库下自动创建users集合并写入3个文档</p>
<br>

<p><strong>当json文件中存放单个json对象时，导入命令如下</strong></p>
<p>使用–file</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mongoimport -d test -c users --file .\要导入的文件\user.json</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511234828596.png" alt="image-20210511234828596"></p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511234837217.png" alt="image-20210511234837217"></p>
<br>

<h3 id="2-5数据库的查询"><a href="#2-5数据库的查询" class="headerlink" title="2.5数据库的查询"></a>2.5数据库的查询</h3><p>查询文档两种方式：</p>
<ul>
<li>使用集合构造函数的<strong>find()方法</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Course为集合的构造函数</span></span><br><span class="line"><span class="keyword">const</span> Course = mongoose.model(<span class="string">&#x27;Course&#x27;</span>,courseSchema);<span class="comment">//courses</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查询集合中所有的文档(当find方法没有参数时)</span></span><br><span class="line">Course.find().then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p>find()方法<strong>默认返回promise对象</strong></p>
<p>promise对象的then方法接收的<strong>查询结果为一个数组</strong></p>
<p>数组中的元素为查询到的文档的JSON对象表示，当查询不到任何文档时返回空数组</p>
<p>find()方法使用<strong>一个JSON对象作为参数</strong>，json对象中属性即为查找条件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Course.find(&#123;<span class="attr">name</span>: <span class="string">&quot;Javascript&quot;</span>&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p><code>&#123;name: &quot;Javascript&quot;&#125;</code>即为查找name字段值为Javascript的文档</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512213042106.png" alt="image-20210512213042106"></p>
<br>

<ul>
<li><p>使用集合构造函数的<strong>findOne()方法</strong></p>
<ul>
<li><p>findOne()方法<strong>查询结果为一个JSON对象</strong>，而find()方法<strong>查询结果为一个包含0或多个JSON对象的数组</strong></p>
</li>
<li><p>findOne()方法和find()方法都默认返回promise对象，使用promise对象的then方法获取执行结果</p>
</li>
<li><p>findOne()方法和find()方法的参数设置格式相同</p>
</li>
<li><p>当findOne()方法<strong>没有参数时</strong>返回集合中的第一个文档的JSON对象</p>
</li>
<li><p><strong>有参数时</strong>会返回满足参数条件的第一个文档的JSON对象</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Course.findOne(&#123;<span class="attr">name</span>: <span class="string">&quot;Javascript123&quot;</span>&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512213745252.png" alt="image-20210512213745252"></p>
<br>

<h4 id="2-5-1按范围查询"><a href="#2-5-1按范围查询" class="headerlink" title="2.5.1按范围查询"></a>2.5.1按范围查询</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.find(&#123;<span class="attr">age</span>:&#123;<span class="attr">$gt</span>:<span class="number">21</span>,<span class="attr">$lt</span>:<span class="number">23</span>&#125;&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p>将作为find()方法参数的JSON对象中的<strong>属性值改为表示匹配信息JSON的对象</strong></p>
<p><code>&#123;age:&#123;$gt:21,$lt:23&#125;&#125;</code></p>
<ul>
<li>$gt代表大于</li>
<li>$lt代表小于</li>
</ul>
<p>表示匹配age字段值大于21，小于23的文档</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512221148976.png" alt="image-20210512221148976"></p>
<br>

<h4 id="2-5-2按匹配包含查询"><a href="#2-5-2按匹配包含查询" class="headerlink" title="2.5.2按匹配包含查询"></a>2.5.2按匹配包含查询</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.find(&#123;<span class="attr">hobbies</span>:&#123;<span class="attr">$in</span>:[<span class="string">&#x27;篮球&#x27;</span>]&#125;&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p><code>&#123;hobbies:&#123;$in:[&#39;篮球&#39;]&#125;&#125;</code></p>
<p>匹配hobbies字段中包含篮球的文档，数组中可以填写多个包含项</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512221742490.png" alt="image-20210512221742490"></p>
<br>

<h4 id="2-5-3选择查询的字段"><a href="#2-5-3选择查询的字段" class="headerlink" title="2.5.3选择查询的字段"></a>2.5.3选择查询的字段</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.find().select(<span class="string">&quot;name age&quot;</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p>对find()方法<strong>返回的promise对象使用select()方法</strong>选择要查询的字段名</p>
<ul>
<li><p>_id字段是每次查询时默认要查询的字段</p>
</li>
<li><p>在select方法的参数字段名前加<code>-</code>意味着查询时不显示这个字段</p>
</li>
<li><p><code>select(&quot;name age -_id&quot;)</code>即意味着查询name，age字段，不查询_id字段</p>
</li>
</ul>
<p><code>&quot;name age&quot;</code>要查询的字段名作为select方法的参数，字段名用空格隔开</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512222153159.png" alt="image-20210512222153159"></p>
<br>

<h4 id="2-5-4对查询结果按照某字段排序"><a href="#2-5-4对查询结果按照某字段排序" class="headerlink" title="2.5.4对查询结果按照某字段排序"></a>2.5.4对查询结果按照某字段排序</h4><p>查询商品的信息时会使用排序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.find().sort(<span class="string">&quot;age&quot;</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p>对find()方法<strong>返回的promise对象使用sort()方法</strong>进行排序</p>
<ul>
<li>按照sort()方法的参数填写的字段名排序<ul>
<li>字段名前加<code>-</code>即意为降序排序</li>
<li>不加<code>-</code>即意为升序排序</li>
</ul>
</li>
</ul>
<center>按年龄升序排序</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512222459529.png" alt="image-20210512222459529"></p>
<br>

<center>年龄降序排序</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.find().sort(<span class="string">&quot;-age&quot;</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512222552276.png" alt="image-20210512222552276"></p>
<br>

<h4 id="2-5-5查询时跳过数据，限制查询数量"><a href="#2-5-5查询时跳过数据，限制查询数量" class="headerlink" title="2.5.5查询时跳过数据，限制查询数量"></a>2.5.5查询时跳过数据，限制查询数量</h4><p>limit()和skip()方法结合使用可以实现分页功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//跳过第1条文档，查询最多2条文档</span></span><br><span class="line">User.find().skip(<span class="number">1</span>).limit(<span class="number">2</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p>对find()方法<strong>返回的promise对象</strong></p>
<ul>
<li>使用skip()方法设置<strong>跳过多少条数据</strong></li>
<li>使用limit()方法设置<strong>最多查询多少条数据</strong></li>
</ul>
<center>总共四条数据，跳过一条查询两条</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512222941101.png" alt="image-20210512222941101"></p>
<br>

<h3 id="2-6数据库文档的删除"><a href="#2-6数据库文档的删除" class="headerlink" title="2.6数据库文档的删除"></a>2.6数据库文档的删除</h3><h4 id="2-6-1删除单个文档"><a href="#2-6-1删除单个文档" class="headerlink" title="2.6.1删除单个文档"></a>2.6.1删除单个文档</h4><p>使用集合构造函数的findOneAndDelete()方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找并删除匹配的第一条文档</span></span><br><span class="line">User.findOneAndDelete(&#123;<span class="attr">_id</span>:<span class="string">&#x27;609bdfc298ed4e560fe78266&#x27;</span>&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<ul>
<li>查找并删除<strong>匹配的第一条文档</strong></li>
<li>此例删除_id字段为’609bdfc298ed4e560fe78266’的文档</li>
<li>result为被删除文档的<strong>JSON对象</strong></li>
<li>参数为空则会删除集合中的第一个元素</li>
</ul>
<br>

<h4 id="2-6-2删除多个文档"><a href="#2-6-2删除多个文档" class="headerlink" title="2.6.2删除多个文档"></a>2.6.2删除多个文档</h4><p>使用集合构造函数的deleteMany()方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.deleteMany(&#123;<span class="attr">hobbies</span>:&#123;<span class="attr">$in</span>:<span class="string">&#x27;足球&#x27;</span>&#125;&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<ul>
<li>一次删除满足条件的所有文档</li>
<li>本例删除所有hobbies字段中<strong>包含’足球’的文档</strong></li>
<li>参数为空时会<strong>删除集合中所有文档</strong></li>
<li>result为一个对象，包含<strong>三个属性</strong><ul>
<li>ok: 1，值为1即表示删除成功</li>
<li>n: 2，2即表示删除了两个文档</li>
<li>deleteCount：2，删除计数为2</li>
</ul>
</li>
</ul>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210513224626695.png" alt="image-20210513224626695"></p>
<br>

<h3 id="2-7数据库文档修改"><a href="#2-7数据库文档修改" class="headerlink" title="2.7数据库文档修改"></a>2.7数据库文档修改</h3><h4 id="2-7-1修改单个文档"><a href="#2-7-1修改单个文档" class="headerlink" title="2.7.1修改单个文档"></a>2.7.1修改单个文档</h4><p>使用集合构造函数的<code>updateOne()</code>方法</p>
<ul>
<li>updateOne(‘查询条件’,’要修改的值’)</li>
<li>只能修改一个匹配文档</li>
<li>返回promise对象</li>
<li>执行结果result为一个对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.updateOne(&#123;<span class="attr">name</span>:<span class="string">&quot;杨启明&quot;</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&quot;杨启明1&quot;</span>&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p>找到name字段值为杨启明的文档，修改其name字段值为杨启明1</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517212114554.png" alt="image-20210517212114554"></p>
<center>上图红框即为result表示的对象</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517212203837.png" alt="image-20210517212203837"></p>
<h4 id="2-7-2修改多个文档"><a href="#2-7-2修改多个文档" class="headerlink" title="2.7.2修改多个文档"></a>2.7.2修改多个文档</h4><p>集合构造函数的updateMany()方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.updateMany(&#123;&#125;,&#123;<span class="attr">age</span>:<span class="number">18</span>&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p>第一个参数为空对象即为修改集合中的所有文档</p>
<p>将集合中所有文档中的age字段值改为18</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517212536168.png" alt="image-20210517212536168"></p>
<br>

<h3 id="2-8Mongoose验证"><a href="#2-8Mongoose验证" class="headerlink" title="2.8Mongoose验证"></a>2.8Mongoose验证</h3><p>Mongoose在创建集合规则时可以<strong>为文档的字段设定验证条件</strong>，不满足验证条件的文档在存入数据库时会报错</p>
<p>字段的验证条件在<strong>设定集合规则</strong>时指定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> postSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    <span class="comment">//name:&#123;&#125; JSON对象中写name字段的具体验证要求</span></span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        required:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-8-1-required规则"><a href="#2-8-1-required规则" class="headerlink" title="2.8.1 required规则"></a>2.8.1 required规则</h4><p>required规则取值可以有两种</p>
<ul>
<li>boolean值</li>
<li>数组(数组中可以自定义报错信息)</li>
</ul>
<p><strong>1.require规则值为boolean值</strong></p>
<p><code>required:true</code>代表该字段是必须的(mongoose默认规定字段可以为空)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将一个空文档存入数据库</span></span><br><span class="line">Post.create(&#123;&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517214350607.png" alt="image-20210517214350607"></p>
<center>红框报错，name字段是必须的</center>

<br>

<p><strong>当没有设置required字段为true时</strong></p>
<p>将空文档存入数据库也不会报错</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517214658740.png" alt="image-20210517214658740"></p>
<center>红框即为存入的空文档</center>

<br>

<p><strong>2.required规则值为数组</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> postSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    <span class="comment">//name:&#123;&#125; JSON对象中写name字段的具体验证要求</span></span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">//required规则值为数组</span></span><br><span class="line">        required:[</span><br><span class="line">            <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&#x27;请填入必填项标题&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>数组第一个元素为是否为必填项</p>
<p>第二个参数为报错信息</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517215346089.png" alt="image-20210517215346089"></p>
<center>报错信息变为'请填入必填项标题'</center>

<h4 id="2-8-2-字段长度限制"><a href="#2-8-2-字段长度限制" class="headerlink" title="2.8.2 字段长度限制"></a>2.8.2 字段长度限制</h4><p><strong>针对于type为String的字段值</strong></p>
<p><strong>minlength</strong>规则：限制最小长度</p>
<p><strong>maxlength</strong>规则：限制最大长度</p>
<p>同样规则值可以为数组，第二个元素为报错信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> postSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    <span class="comment">//name:&#123;&#125; JSON对象中写name字段的具体验证要求</span></span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        required:[</span><br><span class="line">            <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&#x27;请填入必填项标题&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">//最小长度为2</span></span><br><span class="line">        minlength:[<span class="number">2</span>,<span class="string">&#x27;输入值小于最小长度2&#x27;</span>],</span><br><span class="line">        <span class="comment">//最大长度为5</span></span><br><span class="line">        maxlength:[<span class="number">5</span>,<span class="string">&#x27;输入值大于最大长度5&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个文档name字段值为&#x27;helloworld&#x27;，并存入数据库</span></span><br><span class="line">Post.create(&#123;<span class="attr">name</span>:<span class="string">&#x27;helloworld&#x27;</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517215830774.png" alt="image-20210517215830774"></p>
<center>长度大于5报错</center>

<br>

<h4 id="2-8-3-trim规则"><a href="#2-8-3-trim规则" class="headerlink" title="2.8.3 trim规则"></a>2.8.3 trim规则</h4><p>trim：规定是否去除字符串两边多余的空格</p>
<p>trim规则的值为boolean值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> postSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    <span class="comment">//name:&#123;&#125; JSON对象中写name字段的具体验证要求</span></span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        required:[</span><br><span class="line">            <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&#x27;请填入必填项标题&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">        minlength:[<span class="number">2</span>,<span class="string">&#x27;输入值小于最小长度2&#x27;</span>],</span><br><span class="line">        maxlength:[<span class="number">5</span>,<span class="string">&#x27;输入值大于最大长度5&#x27;</span>],</span><br><span class="line">        trim:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//name字段值为&#x27;   a bc  &#x27;</span></span><br><span class="line">Post.create(&#123;<span class="attr">name</span>:<span class="string">&#x27;   a bc  &#x27;</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br></pre></td></tr></table></figure>

<p>代码中设置name字段值为’       a bc   ‘</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517220251295.png" alt="image-20210517220251295"></p>
<center>消除多余空格后的文档数据</center>

<br>

<h4 id="2-8-4数值大小限制"><a href="#2-8-4数值大小限制" class="headerlink" title="2.8.4数值大小限制"></a>2.8.4数值大小限制</h4><p>针对于type为Number的字段值</p>
<p>min：最小数值</p>
<p>max：最大数值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">age:&#123;</span><br><span class="line">       type:<span class="built_in">Number</span>,</span><br><span class="line">       <span class="comment">//数值最小值  Number类型</span></span><br><span class="line">       min:<span class="number">18</span>,</span><br><span class="line">       <span class="comment">//数值最大值</span></span><br><span class="line">       max:<span class="number">70</span>,</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>

<br>

<h4 id="2-8-5默认值设置"><a href="#2-8-5默认值设置" class="headerlink" title="2.8.5默认值设置"></a>2.8.5默认值设置</h4><p>使用<strong>default</strong>设置字段默认值，在没有显式创建这个字段时，字段会使用默认值创建</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">publishDate:&#123;</span><br><span class="line"></span><br><span class="line">    type:<span class="built_in">Date</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:<span class="built_in">Date</span>.now</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>publishDate字段的默认值为当前时间</p>
<p>Date内置对象的now属性可以获取当前时间</p>
<br>

<h4 id="2-8-6枚举设置"><a href="#2-8-6枚举设置" class="headerlink" title="2.8.6枚举设置"></a>2.8.6枚举设置</h4><p>使用enmu设置字段<strong>可选的值</strong>，字段的值<strong>不在enmu设定的值中会报错</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">category:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">//枚举值(该字段可选的值)</span></span><br><span class="line">        enum:[<span class="string">&#x27;小说&#x27;</span>,<span class="string">&#x27;散文&#x27;</span>,<span class="string">&#x27;说明文&#x27;</span>]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>category字段的可选值为小说、散文和说明文</p>
<p>enum属性的值也可以是一个对象</p>
<p>values：可选的值数组</p>
<p>message：自定义错误信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum:&#123;</span><br><span class="line">            values: [<span class="string">&#x27;小说&#x27;</span>,<span class="string">&#x27;散文&#x27;</span>,<span class="string">&#x27;说明文&#x27;</span>],</span><br><span class="line">            message: <span class="string">&#x27;不在可选范围内&#x27;</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="2-8-7自定义验证规则"><a href="#2-8-7自定义验证规则" class="headerlink" title="*2.8.7自定义验证规则"></a>*2.8.7自定义验证规则</h4><p>validate：自定义规则,为一个JSON对象</p>
<p>validator：自定义规则验证函数，是validate的元素</p>
<ul>
<li>返回boolean值</li>
<li>true代表验证成功，false代表失败</li>
<li>v即为要验证的字段值</li>
</ul>
<p>message：自定义报错信息，是validate的元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">author:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">//自定义验证规则</span></span><br><span class="line">        validate:&#123;</span><br><span class="line">            <span class="comment">//进行验证的函数</span></span><br><span class="line">            validator:<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//返回boolean值</span></span><br><span class="line">                <span class="comment">//true代表验证成功，false代表失败</span></span><br><span class="line">                <span class="comment">//v即为要验证的字段值</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//v的值小于4即验证通过</span></span><br><span class="line">                <span class="keyword">return</span> v &amp;&amp; v.length&lt;<span class="number">4</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//自定义规则报错信息</span></span><br><span class="line">            message:<span class="string">&#x27;不满足作者字段验证条件&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Post.create(&#123;<span class="attr">name</span>:<span class="string">&#x27;01&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">category</span>:<span class="string">&#x27;小说&#x27;</span>,<span class="attr">author</span>:<span class="string">&#x27;abc&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br></pre></td></tr></table></figure>

<center>创建并保存包含4个字段的文档</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517224430291.png" alt="image-20210517224430291"></p>
<center>保存成功</center>

<ul>
<li>name字段：必填项验证</li>
<li>age字段：数值大小验证</li>
<li>category字段：enmu枚举验证</li>
<li>author字段：自定义验证(长度小于4)</li>
<li>publishDate字段：没有显式创建，使用默认值自动创建</li>
</ul>
<br>

<h4 id="2-8-8通过代码获得错误信息"><a href="#2-8-8通过代码获得错误信息" class="headerlink" title="2.8.8通过代码获得错误信息"></a>2.8.8通过代码获得错误信息</h4><p>集合构造函数的create()方法返回<strong>promise对象</strong></p>
<p>可以使用promise的<strong>then方法</strong>获取执行结果</p>
<p>可以使用promise的<strong>catch方法</strong>获取错误信息</p>
<ul>
<li>catch获取的错误信息以对象的形式返回</li>
</ul>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210518205149772.png" alt="image-20210518205149772"></p>
<center>catch方法返回的对象</center>

<p>具体错误信息提示放在错误对象的errors属性中</p>
<p>如果有多个错误，例如：category字段和author字段都错误</p>
<p>errors中就会嵌套两个相应的错误字段对象</p>
<p>错误字段对象下的properties对象中的message属性存放的就是定义的message错误信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Post.create(&#123;<span class="attr">name</span>:<span class="string">&#x27;01&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">category</span>:<span class="string">&#x27;小说1&#x27;</span>,<span class="attr">author</span>:<span class="string">&#x27;abcde&#x27;</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="comment">//获取错误对象下的errors属性</span></span><br><span class="line">        <span class="keyword">var</span> errin = err.errors</span><br><span class="line">        <span class="comment">//循环每个错误字段对象(categoty和author对象)取其properties对象中的message属性</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> errin)</span><br><span class="line">        	<span class="built_in">console</span>.log(errin[i].properties.message);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210518212854641.png" alt="image-20210518212854641"></p>
<center>取得的message错误信息</center>

<br>

<h3 id="2-9集合关联"><a href="#2-9集合关联" class="headerlink" title="2.9集合关联"></a>2.9集合关联</h3><p>有时数据库的两个集合存在关联</p>
<p>例如<strong>posts文章集合</strong>中文档有一个字段是作者<strong>author</strong></p>
<p><strong>users用户集合</strong>中的用户信息即为<strong>作者信息</strong></p>
<p>在查询posts集合中文档的<strong>作者author信息</strong>时，就需要<strong>关联users集合</strong></p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210518220527147.png" alt="image-20210518220527147"></p>
<center>关联时在posts集合文档的author字段存入users集合文档的_id</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设定user集合规则</span></span><br><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设定post集合规则</span></span><br><span class="line"><span class="keyword">const</span> postSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    title:<span class="built_in">String</span>,</span><br><span class="line">    author:&#123;</span><br><span class="line">        type:mongoose.Schema.Types.ObjectId,</span><br><span class="line">        ref:<span class="string">&#x27;User&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>创建两个集合</center>

<br>

<h4 id="2-9-1使用字段设置关联信息"><a href="#2-9-1使用字段设置关联信息" class="headerlink" title="2.9.1使用字段设置关联信息"></a>2.9.1使用字段设置关联信息</h4><p>posts集合的author字段关联users集合</p>
<ul>
<li><p>author字段的<strong>值类型</strong>为<code>mongoose.Schema.Types.ObjectId</code>，即为文档**_id字段的类型**</p>
</li>
<li><p>ref属性的值为<strong>与本集合关联的集合的构造函数</strong>，此处与posts集合关联的集合为users集合(User为users集合构造函数)</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关联一个文档</span></span><br><span class="line">author:&#123;</span><br><span class="line">        type:mongoose.Schema.Types.ObjectId,</span><br><span class="line">        ref:<span class="string">&#x27;User&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义数组关联多个文档(购物车实例)</span></span><br><span class="line">author:[&#123;</span><br><span class="line">      	type:mongoose.Schema.Types.ObjectId,</span><br><span class="line">        ref:<span class="string">&#x27;User&#x27;</span>  </span><br><span class="line">    &#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">//关联了两个users集合中的文档 </span></span><br><span class="line">Post.create(&#123;<span class="attr">title</span>:<span class="string">&#x27;Firstpost&#x27;</span>,<span class="attr">author</span>:[<span class="string">&#x27;60bec059f4f10041f482247c&#x27;</span>,<span class="string">&#x27;60bec059f4f10041f482247d&#x27;</span>]&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br></pre></td></tr></table></figure>

<center>红框即为关联的user集合文档的_id字段值</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210518220222814.png" alt="image-20210518220222814"></p>
<center>右侧为user集合中的文档</center>

<h4 id="2-9-2-populate-方法查询关联字段信息"><a href="#2-9-2-populate-方法查询关联字段信息" class="headerlink" title="2.9.2 populate()方法查询关联字段信息"></a>2.9.2 populate()方法查询关联字段信息</h4><p>此时posts集合文档中的author字段存储的是users集合中文档的_id值，不方便查看作者信息</p>
<p>使用populate()方法<strong>在查询文档时将关联字段的信息一并查询出来</strong></p>
<ul>
<li>参数即为用来设置关联信息的字段author</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Post.find().populate(<span class="string">&#x27;author&#x27;</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210518221746819.png" alt="image-20210518221746819"></p>
<p>此时查询出的posts集合中的文档<strong>author字段值为 关联的users集合中对应文档的JSON对象</strong>，方便查看</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Mongodb数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>01-Vue</title>
    <url>/2021/09/10/01-Vue/</url>
    <content><![CDATA[<h1 id="Vue学习"><a href="#Vue学习" class="headerlink" title="Vue学习"></a>Vue学习</h1><h2 id="1-什么是Vue"><a href="#1-什么是Vue" class="headerlink" title="1.什么是Vue"></a>1.什么是Vue</h2><ul>
<li>2014年Vue.js正式发布</li>
<li>15年10月27日，正式发布1.0.0</li>
<li>16年4月27日，<strong>发布2.0的预览版本</strong>（主要学习的版本）</li>
<li>现在已经有<strong>3.0</strong>版本的Vue</li>
</ul>
<span id="more"></span>

<p>Vue是一个<strong>渐进式Javascript框架</strong></p>
<p><a href="https://cn.vuejs.org/">Vue官方网站</a></p>
<ul>
<li><strong>框架</strong>：主要提供一些基础性的服务如 <strong>虚拟DOM</strong>和<strong>双向数据绑定</strong>等 节省实际开发代码量</li>
<li>库：主要提供大量的API 如jQuery等 现在<strong>库和框架的界限已经不明显</strong></li>
<li><strong>渐进式</strong>：声明式渲染 -&gt; 组件系统 -&gt; 客户端路由 -&gt; 集中式状态管理 -&gt; 项目构建<ul>
<li>从左至右Vue的使用逐渐深入，项目规模逐渐增大</li>
</ul>
</li>
</ul>
<p>Vue的<strong>主要优点</strong></p>
<ul>
<li>易用：熟悉HTML，CSS和JavaScript后可快速上手Vue</li>
<li>灵活：在一个库和一个框架之间伸缩</li>
<li>高效：20KB运行大小，超快虚拟DOM</li>
</ul>
<br>

<h2 id="2-Hello-Vue简单程序"><a href="#2-Hello-Vue简单程序" class="headerlink" title="2. Hello Vue简单程序"></a>2. Hello Vue简单程序</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello Vue<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入Vue.js框架 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用插值表达式完成Vue的输出 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Vue的插值表达式中可以完成原生js表达式的基本运算 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;1 + 2&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg+&#x27;123&#x27;&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//创建Vue实例</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//el:元素挂载位置 （css选择器或者DOM对象）</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//data：模型数据 值是对象 可以存放键值对类型的数据</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> test = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&#x27;#add&#x27;</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                msg:<span class="string">&#x27;Hello Vue&#x27;</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在官方网站下载<strong>开发版的Vue.js文件</strong><ul>
<li>文件的引入方式类似jQuery.js</li>
</ul>
</li>
</ul>
<br>

<ol>
<li>使用Vue时要<strong>创建Vue实例</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">&#x27;#add&#x27;</span>,</span><br><span class="line">            data:&#123;</span><br><span class="line">                msg:<span class="string">&#x27;Hello Vue&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>el</strong>：元素挂载位置 （css选择器或者DOM对象），即Vue的输出在哪个HTML标签中</li>
<li><strong>data</strong>：模型数据 值是对象 可以存放键值对类型的数据</li>
</ul>
<br>

<ol start="2">
<li>输出Vue数据时使用<strong>插值表达式</strong></li>
</ol>
<ul>
<li><strong>插值表达式</strong>： msg为模型数据中的数据<ul>
<li>插值表达式将数值填充到HTML标签中</li>
<li>也可以完成<strong>基本的计算操作</strong>（如加减和字符串拼接等）</li>
</ul>
</li>
<li>使用Vue进行输出时<strong>不需要书写底层的操作DOM的代码</strong>，简化了开发流程</li>
</ul>
<ol start="3">
<li><p>Vue代码运行原理</p>
<p>Vue框架将<strong>Vue代码转换为原生js代码</strong>运行</p>
<p>称为编译过程</p>
</li>
</ol>
<h2 id="3-Vue模板语法"><a href="#3-Vue模板语法" class="headerlink" title="3. Vue模板语法"></a>3. Vue模板语法</h2><p>Vue<strong>有着自己的一套语法规则</strong>，就像<strong>前端模板引擎art-template</strong>有着自己的一套语法规则一样</p>
<p>模板语法所做的工作就是<strong>前端渲染</strong></p>
<h3 id="3-1-前端渲染"><a href="#3-1-前端渲染" class="headerlink" title="3.1 前端渲染"></a>3.1 前端渲染</h3><p>前端渲染就是<strong>把数据填充到HTML标签中</strong></p>
<p>将<strong>数据和模板结合进行前端渲染</strong>，最后得到静态HTML内容</p>
<br>

<h3 id="3-2-前端渲染的方式"><a href="#3-2-前端渲染的方式" class="headerlink" title="3.2 前端渲染的方式"></a>3.2 前端渲染的方式</h3><ul>
<li>原生js拼接字符串</li>
<li>使用前端模板引擎art-templat</li>
<li>使用Vue特有的模板语法</li>
</ul>
<h4 id="3-2-1-原生js拼接字符串"><a href="#3-2-1-原生js拼接字符串" class="headerlink" title="3.2.1 原生js拼接字符串"></a>3.2.1 原生js拼接字符串</h4><p>将数据<strong>以字符串的方式拼接</strong>并显示在HTML标签中</p>
<p><strong>缺点</strong>：不同开发人员的代码风格不同，导致项目<strong>后期维护困难</strong></p>
<h4 id="3-2-2-前端模板引擎"><a href="#3-2-2-前端模板引擎" class="headerlink" title="3.2.2 前端模板引擎"></a>3.2.2 前端模板引擎</h4><p>例如art-template模板引擎</p>
<ul>
<li>使用<strong>自己的一套模板语法规则</strong></li>
<li>代码规范程度高，易于维护</li>
</ul>
<p><strong>缺点</strong>：没有提供专门的<strong>事件机制</strong>，需要使用原始的方法实现事件绑定等操作</p>
<h4 id="3-2-3-Vue特有模板语法"><a href="#3-2-3-Vue特有模板语法" class="headerlink" title="3.2.3 Vue特有模板语法"></a>3.2.3 Vue特有模板语法</h4><p>Vue模板的特有语法更加易用，解决了上述渲染方式的缺点</p>
<ul>
<li>插值表达式</li>
<li><strong>指令</strong></li>
<li>事件绑定</li>
<li>属性绑定</li>
<li>样式绑定</li>
<li>分支循环结构</li>
</ul>
<br>

<h3 id="3-3-Vue指令"><a href="#3-3-Vue指令" class="headerlink" title="3.3 Vue指令"></a>3.3 Vue指令</h3><ul>
<li>Vue指令本质就是自定义属性</li>
<li>自定义属性：<ul>
<li>H5规定的自定义属性如 <strong>data-</strong></li>
<li>普通的自定义属性如 <strong>abc=’123’</strong></li>
</ul>
</li>
<li>Vue指令<strong>以v-开始</strong> （例如v-cloak）</li>
</ul>
<h4 id="3-3-1-v-cloak指令"><a href="#3-3-1-v-cloak指令" class="headerlink" title="3.3.1 v-cloak指令"></a>3.3.1 v-cloak指令</h4><ul>
<li><p>插值表达式存在<strong>闪动现象</strong></p>
<ul>
<li>闪动：即在<strong>快速刷新浏览器或者浏览器卡顿</strong>时，对于插值表达式<strong>可能会先在浏览器显示<strong>，</strong>再被替换为真正的数据</strong></li>
<li><strong>Vue在渲染数据时</strong>实际是先将放到HTML标签中，然后再迅速替换为真正的数据，所以会出现闪动的情况</li>
</ul>
</li>
<li><p>指令的<strong>本质就是自定义属性</strong></p>
</li>
<li><p>使用<strong>v-cloak指令</strong>可以解决闪动的问题</p>
<ul>
<li>可以先将该插值表达式隐藏，等待在内存中完成替换后一次显示最终结果</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/* v-cloak指令可以解决插值表达式的闪动问题 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-attr">[v-cloak]</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>:none;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在style标签中使用属性选择器设置指令<ul>
<li>[v-cloak]即为css中的属性选择器</li>
</ul>
</li>
<li>在<strong>渲染的标签中</strong>作为<strong>自定义属性</strong>加入该指令</li>
</ul>
<h4 id="3-3-2-数据绑定指令"><a href="#3-3-2-数据绑定指令" class="headerlink" title="3.3.2 数据绑定指令"></a>3.3.2 数据绑定指令</h4><ul>
<li>v-text</li>
<li>v-html</li>
<li>v-pre</li>
</ul>
<ol>
<li><p><strong>v-text</strong></p>
<p>填充纯文本，与直接使用插值表达式效果相同，并且没有闪动问题</p>
<p>相比于插值表达式更加简洁</p>
<p>v-text属性值为data中的数据变量</p>
</li>
<li><p><strong>v-html</strong></p>
<p>填充html代码片段</p>
<p>使用这个指令渲染的数据中的<strong>html标签会被浏览器解析</strong></p>
<p>v-html属性值为data中的数据变量</p>
<p><strong>注意：</strong></p>
<ul>
<li>有安全问题</li>
<li>只有数据来源是本网站时使用，来自<strong>第三方的数据不可用</strong>（容易被xss攻击）</li>
</ul>
</li>
<li><p><strong>v-pre</strong></p>
<p>填充原始信息</p>
<p>将要输出的数据原封不同的显示在页面中，<strong>不经过Vue框架渲染</strong></p>
<p>使用v-pre输出时，页面中会直接显示</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 插值表达式 --&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;!-- 填充纯文本数据 --&gt;</span><br><span class="line">&lt;div v-text=<span class="string">&#x27;msg&#x27;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;!-- 填充HTML片段 --&gt;</span><br><span class="line">&lt;div v-html=<span class="string">&#x27;msg1&#x27;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;!-- 填充原始信息(不通过Vue框架解析) --&gt;</span><br><span class="line">&lt;div v-pre&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data:&#123;</span><br><span class="line">    	msg:<span class="string">&#x27;Hello Vue&#x27;</span>,</span><br><span class="line">        msg1:<span class="string">&#x27;&lt;h1&gt;Hello Vue&lt;/h1&gt;&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/01-Vue/image-20210910190456163-1632056227618.png" alt="三种指令显示结果"></p>
<h4 id="3-3-3-数据响应式"><a href="#3-3-3-数据响应式" class="headerlink" title="3.3.3 数据响应式"></a>3.3.3 数据响应式</h4><ol>
<li><p><strong>何为响应式</strong></p>
<p>html5响应式布局：屏幕尺寸的变化导致样式的变化</p>
<p><strong>数据响应式</strong>：数据的变化导致页面内容的变化（具有响应式功能的数据<strong>在浏览器控制台被修改时</strong>，页面中会同步改变）</p>
</li>
<li><p><strong>数据绑定</strong></p>
<p>将数据填充到html标签的过程</p>
</li>
<li><p><strong>v-once指令</strong></p>
<p>只编译一次</p>
<p>即有这个属性的标签<strong>在数据绑定完成后就不再具有响应式的功能</strong>，在l浏览器控制台修改时，页面不会变化</p>
<ul>
<li>可以让Vue框架不必一直监听该数据，提高性能</li>
</ul>
</li>
</ol>
<h4 id="3-3-4-双向数据绑定"><a href="#3-3-4-双向数据绑定" class="headerlink" title="3.3.4 双向数据绑定"></a>3.3.4 双向数据绑定</h4><p><strong>数据绑定是单向的</strong>：即模板数据-&gt;页面（模板数据发生变化后页面也跟着发生变化）</p>
<p><strong>双向数据绑定</strong>：用户修改数据时，对应的模板数据值也发生变化，这<strong>与数据绑定的单向一起称为双向数据绑定</strong></p>
<ul>
<li><p>双向数据绑定多用于用户交互的场景中，例如文本输入框</p>
</li>
<li><p>实现双向数据绑定<strong>使用指令v-model</strong></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 插值表达式 --&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;!-- 双向数据绑定文本输入框 --&gt;</span><br><span class="line">&lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>文本输入框的v-model属性代表 当前<strong>文本输入框的内容</strong>与<strong>模板数据msg</strong>双向绑定</li>
</ul>
<p><img data-src="/images/01-Vue/image-20210910192914355-1632056227619.png"></p>
<ul>
<li>当用户修改文本框中的内容时，上方渲染的模板数据内容同步变化</li>
<li>当控制台更改模板数据msg时，文本输入框的内容也会跟着变化</li>
</ul>
<h4 id="3-3-5-MVVM思想"><a href="#3-3-5-MVVM思想" class="headerlink" title="3.3.5 MVVM思想"></a>3.3.5 MVVM思想</h4><p><strong>MVVM思想是Vue的核心设计思想</strong></p>
<p>将不同功能代码放在不同的模块（模块化），再通过特定方式在它们之间建立联系</p>
<p>**M(model)**：模型，即数据</p>
<p>**V(view)**：视图，即模板</p>
<p>**VM(view-model)**：联系view和model的控制逻辑</p>
<p><img data-src="/images/01-Vue/image-20210910193805108-1632056227619.png" alt="view-model"></p>
<ul>
<li>view视图模板的变化通过<strong>DOM监听事件</strong>去联系修改model中的数据<ul>
<li>v-model指令底层用到了事件监听</li>
<li><strong>文本框变化影响模板数据值就使用了事件监听</strong></li>
</ul>
</li>
<li>model中的数据通过上面提到过的<strong>数据绑定</strong>影响view的显示</li>
<li>view-model就是完成上述工作的<strong>控制逻辑</strong></li>
</ul>
<br>

<h4 id="3-3-6-事件绑定"><a href="#3-3-6-事件绑定" class="headerlink" title="3.3.6 事件绑定"></a>3.3.6 事件绑定</h4><p>Vue使用<strong>v-on</strong>指令处理事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue使用v-on指令事件绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&#x27;num++&#x27;</span>&gt;</span>num++<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- v-on指令的简化写法 v-on:替换为@ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;num++&#x27;</span>&gt;</span>num++<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>v-on:&#39;标准事件名&#39;=&#39;表达式或函数&#39;</code></p>
<ul>
<li>标准事件名即click,blur等</li>
<li>表达式或函数，即可以直接写代码作为事件处理函数，也可以传递自定义函数作为处理函数</li>
<li>v-on: 可以简化为@</li>
</ul>
<p>在处理函数处直接写代码显然是不合适的，<strong>应该传递自定义函数做为处理函数</strong></p>
<p>Vue实例中的<strong>methods对象</strong>中存储自定义函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> test = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">&#x27;#add&#x27;</span>,</span><br><span class="line">            data:&#123;</span><br><span class="line">                num:<span class="number">0</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                sum:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="comment">//this即为Vue实例test</span></span><br><span class="line">                    <span class="built_in">this</span>.num++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 传递函数作为事件处理函数（仅传递函数名） --&gt;</span><br><span class="line">&lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;sum&#x27;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line">&lt;!-- 传递函数调用 --&gt;</span><br><span class="line">&lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;sum()&#x27;</span>&gt;</span>按钮4<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在Vue实例的methods方法中定义了<strong>sum函数</strong>实现num++的功能</p>
<ul>
<li><strong>this指的即为Vue实例test</strong></li>
</ul>
</li>
<li><p>使用函数作为事件处理函数时，有两种方式</p>
<ul>
<li>只传递函数名</li>
<li>传递函数调用</li>
</ul>
</li>
</ul>
<h4 id="3-3-7-事件参数传递"><a href="#3-3-7-事件参数传递" class="headerlink" title="3.3.7 事件参数传递"></a>3.3.7 事件参数传递</h4><p>3.3.6中提到事件绑定传递函数作为处理函数有两种方式</p>
<ul>
<li>传递函数名</li>
<li>传递函数调用</li>
</ul>
<ol>
<li><p><strong>传递函数名</strong></p>
<p>此时<strong>事件对象event默认作为函数的第一个参数传递</strong>（不需要显式传参），但此时<strong>不能传递其他参数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 传递函数作为事件处理函数（仅传递函数名） --&gt;</span><br><span class="line">        &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;sum1&#x27;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">sum1:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(event.target.innerHTML);</span><br><span class="line">                    <span class="built_in">this</span>.num++</span><br><span class="line">                &#125;,</span><br></pre></td></tr></table></figure></li>
<li><p><strong>传递函数调用</strong></p>
<p>此时<strong>可以传递除事件对象以外的参数</strong>，但是事件对象参数必须作为<strong>最后一个参数</strong>（必须显式传参），并且<strong>名为$event</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 传递函数调用 --&gt;</span><br><span class="line">        &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;sum2(1,$event)&#x27;</span>&gt;</span>按钮4<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line">            </span><br><span class="line">sum2:<span class="function"><span class="keyword">function</span>(<span class="params">p,event</span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(p)</span><br><span class="line">                    <span class="built_in">console</span>.log(event.target.innerHTML);</span><br><span class="line">                    <span class="built_in">this</span>.num++</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img data-src="/images/01-Vue/image-20210910201546753-1632056227619.png" alt="两种方式的事件绑定触发后结果"></p>
<h4 id="3-3-8-事件修饰符"><a href="#3-3-8-事件修饰符" class="headerlink" title="3.3.8 事件修饰符"></a>3.3.8 事件修饰符</h4><p>事件修饰符可以<strong>简化一些事件操作</strong>比如 <strong>阻止默认行为</strong>，<strong>阻止冒泡</strong>等（官网有详解）</p>
<p><code>v-on:click.&#39;时间修饰符&#39;</code></p>
<p>即可完成事件操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 阻止事件冒泡 --&gt;</span><br><span class="line">&lt;div @click=<span class="string">&#x27;sum2&#x27;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">&#x27;sum1&#x27;</span>&gt;</span>按钮4<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line">&lt;!-- 阻止默认行为 --&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;http://www.baidu.com&quot;</span> @click.prevent&gt;百度&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"> methods:&#123;</span><br><span class="line">                sum1:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">                   <span class="comment">//阻止冒泡</span></span><br><span class="line">                    <span class="comment">//event.stopPropagation()</span></span><br><span class="line">                &#125;,</span><br><span class="line">                sum2:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(event.target.innerHTML);</span><br><span class="line">                    <span class="built_in">this</span>.num++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>例如<code>v-on:click.stop</code>可以<strong>阻止事件冒泡</strong></p>
</li>
<li><p>例如<code>v-on:click.prevent</code>可以<strong>阻止事件默认行为</strong></p>
</li>
<li><p>事件修饰符还可以链式调用</p>
</li>
</ul>
<h4 id="3-3-9-按键修饰符"><a href="#3-3-9-按键修饰符" class="headerlink" title="3.3.9 按键修饰符"></a>3.3.9 按键修饰符</h4><p>主要用于<strong>键盘事件</strong>的筛选</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">&#x27;fn&#x27;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码即<strong>当文本输入框按下enter建时触发fn处理函数</strong></p>
<p>若不加enter则按下任意键都会触发fn函数</p>
<p>官方网站有所有按键修饰符的说明</p>
<h4 id="3-3-10-自定义按键修饰符"><a href="#3-3-10-自定义按键修饰符" class="headerlink" title="3.3.10 自定义按键修饰符"></a>3.3.10 自定义按键修饰符</h4><p>Vue官方<strong>提供的按键修饰符是有限的</strong>，当我们希望使用Vue官方没有的定义的按键修饰符时，可以自定义</p>
<ul>
<li>在script标签中使用下面代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给编号为65的按键a自定义一个按键修饰符f1</span></span><br><span class="line">Vue.config.keyCodes.f1 = <span class="number">65</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时按下f1按键修饰符代表的按键a,就会触发fn函数</span></span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-on:keyup.f1=<span class="string">&#x27;fn&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>f1即为<strong>自定义的按键修饰符名</strong></p>
<p>65为<strong>按键a</strong>在keyCode中的编号（每个按键都有一个唯一编号）（其中字母对应的keyCode值为<strong>该大写字母的ASC码值</strong>）</p>
<br>

<h4 id="3-3-11-属性绑定"><a href="#3-3-11-属性绑定" class="headerlink" title="3.3.11 属性绑定"></a>3.3.11 属性绑定</h4><p>Vue可以<strong>动态处理属性值</strong></p>
<p>就像之前学习过的<strong>getAttribute()和setAttribute()</strong></p>
<ul>
<li>使用v-bind指令动态修改属性值</li>
<li>v-bind简写为:</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-bind指令指定属性值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>百度1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- v-bind指令简写为: --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>百度2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 通过点击事件切换a标签跳转地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;handle&#x27;</span>&gt;</span>切换<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line">                handle:function()&#123;</span><br><span class="line">                    this.url=&#x27;http://itcast.cn&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="3-3-11-使用底层代码实现双向数据绑定"><a href="#3-3-11-使用底层代码实现双向数据绑定" class="headerlink" title="3.3.11 使用底层代码实现双向数据绑定"></a>3.3.11 使用底层代码实现双向数据绑定</h4><p>之前双向数据绑定使用了v-model指令</p>
<p>现在使用<strong>属性绑定 和 事件绑定</strong>写底层代码实现v-model指令的功能</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 底层代码实现双向数据绑定 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&#x27;msg&#x27;</span> <span class="attr">v-on:input</span>=<span class="string">&#x27;inputC&#x27;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 底层代码简写 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&#x27;msg&#x27;</span> <span class="attr">v-on:input</span>=<span class="string">&#x27;msg=$event.target.value&#x27;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用v-model指令实现双向数据绑定 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&#x27;msg&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                msg:<span class="string">&#x27;hello&#x27;</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line"><span class="javascript">                inputC:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.msg = event.target.value</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>v-on:input=&#39;inputC&#39;</code>指令可以简写为<code>v-on:input=&#39;msg=$event.target.value&#39;</code><ul>
<li>不使用处理函数而<strong>直接在指令中通过$event获取输入框的值覆盖模板数据</strong></li>
</ul>
</li>
<li>实际上v-model指令就是<strong>调用了v-bind指令进行属性绑定让文本框显示模板数据的值</strong>，并且<strong>在文本框输入时触发事件</strong>，在事件中获取文本框的值并覆盖模板数据</li>
<li>使用底层代码v-bind指令和v-on指令可以实现v-model的功能</li>
</ul>
<br>

<h4 id="3-3-11-样式绑定-class"><a href="#3-3-11-样式绑定-class" class="headerlink" title="3.3.11 样式绑定 class"></a>3.3.11 样式绑定 class</h4><ul>
<li>对象格式的样式绑定</li>
<li>数组格式的对象绑定</li>
</ul>
<ol>
<li><p><strong>对象格式的样式绑定</strong></p>
<p>使用属性绑定的<strong>指令v-bind修改class属性的值</strong>，即修改类名</p>
<p>可以指定该类是否应用在标签上</p>
<ul>
<li>v-bind:class的值为<strong>对象</strong>，对象中存<strong>储键值</strong>对</li>
<li>每个键值对中 <strong>键为类名</strong>，<strong>值为一个模板数据</strong></li>
<li>有<strong>多个样式则键值对用逗号隔开</strong></li>
<li>若<strong>模板数据为true</strong>则该类名所对应的<strong>样式应用</strong>，否则不应用</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        .div1&#123;</span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">1px</span> red solid;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .color&#123;</span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: YELLOW;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&#x27;&#123;div1:isDiv1,color:isColor&#125;&#x27;</span>&gt;</span>样式绑定测试<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&#x27;change&#x27;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                isDiv1:<span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">                isColor:<span class="literal">true</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line"><span class="javascript">                change:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.isDiv1 = !<span class="built_in">this</span>.isDiv1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>isDiv1和isColor两个模板数据默认为true，所以开始两个类名所对应的样式都应用在div上</li>
<li>点击按钮将模板数据取反则两个样式都不应用</li>
</ul>
<ol start="2">
<li><strong>数组格式的样式绑定</strong></li>
</ol>
<ul>
<li>v-bind:class的值为<strong>数组</strong>，数组中的<strong>元素为模板数据变量</strong></li>
<li><strong>模板数据变量的值为类名</strong></li>
<li>Vue框架从模板数据中获得类名后渲染在标签的class属性中</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数组格式对象绑定 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&#x27;[div1Class,colorClass]&#x27;</span>&gt;</span>数组样式绑定测试<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;change1&#x27;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	data:&#123;</span><br><span class="line">                isDiv1:true,</span><br><span class="line">                isColor:true,</span><br><span class="line">                div1Class:&#x27;div1&#x27;,</span><br><span class="line">                colorClass:&#x27;color&#x27;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                change:function()&#123;</span><br><span class="line">                    this.isDiv1 = !this.isDiv1</span><br><span class="line">                &#125;,</span><br><span class="line">                change1:function()&#123;</span><br><span class="line">                    this.div1Class=&#x27;&#x27;,</span><br><span class="line">                    this.colorClass=&#x27;&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>点击按钮后将模板数据置空字符串，div样式消失</li>
</ul>
<h4 id="3-3-12-样式绑定class的细节"><a href="#3-3-12-样式绑定class的细节" class="headerlink" title="3.3.12 样式绑定class的细节"></a>3.3.12 样式绑定class的细节</h4><ul>
<li>对象格式和数组格式可以<strong>结合使用</strong></li>
<li><code>v-bind:class</code>中class的值可以<strong>简化操作</strong></li>
<li>默认的class样式 会与样式绑定的样式<strong>一起生效</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 两种格式结合使用 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&#x27;[div1Class,&#123;color:isColor&#125;]&#x27;</span>&gt;</span>结合使用<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 简化class值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&#x27;objClass&#x27;</span>&gt;</span>对象格式简化<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&#x27;arrayClass&#x27;</span>&gt;</span>数组格式简化<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 原有的class与样式绑定共存 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fsize&quot;</span> <span class="attr">v-bind:class</span>=<span class="string">&#x27;arrayClass&#x27;</span>&gt;</span>样式共存<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>数组格式的样式绑定<strong>中的元素</strong>可以使用对象格式的样式绑定</li>
<li>直接将样式绑定写在标签内明显<strong>不易维护</strong>，将其<strong>作为模板数据</strong>，通过在标签中<strong>样式绑定模板数据变量来实现样式</strong><ul>
<li>数组格式和对象格式都可以简化</li>
</ul>
</li>
<li>标签原有的class属性与样式绑定的属性<strong>同时存在时</strong>，<strong>标签会结合两种样式</strong></li>
</ul>
<h4 id="3-3-13-样式绑定-style"><a href="#3-3-13-样式绑定-style" class="headerlink" title="3.3.13 样式绑定 style"></a>3.3.13 样式绑定 style</h4><p>样式绑定可以绑定标签内联属性style</p>
<p>同样也分为<strong>对象格式</strong>与<strong>数组格式</strong>，数组格式中，后面元素的样式会<strong>覆盖前面元素存在的样式</strong>，<strong>新增的样式保留</strong></p>
<ul>
<li><code>v-bind:style=&#39;&#123;&#125;&#39;</code>    值为对象，对象中属性为<strong>标准样式名</strong>（width等），属性值即为具体的样式设置（可以通过模板数据传递）</li>
<li><code>v-bind:style=&#39;objStyle&#39;</code>  为了简化，可以传入<strong>模板数据objStyle</strong>作为style值<ul>
<li>objStyle对象中设置样式属性</li>
</ul>
</li>
<li><code>v-bind:style=&#39;[objStyle,nextStyle]&#39;</code>数组中传入<strong>多个样式对象</strong>，<strong>后面的样式会覆盖前面的重复样式</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 对象格式style样式绑定，对象的属性为标准样式名，属性值即为设置的具体样式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&#x27;&#123;width:widthStyle,height:heightStyle,border:borderStyle&#125;&#x27;</span>&gt;</span>style样式绑定<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 简化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&#x27;objStyle&#x27;</span>&gt;</span>style值传入模板数据对象<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数组格式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&#x27;[objStyle,nextStyle]&#x27;</span>&gt;</span>数组格式<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data:&#123;</span><br><span class="line">                widthStyle:&#x27;100px&#x27;,</span><br><span class="line">                heightStyle:&#x27;100px&#x27;,</span><br><span class="line">                borderStyle:&#x27;solid 1px red&#x27;,</span><br><span class="line">				//样式对象</span><br><span class="line">                objStyle:&#123;</span><br><span class="line">                    width:&#x27;100px&#x27;,</span><br><span class="line">                    height:&#x27;100px&#x27;,</span><br><span class="line">                    border:&#x27;solid 1px red&#x27;</span><br><span class="line">                &#125;,</span><br><span class="line"></span><br><span class="line">                nextStyle:&#123;</span><br><span class="line">                    width:&#x27;200px&#x27;,</span><br><span class="line">                    backgroundColor:&#x27;yellow&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>nextStyle对象中的<strong>width:200px会覆盖objStyle中的width:100px</strong></li>
<li>nextStyle对象中的backgroundColor<strong>作为objStyle中没有的样式会保留</strong></li>
</ul>
<h3 id="3-4-分支结构-v-if"><a href="#3-4-分支结构-v-if" class="headerlink" title="3.4 分支结构 v-if"></a>3.4 分支结构 v-if</h3><p>Vue模板语法有自己的分支结构语法，就像art-template使用<code>&#123;&#123;if&#125;&#125;&#123;&#123;else&#125;&#125;&#123;&#123;/if&#125;&#125;</code>实现分支一样</p>
<p><strong>Vue分支指令</strong></p>
<ul>
<li>v-if</li>
<li>v-else-if</li>
<li>v-else</li>
</ul>
<p><strong>Vue中显示隐藏指令</strong></p>
<ul>
<li>v-show</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&#x27;score==100&#x27;</span>&gt;</span>满分<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&#x27;score&gt;80&#x27;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>优秀以下<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&#x27;flag&#x27;</span>&gt;</span>显示<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">         <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line">                score:69,</span><br><span class="line"><span class="javascript">                flag:<span class="literal">true</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>v-if v-else-if v-else</code>：实现if，else if 和else的作用<ul>
<li>指令的<strong>值为判断条件</strong></li>
</ul>
</li>
<li><code>v-show</code> 指令的值为<strong>true或false</strong>代表该标签是否隐藏（样式是否加上<strong>display:none</strong>属性）</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><p>分支指令<code>v-if</code>等，一个分支结构中只有<strong>满足条件的标签才被渲染</strong></p>
</li>
<li><p><code>v-show</code>显示隐藏指令中，无论指令值为true或false，<strong>标签都会被渲染</strong>，指令值只决定<strong>该渲染好的标签是否显示</strong></p>
</li>
<li><p>如果一个标签<strong>经常要显示或者隐藏</strong>，使用v-show，<strong>对样式的修改开销要比重新渲染标签小</strong></p>
</li>
</ul>
<br>

<h3 id="3-5-循环结构-v-for"><a href="#3-5-循环结构-v-for" class="headerlink" title="3.5 循环结构 v-for"></a>3.5 循环结构 v-for</h3><p>指令<code>v-for</code></p>
<p>要循环生成哪个标签，v-for指令就在哪个标签上</p>
<p>可以循环<strong>数组</strong>和<strong>对象</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 循环数组fruits生成3个li标签 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&#x27;(item,index) in fruits&#x27;</span>&gt;</span>&#123;&#123;index+&#x27;---&#x27;+item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 使用key属性指定唯一标识提高Vue性能 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">:key</span>=<span class="string">&#x27;index&#x27;</span> <span class="attr">v-for</span>=<span class="string">&#x27;(item,index) in myFruits&#x27;</span>&gt;</span>&#123;&#123;index+&#x27;---&#x27;+item.ename+&#x27;---&#x27;+item.cname&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                fruits:[<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;pear&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>],</span></span><br><span class="line">                myFruits:[</span><br><span class="line">                    &#123;</span><br><span class="line"><span class="javascript">                        ename:<span class="string">&#x27;apple&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        cname:<span class="string">&#x27;苹果&#x27;</span></span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line"><span class="javascript">                        ename:<span class="string">&#x27;pear&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        cname:<span class="string">&#x27;梨子&#x27;</span></span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当v-for指令的值为<code>(item,index) in fruits</code>时 <strong>循环数组</strong><ul>
<li>会循环fruits数组，<strong>循环索引</strong>为第二个参数index，<strong>循环值</strong>为第一个参数item（第二个参数固定为循环索引）</li>
<li>上述代码即循环渲染三个li标签，依次填入apple,pear,orange</li>
</ul>
</li>
</ul>
<br>

<ul>
<li>当v-for指令的值为<code>(value,key,index) in object</code> 时<strong>循环对象</strong><ul>
<li>第一个参数为<strong>值</strong>，第二个参数为<strong>建</strong>，第三个参数为<strong>循环索引</strong>（三个参数顺序固定）</li>
<li>对象中数据以<strong>键值对</strong>存储<strong>（键:值）</strong></li>
</ul>
</li>
</ul>
<br>

<ul>
<li>使用 <code>:key=&#39;index&#39;</code>属性绑定一个key自定义属性(<strong>v-bind简写为:</strong>)，值为每个li标签唯一的循环索引index<ul>
<li>使用key属性，设置<strong>其值为一系列兄弟标签中唯一的值</strong>，可以帮助Vue区分不同元素，<strong>提高性能</strong></li>
<li>但是在展示效果上有无key属性没有区别</li>
<li><strong>key值的选择遵循以下规则</strong><ul>
<li>一般选择每项数据的id值</li>
<li>若没有id则选择循环索引</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>

<h3 id="3-6-分支和循环结合使用"><a href="#3-6-分支和循环结合使用" class="headerlink" title="3.6 分支和循环结合使用"></a>3.6 分支和循环结合使用</h3><p>v-if指令和v-for指令结合使用</p>
<ul>
<li>即使用v-if指令判断v-for循环的<strong>标签是否渲染</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">           &lt;ul&gt;</span><br><span class="line">               &lt;!-- 分支循环结合 只渲染循环索引为<span class="number">1</span>的标签 --&gt;</span><br><span class="line">               &lt;li v-<span class="keyword">if</span>=<span class="string">&#x27;index==1&#x27;</span> v-<span class="keyword">for</span>=<span class="string">&#x27;(item,index) in fruits&#x27;</span>&gt;&#123;&#123;index+<span class="string">&#x27;---&#x27;</span>+item&#125;&#125;&lt;/li&gt;</span><br><span class="line">           &lt;/ul&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">   &lt;script&gt;</span><br><span class="line">       <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">           el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">           data:&#123;</span><br><span class="line">               fruits:[<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;pear&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>],</span><br><span class="line">           &#125;,</span><br><span class="line">           methods:&#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">   &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述代码循环fruits数组时，只有<strong>当循环索引为1时</strong>，该次循环的标签才会被渲染</li>
<li>最后结果只有数组第二项pear的li标签被渲染（索引为1）</li>
</ul>
<br>

<h3 id="3-7-tab选项卡简单案例"><a href="#3-7-tab选项卡简单案例" class="headerlink" title="3.7 tab选项卡简单案例"></a>3.7 tab选项卡简单案例</h3><ul>
<li>运用Vue框架实现一个选项卡切换案例<ul>
<li>当点击选项时，该选项<strong>背景色变成orange色</strong>，并且<strong>显示该项对应的图片</strong></li>
</ul>
</li>
</ul>
<p><img data-src="/images/01-Vue/image-20210911220749418-1632056227619.png" alt="案例效果"></p>
<p><strong>实现步骤</strong></p>
<ul>
<li>实现传统静态UI效果（不做解释）</li>
<li><strong>基于数据重构UI效果</strong><ul>
<li>结构样式<strong>重构为Vue模板语法形式</strong></li>
<li><strong>处理事件绑定和js逻辑</strong></li>
</ul>
</li>
</ul>
<h4 id="3-7-1-结构样式重构为Vue模板语法模式"><a href="#3-7-1-结构样式重构为Vue模板语法模式" class="headerlink" title="3.7.1 结构样式重构为Vue模板语法模式"></a>3.7.1 结构样式重构为Vue模板语法模式</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tab&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 循环生成li标签 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">:class</span>=<span class="string">&quot;liClass(index)&quot;</span> <span class="attr">:key</span>=<span class="string">&#x27;item.id&#x27;</span> <span class="attr">v-for</span>=<span class="string">&#x27;(item,index) in list&#x27;</span> @<span class="attr">click</span>=<span class="string">&#x27;handle(index)&#x27;</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 循环生成显示图片的div --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[divClass(index),&#x27;images&#x27;]&quot;</span> <span class="attr">:key</span>=<span class="string">&#x27;item.id&#x27;</span> <span class="attr">v-for</span>=<span class="string">&#x27;(item,index) in list&#x27;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&#x27;item.path&#x27;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用Vue模板语法<strong>循环生成li标签</strong><ul>
<li>v-for循环 模板数据list数组</li>
<li>:key属性绑定</li>
<li>:class样式绑定（为js逻辑显示或隐藏标签准备）</li>
<li>显示图片div标签同理</li>
</ul>
</li>
<li>使用Vue模板语法<strong>循环生成显示图片的div</strong></li>
</ul>
<h4 id="3-7-2-处理事件绑定和js逻辑"><a href="#3-7-2-处理事件绑定和js逻辑" class="headerlink" title="3.7.2 处理事件绑定和js逻辑"></a>3.7.2 处理事件绑定和js逻辑</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">            data:&#123;</span><br><span class="line">                <span class="comment">//当前选中项索引 判断选中项并修改其样式</span></span><br><span class="line">                currentIndex:<span class="number">0</span>,</span><br><span class="line">                <span class="comment">//选项数组</span></span><br><span class="line">                list:[&#123;</span><br><span class="line">                    id:<span class="number">1</span>,</span><br><span class="line">                    name:<span class="string">&#x27;img1&#x27;</span>,</span><br><span class="line">                    path:<span class="string">&#x27;./img/01.jpg&#x27;</span></span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    id:<span class="number">2</span>,</span><br><span class="line">                    name:<span class="string">&#x27;img2&#x27;</span>,</span><br><span class="line">                    path:<span class="string">&#x27;./img/02.jpg&#x27;</span></span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    id:<span class="number">3</span>,</span><br><span class="line">                    name:<span class="string">&#x27;img3&#x27;</span>,</span><br><span class="line">                    path:<span class="string">&#x27;./img/03.jpg&#x27;</span></span><br><span class="line">                &#125;],</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                handle:<span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.currentIndex = index</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">//判断li是否显示</span></span><br><span class="line">                liClass:<span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">                    <span class="comment">//当前项就是被选中项</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">this</span>.currentIndex == index)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&#x27;active&#x27;</span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">//判断存放图像div是否显示</span></span><br><span class="line">                divClass:<span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">this</span>.currentIndex == index)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&#x27;show&#x27;</span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>currentIndex模板数据默认为0，即<strong>默认选中第一项</strong></p>
<ul>
<li>选项卡点击事件处理函数<strong>handle</strong><ul>
<li>点击时<strong>将被点击标签的索引index覆盖currentIndex</strong>（currentIndex为当前被点击项的索引）</li>
</ul>
</li>
</ul>
</li>
<li><p>标签的class属性 调用<strong>liClass</strong>和<strong>divClass</strong>函数</p>
<ul>
<li>使用<strong>currentIndex模板数据</strong>和<strong>当前标签循环索引index</strong>比较，若相同则<strong>当前项被选中</strong><ul>
<li>函数返回修改选项卡背景颜色的<strong>类名active</strong>或显示图片div的<strong>类名show</strong></li>
<li>若没有选中则返回<strong>空字符串</strong>（即不添加类名）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>本案例所写的模板的结构即为<strong>声明式编程</strong></li>
<li><strong>声明式编程：</strong>即<strong>模板的结构</strong>和<strong>最终显示的结果</strong>基本相同</li>
</ul>
<br>

<h4 id="3-7-3-Vue模板语法与原生js编写此案例的区别"><a href="#3-7-3-Vue模板语法与原生js编写此案例的区别" class="headerlink" title="3.7.3 Vue模板语法与原生js编写此案例的区别"></a>3.7.3 Vue模板语法与原生js编写此案例的区别</h4><ul>
<li>在使用Vue模板语法重构页面时：<strong>从模板中即能看见循环生成选项卡和图片div</strong></li>
<li>而使用原生js时：通常<strong>在js逻辑中循环创造DOM元素</strong>并<strong>直接通过API添加到页面中其他DOM元素下</strong>，模板中不能反应出选项卡和图片div的循环生成</li>
</ul>
<h4 id="3-7-4-遇见的问题"><a href="#3-7-4-遇见的问题" class="headerlink" title="3.7.4 遇见的问题"></a>3.7.4 遇见的问题</h4><ol>
<li><p><strong>属性绑定时的值书写格式</strong></p>
<ul>
<li>值为<strong>模板数据</strong>时，<strong>不需要加引号</strong>，直接书写</li>
<li>值<strong>不是模板数据</strong>时，<strong>需要加引号</strong>，否则Vue模板会在模板数据中查找此变量</li>
<li>例如属性绑定class，<strong>class的值使用style标签中定义的类名时需要加引号</strong></li>
</ul>
</li>
<li><p><strong>css样式中li .active 和 li.active的区别</strong></p>
</li>
</ol>
<ul>
<li><code>li .active</code>：中间有空格，li标签的<strong>后代中</strong>类名为active的标签应用此样式</li>
<li><code>li.active</code>：中间无空格，类名为active的<strong>li标签</strong>应用此样式</li>
</ul>
<br>

<h2 id="4-Vue常用特性"><a href="#4-Vue常用特性" class="headerlink" title="4. Vue常用特性"></a>4. Vue常用特性</h2><ul>
<li>表单操作</li>
<li>自定义指令</li>
<li>计算属性</li>
<li>过滤器</li>
<li>侦听器</li>
<li>生命周期</li>
</ul>
<h3 id="4-1-表单操作"><a href="#4-1-表单操作" class="headerlink" title="4.1 表单操作"></a>4.1 表单操作</h3><ul>
<li>单行文本框 text</li>
<li>单选框 radio</li>
<li>复选框 checkbox</li>
<li>多行文本框 textarea</li>
<li>多选下拉列表 select</li>
</ul>
<p><strong>表单操作中的提交不通过表单默认事件，通常由js手动控制</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单选框双向数据绑定 --&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 当v-model指令的值等于value值时，该单选框被选中 操控gender的值即可变更单选框状态--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">v-model</span>=<span class="string">&#x27;gender&#x27;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> <span class="attr">v-model</span>=<span class="string">&#x27;gender&#x27;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 多选框双向数据绑定时模板数据使用数组hobby 数组中元素对应value时，该复选框被选中 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;ball&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">v-model</span>=<span class="string">&#x27;hobby&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;ball&quot;</span>&gt;</span>篮球<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sing&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> <span class="attr">v-model</span>=<span class="string">&#x27;hobby&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;sing&quot;</span>&gt;</span>唱歌<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;code&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> <span class="attr">v-model</span>=<span class="string">&#x27;hobby&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;code&quot;</span>&gt;</span>写代码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<center>单选和复选框表单域</center>

<ul>
<li><p>注意：</p>
<ul>
<li><p>模板数据gender值为<strong>Number类型的数字1</strong>或<strong>字符串“1”</strong>时，“男”单选框<strong>均会被选中</strong></p>
</li>
<li><p>但在页面中的<strong>单选表单域</strong>修改选中项时，模板数据会被<strong>绑定为字符串的”1”或者”2”</strong></p>
</li>
<li><p>复选框表单域被修改时同理，数组中的元素被绑定为<strong>字符串</strong></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>职业：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&#x27;occupation&#x27;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span>请选择职业...<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>教师<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>软件工程师<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>律师<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">&#x27;desc&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<center>单/多选下拉框和多行文本框表单域</center>

<ul>
<li>下拉框在select中进行双向数据绑定，同样与value比较</li>
<li>select中<strong>加上multiple即变为多选下拉框</strong>（浏览器中按住shift完成多选）</li>
<li>单选下拉框 ：绑定的数据可以是<strong>Number类型</strong>（修改单选下拉框时，模板数据绑定为<strong>Number</strong>）</li>
<li>多选下拉框 ：绑定的数据是<strong>数组</strong>（不是数组时浏览器控制台报错）（修改多选下拉框时，模板数据数组中元素<strong>绑定为字符串</strong>）</li>
<li>多行文本框表单域双向数据绑定<strong>与单行文本框相同</strong>（不需要与value比较）</li>
</ul>
<h3 id="4-1-表单修饰符"><a href="#4-1-表单修饰符" class="headerlink" title="4.1 表单修饰符"></a>4.1 表单修饰符</h3><p>与按键修饰符与时间i叙事符类似，表单也有表单修饰符</p>
<ul>
<li><strong>number</strong>：将<strong>输入域值绑定为数值</strong>（默认为字符串）</li>
<li><strong>trim</strong>：输入域值绑定到模板数据时<strong>去除前后空格</strong></li>
<li><strong>lazy</strong>：将v-model双向数据绑定的触发事件由<strong>input改为change</strong><ul>
<li>对于单行文本框来说：默认<strong>输入时进行双向数据绑定</strong>，现在改为<strong>文本框失去焦点时绑定</strong></li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.number</span>=<span class="string">&#x27;msg&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.trim</span>=<span class="string">&#x27;msg&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.lazy</span>=<span class="string">&#x27;msg&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-自定义指令"><a href="#4-2-自定义指令" class="headerlink" title="4.2 自定义指令"></a>4.2 自定义指令</h3><p>Vue内置指令数量有限，当内置指令不能满足需求是，可以自定义</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-focus</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Vue.directive(&#x27;focus&#x27;,&#123;</span><br><span class="line">            inserted:function(el)&#123;</span><br><span class="line">                //el即为指令绑定的元素</span><br><span class="line">                //el.focus()即聚焦该元素</span><br><span class="line">                el.focus()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<center>自定义指令在页面刷新时聚焦文本框</center>

<ul>
<li>自定义指令使用<code>Vue.directive</code>方法</li>
<li>第一个参数为<strong>自定义指令名</strong></li>
<li>第二个参数为一个对象，对象中使用<strong>钩子函数</strong><ul>
<li><strong>钩子函数名</strong>在Vue官方文档中定义，代表了不同调用时间</li>
<li>钩子函数传递<strong>el</strong>作为参数</li>
<li>el即为<strong>自定义指令绑定的元素</strong></li>
</ul>
</li>
</ul>
<p><img data-src="/images/01-Vue/image-20210912202743773-1632056227619.png" alt="可选的钩子函数"></p>
<h4 id="4-2-1-自定义指令的钩子函数参数"><a href="#4-2-1-自定义指令的钩子函数参数" class="headerlink" title="4.2.1 自定义指令的钩子函数参数"></a>4.2.1 自定义指令的钩子函数参数</h4><p>钩子函数参数在官方文档中有定义</p>
<p><img data-src="/images/01-Vue/image-20210912202416182-1632056227619.png" alt="钩子函数参数"></p>
<p><strong>使用钩子函数参数实现改变文本框背景颜色</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-bcolor=<span class="string">&#x27;&quot;orange&quot;&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line">Vue.directive(<span class="string">&#x27;bcolor&#x27;</span>,&#123;</span><br><span class="line">            bind:<span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">                <span class="comment">//el即为指令绑定的元素 可以直接操作DOM</span></span><br><span class="line">                <span class="comment">//binding对象参数</span></span><br><span class="line">                el.style.backgroundColor = binding.value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>自定义指令的<strong>绑定值orange</strong>可以通过<code>binding.value</code>获取</p>
</li>
<li><p>通过<strong>el</strong>可以修改DOM元素的属性</p>
</li>
</ul>
<p><img data-src="/images/01-Vue/image-20210912203243372-1632056227619.png" alt="修改背景色为orange色"></p>
<br>

<h4 id="4-2-2-局部指令"><a href="#4-2-2-局部指令" class="headerlink" title="4.2.2 局部指令"></a>4.2.2 局部指令</h4><p>自定义指令还可通过<strong>局部指令</strong>的方式来定义</p>
<ul>
<li>局部指令：只能在<strong>本组件(Vue实例)范围中使用</strong></li>
<li><strong>Vue实例是一种组件</strong></li>
</ul>
<p>上面第一种自定义指令的方式使用<code>Vue.directive</code>方法，称为<strong>全局指令</strong></p>
<ul>
<li>全局指令<strong>没有范围限制</strong></li>
</ul>
<p><strong>局部指令定义</strong>：在组件（Vue实例）中使用<code>directives</code>选项</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">            data:&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//使用directives选项</span></span><br><span class="line">            directives:&#123;</span><br><span class="line">                <span class="comment">//自定义focus指令</span></span><br><span class="line">                focus:&#123;</span><br><span class="line">                    bind:<span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">                    el.style.backgroundColor = binding.value</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="4-3-计算属性"><a href="#4-3-计算属性" class="headerlink" title="4.3 计算属性"></a>4.3 计算属性</h3><p>在<strong>插值表达式中对模板数据进行计算处理</strong>时，会导致模板看起来很复杂</p>
<p>使用计算属性可以让模板看起来更简洁</p>
<p><strong>计算属性</strong>：Vue实例中的computed属性，可以将复杂的计算表达式<strong>提取为计算属性中的方法</strong>，使用时<strong>直接在插值表达式中调用方法即可</strong></p>
<ul>
<li>计算属性中的函数结构需要<strong>使用return返回</strong></li>
<li>计算属性中的函数<strong>只能处理模板数据</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;!-- 直接书写表达式 --&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;msg.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;!-- 使用计算属性 --&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;reverseString&#125;&#125;&lt;/div&gt;</span><br><span class="line">            </span><br><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">            data:&#123;</span><br><span class="line">                msg:<span class="string">&#x27;nihao&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//计算属性</span></span><br><span class="line">            computed:&#123;</span><br><span class="line">                reverseString:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.msg.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<center>使用计算属性简化字符串反转的表达式</center>

<p><code>&#123;&#123;reverseString&#125;&#125;</code>显然比<code>&#123;&#123;msg.split('').reverse().join('')&#125;&#125;</code><strong>更加简洁</strong></p>
<p><img data-src="/images/01-Vue/image-20210912205802547-1632056227619.png" alt="计算结果"></p>
<h3 id="4-4-计算属性和方法的区别"><a href="#4-4-计算属性和方法的区别" class="headerlink" title="4.4 计算属性和方法的区别"></a>4.4 计算属性和方法的区别</h3><p>计算属性（conputed）和 方法（methods）都是Vue实例中的属性，区别在于<strong>是否缓存</strong></p>
<p><strong>计算属性</strong>：基于<strong>它的依赖</strong>（进行计算的模板数据）进行<strong>缓存</strong>，调用时只需写名字</p>
<p><strong>方法</strong>：没有缓存，调用时遵循函数调用使用()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">		&lt;!-- 计算属性 --&gt;</span><br><span class="line">           &lt;div&gt;&#123;&#123;reverseString&#125;&#125;&lt;/div&gt;</span><br><span class="line">           &lt;div&gt;&#123;&#123;reverseString&#125;&#125;&lt;/div&gt;</span><br><span class="line">           &lt;!-- 方法 --&gt;</span><br><span class="line">           &lt;div&gt;&#123;&#123;reverseMessage()&#125;&#125;&lt;/div&gt;</span><br><span class="line">           &lt;div&gt;&#123;&#123;reverseMessage()&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line">               reverseMessage:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                   <span class="built_in">console</span>.log(<span class="string">&#x27;Message&#x27;</span>);</span><br><span class="line">                   <span class="keyword">return</span> <span class="built_in">this</span>.msg.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="comment">//计算属性</span></span><br><span class="line">           computed:&#123;</span><br><span class="line">               reverseString:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                   <span class="built_in">console</span>.log(<span class="string">&#x27;String&#x27;</span>);</span><br><span class="line">                   <span class="keyword">return</span> <span class="built_in">this</span>.msg.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法reverseMessage</strong>和<strong>计算属性reverseString</strong>均执行两次</p>
<p><img data-src="/images/01-Vue/image-20210912211135678-1632056227619.png" alt="执行结果"></p>
<p>但是结果中方法的Message<strong>输出了两次</strong>，但是计算属性的String<strong>只输出了一次</strong></p>
<ul>
<li>这就是<strong>有无缓存的区别</strong></li>
<li>计算属性<code>reverseString</code>依赖的模板数据msg在两次执行期间<strong>没有改变</strong>，当第二次执行时会<strong>直接获取第一次缓存的结果进行返回</strong>，不再进行计算，所以第二次的输出语句被略过了</li>
<li>方法<code>reverseMessage</code>每次调用都会执行一次函数，所以输出两次</li>
<li>当计算表达式<strong>计算量巨大但依赖数据不变且进行多次调用</strong>时，使用计算属性可以利用缓存的特性<strong>提高性能</strong></li>
</ul>
<br>

<h3 id="4-5-侦听器"><a href="#4-5-侦听器" class="headerlink" title="4.5 侦听器"></a>4.5 侦听器</h3><p>侦听器：监听数据（Vue实例data属性中的数据）的变化，当数据变化时会触发监听器所绑定的方法</p>
<p>监听器应用场景：<strong>数据变化时执行异步或开销较大的操作</strong></p>
<ul>
<li>侦听器为<strong>Vue实例中的属性watch</strong>，侦听器绑定方法写在watch属性中，<strong>方法名即为监听的数据名</strong>，变化时会自动调用</li>
<li>监听数据的最新值通过<strong>绑定方法的参数</strong>获取</li>
</ul>
<h4 id="4-5-1侦听器基本用法"><a href="#4-5-1侦听器基本用法" class="headerlink" title="4.5.1侦听器基本用法"></a>4.5.1侦听器基本用法</h4><p>使用侦听器侦听<strong>firstName和lastName两个模板数据</strong>，当其中一个变化时，使用新值组合成fullName</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&#x27;firstName&#x27;</span>&gt;</span><br><span class="line">           &lt;br&gt;</span><br><span class="line">           &lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&#x27;lastName&#x27;</span>&gt;</span><br><span class="line">           &lt;div&gt;&#123;&#123;fullName&#125;&#125;&lt;/div&gt;</span><br><span class="line">           &lt;!-- <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> --&gt;</span><br><span class="line">		<span class="comment">//计算属性 完成拼接</span></span><br><span class="line">           <span class="comment">// computed:&#123;</span></span><br><span class="line">           <span class="comment">//     fullName:function()&#123;</span></span><br><span class="line">           <span class="comment">//         return this.firstName + &#x27;  &#x27; + this.lastName</span></span><br><span class="line">           <span class="comment">//     &#125;</span></span><br><span class="line">           <span class="comment">// &#125;,</span></span><br><span class="line">		<span class="comment">//侦听器完成</span></span><br><span class="line">           watch:&#123;</span><br><span class="line">               firstName:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                   <span class="built_in">this</span>.fullName = val + <span class="string">&#x27; &#x27;</span>+ <span class="built_in">this</span>.lastName</span><br><span class="line">               &#125;,</span><br><span class="line">               lastName:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                   <span class="built_in">this</span>.fullName = <span class="built_in">this</span>.firstName + <span class="string">&#x27;  &#x27;</span> + val</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现的效果为 两个文本框中任何一个改变 下方的div都会展现改变后的fullName</li>
<li>本例中实际上使用侦听器和计算属性可以达到同样的效果，本例只是为了演示侦听器的基本用法</li>
</ul>
<br>

<h4 id="4-5-2-侦听器应用场景简单案例-用户名验证"><a href="#4-5-2-侦听器应用场景简单案例-用户名验证" class="headerlink" title="4.5.2 侦听器应用场景简单案例-用户名验证"></a>4.5.2 侦听器应用场景简单案例-用户名验证</h4><p>用户在文本框中输入用户名，在文本框失去焦点时，判断用户名是否存在并显示不同的提示信息</p>
<p>实现步骤：</p>
<ul>
<li>通过v-model实现文本框数据绑定</li>
<li>提示信息存储在模板数据中</li>
<li><strong>监听器监听输出信息变化</strong></li>
<li>修改触发事件（失去焦点时）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">&quot;&quot;</span>&gt;请输入用户名:&lt;/label&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.lazy=<span class="string">&#x27;uname&#x27;</span>&gt;</span><br><span class="line">&lt;span&gt;&#123;&#123;tip&#125;&#125;&lt;/span&gt;	</span><br><span class="line"></span><br><span class="line">	methods:&#123;</span><br><span class="line">                checkName:<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> that = <span class="built_in">this</span></span><br><span class="line">                    <span class="comment">//使用定时器模拟异步API</span></span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(name == <span class="string">&#x27;admin&#x27;</span>)&#123;</span><br><span class="line">                            that.tip = <span class="string">&#x27;用户名存在请重新输入&#x27;</span></span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            that.tip = <span class="string">&#x27;可以使用&#x27;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,<span class="number">2000</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            watch:&#123;</span><br><span class="line">                uname:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.checkName(val)</span><br><span class="line">                    <span class="built_in">this</span>.tip = <span class="string">&#x27;请稍候&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用表单修饰符lazy改变触发为失去焦点后进行数据绑定</li>
<li><strong>使用定时器模拟异步代码执行</strong></li>
<li>此时<code>this.tip=&#39;请稍后&#39;</code>代码位于方法checkName后<ul>
<li>但是方法checkName执行到定时器时<strong>将异步代码挂起</strong></li>
<li><strong>先显示请稍后</strong>，两秒后再显示判断结果</li>
</ul>
</li>
<li>注意：<ul>
<li>setTimeout定时器中调用Vue实例data属性中的tip数据时，<strong>使用that改变this指向</strong></li>
<li>setTimeout定时器this指向<strong>默认为window</strong></li>
</ul>
</li>
</ul>
<h3 id="4-6-过滤器"><a href="#4-6-过滤器" class="headerlink" title="4.6 过滤器"></a>4.6 过滤器</h3><p>过滤器可以进行数据的格式化处理，比如将字符串格式化为首字母大写，日期格式化为指定格式等</p>
<ul>
<li>过滤器像自定义指令一样分为<strong>全局过滤器和局部过滤器</strong></li>
</ul>
<p><strong>全局过滤器</strong></p>
<ul>
<li>使用Vue框架的<code>filter</code>方法<ul>
<li>第一个参数为<strong>过滤器名称</strong>，第二个参数为<strong>过滤处理函数</strong>（函数接受一个参数即<strong>要过滤的数据</strong>）</li>
</ul>
</li>
</ul>
<p><strong>局部过滤器</strong></p>
<ul>
<li>在Vue实例中的<code>filters</code>属性中定义局部过滤器 函数名为过滤器名称 仅能在当前Vue实例中使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&#x27;msg&#x27;</span>&gt;</span><br><span class="line">            &lt;!-- 插值表达式使用过滤器 --&gt;</span><br><span class="line">            &lt;div&gt;&#123;&#123;msg | upper&#125;&#125;&lt;/div&gt;</span><br><span class="line">            &lt;!-- 级联使用 --&gt;</span><br><span class="line">            &lt;div&gt;&#123;&#123;msg | upper | lower&#125;&#125;&lt;/div&gt;</span><br><span class="line">            &lt;!-- 属性绑定时使用过滤器 --&gt;</span><br><span class="line">            &lt;div :msg=<span class="string">&#x27;msg | upper&#x27;</span>&gt;测试属性绑定过滤&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//全局过滤器</span></span><br><span class="line">        <span class="comment">// Vue.filter(&#x27;upper&#x27;,function(val)&#123;</span></span><br><span class="line">        <span class="comment">//     return val.charAt(0).toUpperCase() + val.slice(1)</span></span><br><span class="line">        <span class="comment">// &#125;)</span></span><br><span class="line">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">            data:&#123;</span><br><span class="line">                msg:<span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//局部过滤器</span></span><br><span class="line">            filters:&#123;</span><br><span class="line">                <span class="comment">//数据首字母大写</span></span><br><span class="line">                upper:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> val.charAt(<span class="number">0</span>).toUpperCase() + val.slice(<span class="number">1</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">//数据首字母小写</span></span><br><span class="line">                lower:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> val.charAt(<span class="number">0</span>).toLowerCase() + val.slice(<span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<center>使用过滤器将数据格式化为首字母大写或者小写的数据</center>

<ul>
<li>过滤器使用方法：<ul>
<li><strong>插值表达式</strong>中使用：**”|”**前是要过滤的数据，后面是过滤器名</li>
<li>标签<strong>属性绑定</strong>时v-bind指令的绑定值过滤</li>
<li>可以级联过滤，即使用<strong>多个”|”进行多次过滤</strong></li>
</ul>
</li>
</ul>
<h4 id="4-6-1-过滤器使用时传参"><a href="#4-6-1-过滤器使用时传参" class="headerlink" title="4.6.1 过滤器使用时传参"></a>4.6.1 过滤器使用时传参</h4><p>过滤器在使用时可以传递参数</p>
<p>过滤器处理函数<strong>第一个参数默认为待处理的数据</strong>，使用过滤器时传递的参数，<strong>从处理函数第二个参数开始接受</strong></p>
<center><big>格式化日期简单案例</big></center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 向过滤器format传递参数 --&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;msg | format(<span class="string">&#x27;yyyy-MM-dd&#x27;</span>)&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处arg = &#x27;yyyy-MM-dd&#x27;</span></span><br><span class="line">        Vue.filter(<span class="string">&#x27;format&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">val, arg</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//使用正则表达式格式化日期</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">dateFormat</span>(<span class="params">date, format</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> date === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">                    <span class="keyword">var</span> mts = date.match(<span class="regexp">/(\/Date\((\d+)\)\/)/</span>);</span><br><span class="line">                    <span class="keyword">if</span> (mts &amp;&amp; mts.length &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                        date = <span class="built_in">parseInt</span>(mts[<span class="number">2</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                date = <span class="keyword">new</span> <span class="built_in">Date</span>(date);</span><br><span class="line">                <span class="keyword">if</span> (!date || date.toUTCString() == <span class="string">&quot;Invalid Date&quot;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> map = &#123;</span><br><span class="line">                    <span class="string">&quot;M&quot;</span>: date.getMonth() + <span class="number">1</span>, <span class="comment">//月份 </span></span><br><span class="line">                    <span class="string">&quot;d&quot;</span>: date.getDate(), <span class="comment">//日 </span></span><br><span class="line">                    <span class="string">&quot;h&quot;</span>: date.getHours(), <span class="comment">//小时 </span></span><br><span class="line">                    <span class="string">&quot;m&quot;</span>: date.getMinutes(), <span class="comment">//分 </span></span><br><span class="line">                    <span class="string">&quot;s&quot;</span>: date.getSeconds(), <span class="comment">//秒 </span></span><br><span class="line">                    <span class="string">&quot;q&quot;</span>: <span class="built_in">Math</span>.floor((date.getMonth() + <span class="number">3</span>) / <span class="number">3</span>), <span class="comment">//季度 </span></span><br><span class="line">                    <span class="string">&quot;S&quot;</span>: date.getMilliseconds() <span class="comment">//毫秒 </span></span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                format = format.replace(<span class="regexp">/([yMdhmsqS])+/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">all, t</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> v = map[t];</span><br><span class="line">                    <span class="keyword">if</span> (v !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (all.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                            v = <span class="string">&#x27;0&#x27;</span> + v;</span><br><span class="line">                            v = v.substr(v.length - <span class="number">2</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> v;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t === <span class="string">&#x27;y&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> (date.getFullYear() + <span class="string">&#x27;&#x27;</span>).substr(<span class="number">4</span> - all.length);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> all;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> format;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dateFormat(val, arg);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="4-7-生命周期"><a href="#4-7-生命周期" class="headerlink" title="4.7 生命周期"></a>4.7 生命周期</h3><p>一个Vue实例的生命周期指从其<strong>被创建开始到其被销毁结束</strong></p>
<h4 id="生命周期的主要阶段"><a href="#生命周期的主要阶段" class="headerlink" title="生命周期的主要阶段"></a>生命周期的主要阶段</h4><p>共有八种生命周期方法(钩子函数)</p>
<ul>
<li>其this自动指向当前Vue实例</li>
<li>不能使用<strong>箭头函数</strong>创建生命周期方法，这会使得<strong>this指向混乱(变为undefined)</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeCreate:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&quot;beforeCreate&quot;</span>);</span><br><span class="line">         &#125;,</span><br><span class="line">         created:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&#x27;created&#x27;</span>);</span><br><span class="line">         &#125;,</span><br><span class="line">         beforeMount:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&#x27;beforeMount&#x27;</span>);</span><br><span class="line">         &#125;,</span><br><span class="line">         mounted:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&#x27;mounted&#x27;</span>);</span><br><span class="line">         &#125;,</span><br><span class="line">         beforeUpdate:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&#x27;beforeUpdate&#x27;</span>);</span><br><span class="line">         &#125;,</span><br><span class="line">         update:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&#x27;update&#x27;</span>);</span><br><span class="line">         &#125;,</span><br><span class="line">         beforeDestoty:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&#x27;beforeDestoty&#x27;</span>);</span><br><span class="line">         &#125;,</span><br><span class="line">         destotyed:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&#x27;destotyed&#x27;</span>);</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<center>代码段1</center>

<ul>
<li>八种生命周期方法在Vue实例中与<code>data和methods</code>等属性是<strong>同级的</strong></li>
</ul>
<h5 id="挂载阶段（初始化相关属性）"><a href="#挂载阶段（初始化相关属性）" class="headerlink" title="挂载阶段（初始化相关属性）"></a>挂载阶段（初始化相关属性）</h5><p>当Vue实例创建时调用以下四种方法</p>
<ul>
<li>beforeCreate</li>
<li>created</li>
<li>beforeMount</li>
<li><strong>mounted</strong>方法：<ul>
<li>初始化完成时调用，模板内容(data)已存在，可以向视图(view)中填充数据</li>
</ul>
</li>
</ul>
<p><img data-src="/images/01-Vue/image-20210919170833461-1632056227619.png" alt="image-20210919170833461"></p>
<p>当Vue实例创建时，控制台会输出上述四行（根据代码段1定义的钩子函数） </p>
<h5 id="更新阶段（元素或组件的变更）"><a href="#更新阶段（元素或组件的变更）" class="headerlink" title="更新阶段（元素或组件的变更）"></a>更新阶段（元素或组件的变更）</h5><ul>
<li>beforeUpdate</li>
<li>Updated</li>
</ul>
<p>当<strong>修改data中的属性</strong>时会触发上面两个函数</p>
<h5 id="销毁阶段（销毁Vue实例）"><a href="#销毁阶段（销毁Vue实例）" class="headerlink" title="销毁阶段（销毁Vue实例）"></a>销毁阶段（销毁Vue实例）</h5><ul>
<li>beforeDestroy</li>
<li>destroyed</li>
</ul>
<p>当使用<code>this.$destroy()</code>销毁实例时会调用上面方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//methods中的方法</span></span><br><span class="line">destroynow:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    				<span class="comment">//销毁实例</span></span><br><span class="line">                    <span class="built_in">this</span>.$destroy()</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>销毁实例后，<strong>data和methods和computed中的数据全部被清除</strong>，之后再通过调用方法修改data中的数据没有效果</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>09-Vue电商项目实战</title>
    <url>/2021/04/26/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="Vue电商项目实战"><a href="#Vue电商项目实战" class="headerlink" title="Vue电商项目实战"></a>Vue电商项目实战</h1><h2 id="1-项目概述"><a href="#1-项目概述" class="headerlink" title="1. 项目概述"></a>1. 项目概述</h2><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211019110430555.png" alt="image-20211019110430555"></p>
<ul>
<li>移动Web：移动端的浏览器等访问</li>
<li>多个终端使用<strong>同一个数据库</strong>，<strong>同一个服务端API接口</strong></li>
</ul>
<span id="more"></span>

<br>

<h3 id="1-1-管理系统的功能"><a href="#1-1-管理系统的功能" class="headerlink" title="1.1 管理系统的功能"></a>1.1 管理系统的功能</h3><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211019110804214.png" alt="image-20211019110804214"></p>
<h3 id="1-2-开发模式-前后端分离"><a href="#1-2-开发模式-前后端分离" class="headerlink" title="1.2 开发模式 (前后端分离)"></a>1.2 开发模式 (前后端分离)</h3><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211019111122433.png" alt="image-20211019111122433"></p>
<ul>
<li>前端基于Vue技术栈的<strong>单页面应用项目(SPA)</strong></li>
<li>后端写接口，前端调接口</li>
</ul>
<br>

<h3 id="1-3-项目技术选型"><a href="#1-3-项目技术选型" class="headerlink" title="1.3 项目技术选型"></a>1.3 项目技术选型</h3><h4 id="1-3-1-前端项目技术栈"><a href="#1-3-1-前端项目技术栈" class="headerlink" title="1.3.1 前端项目技术栈"></a>1.3.1 前端项目技术栈</h4><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211019112653524.png" alt="image-20211019112653524"></p>
<h4 id="1-3-2-后端项目技术栈"><a href="#1-3-2-后端项目技术栈" class="headerlink" title="1.3.2 后端项目技术栈"></a>1.3.2 后端项目技术栈</h4><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211019112718552.png" alt="image-20211019112718552"></p>
<ul>
<li><p><code>JWT</code>：<code>JSON Web Token</code>令牌，状态保持，身份认证（认证信息保存在客户端）</p>
</li>
<li><p><code>Sequelize</code>：操作数据库的框架</p>
</li>
</ul>
<br>

<h2 id="2-项目初始化"><a href="#2-项目初始化" class="headerlink" title="2. 项目初始化"></a>2. 项目初始化</h2><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211019151411236.png" alt="image-20211019151411236"></p>
<ul>
<li>通过图形化界面创建项目 <ul>
<li><code>vue ui</code>命令</li>
</ul>
</li>
<li>Git仓库使用 <strong>码云</strong></li>
</ul>
<h3 id="2-1-安装ElementUI插件"><a href="#2-1-安装ElementUI插件" class="headerlink" title="2.1 安装ElementUI插件"></a>2.1 安装ElementUI插件</h3><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211019151834747.png" alt="image-20211019151834747"></p>
<h3 id="2-2-安装axios依赖"><a href="#2-2-安装axios依赖" class="headerlink" title="2.2 安装axios依赖"></a>2.2 安装axios依赖</h3><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211019151845028.png" alt="image-20211019151845028"></p>
<br>

<h3 id="2-3-初始化Git远程仓库"><a href="#2-3-初始化Git远程仓库" class="headerlink" title="2.3 初始化Git远程仓库"></a>2.3 初始化Git远程仓库</h3><p>使用**码云(<code>Gitee</code>)**作为远程仓库</p>
<p>Gitee使用收藏在浏览器中</p>
<ol>
<li><p>在自己的码云账户设置<strong>公钥SSH</strong></p>
</li>
<li><p>新建仓库vue_shop</p>
</li>
</ol>
<ul>
<li><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211019164140045.png" alt="image-20211019164140045"></li>
</ul>
<ol start="3">
<li>使用vue创建项目时进行了Git仓库的初始化</li>
</ol>
<ul>
<li><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211019164324231.png" alt="image-20211019164324231"></p>
</li>
<li><p>项目创建后向仓库第一次提交，摘要信息为 <code>init project</code></p>
<ul>
<li><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211019164420980.png" alt="image-20211019164420980"></p>
</li>
<li><p>在gitee网页中可以查看</p>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li>将项目创建后安装的依赖和插件提交</li>
</ol>
<ul>
<li><p>项目创建后安装了<code>ElementUI</code>和<code>axios</code></p>
</li>
<li><p>在项目根目录打开<code>powershall</code></p>
<ul>
<li><p>执行 命令<code>git status  </code>查看**工作树(working tree)**环境</p>
<ul>
<li><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211019164754503.png" alt="image-20211019164754503"></p>
</li>
<li><p>当前处于<strong>master主分支</strong>下</p>
</li>
<li><p>列出了自上次提交后的做出的操作(增加、修改和删除)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用 命令 <code>git add .</code>  将所有操作加入缓存待提交</p>
<ul>
<li><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211019165006217.png" alt="image-20211019165006217"></li>
</ul>
</li>
<li><p>使用 命令 <code>git commit -m &quot;add files&quot;</code>  输入本次提交摘要(<code>add files</code>)并进行提交</p>
<ul>
<li><span style="color:red">此命令提交修改到本地仓库</span></li>
<li><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211019165214111.png" alt="image-20211019165214111"></li>
</ul>
</li>
<li><p>使用 命令<code>git remote add origin https://gitee.com/yang-xiao123/vue_shop.git</code></p>
<p>将<strong>远程仓库</strong>与本地仓库<strong>关联</strong>，<strong>并为远程仓库URL起一个简写名称</strong>(上述命令将**自己gitee的远程仓库<code>vue_shop</code>**与本地仓库关联，并为URL起别名为origin)</p>
</li>
<li><p>使用 命令 <code>git push -u origin master</code></p>
<ul>
<li><p><code>git push &lt;远程仓库名&gt; &lt;本地分支名&gt; [&lt;远程分支名&gt;]</code></p>
</li>
<li><p><strong>远程分支名</strong>省略时与<strong>本地分支名相同</strong></p>
</li>
<li><p>使用<code>-u</code>进行追踪</p>
</li>
<li><p>上述代码：将<strong>本地仓库的master分支</strong>推送到origin所代表的<strong>远程仓库的master分支</strong></p>
<ul>
<li>并使用<code>-u</code>追踪<strong>origin远程仓库的master分支</strong></li>
</ul>
</li>
<li><p>追踪之后，下次将<strong>本地仓库的master分支</strong>推送到<strong>远程仓库的master分</strong>支时</p>
<ul>
<li>命令可以简写为 <code>git push</code> </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-4-后台项目环境安装配置"><a href="#2-4-后台项目环境安装配置" class="headerlink" title="2.4 后台项目环境安装配置"></a>2.4 后台项目环境安装配置</h3><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211019201052794.png" alt="image-20211019201052794"></p>
<ul>
<li>使用集成了MySQL数据库的phpstudy软件，导入<code>mydb.sql</code>文件</li>
</ul>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211019204402843.png" alt="image-20211019204402843"></p>
<ul>
<li>后台接口的文档中查找服务器URL和API等</li>
</ul>
<br>

<h4 id="2-4-1-安装postman进行后台接口测试"><a href="#2-4-1-安装postman进行后台接口测试" class="headerlink" title="2.4.1 安装postman进行后台接口测试"></a>2.4.1 安装postman进行后台接口测试</h4><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211019204138329.png" alt="image-20211019204138329"></p>
<ul>
<li><p>运行<code>node app.js</code>开启服务器</p>
</li>
<li><p>输入请求URL选择请求方式</p>
</li>
<li><p>输入请求参数</p>
</li>
<li><p>点击Send发送请求</p>
</li>
<li><p>下方的Body选项中为返回的数据</p>
</li>
</ul>
<p>上图显示返回数据正常代表接口正常</p>
<br>

<h2 id="3-登录功能"><a href="#3-登录功能" class="headerlink" title="3. 登录功能"></a>3. 登录功能</h2><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211019205149294.png" alt="image-20211019205149294"></p>
<h3 id="3-1-登录页面布局"><a href="#3-1-登录页面布局" class="headerlink" title="3.1 登录页面布局"></a>3.1 登录页面布局</h3><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211019205344548.png" alt="image-20211019205344548"></p>
<br>

<ol>
<li>创建新分支完成登录功能并验证后再合并回主分支</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git checkout -b login</span><br></pre></td></tr></table></figure>

<p>创建login分支并切换到其上</p>
<br>

<ol start="2">
<li>清理项目目录中不需要的组件</li>
</ol>
<p>新项目创建会默认生成初始化的页面，将此页面修改为空白页面</p>
<ul>
<li>删除不需要的<code>Home.vue、HelloWorld.vue和About.vue</code>组件</li>
<li>修改router文件夹下的<code>index.js</code>中的前端路由匹配规则</li>
</ul>
<br>

<h3 id="3-2-创建登录组件"><a href="#3-2-创建登录组件" class="headerlink" title="3.2 创建登录组件"></a>3.2 创建登录组件</h3><ol>
<li>新建<code>Login.vue</code>文件进行配置</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;less&quot;</span> <span class="attr">scoped</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>样式兼容less语法并只在本组件生效</li>
</ul>
<p><span style="color:red">注意：</span></p>
<p>使<code>css</code>样式兼容less语法需要安装<code>less-loader和less</code>依赖</p>
<p>注意安装的版本号</p>
<ul>
<li><a href="mailto:&#108;&#101;&#x73;&#115;&#45;&#x6c;&#x6f;&#x61;&#x64;&#101;&#114;&#x40;&#52;&#46;&#49;&#46;&#48;">&#108;&#101;&#x73;&#115;&#45;&#x6c;&#x6f;&#x61;&#x64;&#101;&#114;&#x40;&#52;&#46;&#49;&#46;&#48;</a></li>
<li><a href="mailto:&#108;&#101;&#115;&#x73;&#64;&#x33;&#46;&#x39;&#x2e;&#x30;">&#108;&#101;&#115;&#x73;&#64;&#x33;&#46;&#x39;&#x2e;&#x30;</a></li>
<li><strong>版本过高会报错</strong> (因为项目使用<strong>vue2.x</strong>版本)</li>
</ul>
<br>

<ol start="2">
<li>在<code>App.vue</code>文件中添加路由占位符<code>&lt;router-view&gt;&lt;/router-view&gt;</code></li>
</ol>
<br>

<ol start="3">
<li>在<code>router/index.js</code>文件中引入<code>Login.vue</code>文件并配置路由规则</li>
</ol>
<ul>
<li>```js<br>//路由重定向<br>{ path: ‘/‘, redirect: ‘/login’ },<br>{ path: ‘/login’, component: Login }<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">4. 查看效果</span><br><span class="line"></span><br><span class="line">- ![image-20211019213817487](&#x2F;images&#x2F;09-Vue电商网站项目实战&#x2F;image-20211019213817487.png)</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">### 3.3 登录组件布局</span><br><span class="line"></span><br><span class="line">1. 设置全局CSS文件</span><br><span class="line"></span><br><span class="line">- 在&#96;assets&#x2F;global.css&#96;文件中写全局样式</span><br><span class="line">- 将&#96;global.css&#96;引入&#96;main.js&#96;文件，使全局样式生效</span><br><span class="line">- 在&#96;Login.vue&#96;文件中加入登录框，并设置样式</span><br><span class="line">- 最后的效果为，**登录组件整体占满屏幕**，背景色为&#96;#2b4b6b&#96;，**登录框居中显示为白色**</span><br><span class="line"></span><br><span class="line">![image-20211019222010527](&#x2F;images&#x2F;09-Vue电商网站项目实战&#x2F;image-20211019222010527.png)</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">### 3.4 登录框头部布局</span><br><span class="line"></span><br><span class="line">![image-20211027204823509](&#x2F;images&#x2F;09-Vue电商网站项目实战&#x2F;image-20211027204823509.png)</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;html</span><br><span class="line">&lt;div class&#x3D;&quot;login_box&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;head_img&quot;&gt;</span><br><span class="line">    	&lt;img src&#x3D;&quot;&#x2F;assets&#x2F;logo.png&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">.head_img&#123;</span><br><span class="line">    width: 130px;</span><br><span class="line">    height: 130px;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    border: 1px solid #eee;</span><br><span class="line">    padding: 10px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translate(-50%,-50%);</span><br><span class="line">    box-shadow:  0 0 10px #eee;</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    &#x2F;&#x2F; less语法嵌套</span><br><span class="line">    img&#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 100%;</span><br><span class="line">        border-radius: 50%;</span><br><span class="line">        background-color: #eee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h3 id="3-5-登录框表单布局"><a href="#3-5-登录框表单布局" class="headerlink" title="3.5 登录框表单布局"></a>3.5 登录框表单布局</h3><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211027212831681.png" alt="image-20211027212831681"></p>
<p>按需导入<code>Element-UI</code>组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Form,FormItem,Input &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line">Vue.use(Button)</span><br><span class="line">Vue.use(Form)</span><br><span class="line">Vue.use(FormItem)</span><br><span class="line">Vue.use(Input)</span><br></pre></td></tr></table></figure>

<CENTER>element.js</CENTER>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 登录表单 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-form</span> <span class="attr">label-width</span>=<span class="string">&quot;0px&quot;</span> <span class="attr">class</span>=<span class="string">&quot;login_form&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 用户名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-input</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 密码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-input</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 按钮 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">class</span>=<span class="string">&quot;btns&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;info&quot;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">.login_form&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    width: 100%;</span><br><span class="line">    padding: 0 10px;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line">.btns&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>Login.vue</center>

<h4 id="3-5-1-表单中文本输入框前小图标"><a href="#3-5-1-表单中文本输入框前小图标" class="headerlink" title="3.5.1 表单中文本输入框前小图标"></a>3.5.1 表单中文本输入框前小图标</h4><p><code>Element-UI</code>可以使用带icon的输入框</p>
<p>可以通过 <code>prefix-icon</code> 和 <code>suffix-icon</code> 属性在 input 组件首部和尾部增加显示图标，也可以通过 slot 来放置图标</p>
<p>使用第三方的小图标来源于阿里图标库</p>
<ol>
<li>将font文件夹放入项目中</li>
<li>在<code>main.js</code>文件中引入字体图标<code>css</code>文件(<code>iconfont.css</code>)</li>
<li>在<code>Element-UI</code>的el-input标签中设定<code>prefix-icon</code>属性设定输入框小图标</li>
</ol>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211101190424190.png" alt="image-20211101190424190"></p>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211101190438137.png" alt="image-20211101190438137"></p>
<br>

<h3 id="3-6-登录框表单双向数据绑定"><a href="#3-6-登录框表单双向数据绑定" class="headerlink" title="3.6 登录框表单双向数据绑定"></a>3.6 登录框表单双向数据绑定</h3><p>根据Element-UI官网</p>
<ol>
<li><p>在el-form标签上添加model<strong>属性绑定</strong></p>
</li>
<li><p>在el-input标签上进行<strong>双向数据绑定</strong>(v-model)</p>
</li>
<li><p>在单文件组件的<code>export default &#123;&#125;</code>对象中定义绑定的模板数据对象</p>
</li>
</ol>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211101191952878.png" alt="image-20211101191952878"></p>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211101192004837.png" alt="image-20211101192004837"></p>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211101192012818.png" alt="image-20211101192012818"></p>
<br>

<h3 id="3-7-表单输入框数据校验"><a href="#3-7-表单输入框数据校验" class="headerlink" title="3.7 表单输入框数据校验"></a>3.7 表单输入框数据校验</h3><p>在客户端进行表单数据校验</p>
<p>根据<code>Element-UI</code>官方文档</p>
<ol>
<li>在el-form标签上进行<code>rules</code>属性绑定(绑定验证规则模板数据对象)</li>
<li>模板数据中定义验证规则对象</li>
<li>将el-form-item标签的prop属性设置为验证规则名</li>
</ol>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211101193308626.png" alt="image-20211101193308626"></p>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211101193316129.png" alt="image-20211101193316129"></p>
<ul>
<li>可以使用数组组合多条验证规则</li>
<li><code>message</code>：验证失败时的提示信息</li>
<li><code>trigger</code>：在什么时候进行验证(blur在失焦时验证)</li>
</ul>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211101193517869.png" alt="image-20211101193517869"></p>
<br>

<h3 id="3-8-表单重置功能实现"><a href="#3-8-表单重置功能实现" class="headerlink" title="3.8 表单重置功能实现"></a>3.8 表单重置功能实现</h3><p>根据Element-UI官方文档</p>
<ol>
<li>给表单对象实例el-form标签添加<code>ref</code>引用属性</li>
<li>给重置按钮绑定事件，点击时触发表单实例的<code>resetFields</code>方法进行重置</li>
</ol>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211101194406325.png" alt="image-20211101194406325"></p>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211101194422565.png" alt="image-20211101194422565"></p>
<center>输出Login.vue单文件组件</center>

<ul>
<li>在单文件组件本身的<code>$refs</code>属性中可以获取表单组件的引用<code>LoginForm</code></li>
</ul>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211101194800125.png" alt="image-20211101194800125"></p>
<br>

<h3 id="3-9-表单提交数据格式验证"><a href="#3-9-表单提交数据格式验证" class="headerlink" title="3.9 表单提交数据格式验证"></a>3.9 表单提交数据格式验证</h3><ol>
<li>获取表单对象实例，提交时触发其<code>validate</code>方法</li>
<li>设定validate方法的参数<ul>
<li>方法的参数为一个回调函数，<ul>
<li>回调函数第一个参数为是否通过的布尔值，</li>
<li>第二个参数为未通过字段组成的对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211101200011669.png" alt="image-20211101200011669"></p>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211101200025803.png" alt="image-20211101200025803"></p>
<br>

<h3 id="3-10-表单提交时发送请求"><a href="#3-10-表单提交时发送请求" class="headerlink" title="3.10 表单提交时发送请求"></a>3.10 表单提交时发送请求</h3><p>表单提交时根据<strong>格式验证结果</strong>决定是否发送请求</p>
<p>使用<code>axios对象</code>发送请求</p>
<br>

<ol>
<li>axios对象配置</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入axios模块</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="comment">// 配置基准URL</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;http://127.0.0.1:8888/api/private/v1/&#x27;</span></span><br><span class="line"><span class="comment">// 将axios注册为Vue原型对象的属性</span></span><br><span class="line">Vue.prototype.$http = axios</span><br></pre></td></tr></table></figure>

<center>main.js文件</center>

<ol start="2">
<li>使用axios对象发送请求</li>
</ol>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211110220753994.png" alt="image-20211110220753994"></p>
<center>Login.vue文件</center>

<ul>
<li><p><code>axios.post()</code>返回promise对象，使用<strong>异步函数和await关键字的方式</strong>获取服务端响应对象</p>
</li>
<li><p>响应对象中的<strong>data属性</strong>为服务端<strong>实际响应的数据对象</strong></p>
<ul>
<li>通过对象解构的方法获取data属性值</li>
</ul>
</li>
<li><p>请求使用的URL路径(login)在<strong>后台API接口文档</strong>中查看</p>
</li>
</ul>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211110221224945.png" alt="image-20211110221224945"></p>
<center>console.log(res) 的结果</center>

<br>

<h3 id="3-11-登录结果弹窗提示"><a href="#3-11-登录结果弹窗提示" class="headerlink" title="3.11 登录结果弹窗提示"></a>3.11 登录结果弹窗提示</h3><p>使用<code>element-ui</code>的<code>Message 消息提示</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Message&#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"><span class="comment">//将Message注册为Vue原型对象上的属性message(属性名自定义)</span></span><br><span class="line">Vue.prototype.$message = Message</span><br></pre></td></tr></table></figure>

<center>src/plugins/element.js文件</center>

<ul>
<li>Message挂载时需要作为<code>Vue.prototype</code>的属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(res.meta.status !== <span class="number">200</span>)&#123;</span><br><span class="line">          <span class="built_in">this</span>.$message.error(<span class="string">&#x27;登录失败&#x27;</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.$message.success(<span class="string">&#x27;登录成功&#x27;</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<center>Login.vue文件</center>

<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211115212442721.png" alt="image-20211115212442721"></p>
<br>

<h3 id="3-12-登录成功后的处理"><a href="#3-12-登录成功后的处理" class="headerlink" title="3.12 登录成功后的处理"></a>3.12 登录成功后的处理</h3><ol>
<li>登录成功后将token信息保存在<code>sessionStorage</code>中<ul>
<li>登录后进行操作访问其他接口需要使用token验证身份</li>
<li>将token存储在<code>sessionStorage</code>中，页面关闭即删除token信息，提高安全性</li>
<li><code>sessionStorage</code>中的信息以<strong>键值对存储</strong></li>
</ul>
</li>
<li>使用编程式导航跳转到后台主页</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$message.success(<span class="string">&#x27;登录成功&#x27;</span>)</span><br><span class="line"><span class="comment">//将token记录在sessionStorage中</span></span><br><span class="line"><span class="built_in">window</span>.sessionStorage.setItem(<span class="string">&#x27;token&#x27;</span>,res.data.token)</span><br><span class="line"><span class="comment">//通过编程式导航跳转到后台主页</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(<span class="string">&#x27;/home&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211115215543049.png" alt="image-20211115215543049"></p>
<center>浏览器保存的token信息</center>

<br>

<h3 id="3-13-路由导航守卫"><a href="#3-13-路由导航守卫" class="headerlink" title="3.13 路由导航守卫"></a>3.13 路由导航守卫</h3><p>客户端在访问需要权限的页面时需要先进行登录</p>
<p>由<code>vue-router</code>的<strong>导航守卫</strong>来对路由变化的过程进行监控和操作</p>
<p><span style="color:red">“导航”表示路由正在发生改变。</span></p>
<p>使用<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB"><strong>全局前置守卫</strong></a>对未登录用户的访问作出限制</p>
<br>

<ul>
<li><p>全局前置守卫：</p>
<p> 当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 <strong>等待中</strong>。</p>
<p>每个守卫方法接收<strong>三个参数</strong>：</p>
<ul>
<li><strong><code>to: Route</code></strong>: 即将要进入的目标 <a href="https://router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1">路由对象</a></li>
<li><strong><code>from: Route</code></strong>: 当前导航正要离开的路由对象</li>
<li><strong><code>next: Function</code></strong>: 一定要调用该方法来 <strong>resolve</strong> 这个钩子。执行效果依赖 <code>next</code> 方法的调用参数。</li>
</ul>
</li>
</ul>
<br>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在导出路由对象前设置全局前置守卫</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//若导航的目标为登录页面则直接放行</span></span><br><span class="line">  <span class="keyword">if</span>(to.path === <span class="string">&#x27;/login&#x27;</span>) <span class="keyword">return</span> next()</span><br><span class="line">  <span class="comment">//获取token信息</span></span><br><span class="line">  <span class="keyword">let</span> tokenmsg = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">  <span class="comment">//未登录(没有token信息)则跳转到&#x27;/login&#x27;路由(跳转到登录页面)</span></span><br><span class="line">  <span class="keyword">if</span>(!tokenmsg) <span class="keyword">return</span> next(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">  <span class="comment">//已经登录则直接放行</span></span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出路由对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<center>router/index.js</center>

<br>

<h3 id="3-14-退出登录"><a href="#3-14-退出登录" class="headerlink" title="3.14 退出登录"></a>3.14 退出登录</h3><p>在<code>Home.vue</code>组件中加入退出登录的按钮(el-button)，绑定点击事件</p>
<ul>
<li>删除浏览器<code>session Storage</code>中的token信息</li>
<li>编程式导航到登录页面(‘/login’)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">          logout:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">              <span class="comment">//清除sessionStroage信息</span></span><br><span class="line">              <span class="built_in">window</span>.sessionStorage.clear()</span><br><span class="line">              <span class="comment">//编程式导航</span></span><br><span class="line">              <span class="built_in">this</span>.$router.push(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="3-15-提交登录功能代码到码云"><a href="#3-15-提交登录功能代码到码云" class="headerlink" title="3.15 提交登录功能代码到码云"></a>3.15 提交登录功能代码到码云</h3><ol>
<li><p><strong>将本地仓库的<code>login</code>分支合并到<code>master</code>分支</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge login</span><br></pre></td></tr></table></figure>

<ul>
<li>login分支合并到master分支时，login分支的<strong>提交日志</strong>会被一起合并到master分支</li>
</ul>
</li>
<li><p><strong>将本地仓库的<code>master</code>分支推送更新到远端仓库的<code>master</code>分支</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git push <span class="comment">//项目初始化时已经设定远程链接 使用简写命令进行推送</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>将本地仓库的<code>login</code>分支推送到远端仓库的<code>login</code>分支来记录开发过程</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git checkout login</span><br><span class="line">git push -u origin login	<span class="comment">//将本地仓库的login分支推送到远端仓库的login分支并建立远程链接，之后的推送可以使用简写命令</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看码云远端仓库</li>
</ul>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211122212243784.png" alt="image-20211122212243784"></p>
<p>​    远端仓库新建了login分支以接收本地仓库推送的login分支</p>
</li>
</ol>
<br>

<h2 id="4-处理语法警告问题"><a href="#4-处理语法警告问题" class="headerlink" title="4. 处理语法警告问题"></a>4. 处理语法警告问题</h2><p><code>eslint</code>语法校验不允许使用双引号以及在花括号后加分号</p>
<p>在项目根目录下新建<code>.prettierrc</code>文件来配置文档格式化规则</p>
<p><code>vscode</code>格式化文档快捷键：<code>Shift + Alt + F</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;semi&quot;</span>: <span class="literal">false</span>,	<span class="comment">//不添加分号</span></span><br><span class="line">    <span class="attr">&quot;singleQuote&quot;</span>:<span class="literal">true</span>	<span class="comment">//使用单引号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="5-主页Home组件布局"><a href="#5-主页Home组件布局" class="headerlink" title="5. 主页Home组件布局"></a>5. 主页Home组件布局</h2><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211123212537594.png" alt="image-20211123212537594"></p>
<p>主页由头部Header和下方主体部分的Aside和Main组成</p>
<p>使用<code>Element-UI</code>组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-container</span> <span class="attr">class</span>=<span class="string">&quot;home-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-header</span>&gt;</span></span><br><span class="line">      Header</span><br><span class="line">      <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;info&quot;</span> <span class="attr">plain</span> @<span class="attr">click</span>=<span class="string">&quot;logout&quot;</span>&gt;</span>退出登录<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-container</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-aside</span> <span class="attr">width</span>=<span class="string">&quot;200px&quot;</span>&gt;</span>Aside<span class="tag">&lt;/<span class="name">el-aside</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-main</span>&gt;</span>Main<span class="tag">&lt;/<span class="name">el-main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-container</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">el-container</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;less&quot;</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line">.home-container &#123;</span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100%</span>;	<span class="comment">/*长度占满窗口*/</span></span></span><br><span class="line">&#125;</span><br><span class="line">.el-header &#123;</span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#373d41</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">.el-aside &#123;</span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#333744</span>;</span></span><br><span class="line">&#125;</span><br><span class="line">.el-main &#123;</span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#eaedf1</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<center>Home.vue</center>

<p><code>Element-UI</code>中的组件名即为其类名，也可以自定义类名</p>
<br>

<h3 id="5-1-Header布局"><a href="#5-1-Header布局" class="headerlink" title="5.1 Header布局"></a>5.1 Header布局</h3><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211123213902952.png" alt="image-20211123213902952"></p>
<ul>
<li>图标、文字标识居左，退出按钮居右</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/heima.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>电商后台管理系统<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;info&quot;</span> <span class="attr">plain</span> @<span class="attr">click</span>=<span class="string">&quot;logout&quot;</span>&gt;</span>退出登录<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-header</span>&gt;</span></span><br><span class="line"></span><br><span class="line">.el-header &#123;</span><br><span class="line">        background-color: #373d41;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: space-between;</span><br><span class="line">        align-items: center;</span><br><span class="line">        &gt; div &#123;	</span><br><span class="line">            display: flex;</span><br><span class="line">            align-items: center;</span><br><span class="line">            span &#123;</span><br><span class="line">                padding-left: 5px;</span><br><span class="line">                font-size: 20px;</span><br><span class="line">                color:#fff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<center>Home.vue</center>

<br>

<h3 id="5-2-侧边导航菜单栏布局"><a href="#5-2-侧边导航菜单栏布局" class="headerlink" title="5.2 侧边导航菜单栏布局"></a>5.2 侧边导航菜单栏布局</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-aside</span> <span class="attr">width</span>=<span class="string">&quot;200px&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 导航栏组件 --&gt;</span></span><br><span class="line">    &lt;el-menu</span><br><span class="line">        background-color=&quot;#333744&quot;</span><br><span class="line">        text-color=&quot;#fff&quot;</span><br><span class="line">        active-text-color=&quot;#ffd04b&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        <span class="comment">&lt;!-- 一级菜单 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-submenu</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;el-icon-location&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>导航一<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 二级菜单 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">&quot;1-1&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;el-icon-location&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span>&gt;</span>选项一<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-submenu</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-menu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-aside</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211123220240341.png" alt="image-20211123220240341"></p>
<br>

<h3 id="5-3-通过接口获取菜单数据"><a href="#5-3-通过接口获取菜单数据" class="headerlink" title="5.3 通过接口获取菜单数据"></a>5.3 通过接口获取菜单数据</h3><p>对于登录之外的接口，服务器需要token令牌进行验证。</p>
<p>为了规避<code>CSRF</code>攻击，token一般作为请求头字段<code>Authorization</code>的值传送给服务器</p>
<p>对于<code>axios</code>请求，可以设置<strong>请求拦截器</strong>给发送前的请求添加token令牌</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(config);	<span class="comment">//config为请求对象</span></span><br><span class="line">  config.headers.common.Authorization = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>main.js</center>

<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211123222048263.png" alt="image-20211123222048263"></p>
<ul>
<li>因为登录请求时客户端还没有存储token，所以Authorization字段值为null</li>
</ul>
<br>

<h4 id="5-3-1-获取菜单数据并渲染在模板中"><a href="#5-3-1-获取菜单数据并渲染在模板中" class="headerlink" title="5.3.1 获取菜单数据并渲染在模板中"></a>5.3.1 获取菜单数据并渲染在模板中</h4><ol>
<li>获取菜单数据</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">           <span class="comment">//菜单数据数组</span></span><br><span class="line">           menuList: [],</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;	<span class="comment">//生命周期钩子</span></span><br><span class="line">       <span class="comment">//组件创建完时获取菜单数据</span></span><br><span class="line">       <span class="built_in">this</span>.getMenu()</span><br><span class="line">   &#125;,</span><br><span class="line">getMenu: <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="comment">//axios请求get方式获取菜单数据</span></span><br><span class="line">           <span class="keyword">let</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> <span class="built_in">this</span>.$http.get(<span class="string">&#x27;menus&#x27;</span>)</span><br><span class="line">           <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="built_in">this</span>.$message.error(res.meta.msg)</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="built_in">this</span>.menuList = res.data	<span class="comment">//将菜单数据赋值给模板数据</span></span><br><span class="line">           <span class="built_in">console</span>.log(<span class="built_in">this</span>.menuList)</span><br><span class="line">       &#125;,</span><br></pre></td></tr></table></figure>

<center>Home.vue的组件配置对象内容</center>

<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211123225724185.png" alt="image-20211123225724185"></p>
<center>返回的菜单数据数组</center>

<ul>
<li>子菜单保存在<code>children</code>数组中</li>
</ul>
<br>

<ol start="2">
<li>渲染菜单数据</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 一级菜单 --&gt;</span></span><br><span class="line">&lt;el-submenu</span><br><span class="line">            :index=&quot;item.id + &#x27;&#x27;&quot;</span><br><span class="line">            v-for=&quot;item in menuList&quot;   <span class="comment">&lt;!-- 一级菜单循环 --&gt;</span></span><br><span class="line">            :key=&quot;item.id&quot;</span><br><span class="line">            &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;el-icon-location&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; item.authName &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 二级菜单 --&gt;</span></span><br><span class="line">    &lt;el-menu-item</span><br><span class="line">                  :index=&quot;subitem.id + &#x27;&#x27;&quot;</span><br><span class="line">                  v-for=&quot;subitem in item.children&quot; <span class="comment">&lt;!-- 二级菜单循环 --&gt;</span></span><br><span class="line">                  :key=&quot;subitem.id&quot;</span><br><span class="line">                  &gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;el-icon-location&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; subitem.authName &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-submenu</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用<strong>两层循环结构</strong>渲染菜单数据<ul>
<li>循环时注意使用id值属性绑定<code>:key</code></li>
<li>index属性为<code>Element-UI</code>组件库对每个菜单项的标识，同样使用id值绑定<ul>
<li>index属性值规定为<strong>String类型</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211123230208897.png" alt="image-20211123230208897"></p>
<br>

<h3 id="5-4-左侧菜单格式美化"><a href="#5-4-左侧菜单格式美化" class="headerlink" title="5.4 左侧菜单格式美化"></a>5.4 左侧菜单格式美化</h3><p>替换<strong>二级菜单图标</strong>、<strong>一级菜单图标</strong>和<strong>选中二级菜单时的颜色</strong></p>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211124200658982.png" alt="image-20211124200658982"></p>
<center>修改选中时的颜色</center>

<p>根据<code>Element-UI</code>组件库的图标类名<strong>修改二级菜单i标签class属性值</strong></p>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211124200808932.png" alt="image-20211124200808932"></p>
<center>二级菜单图标</center>

<p>使用导入的第三方组件库的小图标替换一级菜单图标</p>
<ul>
<li>循环生成的一级菜单需要使用不同的小图标</li>
<li>利用<strong>模板数据对象</strong>存储每个一级菜单项的<strong>图标class属性值</strong>，根据ID值设置不同的小图标</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">:class</span>=<span class="string">&quot;iconList[item.id]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"></span><br><span class="line">data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            menuList: [],</span><br><span class="line">            iconList: &#123;</span><br><span class="line">                125: &#x27;iconfont icon-user&#x27;,</span><br><span class="line">                103: &#x27;iconfont icon-tijikongjian&#x27;,</span><br><span class="line">                101: &#x27;iconfont icon-shangpin&#x27;,</span><br><span class="line">                102: &#x27;iconfont icon-danju&#x27;,</span><br><span class="line">                145: &#x27;iconfont icon-baobiao&#x27;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<br>

<h3 id="5-5-左侧菜单优化"><a href="#5-5-左侧菜单优化" class="headerlink" title="5.5 左侧菜单优化"></a>5.5 左侧菜单优化</h3><ol>
<li><p>实现同时只展开一个下拉菜单功能</p>
<p>根据<code>Element-UI</code>官方文档在<code>el-menu</code>组件添加属性解决</p>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211124201954595.png" alt="image-20211124201954595"></p>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211124202637887.png" alt="image-20211124202637887"></p>
<ul>
<li>标签属性值为Boolean类型时需要进行<strong>属性绑定</strong>，否则’true’会被默认识别为String类型</li>
</ul>
</li>
</ol>
<br>

<ol start="2">
<li><p>解决下拉菜单边框超出父元素问题</p>
<p>将el-menu标签的<code>boder-right</code>设置为<code>none</code></p>
</li>
</ol>
<br>

<h3 id="5-6-左侧菜单折叠功能"><a href="#5-6-左侧菜单折叠功能" class="headerlink" title="5.6 左侧菜单折叠功能"></a>5.6 左侧菜单折叠功能</h3><p>使用<code>Element-UI</code>组件库的<code>menu</code>组件的属性实现折叠</p>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211124203710927.png" alt="image-20211124203710927"></p>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211124203716622.png" alt="image-20211124203716622"></p>
<ol>
<li><p>添加实现折叠功能的div</p>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211124203529907.png" alt="image-20211124203529907"></p>
</li>
<li><p>为div写<code>css</code>样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.toggle-button</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#4A5064</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">letter-spacing</span>: <span class="number">0.2em</span>;  //字母间间隔</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>给div绑定点击事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">toggleButton: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    		<span class="comment">//使用isToggle模板数据作为collapse属性的值 初始为false(不折叠)</span></span><br><span class="line">    		<span class="comment">//点击div修改此Boolean值实现折叠效果</span></span><br><span class="line">            <span class="built_in">this</span>.isToggle = !<span class="built_in">this</span>.isToggle</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211124203931105.png" alt="image-20211124203931105"></p>
</li>
</ol>
<center>折叠效果</center>

<br>

<h3 id="5-7-主页重定向显示welcome信息"><a href="#5-7-主页重定向显示welcome信息" class="headerlink" title="5.7 主页重定向显示welcome信息"></a>5.7 主页重定向显示welcome信息</h3><p>1.创建<code>Welcome.vue</code>单文件组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;Welcome&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>2.设定其作为<code>/home</code>路由的嵌套子路由规则</p>
<p>3.设定<code>/home</code>路由重定向到<code>/welcome</code>路由</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="comment">//路由重定向</span></span><br><span class="line">    redirect: <span class="string">&#x27;/welcome&#x27;</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    <span class="comment">// /welcome路由作为/home的嵌套子路由</span></span><br><span class="line">    children: [</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;/welcome&#x27;</span>, <span class="attr">component</span>: Welcome &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<center>src/router/index.js</center>

<p>4.在<code>home.vue</code>模板中设定路由占位符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-main</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 路由占位符 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-main</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<p>重定向的流程</p>
<ul>
<li>锚链接更改为<code>/home</code>，将<code>Home</code>组件渲染到<code>vue</code>根实例中</li>
<li><code>/home</code>路由重定向到<code>/welcome</code>，将<code>Welcome</code>组件渲染到<code>Home</code>组件中的路由占位符处</li>
</ul>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211124205445725.png" alt="image-20211124205445725"></p>
<center>重定向到/welcome路由的效果</center>

<br>

<h3 id="5-8-侧边菜单栏路由改造"><a href="#5-8-侧边菜单栏路由改造" class="headerlink" title="5.8 侧边菜单栏路由改造"></a>5.8 侧边菜单栏路由改造</h3><p>根据<code>Element-UI</code>文档<strong>给menu组件添加router属性开启<code>vue-router</code>模式</strong></p>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211124205935613.png" alt="image-20211124205935613"></p>
<p>修改二级菜单的<strong>index属性</strong>，二级菜单被激活时，根据其index值进行路由跳转</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 二级菜单 --&gt;</span></span><br><span class="line">&lt;el-menu-item</span><br><span class="line">    :index=&quot; &#x27;/&#x27; + subitem.path&quot;</span><br><span class="line">    v-for=&quot;subitem in item.children&quot;</span><br><span class="line">    :key=&quot;subitem.id&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取响应数据的path属性加上<code>&#39;/&#39;</code>作为index值进行路由跳转</li>
</ul>
<br>

<h3 id="5-9-用户列表二级菜单路由"><a href="#5-9-用户列表二级菜单路由" class="headerlink" title="5.9 用户列表二级菜单路由"></a>5.9 用户列表二级菜单路由</h3><p>1.创建<code>Users.vue</code>组件</p>
<p>2.添加<code>Home</code>组件的子路由规则</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">children: [</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;/welcome&#x27;</span>, <span class="attr">component</span>: Welcome &#125;,</span><br><span class="line">      <span class="comment">//Home组件的子路由规则渲染Users组件</span></span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;/users&#x27;</span>, <span class="attr">component</span>: Users&#125;</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211124210826671.png" alt="image-20211124210826671"></p>
<br>

<h3 id="5-10-菜单栏选中状态保持"><a href="#5-10-菜单栏选中状态保持" class="headerlink" title="5.10 菜单栏选中状态保持"></a>5.10 菜单栏选中状态保持</h3><p>默认在登陆后并<strong>点击二级菜单时</strong>，二级菜单会<strong>蓝色高亮显示</strong></p>
<p>但是当刷新页面时，对应的二级菜单组件仍被渲染，但是选中状态丢失</p>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211124211833571.png" alt="image-20211124211833571"></p>
<center>选中状态丢失</center>

<p><strong>解决办法</strong></p>
<p>menu组件的属性<code>default-active</code>值为当前选中的导航项的index值</p>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211124211917475.png" alt="image-20211124211917475"></p>
<p>在每次点击菜单项时，保存选中项的index值，在刷新等情况下对<code>default-active</code>属性重新赋值，以此保持登录状态</p>
<br>

<p><strong>1.为每个二级菜单添加点击事件，将其index值记录在<code>sessionStorage</code>中</strong></p>
<p><code>default-active</code>的取值属性绑定<code>activeIndex</code>数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 二级菜单 --&gt;</span><br><span class="line">&lt;el-menu-item</span><br><span class="line">    :index=<span class="string">&quot; &#x27;/&#x27; + subitem.path&quot;</span></span><br><span class="line">    v-<span class="keyword">for</span>=<span class="string">&quot;subitem in item.children&quot;</span></span><br><span class="line">    :key=<span class="string">&quot;subitem.id&quot;</span></span><br><span class="line">    @click=<span class="string">&quot;getNavState(&#x27;/&#x27; + subitem.path)&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">                            </span><br><span class="line">getNavState:<span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.sessionStorage.setItem(<span class="string">&#x27;activeIndex&#x27;</span>,index)</span><br><span class="line">    <span class="comment">//将选中项的index值赋给activeIndex变量，以此更改导航栏的选中项</span></span><br><span class="line">    <span class="built_in">this</span>.activeIndex = index</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.在Home组件的<code>created</code>钩子函数中进行<code>default-active</code>属性的赋值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">//组件创建完时获取菜单数据</span></span><br><span class="line">        <span class="built_in">this</span>.getMenu()</span><br><span class="line">    	<span class="comment">//activeIndex属性赋值</span></span><br><span class="line">        <span class="built_in">this</span>.activeIndex = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">&#x27;activeIndex&#x27;</span>)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<br>

<h2 id="6-用户列表Users组件"><a href="#6-用户列表Users组件" class="headerlink" title="6. 用户列表Users组件"></a>6. 用户列表Users组件</h2><h3 id="6-1-用户列表基本UI结构绘制"><a href="#6-1-用户列表基本UI结构绘制" class="headerlink" title="6.1 用户列表基本UI结构绘制"></a>6.1 用户列表基本UI结构绘制</h3><p>用户列表基本<code>UI</code>结构由<strong>面包屑导航条</strong>和<strong>卡片容器</strong>构成</p>
<br>

<p><strong>1.面包屑导航条</strong></p>
<p>使用<code>Element-UI</code>的<code>el-breadcrumb</code>组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 面包屑导航 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-breadcrumb</span> <span class="attr">separator-class</span>=<span class="string">&quot;el-icon-arrow-right&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-breadcrumb-item</span> <span class="attr">:to</span>=<span class="string">&quot;&#123; path: &#x27;/&#x27; &#125;&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-breadcrumb-item</span>&gt;</span>用户管理<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-breadcrumb-item</span>&gt;</span>用户列表<span class="tag">&lt;/<span class="name">el-breadcrumb-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-breadcrumb</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<p><strong>2.卡片容器</strong></p>
<p>使用<code>el-card</code>组件实现卡片容器</p>
<p>使用<code>el-row</code>和<code>el-col</code>组件实现分栏布局</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 卡片容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-card</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 分栏布局 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- gutter设定每列间隔 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-row</span> <span class="attr">:gutter</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 占据8栏 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;8&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 输入框组件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入内容&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">slot</span>=<span class="string">&quot;append&quot;</span> <span class="attr">class</span>=<span class="string">&quot;el-icon-search&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span>查找用户<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-card</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>分栏布局</strong></p>
<p>通过基础的24分栏，快速构建布局</p>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211124222157710.png" alt="image-20211124222157710"></p>
<center>基本UI绘制</center>

<br>

<h3 id="6-2-用户列表数据获取"><a href="#6-2-用户列表数据获取" class="headerlink" title="6.2 用户列表数据获取"></a>6.2 用户列表数据获取</h3><p>根据后台API接口文档建立<code>axios get</code>请求</p>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211125120252626.png" alt="image-20211125120252626"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.usersList()	<span class="comment">//组件创建完后即发起axios请求</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        usersList:<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> &#123;<span class="attr">data</span>:res&#125; = <span class="keyword">await</span> <span class="built_in">this</span>.$http.get(<span class="string">&#x27;users&#x27;</span>,&#123;<span class="attr">params</span>:<span class="built_in">this</span>.paramsInfo&#125;)	<span class="comment">//使用构建好的paramsInfo数据作为请求参数</span></span><br><span class="line">            <span class="keyword">if</span>(res.meta.status !== <span class="number">200</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.$message.error(res.meta.msg)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.userlist = res.data.users	<span class="comment">//查询出的用户数组赋值</span></span><br><span class="line">            <span class="built_in">this</span>.total = res.data.total		<span class="comment">//查询出的总数赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="6-3-用户列表数据表格绘制"><a href="#6-3-用户列表数据表格绘制" class="headerlink" title="6.3 用户列表数据表格绘制"></a>6.3 用户列表数据表格绘制</h3><p>使用<code>el-table</code>和<code>el-table-column</code>组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 用户数据表格渲染 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- stripe隔行变色 border竖直边框 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- data即为表格数据源userlist数组 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-table</span> <span class="attr">:data</span>=<span class="string">&quot;userlist&quot;</span> <span class="attr">stripe</span> <span class="attr">border</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- type=&quot;index&quot; 添加表格索引列 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">&quot;#&quot;</span> <span class="attr">type</span>=<span class="string">&quot;index&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- label表格列名 prop列数据对应的值(userlist中的对象属性) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">&quot;姓名&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">&quot;邮箱&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">&quot;电话&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;mobile&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">&quot;角色&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;role_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">&quot;状态&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;mg_state&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">&quot;操作&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211125121833078.png" alt="image-20211125121833078"></p>
<br>

<h4 id="6-3-1-通过作用域插槽渲染状态列开关"><a href="#6-3-1-通过作用域插槽渲染状态列开关" class="headerlink" title="6.3.1 通过作用域插槽渲染状态列开关"></a>6.3.1 通过作用域插槽渲染状态列开关</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">&quot;状态&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;mg_state&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 作用域插槽 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;scope&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-switch</span> <span class="attr">v-model</span>=<span class="string">&quot;scope.row.mg_state&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-switch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>el-table-column</code>组件的<code>template</code>模板字段中使用<strong>slot插槽的row属性</strong>向父组件传递了当前行的信息，父组件通过<strong>作用域插槽</strong>的<code>slot-scope</code>属性接收</p>
<ul>
<li>使用<code>scope.row.mg_state</code>即可获取当前行状态列的值(Boolean值)</li>
</ul>
<br>

<p>使用<code>Element-UI</code>组件库的<strong>Switch开关组件</strong>实现状态列的开关显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-switch</span> <span class="attr">v-model</span>=<span class="string">&quot;scope.row.mg_state&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-switch</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>开关组件<strong>双向数据绑定</strong><code>scope.row.mg_state</code>(Boolean类型)，开关组件根据Boolean值改变状态</li>
</ul>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211125124836594.png" alt="image-20211125124836594"></p>
<center>状态列开关组件渲染</center>

<br>

<h4 id="6-3-2-作用域插槽渲染操作列按钮"><a href="#6-3-2-作用域插槽渲染操作列按钮" class="headerlink" title="6.3.2 作用域插槽渲染操作列按钮"></a>6.3.2 作用域插槽渲染操作列按钮</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">&quot;操作&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;scope&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 修改按钮 --&gt;</span></span><br><span class="line">        &lt;el-button</span><br><span class="line">            type=&quot;primary&quot;</span><br><span class="line">            icon=&quot;el-icon-edit&quot;</span><br><span class="line">            size=&quot;mini&quot;</span><br><span class="line">         &gt;<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">		 <span class="comment">&lt;!-- 删除按钮 --&gt;</span></span><br><span class="line">         &lt;el-button</span><br><span class="line">            type=&quot;danger&quot;</span><br><span class="line">            icon=&quot;el-icon-delete&quot;</span><br><span class="line">            size=&quot;mini&quot;</span><br><span class="line">          &gt;<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">		  <span class="comment">&lt;!-- 鼠标悬停时提示文字 --&gt;</span></span><br><span class="line">          &lt;el-tooltip</span><br><span class="line">              :enterable=&quot;false&quot;</span><br><span class="line">              class=&quot;item&quot;</span><br><span class="line">              effect=&quot;dark&quot;</span><br><span class="line">              content=&quot;分配角色&quot;</span><br><span class="line">              placement=&quot;top&quot;</span><br><span class="line">          &gt; </span><br><span class="line">            <span class="comment">&lt;!-- 分配角色按钮 --&gt;</span></span><br><span class="line">            &lt;el-button</span><br><span class="line">                type=&quot;warning&quot;</span><br><span class="line">                icon=&quot;el-icon-setting&quot;</span><br><span class="line">                size=&quot;mini&quot;</span><br><span class="line">            &gt;<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    	  <span class="tag">&lt;/<span class="name">el-tooltip</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>el-button</code>组件和<code>el-tooltip</code>组件</p>
<p><code>el-tooltip</code>组件用于展示<strong>鼠标悬停时的提示信息</strong></p>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211126110819097.png" alt="image-20211126110819097"></p>
<br>

<h3 id="6-4-数据分页效果"><a href="#6-4-数据分页效果" class="headerlink" title="6.4 数据分页效果"></a>6.4 数据分页效果</h3><p>使用<code>el-pagination</code>组件实现分页效果</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;el-pagination</span><br><span class="line">   @size-change=&quot;handleSizeChange&quot;</span><br><span class="line">   @current-change=&quot;handleCurrentChange&quot;</span><br><span class="line">   :current-page=&quot;paramsInfo.pagenum&quot;</span><br><span class="line">   :page-sizes=&quot;[1, 2, 3, 4]&quot;</span><br><span class="line">   :page-size=&quot;paramsInfo.pagesize&quot;</span><br><span class="line">   layout=&quot;total, sizes, prev, pager, next, jumper&quot;</span><br><span class="line">   :total=&quot;total&quot;</span><br><span class="line">               &gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">el-pagination</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>size-change：自定义事件绑定，<strong>每页显示数据条数</strong>改变时触发</li>
<li>current-change：当前显示页变化时触发</li>
<li>current-page：当前显示的页码，属性绑定<code>paramsInfo.pagenum</code></li>
<li>page-sizes：属性绑定一个数组，表示可选的<strong>每页数据条数</strong></li>
<li>layout：分页组件功能布局(总数，页数据条数选择等)</li>
<li>total：属性绑定查询的数据总数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handleSizeChange:<span class="function"><span class="keyword">function</span>(<span class="params">newsize</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.paramsInfo.pagesize = newsize</span><br><span class="line">    <span class="built_in">this</span>.usersList()</span><br><span class="line">&#125;,</span><br><span class="line">handleCurrentChange:<span class="function"><span class="keyword">function</span>(<span class="params">newpage</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//修改请求参数对象</span></span><br><span class="line">    <span class="built_in">this</span>.paramsInfo.pagenum = newpage</span><br><span class="line">    <span class="comment">//重新发起请求</span></span><br><span class="line">    <span class="built_in">this</span>.usersList()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>事件处理函数，当<strong>每页数据条数变化</strong>或者<strong>当前显示页码变化</strong>时触发</li>
<li>根据<strong>新的查询参数重新发起请求</strong>后渲染数据表格</li>
</ul>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211126125249190.png" alt="image-20211126125249190"></p>
<br>

<h3 id="6-5-状态列修改保存到数据库"><a href="#6-5-状态列修改保存到数据库" class="headerlink" title="6.5 状态列修改保存到数据库"></a>6.5 状态列修改保存到数据库</h3><p>1.状态开关绑定<strong>change事件</strong>，传递<strong>当前行用户信息</strong>作为参数</p>
<p>2.事件处理函数中发起修改用户信息的put请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;el-<span class="keyword">switch</span></span><br><span class="line">    v-model=<span class="string">&quot;scope.row.mg_state</span></span><br><span class="line"><span class="string">	//change事件绑定</span></span><br><span class="line"><span class="string">    @change=&quot;</span>switchChange(scope.row)<span class="string">&quot;</span></span><br><span class="line"><span class="string">&gt;&lt;/el-switch&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">switchChange: <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">userinfo</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//发起put修改请求</span></span><br><span class="line">    <span class="keyword">let</span> &#123;<span class="attr">data</span>:res&#125; = <span class="keyword">await</span> <span class="built_in">this</span>.$http.put(<span class="string">`users/<span class="subst">$&#123;userinfo.id&#125;</span>/state/<span class="subst">$&#123;userinfo.mg_state&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">if</span>(res.meta.status !== <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="comment">//修改失败 弹窗错误信息</span></span><br><span class="line">        <span class="built_in">this</span>.$message.error(res.meta.msg)</span><br><span class="line">        <span class="comment">//重置用户状态</span></span><br><span class="line">        userinfo.mg_state = !userinfo.mg_state</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//修改成功 弹窗成功提示</span></span><br><span class="line">        <span class="built_in">this</span>.$message.success(res.meta.msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>修改状态开关后提交请求<strong>修改数据库中的用户数据</strong>，保存新状态信息</p>
<br>

<h3 id="6-6-搜索按钮功能实现"><a href="#6-6-搜索按钮功能实现" class="headerlink" title="6.6 搜索按钮功能实现"></a>6.6 搜索按钮功能实现</h3><p>1.输入框双向属性绑定<code>paramsInfo.query</code>，输入框内容即为<code>get</code>请求参数中的<code>query</code>参数</p>
<p>2.<strong>搜索按钮绑定点击事件</strong>调用<code>userList</code>方法发起<code>get</code>请求</p>
<p>3.在输入框添加<strong>清空按钮</strong>，输入框绑定清空事件，<strong>清空时重新发起请求</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;el-input</span><br><span class="line">   placeholder=&quot;请输入内容&quot;</span><br><span class="line">   v-model=&quot;paramsInfo.query&quot;</span><br><span class="line">   clearable</span><br><span class="line">   @clear=&quot;usersList&quot;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;el-button</span><br><span class="line">        slot=&quot;append&quot;</span><br><span class="line">        class=&quot;el-icon-search&quot;</span><br><span class="line">        @click=&quot;usersList&quot;</span><br><span class="line">        &gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>el-input</code>的<code>clearable</code>属性：是否可清空</p>
<p><code>clear</code>事件绑定：在点击输入框清空按钮后触发</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">paramsInfo: &#123;</span><br><span class="line">    query: <span class="string">&#x27;&#x27;</span>,	<span class="comment">//根据字符串查询对应用户名的用户信息</span></span><br><span class="line">    pagenum: <span class="number">1</span>,</span><br><span class="line">    pagesize: <span class="number">2</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>query参数可以为空，不为空时<strong>查询所有用户名包含query参数</strong>的用户信息</p>
<br>

<h3 id="6-7-添加用户表单"><a href="#6-7-添加用户表单" class="headerlink" title="6.7 添加用户表单"></a>6.7 添加用户表单</h3><p>点击添加用户按钮，修改<code>el-dialog</code>组件的<code>visible.sync</code>属性<strong>显示用户表单弹窗</strong></p>
<p>使用<code>el-dialog</code>组件弹窗实现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;el-form</span><br><span class="line">         :model=&quot;addUserInfo&quot;</span><br><span class="line">         :rules=&quot;addUserRules&quot;</span><br><span class="line">         ref=&quot;addUserRef&quot;</span><br><span class="line">         label-width=&quot;70px&quot;</span><br><span class="line">&gt;</span><br><span class="line">	<span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;用户名&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;addUserInfo.username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;密码&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;addUserInfo.password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;邮箱&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;addUserInfo.email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;手机号&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;mobile&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;addUserInfo.mobile&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">addUserRules:&#123;</span><br><span class="line">    username:[</span><br><span class="line">        &#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;用户名必填&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">min</span>: <span class="number">3</span>, <span class="attr">max</span>: <span class="number">5</span>, <span class="attr">message</span>: <span class="string">&#x27;长度在 3 到 5 个字符&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    password:[</span><br><span class="line">            &#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;密码必填&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">min</span>: <span class="number">6</span>, <span class="attr">max</span>: <span class="number">10</span>, <span class="attr">message</span>: <span class="string">&#x27;长度在 6 到 10 个字符&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    email:[</span><br><span class="line">            &#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;邮箱必填&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    mobile:[</span><br><span class="line">            &#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;邮箱必填&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">min</span>: <span class="number">11</span>, <span class="attr">max</span>: <span class="number">11</span>, <span class="attr">message</span>: <span class="string">&#x27;长度为 11 个字符&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211126192733781.png" alt="image-20211126192733781"></p>
<br>

<h4 id="6-7-1-自定义验证规则使用"><a href="#6-7-1-自定义验证规则使用" class="headerlink" title="6.7.1 自定义验证规则使用"></a>6.7.1 自定义验证规则使用</h4><p>对于<strong>邮箱和手机号</strong>使用自定义验证规则进行验证</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> checkemail = <span class="function">(<span class="params">rule,value,cb</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//使用正则表达式进行验证</span></span><br><span class="line">    <span class="keyword">const</span> regEmail = <span class="regexp">/^([A-Za-z0-9_-])+@([A-Za-z0-9-_])+(\.[a-zA-Z0-9_-])+/</span></span><br><span class="line">    <span class="keyword">if</span>(regEmail.test(value))&#123;</span><br><span class="line">        <span class="comment">//通过验证</span></span><br><span class="line">        <span class="keyword">return</span> cb()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//验证失败</span></span><br><span class="line">    <span class="keyword">return</span> cb(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请输入正确格式的邮箱&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> checkmobile = <span class="function">(<span class="params">rule,value,cb</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> regMobile = <span class="regexp">/^(0|86|17951)?(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]&#123;8&#125;$/</span></span><br><span class="line">    <span class="keyword">if</span>(regMobile.test(value))&#123;</span><br><span class="line">        <span class="keyword">return</span> cb()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cb(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请输入正确格式的手机号&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在组件数据<code>data()&#123;&#125;</code>中定义 验证规则(在<code>return</code>前定义)</li>
<li>自定义验证规则变量为一个<strong>箭头函数</strong><ul>
<li>接收3个参数 <code>rule,value和cb</code></li>
<li><code>rule</code>：验证规则</li>
<li><code>value</code>：<strong>待验证的数据</strong></li>
<li><code>cb</code>：回调函数，返回验证结果时调用(通过则无参数调用，失败则以错误对象作为参数)</li>
</ul>
</li>
</ul>
<br>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">email:[</span><br><span class="line">    &#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;邮箱必填&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;,</span><br><span class="line">    <span class="comment">//使用自定义验证规则进行验证(validator:验证规则对象)</span></span><br><span class="line">    &#123; <span class="attr">validator</span>: checkemail, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span>&#125;</span><br><span class="line">],</span><br><span class="line">mobile:[</span><br><span class="line">   &#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;邮箱必填&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;,</span><br><span class="line">   &#123; <span class="attr">validator</span>: checkmobile, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>addUserRules</code>验证规则对象中使用自定义验证规则</li>
</ul>
<br>

<h4 id="6-7-2-添加用户表单关闭后重置"><a href="#6-7-2-添加用户表单关闭后重置" class="headerlink" title="6.7.2 添加用户表单关闭后重置"></a>6.7.2 添加用户表单关闭后重置</h4><p>1.监听dialog关闭事件</p>
<p>2.在关闭事件中调用表单引用的resetFields方法清空表单</p>
<br>

<h4 id="6-7-3-添加用户前预校验"><a href="#6-7-3-添加用户前预校验" class="headerlink" title="6.7.3 添加用户前预校验"></a>6.7.3 添加用户前预校验</h4><p>1.确定按钮绑定点击事件</p>
<p>2.点击事件中调用表单引用的<code>validate</code>方法进行预校验</p>
<br>

<h4 id="6-7-4-校验通过发送添加用户请求"><a href="#6-7-4-校验通过发送添加用户请求" class="headerlink" title="6.7.4 校验通过发送添加用户请求"></a>6.7.4 校验通过发送添加用户请求</h4><p>1.在表单引用的<code>validate</code>方法的<strong>参数箭头函数</strong>中发送添加用户请求 (根据接口文档中请求格式)</p>
<p>2.发送后获取响应，判断是否添加成功，成功则<strong>提示成功信息，隐藏dialog，刷新用户列表</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$refs.addUserRef.validate(<span class="keyword">async</span> valid =&gt; &#123;</span><br><span class="line">    <span class="comment">//验证不通过</span></span><br><span class="line">    <span class="keyword">if</span>(!valid) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">//通过则发起添加用户请求 </span></span><br><span class="line">    <span class="keyword">let</span> &#123;<span class="attr">data</span>:res&#125; = <span class="keyword">await</span> <span class="built_in">this</span>.$http.post(<span class="string">&#x27;users&#x27;</span>,<span class="built_in">this</span>.addUserInfo)</span><br><span class="line">    <span class="keyword">if</span>(res.meta.status !== <span class="number">201</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.$message.error(<span class="string">&#x27;添加用户失败&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$message.success(<span class="string">&#x27;添加用户成功&#x27;</span>)</span><br><span class="line">        <span class="comment">//添加成功后隐藏dialog</span></span><br><span class="line">        <span class="built_in">this</span>.userAddVisible = <span class="literal">false</span></span><br><span class="line">        <span class="comment">//添加成功后刷新用户列表</span></span><br><span class="line">        <span class="built_in">this</span>.usersList()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="6-8-修改用户弹窗"><a href="#6-8-修改用户弹窗" class="headerlink" title="6.8 修改用户弹窗"></a>6.8 修改用户弹窗</h3><p>1.加入修改用户的<code>dialog</code>弹窗，控制弹窗显示的变量为<code>userEditVisible</code></p>
<p>2.修改按钮绑定点击事件</p>
<p>3.点击事件中置<code>userEditVisible</code>为<code>true</code>，显示修改弹窗，进行修改相应的操作</p>
<h4 id="6-8-1-根据ID查询待修改用户的数据"><a href="#6-8-1-根据ID查询待修改用户的数据" class="headerlink" title="6.8.1 根据ID查询待修改用户的数据"></a>6.8.1 根据ID查询待修改用户的数据</h4><p>发起请求查询用户数据 <strong>(users/:id)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改用户</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">userEdit</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//显示弹窗</span></span><br><span class="line">    <span class="built_in">this</span>.userEditVisible = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">let</span> &#123;<span class="attr">data</span>:res&#125; = <span class="keyword">await</span> <span class="built_in">this</span>.$http.get(<span class="string">&#x27;users/&#x27;</span> + id)</span><br><span class="line">    <span class="keyword">if</span>(res.meta.status !== <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.$message.error(<span class="string">&#x27;查询用户信息失败&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//保存用户信息到editUserInfo中</span></span><br><span class="line">        <span class="built_in">this</span>.editUserInfo = res.data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-8-2-修改用户表单绘制"><a href="#6-8-2-修改用户表单绘制" class="headerlink" title="6.8.2 修改用户表单绘制"></a>6.8.2 修改用户表单绘制</h4><p>1.在修改用户的<code>dialog</code>弹窗中<strong>加入修改表单作为<code>dialog</code>主体</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-form</span> <span class="attr">:model</span>=<span class="string">&quot;editForm&quot;</span> <span class="attr">:rules</span>=<span class="string">&quot;editFormRules&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;editFormRef&quot;</span> <span class="attr">label-width</span>=<span class="string">&quot;70px&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;用户名&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;editForm.username&quot;</span> <span class="attr">disabled</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;邮箱&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;editForm.email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;手机&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;mobile&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;editForm.mobile&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.组件数据中加入修改表单的验证规则<code>editFormRules</code></p>
<br>

<h4 id="6-8-3-修改弹窗关闭后重置"><a href="#6-8-3-修改弹窗关闭后重置" class="headerlink" title="6.8.3 修改弹窗关闭后重置"></a>6.8.3 修改弹窗关闭后重置</h4><p>1.弹窗添加close事件</p>
<p>2.close事件处理函数中调用表单引用的resetFields方法</p>
<h4 id="6-8-4-修改预验证通过后提交"><a href="#6-8-4-修改预验证通过后提交" class="headerlink" title="6.8.4 修改预验证通过后提交"></a>6.8.4 修改预验证通过后提交</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改提交预验证</span></span><br><span class="line"><span class="function"><span class="title">userEditInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$refs.editFormRef.validate( <span class="keyword">async</span> valid =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(!valid) <span class="keyword">return</span></span><br><span class="line">        <span class="comment">//验证通过发送修改请求</span></span><br><span class="line">        <span class="keyword">let</span> &#123;<span class="attr">data</span>:res&#125; = <span class="keyword">await</span> <span class="built_in">this</span>.$http.put(<span class="string">&#x27;users/&#x27;</span> + <span class="built_in">this</span>.editForm.id, &#123;</span><br><span class="line">            email:<span class="built_in">this</span>.editForm.email,</span><br><span class="line">            mobile:<span class="built_in">this</span>.editForm.mobile</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span>(res.meta.status != <span class="number">200</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.$message.error(<span class="string">&#x27;修改失败&#x27;</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//关闭弹窗</span></span><br><span class="line">            <span class="built_in">this</span>.userEditVisible = <span class="literal">false</span></span><br><span class="line">            <span class="comment">//刷新用户数据</span></span><br><span class="line">            <span class="built_in">this</span>.usersList()</span><br><span class="line">            <span class="comment">//提示修改成功</span></span><br><span class="line">            <span class="built_in">this</span>.$message.success(<span class="string">&#x27;修改成功&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>通过<code>validate</code>方法进行预验证</li>
<li>通过验证后发送修改请求(PUT方式)</li>
<li>接收正确响应后，关闭修改弹窗，刷新用户数据，提示成功信息</li>
</ol>
<br>

<h3 id="6-9-用户删除操作"><a href="#6-9-用户删除操作" class="headerlink" title="6.9 用户删除操作"></a>6.9 用户删除操作</h3><h4 id="6-9-1-删除用户弹框"><a href="#6-9-1-删除用户弹框" class="headerlink" title="6.9.1 删除用户弹框"></a>6.9.1 删除用户弹框</h4><p>点击删除用户按钮后弹框提示再次确认</p>
<ol>
<li>从<code>ElementUI</code>按需导入<code>MessageBox</code>，注册为<code>Vue</code>原型对象的属性<code>Vue.prototype.$confirm = MessageBox</code></li>
<li>删除按钮绑定点击事件(用户id作为参数)</li>
<li>点击事件中使用<code>$confirm</code>进行弹框提示</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按id删除用户</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">removeUserByID</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//弹框再次确认</span></span><br><span class="line">    <span class="keyword">let</span> confirmRes =  <span class="keyword">await</span> <span class="built_in">this</span>.$confirm(<span class="string">&#x27;此操作将永久删除该用户, 是否继续?&#x27;</span>, <span class="string">&#x27;提示&#x27;</span>, &#123;</span><br><span class="line">        confirmButtonText: <span class="string">&#x27;确定&#x27;</span>,</span><br><span class="line">        cancelButtonText: <span class="string">&#x27;取消&#x27;</span>,</span><br><span class="line">        type: <span class="string">&#x27;warning&#x27;</span>,</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> err)	<span class="comment">//关闭弹框时的处理</span></span><br><span class="line">    <span class="comment">//判断用户点击确认还是关闭弹框</span></span><br><span class="line">    <span class="keyword">if</span>(confirmRes != <span class="string">&#x27;confirm&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.$message.info(<span class="string">&#x27;取消删除&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$message.success(<span class="string">&#x27;确认删除&#x27;</span>)</span><br><span class="line">        <span class="comment">//发送删除请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.$confirm</code>返回Promise对象，使用<code>async</code>和<code>await</code>简化操作</li>
</ul>
<h4 id="6-9-2-发送删除请求"><a href="#6-9-2-发送删除请求" class="headerlink" title="6.9.2 发送删除请求"></a>6.9.2 发送删除请求</h4><p>再次确认删除后发送删除请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送删除请求</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">data</span>:res&#125; = <span class="keyword">await</span> <span class="built_in">this</span>.$http.delete(<span class="string">&#x27;users/&#x27;</span> + id)</span><br><span class="line"><span class="keyword">if</span>(res.meta.status !== <span class="number">200</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$message.error(<span class="string">&#x27;删除失败&#x27;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$message.success(<span class="string">&#x27;删除成功&#x27;</span>)</span><br><span class="line">    <span class="comment">//刷新用户数据</span></span><br><span class="line">    <span class="built_in">this</span>.usersList()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据id删除用户后刷新用户数据</li>
</ul>
<br>

<h2 id="7-权限列表Rights组件"><a href="#7-权限列表Rights组件" class="headerlink" title="7. 权限列表Rights组件"></a>7. 权限列表Rights组件</h2><ol>
<li>创建<code>Rights.vue</code>文件</li>
<li><code>router/index.js</code>中设置路由规则</li>
</ol>
<h3 id="7-1-权限列表页面布局"><a href="#7-1-权限列表页面布局" class="headerlink" title="7.1 权限列表页面布局"></a>7.1 权限列表页面布局</h3><p>1.面包屑</p>
<p>2.卡片视图</p>
<h3 id="7-2-权限列表数据获取"><a href="#7-2-权限列表数据获取" class="headerlink" title="7.2 权限列表数据获取"></a>7.2 权限列表数据获取</h3><p>使用get请求在<strong>created钩子函数</strong>中获取权限列表</p>
<p>请求URL为 <code>/rights/list</code>，获取<strong>数组格式</strong>的权限数据</p>
<h3 id="7-3-权限列表表格布局"><a href="#7-3-权限列表表格布局" class="headerlink" title="7.3 权限列表表格布局"></a>7.3 权限列表表格布局</h3><p>权限等级列使用<strong>el-tag组件</strong>展示等级标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">&quot;权限等级&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;level&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 作用域插槽获取本行数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;scope&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-tag</span> <span class="attr">v-if</span>=<span class="string">&quot;scope.row.level === &#x27;0&#x27;&quot;</span>&gt;</span>一级<span class="tag">&lt;/<span class="name">el-tag</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-tag</span> <span class="attr">type</span>=<span class="string">&quot;success&quot;</span> <span class="attr">v-else-if</span>=<span class="string">&quot;scope.row.level === &#x27;1&#x27;&quot;</span>&gt;</span>二级<span class="tag">&lt;/<span class="name">el-tag</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-tag</span> <span class="attr">type</span>=<span class="string">&quot;warning&quot;</span> <span class="attr">v-else</span>&gt;</span>三级<span class="tag">&lt;/<span class="name">el-tag</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>v-if</code>选择指令<strong>判断应该显示的等级标签</strong></li>
</ul>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211209210301468.png" alt="image-20211209210301468"></p>
<br>

<h3 id="7-4-权限管理业务分析"><a href="#7-4-权限管理业务分析" class="headerlink" title="7.4 权限管理业务分析"></a>7.4 权限管理业务分析</h3><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211209210647131.png" alt="image-20211209210647131"></p>
<center>用户-角色-权限关系图</center>

<ul>
<li>给用户设置角色，每个角色对应不同的权限</li>
<li><strong>用户根据自身角色拥有对应权限</strong></li>
</ul>
<br>

<h2 id="8-角色列表Roles组件"><a href="#8-角色列表Roles组件" class="headerlink" title="8. 角色列表Roles组件"></a>8. 角色列表Roles组件</h2><ol>
<li>创建<code>Roles.vue</code>文件</li>
<li><code>router/index.js</code>中设置路由规则</li>
</ol>
<h3 id="8-1-角色列表页面布局"><a href="#8-1-角色列表页面布局" class="headerlink" title="8.1 角色列表页面布局"></a>8.1 角色列表页面布局</h3><p>1.面包屑</p>
<p>2.卡片视图</p>
<h3 id="8-2-角色列表数据获取"><a href="#8-2-角色列表数据获取" class="headerlink" title="8.2 角色列表数据获取"></a>8.2 角色列表数据获取</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">getRolesList</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//get请求获取角色列表数据</span></span><br><span class="line">    <span class="keyword">let</span> &#123;<span class="attr">data</span>:res&#125; = <span class="keyword">await</span> <span class="built_in">this</span>.$http.get(<span class="string">&#x27;roles&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(res.meta.status != <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.$message.error(<span class="string">&#x27;角色列表获取失败&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.rolesList = res.data</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.rolesList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-角色列表表格布局"><a href="#8-3-角色列表表格布局" class="headerlink" title="8.3 角色列表表格布局"></a>8.3 角色列表表格布局</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 角色列表表格 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-table</span> <span class="attr">:data</span>=<span class="string">&quot;rolesList&quot;</span> <span class="attr">stripe</span> <span class="attr">border</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 展开列 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">type</span>=<span class="string">&quot;expand&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 索引列 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">type</span>=<span class="string">&quot;index&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;roleName&quot;</span> <span class="attr">label</span>=<span class="string">&quot;角色名称&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;roleDesc&quot;</span> <span class="attr">label</span>=<span class="string">&quot;角色描述&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 操作列 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">&quot;操作&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;scope&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">icon</span>=<span class="string">&quot;el-icon-edit&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;danger&quot;</span> <span class="attr">icon</span>=<span class="string">&quot;el-icon-delete&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;warning&quot;</span> <span class="attr">icon</span>=<span class="string">&quot;el-icon-setting&quot;</span>&gt;</span>分配权限<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211209214936861.png" alt="image-20211209214936861"></p>
<br>

<h3 id="8-4-展开列各级权限视图渲染"><a href="#8-4-展开列各级权限视图渲染" class="headerlink" title="8.4 展开列各级权限视图渲染"></a>8.4 展开列各级权限视图渲染</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 展开列 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">type</span>=<span class="string">&quot;expand&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;scope&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-row</span> <span class="attr">:class</span>=<span class="string">&quot;[&#x27;bdbottom&#x27; , i1 === 0 ? &#x27;bdtop&#x27; : &#x27;&#x27;,&#x27;vcenter&#x27;]&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;(item1,i1) in scope.row.children&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item1.id&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 渲染一级权限 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-tag</span>&gt;</span>&#123;&#123;item1.authName&#125;&#125;<span class="tag">&lt;/<span class="name">el-tag</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;el-icon-caret-right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 二三级权限 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;19&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-row</span> <span class="attr">:class</span>=<span class="string">&quot;[i2 === 0 ? &#x27;&#x27; : &#x27;bdtop&#x27;, &#x27;vcenter&#x27; ]&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;(item2,i2) in item1.children&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item2.id&quot;</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 二级权限 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;6&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-tag</span> <span class="attr">type</span>=<span class="string">&quot;success&quot;</span>&gt;</span>&#123;&#123;item2.authName&#125;&#125;<span class="tag">&lt;/<span class="name">el-tag</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;el-icon-caret-right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 三级权限 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;18&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-tag</span> <span class="attr">type</span>=<span class="string">&quot;warning&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;(item3,i3) in item2.children&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item3.id&quot;</span>&gt;</span>&#123;&#123;item3.authName&#125;&#125;<span class="tag">&lt;/<span class="name">el-tag</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211215170826499.png" alt="image-20211215170826499"></p>
<ul>
<li><p>循环每一级数据的<strong>children数组</strong>渲染各级权限</p>
</li>
<li><p>设置最小宽度，使窗口过小时显示宽度不变</p>
<ul>
<li>```css<br>#app{<pre><code>/* 页面宽度小于1400px时，固定为1400px显示 */
min-width: 1400px;
</code></pre>
}<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 设置tag组件垂直居中（使用flex布局）</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;css</span><br><span class="line">    &#x2F;&#x2F; 垂直居中</span><br><span class="line">    .vcenter&#123;</span><br><span class="line">        display: flex;</span><br><span class="line">        align-items: center;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<br>

<h3 id="8-5-展开列下删除角色指定权限"><a href="#8-5-展开列下删除角色指定权限" class="headerlink" title="8.5 展开列下删除角色指定权限"></a>8.5 展开列下删除角色指定权限</h3><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20211215172820759.png" alt="image-20211215172820759"></p>
<ul>
<li>给<strong>各级tag标签</strong>添加删除按钮</li>
<li>绑定close事件</li>
<li>事件<code>deleteRightsById</code>中进行删除操作( MessageBox 弹框)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除角色权限</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">deleteRightsById</span>(<span class="params">role, rightId</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> confirmResult = <span class="keyword">await</span> <span class="built_in">this</span>.$confirm(</span><br><span class="line">        <span class="string">&#x27;此操作将永久删除该权限, 是否继续?&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;提示&#x27;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            confirmButtonText: <span class="string">&#x27;确定&#x27;</span>,</span><br><span class="line">            cancelButtonText: <span class="string">&#x27;取消&#x27;</span>,</span><br><span class="line">            type: <span class="string">&#x27;warning&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> err)</span><br><span class="line">    <span class="keyword">if</span> (confirmResult != <span class="string">&#x27;confirm&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$message.info(<span class="string">&#x27;取消删除&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//确认删除，发起delete请求</span></span><br><span class="line">        <span class="keyword">let</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> <span class="built_in">this</span>.$http.delete(</span><br><span class="line">            <span class="string">`roles/<span class="subst">$&#123;role.id&#125;</span>/rights/<span class="subst">$&#123;rightId&#125;</span>`</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> (res.meta.status !== <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.$message.error(<span class="string">&#x27;删除权限失败&#x27;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//修改当前角色的权限信息，避免全部刷新，仅刷新当前角色权限</span></span><br><span class="line">            role.children = res.data</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>delete请求返回结果后，修改<strong>当前角色的权限信息</strong>，避免全部刷新</li>
</ul>
<br>

<h3 id="8-6-分配权限"><a href="#8-6-分配权限" class="headerlink" title="8.6 分配权限"></a>8.6 分配权限</h3><p>1.点击分配权限按钮，从后台获取权限信息，显示在弹出的dialog对话框中    </p>
<ul>
<li>使用<strong>树形控件</strong>(Element-UI组件)将权限树形展示</li>
</ul>
<br>

<p>2.对树形控件进行优化</p>
<ul>
<li>每个权限显示复选框</li>
<li>对话框展示自动展开所有权限</li>
<li>树形中<strong>每个权限节点设置对应的唯一标识</strong>(使用权限id做为标识)</li>
</ul>
<br>

<p>3.已有三级权限的默认勾选</p>
<p><strong>使用递归获取角色拥有的三级权限id</strong>，使用树形控件的<code>default-checked-keys</code>属性默认勾选角色已有权限。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过递归获取角色已有三级权限的id，存入defKeys数组，使对话框默认选中已有权限</span></span><br><span class="line"><span class="function"><span class="title">getLeafKeys</span>(<span class="params">node,arr</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 没有children说明是最后一级权限</span></span><br><span class="line">    <span class="keyword">if</span>(!node.children) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.push(node.id)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        node.children.forEach(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">this</span>.getLeafKeys(item,arr))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>递归获取角色的三级权限id</center>

<br>

<p>4.树形权限结构中修改权限后发起请求同步修改</p>
<ul>
<li>分配权限Dialog框确定按钮绑定<code>allowRights</code>事件</li>
<li><code>allowRights</code>事件中<strong>获取选中权限的id</strong>，发起请求(<code>角色授权</code>)修改数据库</li>
<li>重新获取<code>rightsList</code>，隐藏Dialog框</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">allowRights</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//获取选中和半选中节点的key值数组</span></span><br><span class="line">    <span class="keyword">let</span> keys = [...this.$refs.treeRef.getCheckedKeys(),</span><br><span class="line">                ...this.$refs.treeRef.getHalfCheckedKeys()</span><br><span class="line">               ]</span><br><span class="line">    <span class="keyword">const</span> idStr = keys.join(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="comment">//选中的权限id发送到后台</span></span><br><span class="line">    <span class="keyword">let</span> &#123;<span class="attr">data</span>:res&#125; = <span class="keyword">await</span> <span class="built_in">this</span>.$http.post(<span class="string">`roles/<span class="subst">$&#123;<span class="built_in">this</span>.roleId&#125;</span>/rights`</span>,&#123;<span class="attr">rids</span>:idStr&#125;)</span><br><span class="line">    <span class="keyword">if</span>(res.meta.status !== <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.$message.error(<span class="string">&#x27;分配权限失败&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$message.success(<span class="string">&#x27;分配权限成功&#x27;</span>)</span><br><span class="line">        <span class="comment">//重新获取权限数据</span></span><br><span class="line">        <span class="built_in">this</span>.getRolesList()</span><br><span class="line">        <span class="built_in">this</span>.setRightDialogVisible = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="8-7-用户列表Users组件给用户分配角色"><a href="#8-7-用户列表Users组件给用户分配角色" class="headerlink" title="* 8.7 用户列表Users组件给用户分配角色"></a>* 8.7 用户列表Users组件给用户分配角色</h3><p>1.分配角色弹框</p>
<p>2.弹框中下拉列表(<code>el-select</code>)选择用户的新角色</p>
<ul>
<li>弹框关闭清除选中的新角色id (<code>selectedRoleId</code>)，下次打开下拉列表显示<code>&#39;请选择&#39;</code></li>
</ul>
<p>3.使用新角色id发送请求同步数据</p>
<p>4.重新获取用户数据列表</p>
<br>

<h3 id="8-8-权限管理开发完毕Git提交"><a href="#8-8-权限管理开发完毕Git提交" class="headerlink" title="8.8 权限管理开发完毕Git提交"></a>8.8 权限管理开发完毕Git提交</h3><ul>
<li>rights分支本地提交(commit)，远端提交(push)</li>
<li>master分支合并rights分支(merge)，远端提交master分支(push)</li>
</ul>
<br>

<h2 id="9-商品管理"><a href="#9-商品管理" class="headerlink" title="9. 商品管理"></a>9. 商品管理</h2><p>在<code>goods_cate</code>分支下开发商品管理模块    </p>
<h3 id="9-1-商品分类Cate组件"><a href="#9-1-商品分类Cate组件" class="headerlink" title="9.1 商品分类Cate组件"></a>9.1 商品分类Cate组件</h3><ul>
<li>创建<code>/components/goods/Cate.vue</code></li>
<li>定义路由</li>
</ul>
<h4 id="9-1-1-Cate组件布局"><a href="#9-1-1-Cate组件布局" class="headerlink" title="9.1.1 Cate组件布局"></a>9.1.1 Cate组件布局</h4><ul>
<li>面包屑导航</li>
<li>卡片视图<ul>
<li>添加分类按钮</li>
<li>分类表格(使用<code>vue-table-with-tree-grid</code>插件,<a href="https://github.com/MisterTaki/vue-table-with-tree-grid">插件的GitHub</a>)</li>
<li>分页部分</li>
</ul>
</li>
</ul>
<h4 id="9-1-2-分类表格自定义模板列"><a href="#9-1-2-分类表格自定义模板列" class="headerlink" title="9.1.2 分类表格自定义模板列"></a>9.1.2 分类表格自定义模板列</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">columns: [</span><br><span class="line">                &#123;</span><br><span class="line">                    label: <span class="string">&#x27;分类名称&#x27;</span>,</span><br><span class="line">                    prop: <span class="string">&#x27;cat_name&#x27;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    label: <span class="string">&#x27;是否有效&#x27;</span>,</span><br><span class="line">                    <span class="comment">//定义为模板列</span></span><br><span class="line">                    type: <span class="string">&#x27;template&#x27;</span>,</span><br><span class="line">                    <span class="comment">//对应的模板名字为isok</span></span><br><span class="line">                    template: <span class="string">&#x27;isok&#x27;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 是否有效 模板列 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;isok&quot;</span> <span class="attr">slot-scope</span>=<span class="string">&quot;scope&quot;</span>&gt;</span></span><br><span class="line">    &lt;i</span><br><span class="line">        class=&quot;el-icon-success&quot;</span><br><span class="line">        v-if=&quot;scope.row.cat_deleted === false&quot;</span><br><span class="line">        style=&quot;color: lightgreen;&quot;</span><br><span class="line">    &gt;<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;el-icon-error&quot;</span> <span class="attr">v-else</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="9-1-3-分页部分"><a href="#9-1-3-分页部分" class="headerlink" title="9.1.3 分页部分"></a>9.1.3 分页部分</h4><p>通过<code>el-pagination</code>组件实现</p>
<br>

<h4 id="9-1-4-Cate组件新增分类功能"><a href="#9-1-4-Cate组件新增分类功能" class="headerlink" title="9.1.4 Cate组件新增分类功能"></a>9.1.4 Cate组件新增分类功能</h4><ul>
<li>点击按钮弹出dialog框<ul>
<li>输入新分类名，选择其父级分类</li>
<li>校验后发起请求同步数据</li>
</ul>
</li>
</ul>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220309211759635.png" alt="image-20220309211759635"></p>
<center>添加分类dialog</center>

<p>选择父级分类使用<code>el-cascader</code>组件(级联选择器)实现</p>
<br>

<h3 id="9-2-分类参数Params组件"><a href="#9-2-分类参数Params组件" class="headerlink" title="9.2 分类参数Params组件"></a>9.2 分类参数Params组件</h3><p>商品的分类参数分为<strong>动态参数</strong>和<strong>静态参数</strong></p>
<ul>
<li>动态参数：可以动态选择的参数，比如商品的不同型号</li>
<li>静态参数：只能够看到的商品固定信息</li>
</ul>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220317095218060.png" alt="image-20220317095218060"></p>
<br>

<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220317095535717.png" alt="image-20220317095535717"></p>
<ul>
<li>选择商品分类，只允许选择三级分类</li>
<li>选择参数按钮，弹出dialog框添加参数，未选择分类时禁用</li>
<li>使用表格显示详细参数，展开行使用<code>el-tag</code>显示参数值</li>
<li>展开行添加按钮进行简单的参数值添加</li>
</ul>
<br>

<h3 id="9-3-商品列表List组件"><a href="#9-3-商品列表List组件" class="headerlink" title="9.3 商品列表List组件"></a>9.3 商品列表List组件</h3><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220317212124662.png" alt="image-20220317212124662"></p>
<ul>
<li>添加商品区域<ul>
<li>带按钮的输入框(搜索指定商品)</li>
<li>添加按钮(跳转到<code>Add组件</code>进行商品添加)</li>
</ul>
</li>
<li>商品列表数据表格<ul>
<li>通过<strong>Vue全局过滤器</strong><code>dateFormat</code>处理<strong>毫秒数</strong>的创建时间</li>
</ul>
</li>
<li>分页功能 (<code>el-pagination</code>组件)</li>
</ul>
<br>

<h3 id="9-4-添加商品Add组件"><a href="#9-4-添加商品Add组件" class="headerlink" title="9.4 添加商品Add组件"></a>9.4 添加商品Add组件</h3><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220317212552592.png" alt="image-20220317212552592"></p>
<ul>
<li><code>alert</code>警告框</li>
<li>step步骤条</li>
<li>左侧tab页签</li>
</ul>
<h4 id="9-4-1-Form表单数据"><a href="#9-4-1-Form表单数据" class="headerlink" title="9.4.1 Form表单数据"></a>9.4.1 Form表单数据</h4><p>Form表单包裹<code>el-tabs</code>组件，每个tab页签中均有表单数据。</p>
<p>el-tab组件<strong>必须</strong>被el-tabs组件直接包裹，所以Form表单只能包裹el-tabs组件</p>
<h4 id="9-4-2-基本信息tab页签"><a href="#9-4-2-基本信息tab页签" class="headerlink" title="9.4.2 基本信息tab页签"></a>9.4.2 基本信息tab页签</h4><ul>
<li>待验证的input输入框</li>
<li>级联选择器(选择商品所属分类) <code>el-cascader</code>组件</li>
<li><strong>未选择分类时禁止跳转向其他页签</strong></li>
</ul>
<h4 id="9-4-3-商品参数tab页签"><a href="#9-4-3-商品参数tab页签" class="headerlink" title="9.4.3 商品参数tab页签"></a>9.4.3 商品参数tab页签</h4><ul>
<li><p>请求分类的动态参数</p>
</li>
<li><p>通过<strong>复选框组</strong>(<code>el-checkbox-group</code>)展示分类的所有<strong>动态参数</strong></p>
</li>
</ul>
<h4 id="9-4-4-商品属性tab页签"><a href="#9-4-4-商品属性tab页签" class="headerlink" title="9.4.4 商品属性tab页签"></a>9.4.4 商品属性tab页签</h4><ul>
<li>请求分类的静态属性</li>
<li>通过<strong>input输入框</strong>展示所有的静态属性</li>
</ul>
<h4 id="9-4-5-商品图片tab页签"><a href="#9-4-5-商品图片tab页签" class="headerlink" title="9.4.5 商品图片tab页签"></a>9.4.5 商品图片tab页签</h4><ul>
<li>使用<code>el-upload</code>组件实现图片上传(请求头添加token)<ul>
<li>图片预览</li>
<li>已上传图片的移除</li>
</ul>
</li>
<li>图片上传后将图片临时地址保存在pics数组中</li>
<li>图片预览事件<ul>
<li>获取图片URL，显示dialog进行预览，dialog中的img标签显示图片</li>
</ul>
</li>
<li>图片移除事件<ul>
<li>获取图片临时地址</li>
<li>在addForm中的pics中查找图片索引</li>
<li>根据索引删除pics数组中该图片对象</li>
</ul>
</li>
</ul>
<h4 id="9-4-6-商品内容tab页签"><a href="#9-4-6-商品内容tab页签" class="headerlink" title="9.4.6 商品内容tab页签"></a>9.4.6 商品内容tab页签</h4><p>使用<code>vue-quill-editor</code>插件，构建富文本编辑器</p>
<ul>
<li><strong>添加商品</strong>按钮<ul>
<li>使用<code>lodash</code>插件深拷贝<code>addForm</code></li>
<li>处理<code>attrs</code>字段和<code>goods_cat</code>字段</li>
<li>路径<code>&#39;goods&#39;</code>，<strong>发起<code>post</code>请求</strong>添加商品</li>
<li>商品添加完后，编程式路由导航跳转到商品列表页面</li>
</ul>
</li>
</ul>
<h4 id="9-4-7-商品管理模块开发完成"><a href="#9-4-7-商品管理模块开发完成" class="headerlink" title="9.4.7 商品管理模块开发完成"></a>9.4.7 商品管理模块开发完成</h4><p>Git提交</p>
<br>

<h2 id="10-订单管理"><a href="#10-订单管理" class="headerlink" title="10.订单管理"></a>10.订单管理</h2><h3 id="10-1-页面布局"><a href="#10-1-页面布局" class="headerlink" title="10.1 页面布局"></a>10.1 页面布局</h3><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220322161321485.png" alt="image-20220322161321485"></p>
<h3 id="10-2-修改地址操作"><a href="#10-2-修改地址操作" class="headerlink" title="10.2 修改地址操作"></a>10.2 修改地址操作</h3><p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220322161331623.png" alt="image-20220322161331623"></p>
<h3 id="10-3-查看订单物流信息"><a href="#10-3-查看订单物流信息" class="headerlink" title="10.3 查看订单物流信息"></a>10.3 查看订单物流信息</h3><p>使用<code>TimeLine</code> (Element-UI组件)</p>
<p>因为接口失效，所以没有完成</p>
<br>

<h2 id="11-数据统计"><a href="#11-数据统计" class="headerlink" title="11.数据统计"></a>11.数据统计</h2><p>使用<code>echarts</code>插件在页面显示统计图表</p>
<p><a href="https://echarts.apache.org/handbook/zh/get-started/">echarts官方文档</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 1. 为 ECharts 准备一个定义了宽高的 DOM --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 750px; height: 400px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.基于准备好的dom，初始化echarts实例</span></span><br><span class="line"><span class="keyword">var</span> myChart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;main&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.指定图表的配置项和数据</span></span><br><span class="line"><span class="keyword">let</span> result = _.merge(<span class="built_in">this</span>.options, res.data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.使用刚指定的配置项和数据显示图表。</span></span><br><span class="line">myChart.setOption(result)</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化<code>echarts</code>实例要在<code>mounted</code>钩子中进行<ul>
<li>mounted钩子调用时，页面DOM元素<strong>已经加载完毕</strong></li>
</ul>
</li>
</ul>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220322165919184.png" alt="image-20220322165919184"></p>
<br>

<h2 id="12-项目优化和上线"><a href="#12-项目优化和上线" class="headerlink" title="12. 项目优化和上线"></a>12. 项目优化和上线</h2><br>

<h2 id="遇见的问题"><a href="#遇见的问题" class="headerlink" title="##. 遇见的问题"></a>##. 遇见的问题</h2><h3 id="1-el-cascader组件在选项过多时列表过长显示不完全"><a href="#1-el-cascader组件在选项过多时列表过长显示不完全" class="headerlink" title="1.el-cascader组件在选项过多时列表过长显示不完全"></a>1.<code>el-cascader</code>组件在选项过多时列表过长显示不完全</h3><p>级联选择器</p>
<p>在<code>global.css</code><strong>全局css文件</strong>中设置<code>el-cascader-panel</code>类的<code>height</code>属性限制列表高度</p>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220309212154455.png" alt="image-20220309212154455"></p>
<p>在<code>Cate.vue</code>文件中的style标签中设置<code>el-cascader-panel</code>类的样式<strong>无效</strong></p>
<p>scoped属性使得该style标签下的样式<strong>仅作用于本单文件组件中的类</strong></p>
<p>而<code>el-cascader-panel</code>是在项目运行后才生成的类，所以不起效</p>
<br>

<h3 id="2-input输入域在渲染后自动获取焦点"><a href="#2-input输入域在渲染后自动获取焦点" class="headerlink" title="2. input输入域在渲染后自动获取焦点"></a>2. input输入域在渲染后自动获取焦点</h3><p>点击<code>+New Tag</code>按钮后，通过v-if渲染出input输入域并<strong>自动获取其焦点</strong></p>
<p><img data-src="/images/09-Vue%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/image-20220311154524351.png" alt="image-20220311154524351"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示新参数值输入框</span></span><br><span class="line"><span class="function"><span class="title">showInput</span>(<span class="params">row</span>)</span> &#123;</span><br><span class="line">    row.inputVisible = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//文本框自动获取焦点</span></span><br><span class="line">    <span class="built_in">this</span>.$nextTick( <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//获取焦点</span></span><br><span class="line">        <span class="built_in">this</span>.$refs.saveTagInput.$refs.input.focus();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>this.$nextTick()</code>方法：</p>
<ul>
<li>在页面重新渲染后(此处为input输入域渲染完后) 触发其回调函数获取input焦点</li>
<li>若不使用此方法，<span style="color:red;">则会在还没有渲染出input域时就获取焦点</span>，结果报错</li>
</ul>
<br>

<h3 id="3-图片上传问题"><a href="#3-图片上传问题" class="headerlink" title="3. 图片上传问题"></a>3. 图片上传问题</h3><p>在<strong>添加商品</strong>时</p>
<p>使用<code>el-upload</code>组件进行图片的上传</p>
<p>通过组件的action属性设置请求URL后<span style="color:red;">由组件自动发起请求</span></p>
<ul>
<li>未使用<code>axios</code>，<code>action</code>属性值应为<strong>完整的</strong>后台接口URL。</li>
<li>未使用<code>axios</code>，请求头的token信息需要<strong>手动添加</strong>。(<code>main.js</code>文件中请求拦截添加的不生效)</li>
</ul>
<p><code>el-upload</code>组件的<code>header</code>属性可以指定请求头对象</p>
<br>

<h3 id="4-添加商品时对goods-cat字段的处理"><a href="#4-添加商品时对goods-cat字段的处理" class="headerlink" title="4. 添加商品时对goods_cat字段的处理"></a>4. 添加商品时对goods_cat字段的处理</h3><p><code>addForm.goods_cat</code>与<code>el-cascader</code>级联选择器<strong>双向数据绑定</strong></p>
<p>若直接在<code>addForm</code>上处理<code>goods_cat</code>为字符串，会导致<strong>级联选择器双向数据绑定字符串而报错</strong></p>
<ul>
<li><code>el-cascader</code>级联选择器 双向数据绑定<strong>必须为数组</strong></li>
</ul>
<p>解决：使用<code>lodash</code>插件将<code>addForm</code>进行<strong>深拷贝</strong>后再处理数据</p>
<p>深拷贝也可以通过<strong>递归深入对象内部进行拷贝完成</strong></p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>17-多人博客管理系统项目</title>
    <url>/2021/08/30/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="多人博客管理系统项目"><a href="#多人博客管理系统项目" class="headerlink" title="多人博客管理系统项目"></a>多人博客管理系统项目</h1><ul>
<li>分为两部分<ul>
<li><strong>展示页面</strong>：博客前台展示文章总览页面和文章详情页面</li>
<li><strong>管理页面</strong>：查看上传的文章列表，注册的用户列表，对文章增删查改等</li>
</ul>
</li>
</ul>
<h2 id="1-项目初始化"><a href="#1-项目初始化" class="headerlink" title="1.项目初始化"></a>1.项目初始化</h2><h3 id="1-1-创建项目目录文件夹"><a href="#1-1-创建项目目录文件夹" class="headerlink" title="1.1 创建项目目录文件夹"></a>1.1 创建项目目录文件夹</h3><ul>
<li>myblog_project：项目根目录<ul>
<li>public：静态资源文件夹</li>
<li>route：模块化路由文件夹</li>
<li>model：数据库和数据处理文件夹</li>
<li>views：模板文件夹</li>
<li>app.js：项目入口(主模块)</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h3 id="1-2-初始化项目描述文件"><a href="#1-2-初始化项目描述文件" class="headerlink" title="1.2 初始化项目描述文件"></a>1.2 初始化项目描述文件</h3><ul>
<li><code>npm init- y</code></li>
</ul>
<h3 id="1-3-下载依赖模块"><a href="#1-3-下载依赖模块" class="headerlink" title="1.3 下载依赖模块"></a>1.3 下载依赖模块</h3><ul>
<li><code>npm install express mongoose art-template express-art-template</code></li>
</ul>
<h3 id="1-4-创建网站服务器"><a href="#1-4-创建网站服务器" class="headerlink" title="1.4 创建网站服务器"></a>1.4 创建网站服务器</h3><ul>
<li>访问路径为localhost:80</li>
</ul>
<h3 id="1-5-模块化路由"><a href="#1-5-模块化路由" class="headerlink" title="1.5 模块化路由"></a>1.5 模块化路由</h3><p>route文件夹下创建两个js文件</p>
<ul>
<li>home.js：展示页面路由模块</li>
<li>admin.js：管理页面路由模块</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> home = express.Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">//二级目录设置为&#x27;/&#x27;,访问时只需输入一级目录，浏览器自动加上&#x27;/&#x27;</span></span><br><span class="line">home.get(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">&#x27;博客展示页面&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = home</span><br></pre></td></tr></table></figure>

<center>home.js模块</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">&#x27;./route/home&#x27;</span>)</span><br><span class="line">app.use(<span class="string">&#x27;/home&#x27;</span>,home)</span><br></pre></td></tr></table></figure>

<center>主模块中引入路由模块并匹配一级路由</center>

<h3 id="1-6-请求静态页面处理"><a href="#1-6-请求静态页面处理" class="headerlink" title="1.6 请求静态页面处理"></a>1.6 请求静态页面处理</h3><p>将静态页面放在public文件夹下(例如管理页面和内容页面的js和css文件)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态资源请求</span></span><br><span class="line">    <span class="comment">//放在最上层避免模块化路由路径干扰</span></span><br><span class="line">app.use(express.static(path.join(__dirname,<span class="string">&#x27;public&#x27;</span>)))</span><br></pre></td></tr></table></figure>

<p>在app.js中使用<code>express.static</code>方法处理静态资源请求</p>
<h3 id="1-7-博客管理页面模板构建"><a href="#1-7-博客管理页面模板构建" class="headerlink" title="1.7 博客管理页面模板构建"></a>1.7 博客管理页面模板构建</h3><p>将后缀为.art的模板文件放在<strong>views文件下的admin文件夹</strong>中</p>
<ul>
<li>本项目中管理页面和内容页面的<strong>html文件使用art-template模板引擎渲染</strong>，所以改后缀为.art后放入views文件夹中</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板文件目录设置</span></span><br><span class="line">app.set(<span class="string">&#x27;views&#x27;</span>,path.join(__dirname,<span class="string">&#x27;views&#x27;</span>))</span><br><span class="line"><span class="comment">//模板默认后缀设置</span></span><br><span class="line">app.set(<span class="string">&#x27;view engine&#x27;</span>,<span class="string">&#x27;art&#x27;</span>)</span><br><span class="line"><span class="comment">//设置art后缀的模板使用的模板引擎</span></span><br><span class="line">app.engine(<span class="string">&#x27;art&#x27;</span>,<span class="built_in">require</span>(<span class="string">&#x27;express-art-template&#x27;</span>))</span><br></pre></td></tr></table></figure>

<center>app.js中配置如下</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">admin.get(<span class="string">&#x27;/login&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.render(<span class="string">&#x27;admin/login&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>admin.js中配置对模板请求的响应</center>

<h3 id="1-8-模板中相对路径的问题"><a href="#1-8-模板中相对路径的问题" class="headerlink" title="1.8 模板中相对路径的问题"></a>1.8 模板中相对路径的问题</h3><p>模板中许多外链文件如css和js文件使用的都是<strong>相对路径</strong></p>
<p>模板中的相对路径是<strong>相对于浏览器地址栏的路径</strong></p>
<p>改为<strong>绝对路径</strong>可以避免因路由对象的虚拟路径而取不到静态资源文件的问题</p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210830203446873.png" alt="login.art模板中的相对路径"></p>
<br>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210830203543389.png" alt="相对路径相对于浏览器地址栏的路径"></p>
<p>此时浏览器将地址栏中的login当作文件，所以<strong>相对路径即相对于/abc</strong></p>
<ul>
<li><p>可见此时请求静态资源<code>base.css</code>的路径变为了<code>http://localhost/abc/css/base.css</code></p>
</li>
<li><p>而<code>base.css</code>静态资源文件并不在<code>/public/abc</code>文件夹下，并且public文件夹下也并不存在abc文件夹，所以无法获取静态资源文件</p>
</li>
<li><p>/abc只是admin路由对象匹配的<strong>虚拟路径</strong>，这个虚拟路径<strong>随时可以发生变化</strong></p>
</li>
<li><p>所以在模块中使用相对路径获取静态资源文件并不合适</p>
</li>
<li><p>改为使用<strong>绝对路径</strong>解决这个问题</p>
</li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210830204312384.png" alt="login.art模板中使用绝对路径"></p>
<p>在原先的相对路径前加上<code>&#39;/&#39;</code>使其变为绝对路径，同时根据静态资源文件的路径加上admin</p>
<p>此时请求静态资源文件的路径变为<code>http://localhost/admin/css/base.css</code></p>
<p>经过<code>express.static</code>方法处理后在<code>/public/admin/css/base.css</code>找到静态资源文件</p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210830205046226.png" alt="模板使用绝对路径获取静态资源文件"></p>
<br>

<h3 id="1-9-优化模板中公共代码"><a href="#1-9-优化模板中公共代码" class="headerlink" title="1.9 优化模板中公共代码"></a>1.9 优化模板中公共代码</h3><p>将模板中公共代码提取为子模版</p>
<p>将除login.art外的<strong>四个模板的头部和侧边栏提取为子模版</strong></p>
<p>子模版header.art和aside.art存放在**/views/admin/common**文件夹下</p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210830210812174.png" alt="子模版引入"></p>
<br>

<h3 id="1-10-提取模板骨架"><a href="#1-10-提取模板骨架" class="headerlink" title="1.10 提取模板骨架"></a>1.10 提取模板骨架</h3><p>将除login.art外的四个模板中的开头结尾html结构提取到<code>./common/layout.art</code>文件中</p>
<p>让四个模板继承骨架文件layout.art，并填上各自模板独立的内容</p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210831163400493.png" alt="修改后的user.art模板"></p>
<br>

<h2 id="2-登录功能"><a href="#2-登录功能" class="headerlink" title="2. 登录功能"></a>2. 登录功能</h2><h3 id="2-1-创建用户集合初始化用户"><a href="#2-1-创建用户集合初始化用户" class="headerlink" title="2.1 创建用户集合初始化用户"></a>2.1 创建用户集合初始化用户</h3><ul>
<li>连接数据库</li>
<li>创建用户集合</li>
<li>初始化用户</li>
</ul>
<h4 id="2-1-1-连接数据库"><a href="#2-1-1-连接数据库" class="headerlink" title="2.1.1 连接数据库"></a>2.1.1 连接数据库</h4><p>model文件夹下的connect.js文件连接<strong>数据库blog</strong></p>
<h4 id="2-1-2-创建用户集合"><a href="#2-1-2-创建用户集合" class="headerlink" title="2.1.2 创建用户集合"></a>2.1.2 创建用户集合</h4><p>model文件夹下的user.js文件创建用户集合</p>
<p>用户<strong>user集合</strong>规则：用户名，邮箱，密码，角色，状态</p>
<p>状态：0代表启用(默认为0)，1代表禁用</p>
<p>导出<strong>集合构造函数User</strong></p>
<h4 id="2-1-3-创建初始化用户"><a href="#2-1-3-创建初始化用户" class="headerlink" title="2.1.3 创建初始化用户"></a>2.1.3 创建初始化用户</h4><p>在user.js文件中创建一个初始化管理员用户</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个初始化用户</span></span><br><span class="line">User.create(&#123;</span><br><span class="line">    username:<span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    email:<span class="string">&#x27;zhangsan@123.com&#x27;</span>,</span><br><span class="line">    password:<span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">    role:<span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">    state:<span class="number">0</span></span><br><span class="line">&#125;).then( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;初始化用户创建成功&#x27;</span>);</span><br><span class="line">&#125;).catch( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;初始化用户创建失败&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210831213028363.png" alt="创建的初始化用户"></p>
<br>

<h3 id="2-2-提交前客户端一次验证"><a href="#2-2-提交前客户端一次验证" class="headerlink" title="2.2 提交前客户端一次验证"></a>2.2 提交前客户端一次验证</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提取表单所有控件并转化为方便处理的对象格式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serializeToJSON</span> (<span class="params">form</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = &#123;&#125;</span><br><span class="line">    <span class="comment">//serializeArray()方法</span></span><br><span class="line">    <span class="comment">//将表单所有控件按名值提取为对象并组成一个数组</span></span><br><span class="line">    <span class="comment">//[&#123;name:&#x27;email&#x27;,value:&#x27;....&#x27;&#125;,&#123;name:&#x27;password&#x27;,value:&#x27;...&#x27;&#125;]</span></span><br><span class="line">    <span class="keyword">let</span> f = form.serializeArray()</span><br><span class="line">    <span class="comment">//将上述提取的数组简化为&#123;email:&#x27;...&#x27;,password:&#x27;...&#x27;&#125;</span></span><br><span class="line">    f.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;   </span><br><span class="line">        result[item.name] = item.value</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>common.js</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;/admin/js/common.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt; </span><br><span class="line">    $(<span class="string">&#x27;#loginForm&#x27;</span>).on(<span class="string">&#x27;submit&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> result = serializeToJSON($(<span class="built_in">this</span>))</span><br><span class="line">        <span class="comment">//判断用户是否输入邮箱</span></span><br><span class="line">        <span class="comment">//trim()方法：去除字符串两边空格</span></span><br><span class="line">        <span class="keyword">if</span>(result.email.trim().length == <span class="number">0</span>)&#123;</span><br><span class="line">            alert(<span class="string">&#x27;请输入邮箱&#x27;</span>)</span><br><span class="line">            <span class="comment">//阻止程序运行并阻止表单默认提交事件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//判断用户是否输入密码</span></span><br><span class="line">        <span class="keyword">if</span>(result.password.trim().length == <span class="number">0</span>)&#123;</span><br><span class="line">            alert(<span class="string">&#x27;请输入密码&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<center>login.art模板中进行客户端提交验证</center>

<h4 id="2-2-1-获取用户输入数据"><a href="#2-2-1-获取用户输入数据" class="headerlink" title="2.2.1 获取用户输入数据"></a>2.2.1 获取用户输入数据</h4><p><strong>serializeArray()方法</strong>提取表单中所有控件为<code>[&#123;name:&#39;...&#39;,value:&#39;...&#39;&#125;,&#123;name:&#39;...&#39;,value:&#39;...&#39;&#125;]</code>形式</p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210831223205408.png" alt="serializeArray()方法提取表单控件"></p>
<p>将这种形式的数组进一步简化为易于处理的对象格式 <code>&#123;email:&#39;...&#39;,password:&#39;...&#39;&#125;</code></p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210831224117617.png" alt="处理后的用户输入数据"></p>
<p>使用**自定义函数serializeToJSON()**实现</p>
<ul>
<li>发现**serializeToJSON()**函数的功能比较常用</li>
<li>所以将serializeToJSON()函数提取到一个静态js文件common.js中</li>
<li>文件放在<code>/public/admin/js</code>文件夹下</li>
<li>其他模板获取静态js文件后即可使用这个函数</li>
</ul>
<h4 id="2-2-2-提交验证"><a href="#2-2-2-提交验证" class="headerlink" title="2.2.2 提交验证"></a>2.2.2 提交验证</h4><p>获取用户输入后进行邮箱和密码是否输入的验证</p>
<ul>
<li>若没有则弹出警示框提醒并阻止程序运行和表单提交</li>
<li>若都输入则正常提交</li>
</ul>
<br>

<h3 id="2-3-提交后服务器端二次验证"><a href="#2-3-提交后服务器端二次验证" class="headerlink" title="2.3 提交后服务器端二次验证"></a>2.3 提交后服务器端二次验证</h3><p>当客户端浏览器禁用JavaScript时，客户端一次验证就会失效，所以以防万一需要在服务端二次验证</p>
<ul>
<li>使用body-parser第三方模块获取post请求参数</li>
<li>进行二次验证</li>
</ul>
<p>若<strong>验证失败</strong>则设置响应码为400并响应<strong>error.art</strong>错误模板</p>
<ul>
<li>错误模板继承<strong>layout.art</strong>HTML骨架</li>
<li>再加入3s后返回登录页面的定时器</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123;block <span class="string">&#x27;script&#x27;</span>&#125;&#125;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            location.href = <span class="string">&#x27;/admin/login&#x27;</span> </span><br><span class="line">        &#125;,<span class="number">3000</span>)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&#123;&#123;/block&#125;&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="2-4-服务端查找用户是否存在"><a href="#2-4-服务端查找用户是否存在" class="headerlink" title="2.4 服务端查找用户是否存在"></a>2.4 服务端查找用户是否存在</h3><p>在admin.js路由模块中接受表单post请求时判断用户是否存在</p>
<ul>
<li>先引入model/user.js模块<strong>获取用户集合构造函数</strong></li>
<li>接着findOne方法匹配用户信息</li>
<li>找不到则返回错误信息</li>
<li>找到用户<ul>
<li>密码错误，返回错误信息</li>
<li>密码正确，显示登录成功</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据库查找用户</span></span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> User.findOne(&#123;<span class="attr">email</span>:email&#125;)</span><br><span class="line">    <span class="comment">//如果用户存在</span></span><br><span class="line">    <span class="keyword">if</span>(user)&#123;</span><br><span class="line">        <span class="comment">//密码正确</span></span><br><span class="line">        <span class="keyword">if</span>(user.password == password)&#123;</span><br><span class="line">            res.send(<span class="string">&#x27;登录成功&#x27;</span>)</span><br><span class="line">        <span class="comment">//密码错误</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.render(<span class="string">&#x27;admin/error&#x27;</span>,&#123;<span class="attr">msg</span>:<span class="string">&#x27;邮箱或密码错误&#x27;</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果用户不存在</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.render(<span class="string">&#x27;admin/error&#x27;</span>,&#123;<span class="attr">msg</span>:<span class="string">&#x27;邮箱或密码错误&#x27;</span>&#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<center>admin.js中查找用户是否存在部分代码</center>

<br>

<h3 id="2-5-密码加密-bcrypt"><a href="#2-5-密码加密-bcrypt" class="headerlink" title="2.5 密码加密 bcrypt"></a>2.5 密码加密 bcrypt</h3><p>用户的密码直接以明文形式存放在数据库中是不安全的</p>
<p><strong>使用第三方模块bcrypt进行密码加密</strong></p>
<ul>
<li><p>哈希加密</p>
</li>
<li><p>在密文中加入随机字符串增加破解难度</p>
</li>
</ul>
<h4 id="2-5-1-安装bcrypt模块"><a href="#2-5-1-安装bcrypt模块" class="headerlink" title="2.5.1 安装bcrypt模块"></a>2.5.1 安装bcrypt模块</h4><p>安装前需要三个依赖</p>
<ul>
<li>python 2.x<ul>
<li><strong>在环境变量中配置path</strong></li>
</ul>
</li>
<li>node-gyp 模块<ul>
<li><code>npm install -g node-gyp</code> </li>
<li>全局安装</li>
</ul>
</li>
<li>windows-build-tools 模块<ul>
<li><code>npm install --global --production windows-build-tools</code></li>
<li>在<strong>管理员权限</strong>下安装</li>
<li>全局安装</li>
</ul>
</li>
</ul>
<p>安装bcrypt模块</p>
<ul>
<li><code>npm install bcrypt</code><ul>
<li><strong>管理员权限</strong></li>
</ul>
</li>
</ul>
<br>

<h4 id="2-5-2-加密密码和比对明文密文"><a href="#2-5-2-加密密码和比对明文密文" class="headerlink" title="2.5.2 加密密码和比对明文密文"></a>2.5.2 加密密码和比对明文密文</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">createUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//生成随机数</span></span><br><span class="line">    <span class="comment">//参数数值越大，随机数越复杂</span></span><br><span class="line">    <span class="comment">//默认为10</span></span><br><span class="line">    <span class="keyword">const</span> salt = <span class="keyword">await</span> bcrypt.genSalt(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">//生成加密密码，第一个参数为明文，第二个参数为生成的随机数</span></span><br><span class="line">    <span class="keyword">const</span> pass = <span class="keyword">await</span> bcrypt.hash(<span class="string">&#x27;123456&#x27;</span>,salt)</span><br><span class="line">    <span class="comment">//创建一个初始化用户</span></span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> User.create(&#123;</span><br><span class="line">        username:<span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">        email:<span class="string">&#x27;zhangsan@123.com&#x27;</span>,</span><br><span class="line">        password:pass,</span><br><span class="line">        role:<span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">        state:<span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>创建密码加密的用户文档</center>

<p><code>bcrypt.genSalt(10)</code></p>
<ul>
<li>生成随机字符串，参数越大越复杂，默认为10</li>
<li>返回promise对象</li>
</ul>
<p><code>bcrypt.hash(‘明文’,随机字符串)</code></p>
<ul>
<li><p>返回加密后的密码密文</p>
</li>
<li><p>返回promise对象</p>
</li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210901111933091.png" alt="数据库中的加密密码"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比对明文密码与密文密码</span></span><br><span class="line"><span class="comment">//bcrypt.compare()方法</span></span><br><span class="line"><span class="comment">//第一个参数为明文密码，第二个参数为密文密码</span></span><br><span class="line"><span class="comment">//返回布尔值</span></span><br><span class="line"><span class="keyword">let</span> isValid = <span class="keyword">await</span> bcrypt.compare(password,user.password)</span><br><span class="line"><span class="comment">//密码正确</span></span><br><span class="line"><span class="keyword">if</span>( isValid )&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;登录成功&#x27;</span>)</span><br><span class="line"><span class="comment">//密码错误</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    res.render(<span class="string">&#x27;admin/error&#x27;</span>,&#123;<span class="attr">msg</span>:<span class="string">&#x27;邮箱或密码错误&#x27;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>登录时比对用户输入的明文密码和数据库中的密文密码</center>

<p><code>bcrypt.compare(&#39;明文密码&#39;,密文密码)</code></p>
<ul>
<li><p>返回值为promise对象</p>
</li>
<li><p>使用await关键字获取promise对象结果为<strong>布尔值</strong></p>
<ul>
<li>真 即代表比对成功</li>
</ul>
</li>
</ul>
<h3 id="2-6-cookie和session"><a href="#2-6-cookie和session" class="headerlink" title="2.6 cookie和session"></a>2.6 cookie和session</h3><p>上述客户端登录发送请求给服务端，服务端做出响应后，客户端和服务器端的<strong>连接就断开了</strong>（HTTP协议无连接）</p>
<p>连接断开后就相当于没有登录，再次发送请求时会重置req对象</p>
<p>这是因为<strong>http协议的无状态性</strong>导致的</p>
<p>使用cookie和session存储客户端和服务器的关系数据可以解决这个问题</p>
<h4 id="2-6-1-cookie"><a href="#2-6-1-cookie" class="headerlink" title="2.6.1 cookie"></a>2.6.1 cookie</h4><p>cookie是浏览器在<strong>客户端本地存储</strong>中开辟的一块空间，主要供服务端存储数据</p>
<ul>
<li><p>cookie中的数据以<strong>域名</strong>(Domain)区分</p>
</li>
<li><p>cookie是有<strong>过期时间</strong>的，过期cookie会被浏览器自动删除</p>
</li>
<li><p>cookie会随着客户端的请求<strong>一起被发送到服务器</strong></p>
</li>
<li><p>客户端<strong>第一次</strong>向服务器发送请求时(此时客户端没有存储cookie)，服务端将cookie信息与响应一同发送给客户端</p>
<ul>
<li>客户端接受到响应和cookie信息后将cookie存储在本地硬盘</li>
<li>之后每次客户端发送请求都会带上存储的cookie</li>
</ul>
</li>
</ul>
<h4 id="2-6-2-session"><a href="#2-6-2-session" class="headerlink" title="2.6.2 session"></a>2.6.2 session</h4><p>session实际上就是一个存储在<strong>服务端内存</strong>的对象，在session中可以存储多条数据，每条数据都有一个<code>sessionId</code>作为<strong>唯一标识</strong></p>
<ul>
<li><strong>cookie一般用来存储sessionId</strong>，客户端接受到自己的sessionId后，每次请求都带上自己的sessionId，服务端根据sessionId就可以确定客户端的身份，并维持联系。</li>
</ul>
<h4 id="2-6-3-在登录功能中应用cookie和session"><a href="#2-6-3-在登录功能中应用cookie和session" class="headerlink" title="2.6.3 在登录功能中应用cookie和session"></a>2.6.3 在登录功能中应用cookie和session</h4><p>使用第三方模块<code>express-session</code></p>
<ul>
<li>express框架官方提供的模块</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入express-session对象 用来设置服务器端session</span></span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">&#x27;express-session&#x27;</span>)</span><br><span class="line"><span class="comment">//建立session对象</span></span><br><span class="line">app.use(session(&#123;<span class="attr">secret</span>:<span class="string">&#x27;secret key&#x27;</span>&#125;))</span><br></pre></td></tr></table></figure>

<p>使用app.use拦截所有请求，并设置session对象</p>
<ul>
<li>session方法有一个必填参数secret<ul>
<li>即加密sessionId所用的密钥</li>
<li>密钥可以自定义</li>
<li>此处设置为<code>secret key</code></li>
</ul>
</li>
<li><strong>session对象设置在请求对象下 req.session</strong></li>
</ul>
<p>创建session对象后，当服务端<strong>向session对象中存入数据时</strong>，session对象就会为数据指定唯一的sessionId</p>
<p>并且随着响应把sessionId存放在客户端cookie中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//密码正确</span></span><br><span class="line"><span class="keyword">if</span>( isValid )&#123;</span><br><span class="line">    <span class="comment">//将用户名存储在session对象中</span></span><br><span class="line">    req.session.username = user.username</span><br><span class="line">    res.send(<span class="string">&#x27;登录成功&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>login.js中登录请求路由处理函数部分代码</center>

<p>处理<strong>用户登录请求</strong>时，在服务器二次验证用户存在并且密码正确时<strong>将用户名username存储在session对象中</strong></p>
<p>此时就在session对象中存入了数据，session对象<strong>自动生成sessionId</strong>并随着响应<strong>自动发送</strong>cookie（响应中无需书写添加cookie代码）</p>
<ul>
<li>谷歌浏览器 <strong>检查-&gt;Application-&gt;cookie选项</strong> 就可以看到cookie</li>
<li>红框中字符串即为加密后的sessionId</li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210901172232221.png" alt="客户端存储的cookie"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用户查询页面二级路由</span></span><br><span class="line">admin.get(<span class="string">&#x27;/user&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.render(<span class="string">&#x27;admin/user&#x27;</span>,&#123;<span class="attr">msg</span>:req.session.username&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>admin.js用户查询页面部分代码</center>

<p>在登录后<strong>查询用户页面</strong>时，将session中存放的username作为拼接数据显示在模板中</p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210901172822822.png" alt="session对象中的username显示在模板中"></p>
<p>至此完成了cookie和session在登录功能中的应用</p>
<br>

<h3 id="2-7-登录后跳转到用户列表页面并显示用户名"><a href="#2-7-登录后跳转到用户列表页面并显示用户名" class="headerlink" title="2.7 登录后跳转到用户列表页面并显示用户名"></a>2.7 登录后跳转到用户列表页面并显示用户名</h3><p>因为有多个模板的右上角都需要显示用户名，所以将数据写为<strong>app.locals下的对象</strong>供所有模板使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将user作为模板公共拼接数据</span></span><br><span class="line"><span class="comment">//req.app即为app.js模块中的app对象</span></span><br><span class="line">req.app.locals.userInfo = user</span><br><span class="line"><span class="comment">//重定向到用户展示页面</span></span><br><span class="line">res.redirect(<span class="string">&#x27;/admin/user&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>重定向使用express框架提供的<strong>res.redirect()方法</strong></p>
<p>将user作为公共拼接数据</p>
<p>然后在header.art模板中使用userInfo.username拼接用户名即可</p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210901210811789.png" alt="显示登录用户的用户名"></p>
<br>

<h3 id="2-8-登录拦截"><a href="#2-8-登录拦截" class="headerlink" title="2.8 登录拦截"></a>2.8 登录拦截</h3><p>用户在没有登录时只能访问<code>localhost/admin/login</code>登录页面</p>
<p><strong>此时访问其他页面都应该跳转到登录页面</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//登录拦截</span></span><br><span class="line"><span class="comment">//app.use匹配以&#x27;/admin&#x27;开头的请求路径</span></span><br><span class="line">app.use(<span class="string">&#x27;/admin&#x27;</span>,<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//访问的不是登录页面且没有登录信息</span></span><br><span class="line">    <span class="comment">//此时req.url结果为/admin后面的url</span></span><br><span class="line">    <span class="keyword">if</span>(req.url!=<span class="string">&#x27;/login&#x27;</span> &amp;&amp; !req.session.username)&#123;</span><br><span class="line">        <span class="comment">//重定向</span></span><br><span class="line">        res.redirect(<span class="string">&#x27;/admin/login&#x27;</span>)</span><br><span class="line">    <span class="comment">//有登录信息则放行</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>app.js中登录拦截的代码</center>

<ul>
<li><p>这段代码应该<strong>写在admin路由对象匹配路径的代码前面</strong></p>
</li>
<li><p>通过req.url判断请求的是否为登录页面</p>
</li>
<li><p>同过session对象下有无username属性判断发送请求的客户端是否登录</p>
</li>
</ul>
<br>

<h3 id="2-9-退出登录功能实现"><a href="#2-9-退出登录功能实现" class="headerlink" title="2.9 退出登录功能实现"></a>2.9 退出登录功能实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//登出页面路由</span></span><br><span class="line">admin.get(<span class="string">&#x27;/logout&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//删除session</span></span><br><span class="line">    req.session.destroy(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//删除cookie</span></span><br><span class="line">        res.clearCookie(<span class="string">&#x27;connect.sid&#x27;</span>)</span><br><span class="line">        <span class="comment">//重定向到登录页面</span></span><br><span class="line">        res.redirect(<span class="string">&#x27;/admin/login&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>用户登出时<strong>删除session</strong> <code>req.session.destory</code><ul>
<li>自动根据cookie存储的sessionId删除对应的用户session信息</li>
</ul>
</li>
<li>在<code>req.session.destory</code>的回调函数中<strong>删除cookie</strong>并将页面重定向到登陆页面</li>
<li>删除cookie：<code>res.clearCookie(&#39;cookie名&#39;)</code><ul>
<li>connect.sid为express框架的默认cookie名</li>
</ul>
</li>
</ul>
<br>

<p><strong>注意：</strong></p>
<ul>
<li>express-session模块使用时默认会设置未初始化cookie<ul>
<li>即当客户端向服务端发送请求时就会存储一个cookie</li>
<li>这个cookie不存储用户的sessionId</li>
<li>我们希望用户退出登录时<strong>将这个未初始化cookie也删除</strong></li>
</ul>
</li>
<li>默认的cookie过期时间为null<ul>
<li>即当浏览器关闭时就会删除cookie</li>
<li>我们希望<strong>设置cookie过期时间为一天后</strong></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建立session对象</span></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">    <span class="comment">//加密cookie</span></span><br><span class="line">    secret:<span class="string">&#x27;secret key&#x27;</span>,</span><br><span class="line">    <span class="comment">//不添加未初始化cookie</span></span><br><span class="line">    saveUninitialized:<span class="literal">false</span>,</span><br><span class="line">    cookie:&#123;</span><br><span class="line">        <span class="comment">//设置过期时间(毫秒)</span></span><br><span class="line">        maxAge:<span class="number">24</span> * <span class="number">60</span> *<span class="number">60</span> * <span class="number">1000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<br>

<h3 id="2-10-app-js和admin-js文件优化"><a href="#2-10-app-js和admin-js文件优化" class="headerlink" title="2.10 app.js和admin.js文件优化"></a>2.10 app.js和admin.js文件优化</h3><p><strong>1. 对于网站入口文件app.js</strong></p>
<ul>
<li>我们通常只希望其进行<strong>模块引入</strong>和<strong>简单的配置</strong>工作</li>
<li><strong>功能性的代码</strong>通常通过其他模块引入</li>
</ul>
<p>app.js中的登录拦截就是功能性代码，需要将其分离</p>
<p>在<strong>myblog_project文件夹</strong>下(即<strong>app.js所在目录下</strong>)创建<strong>middleware文件夹</strong>来存放app.js使用的功能性中间件代码</p>
<ul>
<li>将登录拦截app.use中间件的<strong>第二个参数即处理函数抽离</strong>并放在middleware文件夹下的loginGuard.js文件中</li>
<li>在loginGuard.js文件中开放这个函数并<strong>通过require引回app.js中使用</strong></li>
<li>这样可以维持app.js的简单性</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//登录拦截</span></span><br><span class="line">app.use(<span class="string">&#x27;/admin&#x27;</span>,<span class="built_in">require</span>(<span class="string">&#x27;./middleware/loginGuard&#x27;</span>))</span><br></pre></td></tr></table></figure>

<center>app.js登录拦截代码</center>

<p><code>require(&#39;./middleware/loginGuard&#39;)</code>的返回值即为导出的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//访问的不是登录页面且没有登录信息</span></span><br><span class="line">    <span class="comment">//此时req.url结果为/admin后面的url</span></span><br><span class="line">    <span class="keyword">if</span>(req.url!=<span class="string">&#x27;/login&#x27;</span> &amp;&amp; !req.session.username)&#123;</span><br><span class="line">        res.redirect(<span class="string">&#x27;/admin/login&#x27;</span>)</span><br><span class="line">    <span class="comment">//有登录信息则放行</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>loginGuard.js文件</center>

<p><strong>2. 对于路由模块admin.js</strong></p>
<ul>
<li>我们希望它作为一个<strong>路由列表文件</strong></li>
<li>具体的<strong>路由处理函数</strong>需要分离</li>
</ul>
<p>在admin.js所在目录下建立admin文件夹(存放admin.js文件的路由处理函数)</p>
<p>使用app.js文件分离功能函数的方式进行分离即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> admin = express.Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">//登录页面路由</span></span><br><span class="line">admin.get(<span class="string">&#x27;/login&#x27;</span>,<span class="built_in">require</span>(<span class="string">&#x27;./admin/loginPage&#x27;</span>))</span><br><span class="line"><span class="comment">//用户列表页面路由</span></span><br><span class="line">admin.get(<span class="string">&#x27;/user&#x27;</span>,<span class="built_in">require</span>(<span class="string">&#x27;./admin/userPage&#x27;</span>))</span><br><span class="line"><span class="comment">//登出页面路由</span></span><br><span class="line">admin.get(<span class="string">&#x27;/logout&#x27;</span>,<span class="built_in">require</span>(<span class="string">&#x27;./admin/logout&#x27;</span>))</span><br><span class="line"><span class="comment">//登录请求处理路由</span></span><br><span class="line">admin.post(<span class="string">&#x27;/login&#x27;</span>,<span class="built_in">require</span>(<span class="string">&#x27;./admin/login&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = admin</span><br></pre></td></tr></table></figure>

<center>优化后的admin.js文件，仅作为路由列表文件</center>

<br>

<h2 id="3-用户注册功能"><a href="#3-用户注册功能" class="headerlink" title="3. 用户注册功能"></a>3. 用户注册功能</h2><p>当用户点击用户展示页面的新增用户按钮时<strong>跳转到注册用户页面</strong>进行用户注册</p>
<p>在admin.js文件中定义<strong>跳转到注册页面的路由</strong>和<strong>注册信息提交的路由</strong></p>
<p>使用<strong>joi第三方模块</strong>可以方便的进行对象格式验证</p>
<h3 id="3-1-joi第三方模块"><a href="#3-1-joi第三方模块" class="headerlink" title="3.1 joi第三方模块"></a>3.1 joi第三方模块</h3><p><code>npm install joi</code></p>
<ul>
<li><p>下载版本为<strong>17.4.2</strong></p>
</li>
<li><p>创建验证规则</p>
<ul>
<li><code>Joi.object(&#123;&#125;)</code>方法，对象作为参数，对对象的属性进行限制</li>
<li>可以指定待验证属性的<strong>类型</strong>，<strong>长度</strong>，<strong>是否必填</strong>等</li>
<li>可以自定义验证不通过时的报错信息</li>
</ul>
</li>
<li><p>进行验证</p>
<ul>
<li>第一种方式<ul>
<li><code>const &#123;value,error&#125; = schema.validate(‘待验证对象’)</code></li>
<li>schema为验证规则</li>
<li>通过时value为待验证对象，error为undefined</li>
<li>不通过时value为待验证对象，error为错误对象</li>
</ul>
</li>
<li>第二种方式<ul>
<li><code>schema.validateAsync(‘待验证对象’)</code></li>
<li>返回promise对象</li>
<li>使用<strong>异步函数错误捕获</strong>的方式**(try catch)**</li>
<li>在catch中进行错误信息的输出**(err.message输出简要错误信息)**</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入模块</span></span><br><span class="line"><span class="keyword">const</span> Joi = <span class="built_in">require</span>(<span class="string">&#x27;joi&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建验证规则</span></span><br><span class="line"><span class="keyword">const</span> schema = Joi.object(&#123;</span><br><span class="line">    <span class="comment">//username属性的值为字符串，最短2，最长10，必填</span></span><br><span class="line">    <span class="comment">//error()方法可以自定义报错信息</span></span><br><span class="line">    username: Joi.string().min(<span class="number">2</span>).max(<span class="number">10</span>).required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;username验证不通过&#x27;</span>)),</span><br><span class="line">    birthyear: Joi.number().min(<span class="number">1900</span>).max(<span class="number">2021</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种验证方式</span></span><br><span class="line"><span class="keyword">const</span> &#123;value,error&#125; = schema.validate(&#123;<span class="attr">birthyear</span>:<span class="number">1901</span>&#125;)</span><br><span class="line"><span class="comment">//value为验证对象</span></span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br><span class="line"><span class="comment">//验证通过时error为undefined，没通过error为错误对象</span></span><br><span class="line"><span class="built_in">console</span>.log(error.message);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种验证方式</span></span><br><span class="line"><span class="comment">//使用异步函数错误捕获</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//value为验证对象</span></span><br><span class="line">        <span class="keyword">const</span> value = <span class="keyword">await</span> schema.validateAsync(&#123;<span class="attr">birthyear</span>:<span class="number">1900</span>&#125;)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="comment">//输出错误信息</span></span><br><span class="line">        <span class="built_in">console</span>.log(err.message);</span><br><span class="line">        <span class="comment">//终止</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;验证通过&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run()</span><br></pre></td></tr></table></figure>

<h3 id="3-2-使用joi模块实现服务端注册信息验证"><a href="#3-2-使用joi模块实现服务端注册信息验证" class="headerlink" title="3.2 使用joi模块实现服务端注册信息验证"></a>3.2 使用joi模块实现服务端注册信息验证</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Joi = <span class="built_in">require</span>(<span class="string">&#x27;joi&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设定验证规则</span></span><br><span class="line"><span class="keyword">const</span> schema = Joi.object(&#123;</span><br><span class="line">    username: Joi.string().min(<span class="number">2</span>).max(<span class="number">10</span>).required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;用户名验证不通过&#x27;</span>)),</span><br><span class="line">    email: Joi.string().email().required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;邮箱验证不通过&#x27;</span>)),</span><br><span class="line">    password: Joi.string().regex(<span class="regexp">/^[a-zA-Z0-9]&#123;3,30&#125;&amp;/</span>).required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;密码验证不通过&#x27;</span>)),</span><br><span class="line">    role: Joi.string().valid(<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;normal&#x27;</span>).required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;角色值验证不通过&#x27;</span>)),</span><br><span class="line">    state: Joi.number().valid(<span class="number">0</span>,<span class="number">1</span>).required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;状态验证不通过&#x27;</span>)),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> (req,res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">await</span> schema.validateAsync(req.body)</span><br><span class="line">    <span class="comment">//验证不通过则重定向到注册页面并在页面显示错误提示</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        res.redirect(<span class="string">`/admin/user-edit?message=<span class="subst">$&#123;err.message&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    res.send(req.body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>regex(/^[a-zA-Z0-9]&#123;3,30&#125;&amp;/)</code> 密码验证使用正则表达式</p>
<ul>
<li>长度为<strong>3到30</strong>(包括边界)并由<strong>大小写字母和数字0-9</strong>组成的字符串可以通过验证</li>
</ul>
</li>
<li><p><code>valid(&#39;admin&#39;,&#39;normal)</code> 角色验证使用可选字符串</p>
<ul>
<li>只有admin或normal两个字符串可以通过</li>
<li>valid中选择数字同理，只有特定数字可以通过验证</li>
</ul>
</li>
<li><p><code>email()</code>代表符合邮箱字符串格式才能通过</p>
</li>
<li><p>验证不通过时<strong>将错误信息作为请求参数加入重定向url中</strong></p>
<ul>
<li>重定向请求处理时<strong>将参数中的错误信息与模板拼接</strong></li>
</ul>
</li>
<li><p>执行res.redirect()重定向时要<strong>接着return</strong></p>
<ul>
<li>因为重定向时会默认执行res.end()方法结束请求</li>
<li>如果下面的代码还有res.send这类结束请求的代码就会报错</li>
</ul>
</li>
</ul>
<h3 id="3-3-用户添加到数据库"><a href="#3-3-用户添加到数据库" class="headerlink" title="3.3 用户添加到数据库"></a>3.3 用户添加到数据库</h3><p>用户提交信息通过服务端格式验证后，继续判断邮箱是否已经注册，若<strong>没有注册则将用户添加到数据库</strong>并将页面重定向到用户展示页面</p>
<p>若已经注册则重定向回注册页面并显示<strong>邮箱已被注册</strong></p>
<ul>
<li>判断邮箱是否已经注册<ul>
<li>没有注册则将密码加密</li>
<li>然后将新用户信息存入数据库</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//验证用户提交的邮箱是否存在</span></span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> User.findOne(&#123;<span class="attr">email</span>:req.body.email&#125;)</span><br><span class="line">    <span class="comment">//如果存在则重定向回注册页面并显示错误</span></span><br><span class="line">    <span class="keyword">if</span>(user)&#123;</span><br><span class="line">        <span class="keyword">return</span> res.redirect(<span class="string">`/admin/user-edit?message=当前邮箱已经注册`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不存在则可以注册</span></span><br><span class="line">    <span class="comment">//加密用户密码</span></span><br><span class="line">    <span class="keyword">const</span> salt = <span class="keyword">await</span> bcrypt.genSalt(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">//生成加密密码，第一个参数为明文，第二个参数为生成的随机数</span></span><br><span class="line">    <span class="keyword">const</span> password = <span class="keyword">await</span> bcrypt.hash(req.body.password,salt)</span><br><span class="line">    req.body.password = password</span><br><span class="line">    <span class="comment">//在数据库中创建新用户</span></span><br><span class="line">    <span class="keyword">await</span> User.create(req.body)</span><br><span class="line">    <span class="comment">//重定向到用户展示页面</span></span><br><span class="line">    <span class="keyword">return</span> res.redirect(<span class="string">&#x27;/admin/user&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-4-优化user-editSubmit-js文件"><a href="#3-4-优化user-editSubmit-js文件" class="headerlink" title="3.4 优化user-editSubmit.js文件"></a>3.4 优化user-editSubmit.js文件</h3><h4 id="3-4-1-提交信息格式验证代码优化"><a href="#3-4-1-提交信息格式验证代码优化" class="headerlink" title="3.4.1 提交信息格式验证代码优化"></a>3.4.1 提交信息格式验证代码优化</h4><ul>
<li>验证提交信息格式的代码属于<strong>用户数据处理的代码</strong>，并可能多次使用<ul>
<li>将其提取放在<strong>model/user.js</strong>文件中</li>
<li>model文件夹存放<strong>数据处理</strong>的文件</li>
<li>user.js文件存放<strong>用户数据处理</strong>代码</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//验证用户注册信息格式函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validateSubmit</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> schema = Joi.object(&#123;</span><br><span class="line">        username: Joi.string().min(<span class="number">2</span>).max(<span class="number">10</span>).required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;用户名验证不通过&#x27;</span>)),</span><br><span class="line">        email: Joi.string().email().required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;邮箱验证不通过&#x27;</span>)),</span><br><span class="line">        password: Joi.string().regex(<span class="regexp">/^[a-zA-Z0-9]&#123;3,16&#125;$/</span>).required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;密码验证不通过&#x27;</span>)),</span><br><span class="line">        role: Joi.string().valid(<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;normal&#x27;</span>).required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;角色值验证不通过&#x27;</span>)),</span><br><span class="line">        state: Joi.number().valid(<span class="number">0</span>,<span class="number">1</span>).required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;状态验证不通过&#x27;</span>)),</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> schema.validateAsync(user)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//导出User集合构造函数和注册信息格式验证函数</span></span><br><span class="line"><span class="comment">//使用对象,方便之后其他对象导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    User,</span><br><span class="line">    validateSubmit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-2-重定向错误处理代码优化"><a href="#3-4-2-重定向错误处理代码优化" class="headerlink" title="3.4.2 重定向错误处理代码优化"></a>3.4.2 重定向错误处理代码优化</h4><ul>
<li>格式验证不通过和邮箱已经被注册时进行重定向属于<strong>错误处理代码</strong><ul>
<li>将其提取后放在app.js文件中的<strong>错误处理中间件中</strong></li>
<li><strong>next()方法接受字符串作为参数</strong>，需要将对象转换为字符串(<code>JSON.stringify()</code>方法)</li>
<li><strong>next()方法的参数</strong>即为错误处理中间件的<strong>err参数</strong></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// return res.redirect(`/admin/user-edit?message=当前邮箱已经注册`)</span></span><br><span class="line"><span class="comment">//将原本的重定向代码替换为下面的next()方法</span></span><br><span class="line">next(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">path</span>:<span class="string">&#x27;/admin/user-edit&#x27;</span>,<span class="attr">message</span>:<span class="string">&#x27;当前邮箱已经注册&#x27;</span>&#125;))</span><br></pre></td></tr></table></figure>

<center>user-editSubmit.js文件中跳转错误处理中间件</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入模块化路由</span></span><br><span class="line"><span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">&#x27;./route/home&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> admin = <span class="built_in">require</span>(<span class="string">&#x27;./route/admin&#x27;</span>)</span><br><span class="line">app.use(<span class="string">&#x27;/home&#x27;</span>,home)</span><br><span class="line">app.use(<span class="string">&#x27;/admin&#x27;</span>,admin)</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误处理中间件</span></span><br><span class="line"><span class="comment">//next()方法的参数即为错误处理中间件的err参数</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//转换回对象提取数据</span></span><br><span class="line">    <span class="keyword">const</span> &#123;path,message&#125; = <span class="built_in">JSON</span>.parse(err)</span><br><span class="line">    <span class="comment">//重定向</span></span><br><span class="line">    res.redirect(<span class="string">`<span class="subst">$&#123;path&#125;</span>?message=<span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>app.js中错误处理中间件</center>

<h2 id="4-用户列表页面"><a href="#4-用户列表页面" class="headerlink" title="4. 用户列表页面"></a>4. 用户列表页面</h2><p>用户登录成功或者注册成功时<strong>会跳转到用户列表页面</strong></p>
<p>用户列表页面需要<strong>显示当前数据库中已注册用户的信息</strong></p>
<ul>
<li>请求用户列表页面时将数据库中的所有注册用户数据<strong>作为拼接数据进行模板渲染</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;User&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../../model/user&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> (req,res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> users = <span class="keyword">await</span> User.find()</span><br><span class="line">    res.render(<span class="string">&#x27;admin/user&#x27;</span>,&#123;</span><br><span class="line">        users:users</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>userPage.js</center>

<ul>
<li>在用户列表页面模板中<strong>通过循环显示用户数据</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123;each users&#125;&#125;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;&#123;&#123;@$value._id&#125;&#125;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;&#123;&#123;$value.username&#125;&#125;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;&#123;&#123;$value.email&#125;&#125;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;&#123;&#123;$value.role == <span class="string">&#x27;admin&#x27;</span> ? <span class="string">&#x27;管理员&#x27;</span> : <span class="string">&#x27;普通用户&#x27;</span>&#125;&#125;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;&#123;&#123;$value.state == <span class="number">0</span> ? <span class="string">&#x27;启用&#x27;</span> : <span class="string">&#x27;禁用&#x27;</span>&#125;&#125;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        &lt;a href=<span class="string">&quot;user-edit.html&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;glyphicon glyphicon-edit&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line">		&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;glyphicon glyphicon-remove&quot;</span> data-toggle=<span class="string">&quot;modal&quot;</span> data-target=<span class="string">&quot;.confirm-modal&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">	&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&#123;&#123;/each&#125;&#125;</span><br></pre></td></tr></table></figure>

<center>user.art模板循环显示用户信息</center>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210906172011394.png" alt="用户列表页面实际效果"></p>
<br>

<h3 id="4-1-用户列表分页显示功能"><a href="#4-1-用户列表分页显示功能" class="headerlink" title="4.1 用户列表分页显示功能"></a>4.1 用户列表分页显示功能</h3><p>实现分页功能的几个要点：</p>
<ul>
<li>每一页显示的数据条数</li>
<li>数据库中要显示的数据总条数</li>
<li>当前要显示的页码<ul>
<li>当前要显示的页码通过get请求参数传递到服务器</li>
<li>若为最后一页则要取消下一页按钮</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前请求的页码参数</span></span><br><span class="line"><span class="keyword">const</span> page = req.query.page || <span class="number">1</span></span><br><span class="line"><span class="comment">//设定一页显示的数据条数</span></span><br><span class="line"><span class="keyword">const</span> pageSize = <span class="number">1</span></span><br><span class="line"><span class="comment">//获取数据库中数据总条数</span></span><br><span class="line"><span class="comment">//参数为匹配条件，空则匹配所有数据</span></span><br><span class="line"><span class="keyword">const</span> count = <span class="keyword">await</span> User.countDocuments(&#123;&#125;)</span><br><span class="line"><span class="comment">//总页数</span></span><br><span class="line"><span class="keyword">const</span> total = <span class="built_in">Math</span>.ceil(count/pageSize)</span><br><span class="line"><span class="comment">//当前页首条数据开始位置</span></span><br><span class="line"><span class="keyword">const</span> start = (page - <span class="number">1</span>) * pageSize</span><br><span class="line"><span class="comment">//从数据库中查询当前页数据</span></span><br><span class="line"><span class="keyword">const</span> users = <span class="keyword">await</span> User.find().limit(pageSize).skip(start)</span><br><span class="line"><span class="comment">//渲染模板</span></span><br><span class="line">res.render(<span class="string">&#x27;admin/user&#x27;</span>,&#123;</span><br><span class="line">    users:users</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>userPage.js中分页功能代码</center>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;% for (var i=1 ; i&lt;=total ; i++) &#123; %&gt;</span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/admin/user?page=&lt;%= i %&gt;&quot;</span>&gt;</span>&lt;%= i %&gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<center>user.art中使用模板原始语法循环生成每一页按钮</center>

<ul>
<li><p>获取请求页码时 <code>|| 1</code>，此时若请求中没有传递页码参数，page = 1，默认显示第一页数据</p>
</li>
<li><p>当页首条数据在数据库中序号为 <code>(page - 1) * pageSize</code></p>
</li>
<li><p>总页数计算时向上取整，不满一页的数据也算一页</p>
</li>
<li><p>查询时使用<code>limit()</code>和<code>skip()</code>方法</p>
<ul>
<li>limit()  限制一次查询的数据条数</li>
<li>skip()   限制本次查询从哪一条数据开始<ul>
<li>参数为数据在数据库中的序号</li>
<li>数据库中的<strong>第1条数据序号为0</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-1-1-适时取消上一页-下一页按钮"><a href="#4-1-1-适时取消上一页-下一页按钮" class="headerlink" title="4.1.1 适时取消上一页/下一页按钮"></a>4.1.1 适时取消上一页/下一页按钮</h4><p>当前页为第一页或者最后一页时隐藏上一页或下一页按钮</p>
<p><strong>防止访问不存在的页导致错误</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;display: &lt;%= page-1==0 ? &#x27;none&#x27; : &#x27;inline&#x27;%&gt;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/admin/user?page=&lt;%= page-1 %&gt;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="symbol">&amp;laquo;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<center>user.art中上一页按钮显示隐藏</center>

<p>使用<strong>模板原始语法修改li标签display属性值</strong>实现隐藏显示</p>
<p>当前页page=1时即隐藏上一页按钮</p>
<p>下一页按钮同理</p>
<ul>
<li>此处html模板中显示使用inline，修改为显示时也使用inline</li>
<li>下一页判断时<code>page-0+1</code>先使用<code>page-0</code>将<strong>字符串隐式转换为数字再进行加法</strong></li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210906223507179.png" alt="当前显示第一页时隐藏上一页按钮"></p>
<br>

<h2 id="5-用户信息修改功能"><a href="#5-用户信息修改功能" class="headerlink" title="5. 用户信息修改功能"></a>5. 用户信息修改功能</h2><h3 id="5-1-用户信息修改页面"><a href="#5-1-用户信息修改页面" class="headerlink" title="5.1 用户信息修改页面"></a>5.1 用户信息修改页面</h3><p><strong>用户信息修改</strong>和<strong>新用户添加</strong>使用同一个模板即<code>user-edit.art</code></p>
<p>当用户点击用户列表页面的编辑按钮时，将要修改的用户ID作为get参数发送，请求地址<code>/admin/user-edit</code>（修改和添加使用同一个请求地址）</p>
<p>将要修改的用户信息填入文本框</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求参数是否有id参数</span></span><br><span class="line"><span class="keyword">if</span>(id)&#123;</span><br><span class="line">    <span class="comment">//用户信息修改</span></span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> User.findOne(&#123;<span class="attr">_id</span>:id&#125;)</span><br><span class="line">    res.render(<span class="string">&#x27;admin/user-edit&#x27;</span>,&#123;</span><br><span class="line">        message:message,</span><br><span class="line">        user:user,</span><br><span class="line">        <span class="comment">//link来区分修改和添加提交地址</span></span><br><span class="line">        link:<span class="string">&#x27;/admin/user-editChange&#x27;</span>,</span><br><span class="line">        button:<span class="string">&#x27;修改&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//添加新用户</span></span><br><span class="line"> 	res.render(<span class="string">&#x27;admin/user-edit&#x27;</span>,&#123;</span><br><span class="line">        message:message,</span><br><span class="line">        link:<span class="string">&#x27;/admin/user-edit&#x27;</span>,</span><br><span class="line">        button:<span class="string">&#x27;添加&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>user-edit.js中处理修改和新增用户请求</center>

<ul>
<li>首先从请求参数中解构出id参数</li>
<li><strong>判断id参数是否存在</strong><ul>
<li>是 修改请求<ul>
<li>数据库中查询要修改的用户数据</li>
<li>作为模板拼接数据渲染</li>
</ul>
</li>
<li>否 新增用户请求(用户注册)</li>
</ul>
</li>
</ul>
<br>

<p><strong>user-edit.art模板渲染时注意的问题</strong></p>
<ul>
<li>因为新增用户时<strong>不需要将用户数据作为拼接数据</strong>，所以模板中使用user数据时要<strong>先判断user是否存在</strong><ul>
<li>如果新增用户时模板<strong>使用一个不存在的拼接数据</strong>，会报错</li>
<li><code>&#123;&#123;@user && user._id&#125;&#125;</code>使用与运算符判断，如果user拼接数据存在，再填入user._id，否则留空<ul>
<li>使用@进行id的原文输出(id在数据库中存储的格式为<code>ObjectId</code>)</li>
</ul>
</li>
</ul>
</li>
<li>修改信息和新增用户<strong>使用不同的表单提交地址</strong><ul>
<li>使用拼接数据<code>link</code>区分提交地址</li>
</ul>
</li>
<li>两个页面提交按钮的文字不同 <strong>修改/提交</strong> 使用button拼接数据区分</li>
<li>修改用户信息时<strong>密码并不显示在文本框中</strong>，用户需进行下一步验证才能修改密码</li>
</ul>
<br>

<h3 id="5-2-用户信息修改提交"><a href="#5-2-用户信息修改提交" class="headerlink" title="5.2 用户信息修改提交"></a>5.2 用户信息修改提交</h3><p>点击提交按钮后发送<strong>post请求</strong>到<code>/admin/user-modify</code>地址</p>
<ul>
<li><strong>将修改用户的id</strong>作为get参数</li>
<li><strong>修改信息</strong>作为post参数</li>
<li>post请求也可以添加get参数</li>
</ul>
<p>服务器接受请求后使用bcrypt模块<strong>比对用户输入的密码和数据库中的密码</strong></p>
<ul>
<li>成功则允许修改，更新数据库中用户数据</li>
<li>失败则重定向回修改页面并显示错误信息</li>
</ul>
<h4 id="5-2-1-密码比对错误时"><a href="#5-2-1-密码比对错误时" class="headerlink" title="5.2.1 密码比对错误时"></a>5.2.1 密码比对错误时</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//密码比对失败</span></span><br><span class="line"><span class="comment">//调用错误处理中间件重定向回修改页面并显示错误信息</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">path</span>:<span class="string">&#x27;/admin/user-edit&#x27;</span>,<span class="attr">message</span>:<span class="string">&#x27;密码错误，请重试&#x27;</span>,<span class="attr">id</span>:id&#125;</span><br><span class="line">next(<span class="built_in">JSON</span>.stringify(obj))</span><br></pre></td></tr></table></figure>

<center>user-modify.js文件密码比对失败时处理</center>

<p>比对失败时，将<strong>重定向地址</strong>，<strong>错误信息</strong>，<strong>用户id</strong>(重定向后显示用户信息使用)作为错误对象传递到错误处理中间件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误处理中间件</span></span><br><span class="line"><span class="comment">//出错后带着错误信息重定向</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">JSON</span>.parse(err)</span><br><span class="line">    <span class="comment">//修改用户信息密码比对错误时的 result = &#123;path:&#x27;...&#x27;,message:&#x27;...&#x27;,id:...&#125;</span></span><br><span class="line">    <span class="keyword">const</span> params = []</span><br><span class="line">    <span class="comment">//通过循环将要添加的多个请求参数存入数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> attr <span class="keyword">in</span> result)&#123;</span><br><span class="line">        <span class="keyword">if</span>(attr != <span class="string">&#x27;path&#x27;</span>)&#123;</span><br><span class="line">            params.push(<span class="string">`<span class="subst">$&#123;attr&#125;</span>=<span class="subst">$&#123;result[attr]&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用数组join方法以&amp;分隔 将多个请求参数添加到url中</span></span><br><span class="line">    res.redirect(<span class="string">`<span class="subst">$&#123;result.path&#125;</span>?<span class="subst">$&#123;params.join(<span class="string">&#x27;&amp;&#x27;</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>app.js中改进后的错误处理中间件</center>

<ul>
<li>之前的错误处理中间件在重定向时<strong>将请求参数固定写为一个</strong>，但是重定向时的<strong>请求参数个数通常不定</strong></li>
<li>需要动态根据每个错误修改参数个数</li>
</ul>
<p>使用<strong>循环遍历错误对象</strong>，将其中每个请求参数存入数组</p>
<p>使用<strong>数组join方法</strong>将每个元素以&amp;拼接后作为url中的请求参数</p>
<ul>
<li><strong>注意：</strong>以变量获取对象属性时使用**[]**，例如上述代码第二次循环时<code>attr = message</code></li>
<li>获取<code>result.message</code>属性时，代码为<code>result[attr]</code></li>
</ul>
<p>此时当用户在修改用户信息页面<strong>输入错误的密码并点击修改按钮</strong>后，页面重定向到修改用户信息页面并提示错误信息</p>
<br>

<h4 id="5-2-2-密码比对成功时"><a href="#5-2-2-密码比对成功时" class="headerlink" title="5.2.2 密码比对成功时"></a>5.2.2 密码比对成功时</h4><p>更新数据库中对应用户的<strong>除密码外的信息</strong></p>
<p>然后重定向到用户列表页面，修改后的结果可以在列表页面查看</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//密码比对成功</span></span><br><span class="line"><span class="comment">//更新数据库中信息(密码不更新)</span></span><br><span class="line"><span class="keyword">await</span> User.updateOne(&#123;<span class="attr">_id</span>:id&#125;,&#123;</span><br><span class="line">    username:username,</span><br><span class="line">    email:email,</span><br><span class="line">    role:role,</span><br><span class="line">    state:state</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//重定向到用户列表页面</span></span><br><span class="line">res.redirect(<span class="string">&#x27;/admin/user&#x27;</span>)</span><br></pre></td></tr></table></figure>

<br>

<h2 id="6-用户删除功能"><a href="#6-用户删除功能" class="headerlink" title="6. 用户删除功能"></a>6. 用户删除功能</h2><p>在用户列表页面点击用户信息后的删除按钮将用户删除</p>
<ul>
<li>给删除按钮添加自定义属性<code>data-id</code>(即为要删除用户的id)</li>
<li>script代码加入删除按钮点击事件，在处理函数中获取data-id属性值</li>
<li>将<strong>用户id</strong>设置为表单隐藏域的<strong>value属性值</strong></li>
<li>表单设置为GET请求，提交地址为<code>/admin/user-delete</code></li>
<li>服务器端设置删除路由<code>/admin/user-delete</code></li>
<li>服务端接受请求获取GET请求参数id</li>
<li>根据id删除对应用户</li>
<li><strong>重定向回用户列表页面</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    $(<span class="string">&#x27;.delete&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    	<span class="comment">//获取删除按钮自定义属性</span></span><br><span class="line">        <span class="keyword">let</span> id = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;data-id&#x27;</span>)</span><br><span class="line">        <span class="comment">//将id值 给表单隐藏域的value属性</span></span><br><span class="line">        $(<span class="string">&#x27;#userDelete&#x27;</span>).val(id)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<center>删除按钮点击事件</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;您确定要删除这个用户吗?&lt;/p&gt;</span><br><span class="line"><span class="comment">//表单隐藏域</span></span><br><span class="line">&lt;input type=<span class="string">&quot;hidden&quot;</span> name=<span class="string">&quot;id&quot;</span> id=<span class="string">&quot;userDelete&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<center>表单隐藏域</center>

<ul>
<li>表单隐藏域即为一个<strong>type值为hidden的input标签</strong></li>
<li>他不显示在页面中，只起<strong>设定表单请求参数的作用</strong></li>
<li>当表单以GET请求方式提交时，隐藏域请求参数<strong>仍显示在地址栏中（localhost/admin/user-delete?id=…）</strong></li>
</ul>
<br>

<h2 id="7-文章管理功能"><a href="#7-文章管理功能" class="headerlink" title="7.文章管理功能"></a>7.文章管理功能</h2><ul>
<li>给<strong>文章列表页面</strong>和<strong>文章编辑页面</strong>添加路由</li>
<li><code>views/admin/commom</code>文件夹下的<strong>aside.art侧边栏模板文件</strong>中为文章管理和用户管理添加超链接</li>
<li>在用户页面(列表和编辑)和文章页面的路由处理函数中添加模板公共拼接数据，根据变量<strong>currentLink的值</strong>判断侧边栏选中项</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item &#123;&#123;currentLink == &#x27;user&#x27; ? &#x27;active&#x27; : &#x27;&#x27;&#125;&#125;&quot;</span> href=<span class="string">&quot;/admin/user&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<center>aside.art文件中判断侧边栏是否选中用户管理</center>

<h3 id="7-1-创建文章集合articles"><a href="#7-1-创建文章集合articles" class="headerlink" title="7.1 创建文章集合articles"></a>7.1 创建文章集合articles</h3><p>创建集合规则时注意：文章集合中的<strong>一个作者字段即对应用户集合中一个的文档</strong>（一条用户信息），需要使用<strong>集合关联</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建集合规则</span></span><br><span class="line"><span class="keyword">const</span> articleSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    title:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        required:[<span class="literal">true</span>,<span class="string">&#x27;请输入标题&#x27;</span>],</span><br><span class="line">        minlength:<span class="number">4</span>,</span><br><span class="line">        maxlength:<span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//作者实际就是用户集合中的文档（用户信息）</span></span><br><span class="line">    <span class="comment">//集合关联</span></span><br><span class="line">    author:&#123;</span><br><span class="line">        type:mongoose.Schema.Types.ObjectId,</span><br><span class="line">        ref:<span class="string">&#x27;User&#x27;</span>,</span><br><span class="line">        required:[<span class="literal">true</span>,<span class="string">&#x27;请写作者&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    publishDate:&#123;</span><br><span class="line">        type:<span class="built_in">Date</span>,</span><br><span class="line">        <span class="keyword">default</span>:<span class="built_in">Date</span>.now</span><br><span class="line">    &#125;,</span><br><span class="line">    cover:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>:<span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    content:&#123;</span><br><span class="line">        type:<span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>创建文章集合规则</center>

<h3 id="7-2-添加文章功能"><a href="#7-2-添加文章功能" class="headerlink" title="7.2 添加文章功能"></a>7.2 添加文章功能</h3><ul>
<li>给article-edit.art页面的表单设置提交地址，提交方式，<strong>编码类型</strong>，请求参数名<ul>
<li>编码类型需要设置为<strong>multipart/form-data</strong>，表单数据以二进制编码</li>
<li>表单中<strong>上传文件时</strong>，数据<strong>必须以二进制编码</strong></li>
</ul>
</li>
<li>设置文章添加路由</li>
<li>表单数据以二进制编码时，接收表单数据需要使用<strong>第三方模块formidable</strong></li>
</ul>
<h4 id="7-2-1-formidable模块-处理二进制表单数据"><a href="#7-2-1-formidable模块-处理二进制表单数据" class="headerlink" title="7.2.1 formidable模块 处理二进制表单数据"></a>7.2.1 formidable模块 处理二进制表单数据</h4><ul>
<li>支持解析GET/POST请求参数，<strong>解析上传文件</strong></li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210908202048388.png" alt="formidable模块基本使用"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//formidable模块处理二进制表单数据(有文件上传的表单)</span></span><br><span class="line"><span class="keyword">const</span> formidable = <span class="built_in">require</span>(<span class="string">&#x27;formidable&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//创建表单解析对象form</span></span><br><span class="line">    <span class="keyword">const</span> form = formidable.IncomingForm()</span><br><span class="line">    <span class="comment">//设定上传文件存储位置</span></span><br><span class="line">    form.uploadDir = path.join(__dirname,<span class="string">&#x27;../&#x27;</span>,<span class="string">&#x27;../&#x27;</span>,<span class="string">&#x27;public&#x27;</span>,<span class="string">&#x27;uploads&#x27;</span>)</span><br><span class="line">    <span class="comment">//保留上传文件后缀</span></span><br><span class="line">    form.keepExtensions = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//解析表单数据</span></span><br><span class="line">    <span class="comment">//第一个参数为请求对象 第二个为回调函数</span></span><br><span class="line">    form.parse(req,<span class="function">(<span class="params">err,fields,files</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//err为错误对象 出错为对象 正常为null</span></span><br><span class="line">        <span class="comment">//fields 对象类型 为普通请求参数(非文件上传参数)</span></span><br><span class="line">        <span class="comment">//files 对象类型 上传文件的相关信息</span></span><br><span class="line">        res.send(fields)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>article-add.js文件处理二进制表单数据</center>

<ul>
<li>上传文件保存在<code>myblog_project/public/uploads</code>文件夹下</li>
<li>保留文件后缀</li>
</ul>
<br>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210908203033806.png" alt="fields对象内容"></p>
<ul>
<li>fields对象内容<ul>
<li>除cover上传文件参数外的<strong>其他普通参数</strong></li>
</ul>
</li>
</ul>
<br>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210908203525686.png" alt="files对象内容"></p>
<ul>
<li>对象中有cover（文件上传的参数名）属性</li>
<li>cover属性是一个对象<ul>
<li>size文件大小</li>
<li>path文件在本地存储路径（避免文件名重复会使用一个随机生成的）</li>
<li>name文件上传时的名字</li>
<li>type文件类型</li>
<li>mtime最后修改时间</li>
</ul>
</li>
</ul>
<br>

<h4 id="7-2-2-添加文章页面显示登录用户id"><a href="#7-2-2-添加文章页面显示登录用户id" class="headerlink" title="7.2.2 添加文章页面显示登录用户id"></a>7.2.2 添加文章页面显示登录用户id</h4><p>使用模板公共拼接数据<strong>userInfo</strong>（login.js文件中用户登录后将用户对象做为公共拼接数据userInfo）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input name=<span class="string">&quot;author&quot;</span> type=<span class="string">&quot;text&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;form-control&quot;</span> readonly value=<span class="string">&quot;&#123;&#123;@userInfo._id&#125;&#125;&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>使用@原文输出id</p>
<br>

<h4 id="7-2-3-上传文章封面显示缩略图"><a href="#7-2-3-上传文章封面显示缩略图" class="headerlink" title="7.2.3 上传文章封面显示缩略图"></a>7.2.3 上传文章封面显示缩略图</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文件上传文本框加上multiple属性后可以一次选择多个文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;cover&quot;</span> <span class="attr">id</span>=<span class="string">&quot;files&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>文件上传文本框（type=’file’）</li>
<li>加multiple属性可以一次选择多个文件上传</li>
</ul>
<br>

<p><strong>文件读取对象 FileReader</strong></p>
<p>JS的文件读取对象FileReader可以读取通过文件上传文本框上传的文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建文件读取对象</span></span><br><span class="line"><span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line"><span class="comment">//读取文件</span></span><br><span class="line">reader.readAsDataURL(<span class="string">&#x27;文件&#x27;</span>)</span><br><span class="line"><span class="comment">//监听文件读取完毕事件（文件读取是异步API，不能使用返回值获取结果）</span></span><br><span class="line"><span class="comment">//reader.result即为读取文件的内容</span></span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(reader.result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<center>文件读取对象基本使用</center>



<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210908210224806.png" alt="右侧为读取图片时reader.result内容"></p>
<ul>
<li>对于图片文件的读取，上图右侧即为读取后reader.result的内容</li>
<li>将reader.result的内容<strong>直接作为img标签src属性的值</strong>，效果与直接外链图片一致</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="comment">//获取上传文件文本框（type=&#x27;file&#x27;）</span></span><br><span class="line">        <span class="keyword">let</span> file = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#files&#x27;</span>)</span><br><span class="line">        <span class="comment">//获取预览img标签</span></span><br><span class="line">        <span class="keyword">let</span> preview = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#preview&#x27;</span>)</span><br><span class="line">        <span class="comment">//监听文件上传事件 上传文件文本框change即代表有文件上传</span></span><br><span class="line">        file.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//创建文件读取对象</span></span><br><span class="line">            <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line">            <span class="comment">//读取文件</span></span><br><span class="line">            reader.readAsDataURL(<span class="built_in">this</span>.files[<span class="number">0</span>])</span><br><span class="line">            <span class="comment">//监听文件读取完毕事件（文件读取是异步API，不能使用返回值获取结果）</span></span><br><span class="line">            reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                preview.src = reader.result</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<center>article-edit.art文件中上传文件显示缩略图</center>

<ul>
<li>有文件上传时即开始创建文件读取对象FileReader</li>
<li>文件上传文本框的<strong>this.files</strong> 为上传文件的列表</li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210908213035902.png" alt="this.files（上传一个文件）"></p>
<ul>
<li>this.files[0]即为上传的第一个文件<ul>
<li><code>reader.readAsDataURL(this.files[0])</code>  即读取文件列表中第一个文件</li>
</ul>
</li>
<li>文件读取完毕后直接<strong>将结果作为缩略图img标签的src属性</strong></li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210908213411425.png" alt="缩略图效果"></p>
<br>

<h4 id="7-2-4-添加文章存入数据库"><a href="#7-2-4-添加文章存入数据库" class="headerlink" title="7.2.4 添加文章存入数据库"></a>7.2.4 添加文章存入数据库</h4><ul>
<li>将新增文章存入数据库时<strong>两个字段需要注意</strong>：<ul>
<li>author字段存储的是<strong>登录用户的id</strong><ul>
<li>用户id在提交前已经通过公共拼接数据写入文本框value属性</li>
</ul>
</li>
<li>cover字段存储的是<strong>封面文件在服务器本地的绝对存储路径</strong> （也就是模板渲染图片时使用的路径）</li>
</ul>
</li>
</ul>
<h5 id="7-2-4-1-获取封面文件在服务器本地的绝对存储路径"><a href="#7-2-4-1-获取封面文件在服务器本地的绝对存储路径" class="headerlink" title="7.2.4.1 获取封面文件在服务器本地的绝对存储路径"></a>7.2.4.1 获取封面文件在服务器本地的绝对存储路径</h5><p>解析表单数据<code>form.parse</code>方法中回调函数的<strong>files参数存储上传文件的信息</strong></p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210908215109564.png" alt="files对象存储上传文件信息"></p>
<p>其中cover对象的path参数即为上传文件在服务器本机的绝对路径</p>
<p>对绝对路径进行截取获得的<strong>\uploads\upload_5a8abecaac6a7be8db59a90461efb878.jpg <strong>即为</strong>文章集合中cover字段的值</strong></p>
<ul>
<li>在app.js文件中已经设置过<strong>静态资源文件的存放路径为public文件夹下</strong>，所以从public后开始截取</li>
<li>模板文件中的绝对路径使用 <strong>‘/ ’</strong> 开头</li>
<li>使用字符串的<strong>split方法</strong>以public分割字符串，<strong>分割后数组的第二个元素即为cover的值</strong></li>
</ul>
<br>

<p>因为表单中的所有参数被分在两个变量（fields，files）中，所以<strong>创建数据库集合中文档使用的对象需要进行组合</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组合文章数据</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    title:fields.title,</span><br><span class="line">    author:fields.author,</span><br><span class="line">    publishDate:fields.publishDate == <span class="string">&#x27;&#x27;</span> ? <span class="built_in">Date</span>.now() : fields.publishDate,</span><br><span class="line">    <span class="comment">//以public分割的后部分路径</span></span><br><span class="line">    cover:files.cover.path.split(<span class="string">&#x27;public&#x27;</span>)[<span class="number">1</span>],</span><br><span class="line">    content:fields.content,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存入数据库</span></span><br><span class="line"><span class="keyword">await</span> Article.create(obj)</span><br><span class="line"><span class="comment">//重定向到文章列表页</span></span><br><span class="line">res.redirect(<span class="string">&#x27;/admin/article&#x27;</span>)</span><br></pre></td></tr></table></figure>

<center>article-add.js文件 将添加的文章存入数据库</center>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210908222811917.png" alt="数据库中的文章信息"></p>
<br>

<h3 id="7-3-文章列表页面"><a href="#7-3-文章列表页面" class="headerlink" title="7.3 文章列表页面"></a>7.3 文章列表页面</h3><p>查询数据库中所有文章，作为拼接数据，在模板中渲染</p>
<ul>
<li>查询时需要用到<strong>多集合关联查询</strong>（populate()方法）<ul>
<li>查询时author字段值为<strong>mongoose文档对象格式</strong></li>
<li>render方法与其冲突</li>
<li>使用lean()将其<strong>转换为普通对象格式</strong></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询文章集合所有文档</span></span><br><span class="line">    <span class="comment">//链式调用populate()方法 </span></span><br><span class="line">    <span class="comment">//多集合联合查询author字段</span></span><br><span class="line">        <span class="comment">//即查询_id值为author字段值的User集合中的文档</span></span><br><span class="line">        <span class="comment">//并用这个文档对象替换author的值</span></span><br><span class="line">    <span class="comment">//使用lean()缓和查询数据库与渲染模板的冲突</span></span><br><span class="line"><span class="keyword">let</span> articles = <span class="keyword">await</span> Article.find().populate(<span class="string">&#x27;author&#x27;</span>).lean()</span><br><span class="line"></span><br><span class="line"><span class="comment">//渲染模板</span></span><br><span class="line">res.render(<span class="string">&#x27;admin/article&#x27;</span>,&#123;</span><br><span class="line">    articles:articles</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h4 id="7-3-1发布时间格式处理"><a href="#7-3-1发布时间格式处理" class="headerlink" title="7.3.1发布时间格式处理"></a>7.3.1发布时间格式处理</h4><p>使用<strong>第三方模块dateformat</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入dateFormat模块格式化时间</span></span><br><span class="line"><span class="keyword">const</span> dateFormat= <span class="built_in">require</span>(<span class="string">&#x27;dateformat&#x27;</span>)</span><br><span class="line"><span class="comment">//引入art-template</span></span><br><span class="line"><span class="keyword">const</span> template = <span class="built_in">require</span>(<span class="string">&#x27;art-template&#x27;</span>)</span><br><span class="line"><span class="comment">//模板中导入外部变量</span></span><br><span class="line">template.defaults.imports.dateFormat = dateFormat</span><br></pre></td></tr></table></figure>

<center>app.js中引入dateformat模块并向模板导入外部变量</center>

<ul>
<li>项目使用了两个模板 ‘express-art-template’和’art-template’</li>
<li>将dateformat作为art-template模板的外部变量导入</li>
<li>在模板中使用<code>dateFormat(&#39;时间数据&#39;,&#39;格式化格式&#39;)</code>进行格式化</li>
<li><code>&#123;&#123;dateFormat($value.publishDate,'yyyy-mm-dd')&#125;&#125;</code> 格式化为年-月-日</li>
</ul>
<br>

<h4 id="7-3-2-文章列表页面分页"><a href="#7-3-2-文章列表页面分页" class="headerlink" title="7.3.2 文章列表页面分页"></a>7.3.2 文章列表页面分页</h4><p>文章列表页面使用<strong>第三方模块mongoose-sex-page</strong>实现，使用<strong>与用户列表页面分页不同的方法</strong></p>
<p><code>npm install mongoose-sex-page</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入mongoose-sex-page模块进行分页</span></span><br><span class="line"><span class="keyword">const</span> pagination = <span class="built_in">require</span>(<span class="string">&#x27;mongoose-sex-page&#x27;</span>)</span><br><span class="line"><span class="comment">//查询文章集合所有文档</span></span><br><span class="line">    <span class="comment">//链式调用populate()方法 </span></span><br><span class="line">        <span class="comment">//多集合联合查询author字段</span></span><br><span class="line">        <span class="comment">//即查询_id值为author字段值的User集合中的文档</span></span><br><span class="line">        <span class="comment">//并用这个文档对象替换author的值</span></span><br><span class="line">    <span class="comment">//使用mongoose-sex-page模块分页</span></span><br><span class="line">        <span class="comment">//page:当前显示第几页</span></span><br><span class="line">        <span class="comment">//size:一页显示多少条数据</span></span><br><span class="line">        <span class="comment">//display:页面下方分页按钮显示几页</span></span><br><span class="line">        <span class="comment">//exec():从数据库中查询</span></span><br><span class="line">    <span class="keyword">let</span> articles = <span class="keyword">await</span> pagination(Article).page(page).size(<span class="number">2</span>).display(<span class="number">2</span>).populate(<span class="string">&#x27;author&#x27;</span>).exec()</span><br><span class="line">    <span class="comment">//将查询出的对象先转换为JSON字符串再转换为对象</span></span><br><span class="line">    <span class="comment">//将author字段值的类型由mongoose文档对象转换为普通对象避免渲染模板时的冲突</span></span><br><span class="line">    <span class="keyword">let</span> temp = <span class="built_in">JSON</span>.stringify(articles)</span><br><span class="line">    articles = <span class="built_in">JSON</span>.parse(temp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// res.send(articles)</span></span><br><span class="line"></span><br><span class="line">    res.render(<span class="string">&#x27;admin/article&#x27;</span>,&#123;</span><br><span class="line">        articles:articles</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>pagination(‘集合构造函数’).page().size().display().exec()</strong></p>
<ul>
<li>集合构造函数：即要从<strong>哪个集合中查询数据并分页</strong></li>
<li>page()：参数为<strong>当前显示的页码</strong></li>
<li>size()：参数为<strong>一页显示的数据条数</strong></li>
<li>display()：参数为<strong>页面中分页按钮条显示几个按钮</strong><ul>
<li>若参数为2则一次显示2个按钮 1 2</li>
</ul>
</li>
<li>exec()：代表按照前面设定的规则开始在数据库中查询</li>
</ul>
<br>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210909124935375.png" alt="分页模块查询后的结果articles"></p>
</li>
<li><p>上述红框records对象即为<strong>第一页的两条数据</strong></p>
</li>
<li><p>total：总共查询出的数据条数</p>
</li>
<li><p>pages：分页的总页数</p>
</li>
<li><p>display属性为一个数组（循环数组显示分页按钮）</p>
</li>
</ul>
<br>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210909125348445.png" alt="分页效果"></p>
<ul>
<li>一页显示两条数据(<strong>size(2)</strong>)</li>
<li>下方分页按钮条显示两个按钮 1 2 (<strong>display(2)</strong>)</li>
</ul>
<br>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;each articles.display&#125;&#125;</span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/admin/article?page=&#123;&#123;$value&#125;&#125;&quot;</span>&gt;</span>&#123;&#123;$value&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;&#123;/each&#125;&#125;</span><br></pre></td></tr></table></figure>

<center>article.art模板中遍历display数组生成分页按钮并指定请求地址和显示的值</center>

<p>在请求地址中<strong>加入相应的page参数</strong>，服务端<strong>根据page参数返回相应的页码数据</strong></p>
<br>

<h5 id="7-3-2-1-分页按钮功能实现"><a href="#7-3-2-1-分页按钮功能实现" class="headerlink" title="7.3.2.1 分页按钮功能实现"></a>7.3.2.1 分页按钮功能实现</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 上一页按钮 --&gt;</span></span><br><span class="line">&#123;&#123;if articles.page &gt; 1&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/admin/article?page=&#123;&#123;articles.page - 1&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="symbol">&amp;laquo;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;&#123;/if&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定页面按钮 1 2 3 --&gt;</span></span><br><span class="line">&#123;&#123;each articles.display&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/admin/article?page=&#123;&#123;$value&#125;&#125;&quot;</span>&gt;</span>&#123;&#123;$value&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;&#123;/each&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下一页按钮 &gt; --&gt;</span></span><br><span class="line">&#123;&#123;if articles.page &lt; articles.pages&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/admin/article?page=&#123;&#123;articles.page - 0 + 1&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="symbol">&amp;raquo;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;&#123;/if&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>模板<strong>标准语法if判断</strong>，<strong>满足条件时if所包裹的代码才执行</strong></p>
<br>

<h4 id="7-3-3-文章修改和删除功能与用户的修改删除同理"><a href="#7-3-3-文章修改和删除功能与用户的修改删除同理" class="headerlink" title="7.3.3 文章修改和删除功能与用户的修改删除同理"></a>7.3.3 文章修改和删除功能与用户的修改删除同理</h4><br>

<h2 id="8-为mongoDB数据库添加账户"><a href="#8-为mongoDB数据库添加账户" class="headerlink" title="8.为mongoDB数据库添加账户"></a>8.为mongoDB数据库添加账户</h2><p>mongoDB数据库安装后<strong>默认不需要登录账户就可以访问修改数据库数据</strong>，安全性不足</p>
<p>为了提高安全性，给mongoDB数据库设置账户，mongoDB数据库有<strong>两种账户</strong>：</p>
<ul>
<li>超级管理员（roles:[‘root’]）</li>
<li>单个数据库管理员<ul>
<li>先创建超级管理员后才能创建单个数据库管理员</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\Windows\system32&gt; mongo</span><br><span class="line"></span><br><span class="line">&gt; use admin</span><br><span class="line"></span><br><span class="line">&gt; db.createUser(&#123;user:&#39;root&#39;,pwd:&#39;root&#39;,roles:[&#39;root&#39;]&#125;)</span><br><span class="line"></span><br><span class="line">&gt; use blog</span><br><span class="line"></span><br><span class="line">&gt; db.createUser(&#123;user:&#39;blogadmin&#39;,pwd:&#39;blogadmin&#39;,roles:[&#39;readWrite&#39;]&#125;)</span><br><span class="line"></span><br><span class="line">&gt; exit</span><br><span class="line"></span><br><span class="line">PS C:\Windows\system32&gt; net stop mongodb</span><br><span class="line"></span><br><span class="line">PS C:\Windows\system32&gt; mongod --remove</span><br><span class="line"></span><br><span class="line">PS C:\Windows\system32&gt; mongod --logpath&#x3D;&#39;C:\Mongodb\Server\4.4\log\mongod.log&#39; --dbpath&#x3D;&#39;C:\Mongodb\Server\4.4\data&#39; --install -auth</span><br><span class="line"></span><br><span class="line">PS C:\Windows\system32&gt; net start mongoDB</span><br><span class="line">MongoDB 服务正在启动 .</span><br><span class="line">MongoDB 服务已经启动成功。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>进入数据库下的admin数据库和blog数据库分别创建超级管理员和单个数据库管理员</p>
</li>
<li><p>退出卸载mongoDB服务</p>
</li>
<li><p>重新安装服务并指定日志文件和数据库文件存放位置</p>
<ul>
<li>使用-auth参数指定开启账户验证</li>
</ul>
</li>
<li><p>安装完后重启mongoDB服务</p>
</li>
<li><p>自此连接数据库时的connect方法第一个参数需要传递账号密码才能对数据库进行操作</p>
<ul>
<li><p>blog数据库账号密码都为<strong>blogadmin</strong></p>
</li>
<li><p>```js<br>//blog数据库的账号密码都为blogadmin<br>mongoose.connect(‘mongodb://blogadmin:blogadmin@localhost/blog’)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">## 9. 开发环境和生产环境</span><br><span class="line"></span><br><span class="line">- 开发环境：项目**开发人员使用的电脑上的环境**</span><br><span class="line">- 生产环境：项目放到真实的网站服务器上运行时，该**网站服务器主机的环境**</span><br><span class="line"></span><br><span class="line">项目放到**生产环境**运行时需要**对一些修改做出限制**，**不能在生产环境随意更改项目配置**</span><br><span class="line"></span><br><span class="line">项目在**开发环境**运行时可以将客户端请求项目时的测试结果打印在控制台方便开发人员调试</span><br><span class="line"></span><br><span class="line">所以项目运行时需要**区分运行的环境**进行不同的操作</span><br><span class="line"></span><br><span class="line">- 通过**系统变量NODE_ENV**的值来区别运行环境</span><br><span class="line">  - development：开发环境</span><br><span class="line">  - production：生产环境</span><br><span class="line"></span><br><span class="line">![新建系统变量NODE_ENV](&#x2F;images&#x2F;17-多人博客管理系统项目&#x2F;image-20210909200331019.png)</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">- 通过&#96;process.env.NODE_ENV&#96;查询系统变量中的NODE_ENV变量</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">&#x2F;&#x2F;检查运行环境</span><br><span class="line">if(process.env.NODE_ENV &#x3D;&#x3D; &#39;development&#39;)&#123;</span><br><span class="line">    console.log(&#39;开发环境&#39;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    console.log(&#39;生产环境&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<center>app.js检查项目运行环境</center>

<br>

<h3 id="9-1-开发环境将客户端请求打印在控制台（morgan模块）"><a href="#9-1-开发环境将客户端请求打印在控制台（morgan模块）" class="headerlink" title="9.1 开发环境将客户端请求打印在控制台（morgan模块）"></a>9.1 开发环境将客户端请求打印在控制台（morgan模块）</h3><p>使用<strong>第三方模块morgan</strong></p>
<ul>
<li>morgan是一个中间件函数</li>
<li>使用时app.use中间件<strong>放在上层避免其他中间件干扰</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检查运行环境</span></span><br><span class="line"><span class="keyword">if</span>(process.env.NODE_ENV == <span class="string">&#x27;development&#x27;</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开发环境&#x27;</span>);</span><br><span class="line">    <span class="comment">//dev是固定参数</span></span><br><span class="line">    <span class="comment">//morgan是中间件函数</span></span><br><span class="line">    <span class="comment">//将请求信息打印在控制台</span></span><br><span class="line">    app.use(morgan(<span class="string">&#x27;dev&#x27;</span>))</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;生产环境&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>app.js文件客户端请求打印</center>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210909203316334.png" alt="打印的请求信息"></p>
<br>

<h3 id="9-2-不同运行环境使用不同的配置信息（config模块）"><a href="#9-2-不同运行环境使用不同的配置信息（config模块）" class="headerlink" title="9.2 不同运行环境使用不同的配置信息（config模块）"></a>9.2 不同运行环境使用不同的配置信息（config模块）</h3><p><strong>config第三方模块</strong>：可以将不同运行环境下的配置信息抽离到单独的文件中，模块自动判断运行环境并应用相应的配置文件，节省了切换运行环境时手动更换配置信息的维护成本。</p>
<ul>
<li>安装conifg模块<ul>
<li><code>npm i config</code></li>
</ul>
</li>
<li>在项目根目录下创建config文件夹（名称固定）<ul>
<li>文件夹下创建三个json文件<ul>
<li>development.json：开发环境配置文件</li>
<li>production.json：生产环境配置文件</li>
<li>default.json：默认配置文件（在上面两个文件中都获取不到的配置信息在default.json文件中查找）</li>
</ul>
</li>
</ul>
</li>
<li>使用**config.get(‘配置信息名’)**可以获取相应环境下的配置信息</li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210909204804531.png" alt="获取开发环境下的title配置信息"></p>
<br>

<h4 id="9-2-1-将连接数据库信息抽离到开发环境配置文件中"><a href="#9-2-1-将连接数据库信息抽离到开发环境配置文件中" class="headerlink" title="9.2.1 将连接数据库信息抽离到开发环境配置文件中"></a>9.2.1 将连接数据库信息抽离到开发环境配置文件中</h4><p>数据库连接中的<strong>数据库账号密码、地址和端口等</strong>需要抽离到配置文件中方便开发人员修改</p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210909205952850.png" alt="数据库连接信息抽离到开发环境配置文件中"></p>
<br>

<ul>
<li>抽离到配置文件中后，通过<strong>config模块的get方法</strong>获取配置信息后连接数据库</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mongoose.connect(<span class="string">`mongodb://<span class="subst">$&#123;config.get(<span class="string">&#x27;db.user&#x27;</span>)&#125;</span>:<span class="subst">$&#123;config.get(<span class="string">&#x27;db.pwd&#x27;</span>)&#125;</span>@<span class="subst">$&#123;config.get(<span class="string">&#x27;db.host&#x27;</span>)&#125;</span>:<span class="subst">$&#123;config.get(<span class="string">&#x27;db.port&#x27;</span>)&#125;</span>/<span class="subst">$&#123;config.get(<span class="string">&#x27;db.dbname&#x27;</span>)&#125;</span>`</span>,&#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> ,<span class="attr">useUnifiedTopology</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h4 id="9-2-2-将敏感配置信息存储在环境变量中"><a href="#9-2-2-将敏感配置信息存储在环境变量中" class="headerlink" title="9.2.2 将敏感配置信息存储在环境变量中"></a>9.2.2 将敏感配置信息存储在环境变量中</h4><p>一些敏感的配置信息如数据库密码，不应该存放在项目文件中，以防止在分享代码时泄露造成安全隐患</p>
<p><strong>config模块可以在环境变量中提取配置信息</strong>，将<strong>敏感信息存放在系统变量</strong>中就可以防止密码泄露</p>
<ul>
<li>在项目根目录下config文件夹下创建custom-environment-variables.json文件（文件名固定）<ul>
<li>这个文件实现从系统变量中获取配置信息</li>
<li>将<strong>系统变量名</strong>作为这个文件中<strong>配置项属性的值</strong>即可</li>
</ul>
</li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210909211437982.png" alt="从系统变量中获取配置信息"></p>
<p><strong>注意：</strong></p>
<ul>
<li><strong>custom-environment-variables.json</strong>文件内部的db属性要与<strong>development.json</strong>文件中的db属性<strong>格式相同</strong></li>
<li>将<strong>development.json</strong>文件中的敏感配置信息pwd密码<strong>删除</strong>，通过<strong>custom-environment-variables.json</strong>文件<strong>获取系统变量app_pwd的值作为pwd配置项的值</strong></li>
<li>此时数据库连接时会获取系统变量app_pwd的值作为数据库密码，防止了分享代码时密码泄露的隐患</li>
</ul>
<br>

<br>

<br>

<h2 id="10-博客网站前台展示页面"><a href="#10-博客网站前台展示页面" class="headerlink" title="10. 博客网站前台展示页面"></a>10. 博客网站前台展示页面</h2><p>前面在 <strong>7.文章管理功能</strong> 开发完毕时，博客的所有管理页面就完成了</p>
<p>现在开始开发博客网站前台展示页面</p>
<h3 id="10-1-建立路由"><a href="#10-1-建立路由" class="headerlink" title="10.1 建立路由"></a>10.1 建立路由</h3><ul>
<li>博客前台文章总览页面（/home）</li>
<li>博客文章详情页面（/home/article）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> home = express.Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">//博客前台首页(文章总览)</span></span><br><span class="line">home.get(<span class="string">&#x27;/&#x27;</span>,<span class="built_in">require</span>(<span class="string">&#x27;./home/index&#x27;</span>))</span><br><span class="line"><span class="comment">//文章详情页面</span></span><br><span class="line">home.get(<span class="string">&#x27;/article&#x27;</span>,<span class="built_in">require</span>(<span class="string">&#x27;./home/article&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = home</span><br></pre></td></tr></table></figure>

<center>route/home.js</center>

<h3 id="10-2-模板文件处理"><a href="#10-2-模板文件处理" class="headerlink" title="10.2 模板文件处理"></a>10.2 模板文件处理</h3><ul>
<li>博客前台的两个模板文件 <strong>default.art</strong> 和 <strong>article.art</strong>文件存放在/views/home文件夹下</li>
<li>路由处理函数中渲染模板</li>
<li>对模板中的<strong>外链文件路径使用绝对路径</strong></li>
<li>提取两个模板文件的<strong>HTML骨架</strong></li>
<li>提取两个模板文件的<strong>公共部分</strong></li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210909222033037.png" alt="抽离骨架提取公共代码后的default.art文件"></p>
<br>

<h3 id="10-3-从数据库中查询文章并显示在用户总览页面"><a href="#10-3-从数据库中查询文章并显示在用户总览页面" class="headerlink" title="10.3 从数据库中查询文章并显示在用户总览页面"></a>10.3 从数据库中查询文章并显示在用户总览页面</h3><ul>
<li>查询文章数据时使用<strong>多集合级联查询</strong>和<strong>分页规则查询</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询文章</span></span><br><span class="line"><span class="comment">//多集合级联查询</span></span><br><span class="line"><span class="comment">//分页规则查询</span></span><br><span class="line"><span class="keyword">let</span> articles = <span class="keyword">await</span> pagination(Article).page(<span class="number">1</span>).size(<span class="number">4</span>).display(<span class="number">3</span>).populate(<span class="string">&#x27;author&#x27;</span>).exec()</span><br><span class="line"><span class="comment">//转换格式避免渲染冲突</span></span><br><span class="line"><span class="keyword">let</span> temp = <span class="built_in">JSON</span>.stringify(articles)</span><br><span class="line">articles = <span class="built_in">JSON</span>.parse(temp)</span><br><span class="line"></span><br><span class="line"><span class="comment">// res.send(articles)</span></span><br><span class="line">res.render(<span class="string">&#x27;home/default&#x27;</span>,&#123;</span><br><span class="line">    results:articles</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>index.js文件查询文章数据并渲染总览页面</center>

<br>

<ul>
<li><p>渲染default.art页面时<strong>注意：</strong></p>
<ul>
<li><p>每一个文章块<strong>li标签的class值为 fl 和 fr 交替出现</strong></p>
<ul>
<li>渲染时 遍历文章数据数组时 用遍历序号<strong>对2取余</strong>的值判断该文章模块class的取值</li>
<li>即偶数为fl，奇数为fr</li>
</ul>
</li>
<li><p>用户名为<strong>author.username</strong></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 遍历文章数组生成文章预览块 --&gt;</span></span><br><span class="line">		&#123;&#123;each results.records&#125;&#125;</span><br><span class="line">		<span class="comment">&lt;!-- 判断class值 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;&#123;&#123;$index % 2 == 0 ? &#x27;fl&#x27; : &#x27;fr&#x27;&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/home/article?id=&#123;&#123;@$value._id&#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;thumbnail&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;$value.cover&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;article-title&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/home/article?id=&#123;&#123;@$value._id&#125;&#125;&quot;</span>&gt;</span>&#123;&#123;$value.title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article-info&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;author&quot;</span>&gt;</span>&#123;&#123;$value.author.username&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;$value.publishDate&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;brief&quot;</span>&gt;</span></span><br><span class="line">					&#123;&#123;$value.content&#125;&#125;</span><br><span class="line">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		&#123;&#123;/each&#125;&#125;</span><br></pre></td></tr></table></figure>

<center>default.art模块遍历results拼接数据生成文章块</center>

<br>

<h4 id="10-3-1-文章数据格式处理"><a href="#10-3-1-文章数据格式处理" class="headerlink" title="10.3.1 文章数据格式处理"></a>10.3.1 文章数据格式处理</h4><p>文章信息在总览页面显示时要注意：</p>
<ul>
<li>日期以’yyyy-mm-dd‘的格式显示，用<strong>dateFormat第三方模块</strong>实现</li>
<li>文章内容节选需要<strong>去除HTML标签</strong>，<strong>原文输出</strong>，<strong>节选长度</strong><ul>
<li>去除HTML标签使用字符串的replace方法<ul>
<li>使用<strong>正则表达式匹配HTML标签</strong>并替换为空字符串（注意匹配时全局）</li>
<li><code>replace(/&lt;[^&gt;]+&gt;/g,&#39;&#39;)</code></li>
</ul>
</li>
<li>原文输出是为了<strong>防止将空格显示为&amp;nbsp</strong>等情况<ul>
<li>在数据变量前加@原文输出</li>
</ul>
</li>
<li>节选长度使用字符串substr方法自定义<ul>
<li><code>substr(0,100)</code>节选0到100的字符显示</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>

<h4 id="10-3-2-分页按钮条处理"><a href="#10-3-2-分页按钮条处理" class="headerlink" title="10.3.2 分页按钮条处理"></a>10.3.2 分页按钮条处理</h4><p><strong>文章总览页面</strong>的分页原理与<strong>文章列表页面</strong>一致</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 分页开始 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page w1100&quot;</span>&gt;</span></span><br><span class="line">		&#123;&#123;if results.page &gt; 1&#125;&#125;</span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/home/?page=&#123;&#123;results.page - 1&#125;&#125;&quot;</span>&gt;</span>上一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		&#123;&#123;/if&#125;&#125;</span><br><span class="line">        </span><br><span class="line">		&#123;&#123;each results.display&#125;&#125;</span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/home/?page=&#123;&#123;$value&#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&#123;&#123;results.page == $value ? &#x27;active&#x27; : &#x27;&#x27;&#125;&#125;&quot;</span>&gt;</span>&#123;&#123;$value&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		&#123;&#123;/each&#125;&#125;</span><br><span class="line">        </span><br><span class="line">		&#123;&#123;if results.page &lt; results.pages&#125;&#125;</span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/home/?page=&#123;&#123;results.page - 0 + 1&#125;&#125;&quot;</span>&gt;</span>下一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		&#123;&#123;/if&#125;&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 分页结束 --&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>页码按钮增加了选中状态，若<strong>页码按钮值等于当前页码</strong>，则设置class为active进行颜色标记</li>
</ul>
<br>

<h3 id="10-4-文章详情页面"><a href="#10-4-文章详情页面" class="headerlink" title="10.4 文章详情页面"></a>10.4 文章详情页面</h3><p>在文章总览页面的每个文章模块中加入超链接 将该文章的<strong>id值作为get参数传递</strong></p>
<p>服务器接受到请求后根据id查询文章信息并渲染文章详情页面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> (req,res) =&gt; &#123;</span><br><span class="line">    <span class="comment">//接受id参数</span></span><br><span class="line">    <span class="keyword">const</span> id = req.query.id</span><br><span class="line">    <span class="comment">//数据库中查询文章信息</span></span><br><span class="line">    <span class="comment">//多集合级联查询author</span></span><br><span class="line">    <span class="comment">//lean()转换格式</span></span><br><span class="line">    <span class="keyword">let</span> article = <span class="keyword">await</span> Article.findOne(&#123;<span class="attr">_id</span>:id&#125;).populate(<span class="string">&#x27;author&#x27;</span>).lean()</span><br><span class="line">    res.render(<span class="string">&#x27;home/article&#x27;</span>,&#123;</span><br><span class="line">        article:article</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>article.js文章详情页面请求处理</center>

<br>

<br>

<h2 id="11-普通用户和管理用户权限区分"><a href="#11-普通用户和管理用户权限区分" class="headerlink" title="11. 普通用户和管理用户权限区分"></a>11. 普通用户和管理用户权限区分</h2><p>通过用户信息中的<strong>role属性</strong>分别两种用户</p>
<ul>
<li>normal：普通用户</li>
<li>admin：管理员用户</li>
</ul>
<br>

<h3 id="11-1-登录页面处理函数修改"><a href="#11-1-登录页面处理函数修改" class="headerlink" title="11.1 登录页面处理函数修改"></a>11.1 登录页面处理函数修改</h3><p>两种用户登录后应该跳转到不同页面</p>
<ul>
<li>普通用户登录后跳转到<strong>前台首页</strong></li>
<li>管理用户登录后跳转到<strong>用户列表</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断用户角色</span></span><br><span class="line"><span class="keyword">if</span>(user.role == <span class="string">&#x27;normal&#x27;</span>)&#123;</span><br><span class="line">    <span class="comment">//普通用户登录后跳转到前台首页</span></span><br><span class="line">    res.redirect(<span class="string">&#x27;/home/&#x27;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//重定向到用户展示页面</span></span><br><span class="line">    res.redirect(<span class="string">&#x27;/admin/user&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>login.js区分用户修改登陆后显示的页面</center>

<br>

<h3 id="11-2-登录拦截处理函数修改"><a href="#11-2-登录拦截处理函数修改" class="headerlink" title="11.2 登录拦截处理函数修改"></a>11.2 登录拦截处理函数修改</h3><p>之前登录拦截处理函数<strong>只拦截没有登录的用户</strong>，登录后的任意用户都可以访问网站所有网页</p>
<p>现在<strong>普通用户登录后是没有权限访问博客管理页面的</strong></p>
<ul>
<li>将登录成功时将用户的<strong>角色信息存储在session对象中</strong><ul>
<li>修改login.js文件添加<code>req.session.role = user.role</code></li>
</ul>
</li>
<li>登录拦截处理时，当用户登录后，判断用户角色<ul>
<li>若为普通用户，则其<strong>访问/admin下的管理页面时重定向到前台首页</strong></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(req.session.role == <span class="string">&#x27;normal&#x27;</span>)&#123;</span><br><span class="line">    <span class="comment">//普通用户尝试访问管理页面时重定向回前台首页</span></span><br><span class="line">    <span class="keyword">return</span> res.redirect(<span class="string">&#x27;/home/&#x27;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//管理用户放行</span></span><br><span class="line">    next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>loginGuard.js修改后判断用户角色</center>

<br>

<br>

<h2 id="12-文章详情页评论功能"><a href="#12-文章详情页评论功能" class="headerlink" title="12. 文章详情页评论功能"></a>12. 文章详情页评论功能</h2><ul>
<li>model文件夹下创建comment.js文件<strong>创建评论集合</strong></li>
<li>提交评论表单时判断用户登陆状态</li>
<li>服务器端创建处理评论请求的路由</li>
<li>路由处理函数中接受评论信息</li>
<li>将评论信息存储在评论集合中</li>
<li>重定向回文章详情页，并将文章评论信息更新</li>
</ul>
<h3 id="12-1-创建评论集合"><a href="#12-1-创建评论集合" class="headerlink" title="12.1 创建评论集合"></a>12.1 创建评论集合</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建集合构造函数</span></span><br><span class="line"><span class="keyword">const</span> commentSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    aid:&#123;</span><br><span class="line">        type:mongoose.Schema.Types.ObjectId,</span><br><span class="line">        ref:<span class="string">&#x27;Article&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    uid:&#123;</span><br><span class="line">        type:mongoose.Schema.Types.ObjectId,</span><br><span class="line">        ref:<span class="string">&#x27;User&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    publishDate:&#123;</span><br><span class="line">        type:<span class="built_in">Date</span>,</span><br><span class="line">        <span class="keyword">default</span>:<span class="built_in">Date</span>.now</span><br><span class="line">    &#125;,</span><br><span class="line">    commentContent:&#123;</span><br><span class="line">        type:<span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="12-2-评论时判断用户状态"><a href="#12-2-评论时判断用户状态" class="headerlink" title="12.2 评论时判断用户状态"></a>12.2 评论时判断用户状态</h3><p>通过login.js文件在用户登录时添加的<strong>模板公共拼接数据userInfo来判断</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 判断用户登录状态 --&gt;</span></span><br><span class="line">&#123;&#123;if userInfo&#125;&#125;</span><br><span class="line">	<span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;comment-form&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">class</span>=<span class="string">&quot;comment&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;items&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">&#123;&#123;else&#125;&#125;</span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h4</span>&gt;</span>请登陆后再评论<span class="tag">&lt;/<span class="name">h4</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;&#123;/if&#125;&#125;</span><br></pre></td></tr></table></figure>

<center>artcle.art模板</center>

<p><strong>注意：</strong></p>
<ul>
<li>userInfo是模板公共拼接数据，当用户退出时，<strong>logout.js处理函数中需要清除userInfo变量</strong>，否则会导致bug</li>
<li>通过对userInfo置null来清除用户信息</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//登出后清除模板公共数据中的用户信息</span></span><br><span class="line">req.app.locals.userInfo = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="12-3-创建评论功能路由并处理请求"><a href="#12-3-创建评论功能路由并处理请求" class="headerlink" title="12.3 创建评论功能路由并处理请求"></a>12.3 创建评论功能路由并处理请求</h3><ul>
<li>在article.art模板中的<strong>表单设置请求地址等参数</strong></li>
<li>创建评论路由</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//评论提交路由</span></span><br><span class="line">home.post(<span class="string">&#x27;/comment&#x27;</span>,<span class="built_in">require</span>(<span class="string">&#x27;./home/comment&#x27;</span>))</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>处理评论请求函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取评论集合构造函数</span></span><br><span class="line"><span class="keyword">const</span> &#123; Comment &#125; = <span class="built_in">require</span>(<span class="string">&quot;../../model/comment&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> (req,res) =&gt; &#123;</span><br><span class="line">    <span class="comment">//获取评论表单参数</span></span><br><span class="line">    <span class="keyword">const</span> body = req.body</span><br><span class="line">    <span class="comment">//将评论添加到评论集合</span></span><br><span class="line">    <span class="keyword">await</span> Comment.create(body)</span><br><span class="line">    <span class="comment">//重定向回文章详情页</span></span><br><span class="line">    res.redirect(<span class="string">&#x27;/home/article?id=&#x27;</span> + body.aid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210910104323832.png" alt="数据库中comments集合中的评论数据"></p>
<br>

<h3 id="12-4-文章详情页显示对应的评论信息"><a href="#12-4-文章详情页显示对应的评论信息" class="headerlink" title="12.4 文章详情页显示对应的评论信息"></a>12.4 文章详情页显示对应的评论信息</h3><ul>
<li>文章详情页处理函数中，使用<strong>文章id</strong>查询在评论集合中查询出<strong>属于当前文章的所有评论</strong>，将其作为拼接数据渲染模板</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询当前文章的所有评论（使用文章id匹配）</span></span><br><span class="line"><span class="comment">//联合查询出用户信息（显示用户名等）</span></span><br><span class="line"><span class="keyword">let</span> comments = <span class="keyword">await</span> Comment.find(&#123;<span class="attr">aid</span>:id&#125;).populate(<span class="string">&#x27;uid&#x27;</span>).lean()</span><br><span class="line"></span><br><span class="line"><span class="comment">//渲染模板（评论数组作为拼接数据）</span></span><br><span class="line">res.render(<span class="string">&#x27;home/article&#x27;</span>,&#123;</span><br><span class="line">    article:article,</span><br><span class="line">    comments:comments</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>article.js处理函数</center>

<br>

<ul>
<li>遍历评论数组生成评论</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 生成评论 --&gt;</span></span><br><span class="line">&#123;&#123;each comments&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mb10&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article-info&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;author&quot;</span>&gt;</span>&#123;&#123;$value.uid.username&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;dateFormat($value.publishDate,&#x27;yyyy-mm-dd&#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;$value.uid.email&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;comment-content&quot;</span>&gt;</span></span><br><span class="line">		&#123;&#123;$value.content&#125;&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;&#123;/each&#125;&#125;</span><br></pre></td></tr></table></figure>

<center>article.art模板生成评论</center>

<br>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210910105508674.png" alt="显示评论"></p>
<br>

<br>

<h2 id="开发过程遇见的问题"><a href="#开发过程遇见的问题" class="headerlink" title="开发过程遇见的问题"></a>开发过程遇见的问题</h2><h3 id="1-连接mongoDB数据库时报错TextEncoder-is-not-defined"><a href="#1-连接mongoDB数据库时报错TextEncoder-is-not-defined" class="headerlink" title="1.连接mongoDB数据库时报错TextEncoder is not defined"></a>1.连接mongoDB数据库时报错TextEncoder is not defined</h3><p>低于<strong>v11版本</strong>的Node运行环境<strong>不支持TextEncoder方法</strong></p>
<p>将node版本升级到v11解决</p>
<p>进行项目开发时<strong>明确使用的环境版本非常重要</strong>，并且在开发中经常会遇到<strong>不同的项目使用不同版本的Node</strong>，此时频繁切换不同版本的Node非常麻烦。</p>
<p>使用<strong>nvm</strong> 来管理node版本</p>
<br>

<h3 id="2-多集合级联查询与render方法渲染模板冲突"><a href="#2-多集合级联查询与render方法渲染模板冲突" class="headerlink" title="2. 多集合级联查询与render方法渲染模板冲突"></a>2. 多集合级联查询与render方法渲染模板冲突</h3><p><strong>第一种解决办法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> articles = <span class="keyword">await</span> pagination(Article).page(page).size(<span class="number">2</span>).display(<span class="number">2</span>).populate(<span class="string">&#x27;author&#x27;</span>).exec()</span><br><span class="line">    <span class="comment">//将查询出的对象先转换为JSON字符串再转换为对象</span></span><br><span class="line">    <span class="comment">//将author字段值的类型由mongoose文档对象转换为普通对象避免渲染模板时的冲突</span></span><br><span class="line">    <span class="keyword">let</span> temp = <span class="built_in">JSON</span>.stringify(articles)</span><br><span class="line">    articles = <span class="built_in">JSON</span>.parse(temp)</span><br></pre></td></tr></table></figure>

<ul>
<li>将查询结果使用**JSON.stringify()和JSON.parse()**方法转换</li>
<li>将mongoose的<strong>文档格式对象</strong>转化为<strong>普通对象</strong></li>
</ul>
<p><strong>第二种解决办法</strong></p>
<ul>
<li>在populate()方法后链式调用lean()方法</li>
<li>原理与第一种方法相同</li>
<li>但是<strong>使用mongoose-sex-page模块进行分页时与lean()方法冲突</strong></li>
<li>故使用第一种方法</li>
</ul>
<br>

<h3 id="3-实现分页按钮条上一页-下一页按钮隐藏时的问题"><a href="#3-实现分页按钮条上一页-下一页按钮隐藏时的问题" class="headerlink" title="3. 实现分页按钮条上一页/下一页按钮隐藏时的问题"></a>3. 实现分页按钮条上一页/下一页按钮隐藏时的问题</h3><p>如果直接在标签内style属性中的<strong>display属性中使用模板标准语法进行条件表达式判断</strong></p>
<ul>
<li>此时当<strong>VSCODE语言模式选择为HTML时会提示错误</strong>，但项目仍能运行</li>
<li>将语言模式改为art时，不会报错，但文件中又不会提示代码补全</li>
<li>综上，<strong>使用模板标准语法的判断语句</strong>来实现上一页/下一页的隐藏显示</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;if results.page &lt; results.pages&#125;&#125;</span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/home/?page=&#123;&#123;results.page - 0 + 1&#125;&#125;&quot;</span>&gt;</span>下一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">&#123;&#123;/if&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当满足判断条件时，即当前页码小于最后一页时显示下一页，否则隐藏</li>
</ul>
<br>

<h3 id="4-模板中相对路径的问题"><a href="#4-模板中相对路径的问题" class="headerlink" title="4. 模板中相对路径的问题"></a>4. 模板中相对路径的问题</h3><p>模板中许多外链文件如css和js文件使用的都是<strong>相对路径</strong></p>
<p>模板中的相对路径是<strong>相对于浏览器地址栏的路径</strong></p>
<p>改为<strong>绝对路径</strong>可以避免因路由对象的虚拟路径而取不到静态资源文件的问题</p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210830203446873.png" alt="login.art模板中的相对路径"></p>
<br>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210830203543389.png" alt="相对路径相对于浏览器地址栏的路径"></p>
<p>此时浏览器将地址栏中的login当作文件，所以<strong>相对路径即相对于/abc</strong></p>
<ul>
<li><p>可见此时请求静态资源<code>base.css</code>的路径变为了<code>http://localhost/abc/css/base.css</code></p>
</li>
<li><p>而<code>base.css</code>静态资源文件并不在<code>/public/abc</code>文件夹下，并且public文件夹下也并不存在abc文件夹，所以无法获取静态资源文件</p>
</li>
<li><p>/abc只是admin路由对象匹配的<strong>虚拟路径</strong>，这个虚拟路径<strong>随时可以发生变化</strong></p>
</li>
<li><p>所以在模块中使用相对路径获取静态资源文件并不合适</p>
</li>
<li><p>改为使用<strong>绝对路径</strong>解决这个问题</p>
</li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210830204312384.png" alt="login.art模板中使用绝对路径"></p>
<p>在原先的相对路径前加上<code>&#39;/&#39;</code>使其变为绝对路径，同时根据静态资源文件的路径加上admin</p>
<p>此时请求静态资源文件的路径变为<code>http://localhost/admin/css/base.css</code></p>
<p>经过<code>express.static</code>方法处理后在<code>/public/admin/css/base.css</code>找到静态资源文件</p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210830205046226.png" alt="模板使用绝对路径获取静态资源文件"></p>
<br>

<h3 id="5-用户退出登录后在浏览器仍有cookie保存"><a href="#5-用户退出登录后在浏览器仍有cookie保存" class="headerlink" title="5. 用户退出登录后在浏览器仍有cookie保存"></a>5. 用户退出登录后在浏览器仍有cookie保存</h3><p><code>logout.js</code>处理函数中在用户退出登陆后<strong>删除服务端session和客户端cookie</strong></p>
<p>但是退出登陆后在浏览器仍然保存一个cookie</p>
<p><strong>原因为：</strong></p>
<p>express-session模块使用时默认会设置未初始化cookie</p>
<ul>
<li>即当客户端向服务端发送请求时就会存储一个cookie</li>
<li>这个cookie不存储用户的sessionId</li>
<li>我们希望用户退出登录时<strong>将这个未初始化cookie也删除</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建立session对象</span></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">    <span class="comment">//加密cookie</span></span><br><span class="line">    secret:<span class="string">&#x27;secret key&#x27;</span>,</span><br><span class="line">    <span class="comment">//默认不添加未初始化cookie</span></span><br><span class="line">    saveUninitialized:<span class="literal">false</span>,</span><br><span class="line">    cookie:&#123;</span><br><span class="line">        <span class="comment">//设置过期时间(毫秒)</span></span><br><span class="line">        maxAge:<span class="number">24</span> * <span class="number">60</span> *<span class="number">60</span> * <span class="number">1000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在app.js文件中建立session对象时<code>saveUninitialized:false</code></p>
</li>
<li><p>将这个属性置为false则不会自动添加未初始化cookie</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Mongodb数据库</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>04-解构赋值</title>
    <url>/2022/12/11/04-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><h2 id="数组结构"><a href="#数组结构" class="headerlink" title="数组结构"></a>数组结构</h2><p>变量数与数组长度相等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组解构</span></span><br><span class="line">        <span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//前面的let关键字代表这些变量用let关键字声明</span></span><br><span class="line">        <span class="keyword">let</span> [a,b,c]=arr;    <span class="comment">//左侧的[]中填入变量名  右侧为解构的数组</span></span><br><span class="line">        <span class="built_in">console</span>.log(a);     <span class="comment">//数组值被一 一对应赋值给左侧的变量</span></span><br><span class="line">        <span class="built_in">console</span>.log(b);</span><br><span class="line">        <span class="built_in">console</span>.log(c);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>变量数不等于数组长度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当变量数大于数组长度时 多余的变量值为undefined</span></span><br><span class="line">        <span class="built_in">console</span>.log(d);</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">        <span class="built_in">console</span>.log(f);</span><br><span class="line">        <span class="built_in">console</span>.log(g); <span class="comment">//undefined</span></span><br><span class="line"><span class="comment">//变量数小于数组长度时，只解构变量数目的元素</span></span><br><span class="line">        <span class="keyword">let</span> [h,y] = arr</span><br><span class="line">        <span class="built_in">console</span>.log(h); <span class="comment">//1</span></span><br><span class="line">        <span class="built_in">console</span>.log(y);	<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><ul>
<li>第一种解构方法<ul>
<li>被赋值的变量名与对象中的属性名和方法名<strong>相同</strong></li>
<li>被赋值变量的<strong>排列顺序没有影响</strong></li>
</ul>
</li>
<li>第二种解构方法<ul>
<li>可以自定义被赋值的变量名</li>
<li><code>let &#123;name:Myname,age:Myage,score:Myscore&#125;=obj;</code></li>
<li>使用一个键值对接受解构的属性和方法，键名用来匹配对象中的属性方法，<strong>键值则为变量的名称</strong></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">            name:<span class="string">&quot;andy&quot;</span>,</span><br><span class="line">            age:<span class="number">20</span>,</span><br><span class="line">            score:<span class="number">100</span>,</span><br><span class="line">            say:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象解构</span></span><br><span class="line">        <span class="comment">//与数组解构相似 </span></span><br><span class="line">        <span class="comment">//1.第一种解构方法(将属性和方法赋值给同名的变量)</span></span><br><span class="line">        <span class="comment">//被赋值的变量用&#123;&#125;包裹 被赋值的变量名需要与对象内属性名或方法名一致(用变量名匹配对象中的属性和方法)</span></span><br><span class="line">        <span class="keyword">let</span> &#123;name,age,score,say&#125;=obj;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">        <span class="built_in">console</span>.log(age);</span><br><span class="line">        <span class="built_in">console</span>.log(score);</span><br><span class="line">        say();  <span class="comment">//解构后 方法对应的函数赋值给变量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.第二种解构方法(被赋值的变量可以自定义名字)</span></span><br><span class="line">        <span class="comment">//&#123;name:Myname&#125; name用来匹配对象中的属性方法名 Myname是被赋值的变量</span></span><br><span class="line">        <span class="keyword">let</span> &#123;<span class="attr">name</span>:Myname,<span class="attr">age</span>:Myage,<span class="attr">score</span>:Myscore&#125;=obj;</span><br><span class="line">        <span class="built_in">console</span>.log(Myname);    <span class="comment">//:后是被赋值的变量名</span></span><br><span class="line">        <span class="built_in">console</span>.log(Myage);</span><br><span class="line">        <span class="built_in">console</span>.log(Myscore);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>02-es6新增类</title>
    <url>/2022/12/11/02-es6%E6%96%B0%E5%A2%9E%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="ES6新增类"><a href="#ES6新增类" class="headerlink" title="ES6新增类"></a>ES6新增类</h1><h2 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h2><p>ES6之前，JavaScript中没有类的概念</p>
<p>在ES5中使用构造函数近似实现类的功能</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建类 class &quot;类名&quot; &#123;constructor()&#123; &#125;&#125;</span></span><br><span class="line">        <span class="comment">//类名首字母大写 后不加()</span></span><br><span class="line">        <span class="comment">//constructor()&#123;&#125;函数是类默认构造函数 可以接受参数,给类的实例对象设置共有的属性方法，并返回实例对象</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="title">constructor</span>(<span class="params">name,age</span>)</span>&#123;  <span class="comment">//接受参数</span></span><br><span class="line">                <span class="built_in">this</span>.name=name,     <span class="comment">//设置类的共有属性</span></span><br><span class="line">                <span class="built_in">this</span>.age=age    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//类中的函数不需要function  多个函数之间不用逗号分隔</span></span><br><span class="line">            <span class="comment">//类的共有方法</span></span><br><span class="line">            <span class="function"><span class="title">sing</span>(<span class="params">song</span>)</span>&#123;             <span class="comment">//接受参数</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.name+<span class="string">&quot;:&quot;</span>+song);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//new 生成类的实例对象时会自动调用constructor()&#123;&#125;函数 若在定义类时没有写，也会自动生成并调用这个函数</span></span><br><span class="line">        <span class="keyword">var</span> ldh=<span class="keyword">new</span> Star(<span class="string">&quot;刘德华&quot;</span>,<span class="number">30</span>); <span class="comment">//创建类的实例对象   ()中传入参数  （）必须</span></span><br><span class="line">        <span class="keyword">var</span> zxy=<span class="keyword">new</span> Star(<span class="string">&quot;张学友&quot;</span>,<span class="number">31</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(ldh);</span><br><span class="line">        <span class="built_in">console</span>.log(zxy);</span><br><span class="line">        ldh.sing(<span class="string">&quot;冰雨&quot;</span>)  <span class="comment">//调用ldh实例对象的sing方法并传参  输出刘德华:冰雨</span></span><br><span class="line">        zxy.sing(<span class="string">&quot;李香兰&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建类时使用 : <strong>Class关键字</strong></p>
<ul>
<li>```js<br>Class ‘类名’{<pre><code>constructor(name)&#123;
    this.name = name
    this.log = function()&#123;&#125;
&#125;
sing(song)&#123;
    console.log(this.name:song)
&#125;
</code></pre>
}<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 类名**首字母大写**，后直接跟&#96;&#123;&#125;&#96;</span><br><span class="line">  - 使用&#96;constructor()&#123;&#125;&#96;定义类中的**共有属性或方法**</span><br><span class="line">  - 类中**共有方法也可以**直接在constructor后添加（不需要使用function操作符）</span><br><span class="line"></span><br><span class="line">- 调用**类创建实例对象**的方法**与构造函数一样**</span><br><span class="line"></span><br><span class="line">### 类中的this指向</span><br><span class="line"></span><br><span class="line">- constructor中的属性和方法指向**实例对象**</span><br><span class="line">- 类中函数的this指向**调用者**（实例对象）</span><br><span class="line"></span><br><span class="line">### 注意：</span><br><span class="line"></span><br><span class="line">- 类没有变量提升，必须先声明类，再创建类的实例对象</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">- constructor中可以进行事件绑定，使用类中定义的方法作为处理函数</span><br><span class="line">  - 此时处理方法因事件触发而被调用时，**处理方法中的this就指向绑定事件的元素**</span><br><span class="line">  - 此时在处理函数中想使用类中定义的共有属性，需要提前使用变量在constructor中保存this指向</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">class Star&#123;</span><br><span class="line">            constructor(x,y)&#123;</span><br><span class="line">                &#x2F;&#x2F;2.类里面的共有属性和方法一定要加this使用(指明是当前创建的实例对象的属性和方法)</span><br><span class="line">                this.name&#x3D;x;</span><br><span class="line">                console.log(this); &#x2F;&#x2F;this指向实例对象</span><br><span class="line">                that&#x3D;this;  &#x2F;&#x2F;保存constructor中this指向</span><br><span class="line">                this.age&#x3D;y;</span><br><span class="line">                this.btn&#x3D;document.querySelector(&quot;button&quot;);</span><br><span class="line">                this.btn.onclick&#x3D; this.say      &#x2F;&#x2F;调用当前类的say方法this.say进行事件绑定</span><br><span class="line">            &#125;</span><br><span class="line">            say()&#123;</span><br><span class="line">                console.log(this);	&#x2F;&#x2F;this指向调用者（事件绑定的元素或类的实例对象）</span><br><span class="line">                console.log(that.name); &#x2F;&#x2F;输出ldh的name属性 刘德华</span><br><span class="line">            &#125;</span><br><span class="line">            sing()&#123;</span><br><span class="line">                console.log(this);&#x2F;&#x2F;this指向当前实例对象 因为当前实例对象调用了该函数</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>此时在constructor中获取页面<strong>按钮元素进行事件绑定</strong>（使用say()函数作为处理函数）</p>
</li>
<li><p>类必须<strong>被调用</strong>（直接<code>new Star()</code>）或<strong>生成实例对象</strong>后，事件绑定才能生效</p>
</li>
</ul>
<br>

<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p><strong>extends 和 super</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="title">constructor</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.x=x;</span><br><span class="line">                <span class="built_in">this</span>.y=y;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">money</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.x+<span class="built_in">this</span>.y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;父亲&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.使用extends可以继承父类  子类 extends 父类</span></span><br><span class="line">        <span class="comment">//子类可以使用从父类继承来的属性和方法</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="title">constructor</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">super</span>(x,y);     <span class="comment">//super关键字调用了父类中的构造函数 将子类son的x,y传给父类</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.say()+<span class="string">&quot;儿子&quot;</span>;  <span class="comment">//super关键字访问调用父类的普通函数super.say()</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类继承时，<code>extends</code>和<code>super</code>通常一起使用</li>
<li>子类中可以使用父类方法，在子类中使用<code>super.‘父类方法’</code></li>
</ul>
<h3 id="继承时扩展自己的方法"><a href="#继承时扩展自己的方法" class="headerlink" title="继承时扩展自己的方法"></a>继承时扩展自己的方法</h3><p>在constructor中使用super方法后，仍可以进行自己的函数定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="title">constructor</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">super</span>(x,y);         <span class="comment">//super调用父类构造函数必须写在子类this.x=x等操作前面</span></span><br><span class="line">                <span class="built_in">this</span>.x=x;			<span class="comment">//接受参数</span></span><br><span class="line">                <span class="built_in">this</span>.y=y;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">sub</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.x-<span class="built_in">this</span>.y);<span class="comment">//Son类的方法sub</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>01-var/let/const区别</title>
    <url>/2022/12/11/01-var%E5%92%8Clet%E5%92%8Cconst%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="var和let和const区别"><a href="#var和let和const区别" class="headerlink" title="var和let和const区别"></a>var和let和const区别</h1><h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><p>var 声明变量 <strong>没有块级作用域</strong> 存在<strong>变量提升</strong>(将<strong>声明</strong>提升至函数或代码段顶部) 值可更改</p>
<h2 id="let-es6新增"><a href="#let-es6新增" class="headerlink" title="let es6新增"></a>let es6新增</h2><p>let 声明变量 <strong>有块级作用域</strong> <strong>不存在变量提升</strong>(只能先声明再使用) 值可更改</p>
<h2 id="const-es6新增"><a href="#const-es6新增" class="headerlink" title="const  es6新增"></a>const  es6新增</h2><p>const 声明<strong>常量</strong> <strong>有块级作用域</strong> <strong>不存在变量提升</strong>(只能先声明再使用) 值不可更改</p>
<p><strong>值不可更改</strong>(地址不可更改)：</p>
<ul>
<li>基本数据类型不可更改 </li>
<li><strong>引用数据类型可以修改内部数据结构</strong>(但不能直接修改整体引用数据，会导致地址变化)</li>
</ul>
<span id="more"></span>

<p>const常量声明时<strong>必须初始化</strong>，否则报错</p>
<p>当声明的量之后不希望变化（占用的内存地址不变） 最好使用const关键字声明(系统不需要监控常量 提升效率)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    b:<span class="string">&quot;yang&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">a.b = <span class="string">&#x27;xiao&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述代码对于const声明的引用数据类型a内部的值数据类型b进行修改是可行的(并没有修改对象a的地址)</p>
</li>
<li><p><img data-src="../images/01-var%E5%92%8Clet%E5%92%8Cconst%E5%8C%BA%E5%88%AB/image-20210918091704398.png" alt="image-20210918091704398"></p>
</li>
<li><p>输出发现a对象的b属性被修改</p>
</li>
</ul>
<br>

<h2 id="let和const在全局声明时不会在window对象中创建属性"><a href="#let和const在全局声明时不会在window对象中创建属性" class="headerlink" title="let和const在全局声明时不会在window对象中创建属性"></a>let和const在全局声明时不会在window对象中创建属性</h2><p>就像<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const#description"><code>const</code></a> 一样，<code>let</code>不会在全局声明时创建<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window"><code>window</code></a> 对象的属性。</p>
<p>**注意: ** Window 和 window是两个对象</p>
<ul>
<li>输出顶级对象的语句为<code>console.log(window)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">          <span class="keyword">let</span> num = <span class="number">1</span></span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="built_in">this</span>.num);</span><br><span class="line">          &#125;</span><br><span class="line">          a()	<span class="comment">//undefinded</span></span><br><span class="line">          <span class="built_in">console</span>.log(num);	<span class="comment">//1</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用a函数时，函数中的this确实指向window，<code>window.num</code>为<code>undefined</code></li>
<li>但是在全局作用域下直接输出num变量可以得到其值为1</li>
</ul>
]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>03-扩展运算符</title>
    <url>/2022/12/11/03-%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="扩展运算符-（…）"><a href="#扩展运算符-（…）" class="headerlink" title="扩展运算符 （…）"></a>扩展运算符 （…）</h1><h2 id="数组扩展运算符（…array）"><a href="#数组扩展运算符（…array）" class="headerlink" title="数组扩展运算符（…array）"></a>数组扩展运算符（…array）</h2><p>将<strong>数组</strong>或<strong>Set内置对象实例</strong>的元素拆分为以 <code>&#39;,&#39;</code> 分隔的<strong>参数序列(不是字符串)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(...arr);  <span class="comment">//相当于console.log(1,2,3,4);</span></span><br></pre></td></tr></table></figure>

<ul>
<li>输出为<code>1 2 3 4</code>，而不是字符串的<code>‘1,2,3,4’</code>(逗号被识别为分隔符)</li>
</ul>
<span id="more"></span>

<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>进行数组合并</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.第一种方法</span></span><br><span class="line">        <span class="keyword">let</span> arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">let</span> arr2=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];           <span class="comment">//...arr1就为1，2，3</span></span><br><span class="line">        <span class="keyword">let</span> arr3=[...arr1,...arr2];<span class="comment">//将arr1和arr2合并为数组1，2，3，4，5，6</span></span><br><span class="line">        <span class="built_in">console</span>.log(arr3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.第二种方法</span></span><br><span class="line">        <span class="keyword">let</span> arr4=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//push可以一次接收以&quot;，&quot;分隔的多个参数</span></span><br><span class="line">        arr4.push(...arr2); <span class="comment">//使用push方法将arr2数组追加到arr4数组中</span></span><br><span class="line">                            <span class="comment">//相当于arr4.push(4,5,6)</span></span><br><span class="line">        <span class="built_in">console</span>.log(arr4);  <span class="comment">//输出数组[1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>



<h2 id="对象扩展运算符（…obj）"><a href="#对象扩展运算符（…obj）" class="headerlink" title="对象扩展运算符（…obj）"></a>对象扩展运算符（…obj）</h2><p>返回属性键值对以<code>&#39;,&#39;</code>分隔的<strong>序列</strong>(非字符串)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.对象扩展运算符  ...obj</span></span><br><span class="line">        <span class="keyword">let</span> obj=&#123;</span><br><span class="line">            name:<span class="string">&quot;andy&quot;</span>,</span><br><span class="line">            age:<span class="number">20</span>,</span><br><span class="line">            score:<span class="number">100</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将obj对象浅拷贝给objClone对象 相当于使用Object.assign方法</span></span><br><span class="line">        <span class="comment">//对于引用数据类型 浅拷贝只拷贝引用(内存地址仍相同 修改引用数据类型会导致两个对象都被修改)</span></span><br><span class="line">        <span class="keyword">let</span> objClone=&#123;...obj&#125;;</span><br><span class="line">        <span class="built_in">console</span>.log(objClone);</span><br><span class="line">        <span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>let objClone=&#123;...obj&#125;;</code>将<strong>obj对象</strong>浅拷贝给<strong>objClone对象</strong><ul>
<li>相当于调用Object.assign方法进行<strong>浅拷贝</strong>（引用数据只拷贝地址引用）</li>
</ul>
</li>
</ul>
<h2 id="扩展运算符可以用作函数参数的接受"><a href="#扩展运算符可以用作函数参数的接受" class="headerlink" title="扩展运算符可以用作函数参数的接受"></a>扩展运算符可以用作函数参数的接受</h2><ul>
<li>作为函数的形参接受所有或剩余的参数为<strong>数组</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...a可以作为形参接收所有的实参为一个数组</span></span><br><span class="line">        <span class="comment">//若剩余参数前有一个正常的形参 则剩余参数...a会接受剩下的实参</span></span><br><span class="line">        <span class="keyword">const</span> sum=<span class="function">(<span class="params">...a</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> total=<span class="number">0</span>;</span><br><span class="line">            a.forEach(<span class="function"><span class="params">value</span>=&gt;</span>total+=value); <span class="comment">//遍历数组a求和</span></span><br><span class="line">            <span class="keyword">return</span> total;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(sum(<span class="number">10</span>,<span class="number">20</span>));    <span class="comment">//a=[10,20]</span></span><br><span class="line">        <span class="built_in">console</span>.log(sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>));  <span class="comment">//a=[1,2,3,4]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>数组解构中使用扩展运算符</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组解构</span></span><br><span class="line">        <span class="keyword">let</span> arr=[<span class="string">&quot;andy&quot;</span>,<span class="string">&quot;red&quot;</span>,<span class="string">&quot;white&quot;</span>];</span><br><span class="line">        <span class="keyword">let</span> [a,...b]=arr;   <span class="comment">//数组中第一个元素赋值给a 剩余所有元素形成一个数组赋值给b</span></span><br><span class="line">        <span class="built_in">console</span>.log(a); <span class="comment">//输出字符串andy</span></span><br><span class="line">        <span class="built_in">console</span>.log(b); <span class="comment">//输出数组[&quot;red&quot;,&quot;white&quot;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对象解构中使用扩展运算符</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对象解构 </span></span><br><span class="line">        <span class="comment">//注意变量名与属性方法名的匹配</span></span><br><span class="line">        <span class="comment">//剩余参数的变量名可以自定义</span></span><br><span class="line">        <span class="keyword">let</span> obj=&#123;</span><br><span class="line">            name:<span class="string">&quot;black&quot;</span>,</span><br><span class="line">            age:<span class="number">20</span>,</span><br><span class="line">            score:<span class="number">100</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> &#123;name,...c&#125;=obj;</span><br><span class="line">        <span class="built_in">console</span>.log(name);        <span class="comment">//输出name属性的值black</span></span><br><span class="line">        <span class="built_in">console</span>.log(c);        <span class="comment">//输出一个包含obj中剩余属性和方法的新对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li>c 为一个接受obj中剩余属性和方法的<strong>新对象</strong>(与obj地址不同)</li>
</ul>
]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>05-箭头函数</title>
    <url>/2022/12/11/05-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><ul>
<li><p>ES6中新增的定义函数的方式</p>
<ul>
<li><p><code>(&quot;形参&quot;)=&gt;&#123;&quot;函数体&quot;&#125;</code></p>
</li>
<li><p><code>const fn = () =&gt; &#123;&#125;</code>就相当于定义了一个名为fn的箭头函数</p>
</li>
</ul>
</li>
<li><p>当箭头函数只有一个参数时，可以省略<code>()</code></p>
</li>
<li><p>当箭头函数体中<strong>只有一句代码</strong>且<strong>代码执行结果就为返回值</strong>时，可以省略<code>return</code>和函数体的<code>&#123;&#125;</code></p>
</li>
</ul>
<p>箭头函数没有<strong>arguments参数数组</strong></p>
<p>没有<strong>prototype</strong></p>
<p><strong>this指向跟随上下文</strong></p>
<span id="more"></span>

<br>

<h2 id="箭头函数的this指向"><a href="#箭头函数的this指向" class="headerlink" title="箭头函数的this指向"></a>箭头函数的this指向</h2><p>箭头函数的this指向<strong>跟随箭头函数定义位置上下文的this指向</strong></p>
<p>原则上箭头函数没有this指向，只是为了解释原型链而模拟箭头函数的this</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;<span class="attr">name</span>:<span class="string">&quot;andy&quot;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn3=a.call(obj);    <span class="comment">//输出obj对象</span></span><br><span class="line">fn3(); 					<span class="comment">//输出obj对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li>箭头函数作为a函数的返回值，此时<strong>箭头函数this指向与a函数中的this指向相同</strong>（跟随上下文中this指向）</li>
<li>当a的this指向被call方法改变为obj时，箭头函数的this也跟着改变为obj对象</li>
</ul>
<br>

<p>当箭头函数位于全局环境下时，this指向为<strong>window对象</strong></p>
]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>06-es6新增set内置对象</title>
    <url>/2022/12/11/06-ES6%E6%96%B0%E5%A2%9Eset%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="Set内置对象"><a href="#Set内置对象" class="headerlink" title="Set内置对象"></a>Set内置对象</h1><p>Set是ES6扩展内置对象</p>
<p><strong>Set数据结构类似于数组，但是成员都是唯一的，没有重复值</strong></p>
<p><code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p>
<ul>
<li><p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。</p>
</li>
<li><p>Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），</p>
<p>主要的区别是<span style="color:red">向 Set 加入值时认为<code>NaN</code>等于自身</span>，而精确相等运算符认为<code>NaN</code>不等于自身。</p>
</li>
</ul>
<span id="more"></span>

<h2 id="使用Set数据结构进行数组去重"><a href="#使用Set数据结构进行数组去重" class="headerlink" title="使用Set数据结构进行数组去重"></a>使用Set数据结构进行数组去重</h2><p><strong>实现数组去重</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s=<span class="keyword">new</span> <span class="built_in">Set</span>();  <span class="comment">//创建一个新的set数据结构</span></span><br><span class="line">      <span class="comment">//Set()可以接收一个数组来初始化Set的实例对象并返回</span></span><br><span class="line">      <span class="keyword">const</span> s1=<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line">      <span class="built_in">console</span>.log(s1);    <span class="comment">//包含四个唯一的元素 1，2，3，4(删去重复的一个1)</span></span><br><span class="line"><span class="keyword">var</span> arr2=[...s1];   <span class="comment">//使用扩展运算符转换为数组后发现数组中多余的1被去除</span></span><br><span class="line">      <span class="built_in">console</span>.log(arr2);</span><br></pre></td></tr></table></figure>

<ul>
<li>Set对象不同于数组，Set集合没有索引，其实例<strong>不能使用数组下标的方式获取值</strong></li>
<li>可以<strong>使用扩展运算符将Set实例转换为数组</strong>（先转换为以<code>&#39;,&#39;</code>分隔的序列，然后用数组包裹）</li>
</ul>
<h2 id="Set对象实例的方法"><a href="#Set对象实例的方法" class="headerlink" title="Set对象实例的方法"></a>Set对象实例的方法</h2><p>查看<code>Set.prototype</code>上的方法</p>
<p><img data-src="../images/06-ES6%E6%96%B0%E5%A2%9Eset%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/image-20210918124053810.png" alt="image-20210918124053810"></p>
<ul>
<li>根据原型链的成员查找机制，Set对象实例可以使用<code>Set.prototype</code>上的方法</li>
</ul>
<h3 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h3><p>向Set实例对象<strong>添加一个值</strong>，返回实例对象本身</p>
<p>可以链式多次调用add方法添加多个值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s3=<span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="built_in">console</span>.log(s3.add(<span class="string">&quot;a&quot;</span>).add(<span class="string">&quot;b&quot;</span>));<span class="comment">//添加两个值&quot;a&quot;和&quot;b&quot;;并输出包含两个元素的set实例</span></span><br><span class="line"><span class="built_in">console</span>.log([...s3]);   <span class="comment">//转换为数组输出</span></span><br></pre></td></tr></table></figure>

<h3 id="delete方法"><a href="#delete方法" class="headerlink" title="delete方法"></a>delete方法</h3><p>删除实例中<strong>指定值</strong>，返回一个布尔值，表示删除是否成功</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//delete()方法</span></span><br><span class="line">        <span class="comment">//删除某个值，返回一个布尔值，表示删除是否成功</span></span><br><span class="line">		<span class="comment">//s3 = &#x27;a&#x27;,&#x27;b&#x27;</span></span><br><span class="line">        <span class="built_in">console</span>.log(s3.delete(<span class="string">&quot;a&quot;</span>));    <span class="comment">//删除set实例s3中的元素&quot;a&quot; 成功返回true</span></span><br><span class="line">        <span class="built_in">console</span>.log(s3.delete(<span class="string">&quot;c&quot;</span>));    <span class="comment">//删除set实例s3中的元素&quot;c&quot; 没有&quot;c&quot;删除失败返回false</span></span><br><span class="line">        <span class="built_in">console</span>.log(s3);    <span class="comment">//s3中只剩&quot;b&quot;一个元素</span></span><br></pre></td></tr></table></figure>

<h3 id="has方法"><a href="#has方法" class="headerlink" title="has方法"></a>has方法</h3><p>检查参数是否为实例中的成员</p>
<p>返回Boolean值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//has()方法</span></span><br><span class="line">        <span class="comment">//返回一个布尔值，表示该参数是否是set实例的成员</span></span><br><span class="line">        <span class="built_in">console</span>.log(s3.has(<span class="string">&quot;b&quot;</span>));   <span class="comment">//&quot;b&quot;是s3中的成员 返回true</span></span><br></pre></td></tr></table></figure>

<h3 id="clear方法"><a href="#clear方法" class="headerlink" title="clear方法"></a>clear方法</h3><p>清除实例中所有成员</p>
<p>无返回值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//clear()方法</span></span><br><span class="line">        <span class="comment">//清除实例中的所有成员 没有返回值</span></span><br><span class="line">        s3.clear();</span><br><span class="line">        <span class="built_in">console</span>.log(s3);    <span class="comment">//输出空的set实例s3</span></span><br></pre></td></tr></table></figure>

<h3 id="forEach方法"><a href="#forEach方法" class="headerlink" title="forEach方法"></a>forEach方法</h3><p>Set对象的forEach方法与数组的forEach对象使用方法相同</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//set数据结构的遍历</span></span><br><span class="line">        <span class="comment">//set和数组一样拥有遍历方法forEach() 使用方法也一致</span></span><br><span class="line">        <span class="keyword">var</span> s=<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>]);</span><br><span class="line">        s.forEach(<span class="function"><span class="params">value</span>=&gt;</span><span class="built_in">console</span>.log(value));<span class="comment">//遍历输出s中每个成员的值</span></span><br></pre></td></tr></table></figure>

<p>Set对象的<strong>forEach方法</strong>接受两个参数</p>
<ul>
<li>第一个是对其中每个元素调用的<strong>回调函数</strong><ul>
<li>回调函数接受三个参数<ul>
<li>value：当前正在被操作的元素</li>
<li>key：因为Set集合没有索引，所以value和key两个参数<strong>均表示当前正在被操作的元素</strong></li>
<li>set：调用当前forEach方法的Set实例对象</li>
</ul>
</li>
</ul>
</li>
<li>第二个是thisArg，规定回调函数执行过程中的this指向（可选）</li>
</ul>
]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>07-Map内置对象</title>
    <url>/2022/12/11/07-Map%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="Map内置对象"><a href="#Map内置对象" class="headerlink" title="Map内置对象"></a>Map内置对象</h1><p><strong><code>Map</code></strong> 对象保存键值对，并且能够记住键的原始插入顺序。**任何值(对象或者原始值)**都可以作为一个键或一个值。</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Map对象</span></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keyString = <span class="string">&#x27;a string&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加键值对</span></span><br><span class="line">myMap.set(keyString, <span class="string">&quot;和键&#x27;a string&#x27;关联的值&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据键名获取键值</span></span><br><span class="line">myMap.get(keyString);    <span class="comment">// &quot;和键&#x27;a string&#x27;关联的值&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用for...of迭代Map对象</span></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>);</span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> myMap) &#123;	<span class="comment">//迭代键值对</span></span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将会显示两个log。一个是&quot;0 = zero&quot;另一个是&quot;1 = one&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> myMap.keys()) &#123;		<span class="comment">//迭代键名</span></span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将会显示两个log。 一个是 &quot;0&quot; 另一个是 &quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myMap.values()) &#123;	<span class="comment">//迭代键值</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将会显示两个log。 一个是 &quot;zero&quot; 另一个是 &quot;one&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>NaN</code><strong>作为Map对象的键名</strong>时，认为<code>NaN === NaN</code> 返回true</li>
</ul>
]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>02-v-if和v-show区别</title>
    <url>/2022/12/11/02-v-if%E5%92%8Cv-show%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="headerlink" title="v-if和v-show的区别"></a>v-if和v-show的区别</h1><ul>
<li><p>v-if分支结构仅当<strong>满足条件时才会渲染</strong></p>
</li>
<li><p>v-show无论取值<strong>都会渲染</strong>，当v-show取值为false时<strong>隐藏元素</strong></p>
</li>
<li><p>一般来说，<strong>v-if有更高的切换开销</strong>，而<strong>v-show有更高的初始渲染开销</strong></p>
</li>
</ul>
<p>如果需要非常频繁地切换，则使用v-show较好;</p>
<p>如果在运行时条件不太可能改变，则使用v-if 较好。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>04-Vue的diff算法</title>
    <url>/2022/12/11/04-Vue%E7%9A%84diff%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Vue的diff算法"><a href="#Vue的diff算法" class="headerlink" title="Vue的diff算法"></a>Vue的diff算法</h1><p>由于在浏览器中直接操作DOM的代价 <strong>“较大”</strong>，所以Vue引入了<strong>虚拟DOM</strong>，虚拟DOM是对真实DOM的一种抽象描述。</p>
<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><ul>
<li><p>修改真实DOM可能会引起<strong>重绘和回流</strong>，过多的回流会影响性能</p>
</li>
<li><p>更改虚拟DOM<strong>不会进行重绘和回流操作</strong></p>
</li>
<li><p>虚拟DOM就是把真实DOM<strong>转换为Javascript代码</strong></p>
<ul>
<li><img data-src="/images/04-Vue%E7%9A%84diff%E7%AE%97%E6%B3%95/image-20211013101156133.png" alt="image-20211013101156133"></li>
</ul>
</li>
<li><p>虚拟DOM进行多次更改后，一次性比较并<u>修改真实DOM（修改发生了变化的局部DOM）</u> ,在真实DOM中进行重绘和回流，<span style='color:red;'>以此来减少频繁修改真实DOM引起的大量重绘和回流，提高性能</span></p>
</li>
</ul>
<span id="more"></span>

<p>使用虚拟DOM是为了<strong>减少大面积重绘回流造成的性能问题</strong>，不同框架不一定需要虚拟DOM，关键看框架是否会<strong>频繁引发大面积DOM修改</strong></p>
<br>

<h2 id="diff算法的目的"><a href="#diff算法的目的" class="headerlink" title="diff算法的目的"></a>diff算法的目的</h2><p>上述虚拟DOM可以<strong>修改发生变化的局部真实DOM</strong>，以此提高性能</p>
<p><span style='color:red;'>而找到发生变化的局部真实DOM并进行修改就是diff算法的工作</span></p>
<br>

<h2 id="vue的diff算法流程"><a href="#vue的diff算法流程" class="headerlink" title="vue的diff算法流程"></a>vue的diff算法流程</h2><p>只比较同级的节点，</p>
<ul>
<li>若找不到与新节点类型相同的节点，则<strong>插入一个新节点</strong>，</li>
<li>若有相同类型的节点则进行节点属性的<strong>更新</strong>，</li>
<li>最后<strong>删除</strong>新节点列表中不包含的旧节点</li>
</ul>
<p><img data-src="/images/04-Vue%E7%9A%84diff%E7%AE%97%E6%B3%95/image-20211013110525079.png" alt="image-20211013110525079"></p>
<p>旧节点数组Before</p>
<ul>
<li><strong>哨兵节点</strong><code>oldStartIdx和oldEndIdx</code>分别标识数组的头尾</li>
<li><strong>数组中对应哨兵节点下标的值</strong><code>oldStartVnode = Before[oldStartIdx]</code>，oldEndVnode同理<u>（上图Before数组的newEndVnode错误，应改为oldEndVnode）</u></li>
</ul>
<p>新节点数组After</p>
<br>

<p><span style='color:red;'>对于新旧节点数组进行循环判断（7个判断,满足一个则进入下次循环），直到<code>oldStartIdx &gt; oldEndIdx</code>或者<code>newStartIdx &gt; newEndIdx</code></span></p>
<ul>
<li><code>oldStartIdx &gt; oldEndIdx</code><ul>
<li>旧数组先循环完毕，将新数组剩余节点<strong>添加到真实DOM中</strong></li>
</ul>
</li>
<li>``newStartIdx &gt; newEndIdx`<ul>
<li>新数组先循环完毕，将旧数组剩余节点<strong>在真实DOM中删除</strong></li>
</ul>
</li>
</ul>
<h3 id="1-进行优先判断"><a href="#1-进行优先判断" class="headerlink" title="1. 进行优先判断"></a>1. 进行优先判断</h3><p>通过一系列的<strong>优先判断条件</strong>，</p>
<ul>
<li>一方面对于一些不需要做移动的DOM可以得到快速处理，</li>
<li>另一方面使待处理节点变少，缩小了后续操作的处理范围，可以更快地完成同级节点的对比。</li>
</ul>
<h4 id="判断1："><a href="#判断1：" class="headerlink" title="判断1："></a>判断1：</h4><p><strong>（旧数组头节点是否为空）</strong></p>
<p>​    <code>oldStartVnode</code>是否为空，若为true<strong>则<code>oldStartIdx</code>向后移动</strong>，继续下一个节点的判断</p>
<p>​    <strong>跳过旧数组中的空节点</strong></p>
<h4 id="判断2："><a href="#判断2：" class="headerlink" title="判断2："></a>判断2：</h4><p><strong>（旧数组尾节点是否为空）</strong></p>
<p>​    <code>oldEndVnode</code>是否为空，若为true<strong>则<code>oldEndIdx</code>向前移动。</strong></p>
<p>​    <strong>跳过旧数组中的空节点</strong></p>
<h4 id="判断3："><a href="#判断3：" class="headerlink" title="判断3："></a>判断3：</h4><p>​    <strong>（旧数组和新数组头节点是否同类）</strong></p>
<p>​    使用 <code>sameVnode</code>判断before和after未判断的<strong>头节点是否为相同类型节点</strong>，若为true，则按照上面思路说的，对相同类型节点进行节点的<strong>属性的更新</strong>并修改哨兵位置（<strong>oldStartIdx和newStartIdx均后移一位</strong>）。</p>
<h4 id="判断4："><a href="#判断4：" class="headerlink" title="判断4："></a>判断4：</h4><p>​    <strong>（旧数组和新数组尾节点是否同类）</strong></p>
<p>​    使用上一步相同的方法对<code>oldEndVnode和newEndVnode</code>（before和after数组的尾节点）进行判断</p>
<p>​    若为同类型节点，则节点属性更新并修改哨兵位置（<strong>oldEndIdx和newEndIdx均前移一位</strong>）</p>
<h4 id="判断5："><a href="#判断5：" class="headerlink" title="判断5："></a>判断5：</h4><p>​    （<strong>旧数组头节点</strong>和<strong>新数组尾节点</strong>是否同类）</p>
<p>​    使用<code>sameVNode</code>判断<strong>旧列表的头节点和新列表的尾节点</strong>是否同类，<code>sameVnode(oldStartVnode, newEndVnode)</code>，</p>
<p>若为true，更新同类节点，若该节点可以移动，则在真实DOM中<strong>将oldStartVnode放到真实DOM列表的最后。</strong></p>
<p><strong>oldStartIdx向后移动，newEndIdx向前移动</strong></p>
<h4 id="判断6："><a href="#判断6：" class="headerlink" title="判断6："></a>判断6：</h4><p>​    （<strong>旧数组尾节点</strong>和<strong>新数组头节点</strong>是否同类）</p>
<p>​    使用sameVnode比较<strong>旧列表的尾节点和新列表的头节点</strong>，若为true，和上面一样，更新相同节点，将oldEndVnode放到真实节点列表的最开始。</p>
<p><strong>oldEndIdx向前移动，newStartIdx向后移动</strong></p>
<br>

<h3 id="2-优先判断之后"><a href="#2-优先判断之后" class="headerlink" title="2. 优先判断之后"></a>2. 优先判断之后</h3><p>若上述六个判断都不满足，则进入最后的判断7</p>
<h4 id="判断7："><a href="#判断7：" class="headerlink" title="判断7："></a>判断7：</h4><p>​    （<strong>新数组头节点</strong>是否存在于<strong>旧数组头尾节点之间</strong>）</p>
<ul>
<li><p>若存在，<strong>则在真实DOM中将该节点插入到oldStartVnode节点之前</strong>，并<strong>将旧数组中找到的节点置undefined</strong>，<strong>将newStartIdx后移一位</strong></p>
</li>
<li><p>若不存在，<strong>则在真实DOM中新建该节点并插入到oldStartVnode节点之前</strong>，<strong>将newStartIdx后移一位</strong></p>
</li>
</ul>
<p><a href="https://blog.csdn.net/qq_34179086/article/details/88086427">例子解析：</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>03-组件data必须为函数</title>
    <url>/2022/12/11/03-%E7%BB%84%E4%BB%B6%E7%9A%84data%E5%BF%85%E9%A1%BB%E4%B8%BA%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="组件的data必须为函数"><a href="#组件的data必须为函数" class="headerlink" title="组件的data必须为函数"></a>组件的data必须为函数</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;button-counter&#x27;</span>,&#123;</span><br><span class="line">            data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    count:<span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            template:<span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">                        &lt;button @click=&#x27;count++&#x27;&gt;点击了&#123;&#123;count&#125;&#125;次&lt;/button&gt;</span></span><br><span class="line"><span class="string">                      &lt;/div&gt;`</span>,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                add:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.count++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>注册组件时data为一个函数，<strong>函数的返回值为一个对象，对象中定义模板数据</strong></p>
<p>一个组件可以有多个实例，如果data直接使用对象，则一个实例修改数据，其他实例也会一起被修改</p>
<ul>
<li>data为函数时，每个实例可以维护一份<strong>被返回对象的独立的拷贝</strong>，不会互相影响</li>
</ul>
<h1 id="根组件的data可以为对象"><a href="#根组件的data可以为对象" class="headerlink" title="根组件的data可以为对象"></a>根组件的data可以为对象</h1><p>因为<strong>根组件一般只有一个实例</strong>，无所谓多个实例互相影响</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>01-Vue双向数据绑定</title>
    <url>/2022/12/11/01-Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h1 id="Vue双向数据绑定"><a href="#Vue双向数据绑定" class="headerlink" title="Vue双向数据绑定"></a>Vue双向数据绑定</h1><p>vue数据双向绑定是通过<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式来实现的</p>
<p>输出一个Vue实例data中的数据查看</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">            data:&#123;</span><br><span class="line">                obj:&#123;</span><br><span class="line">                    name:<span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            mounted:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">//输出obj</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/01-Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/image-20210927225915544.png" alt="image-20210927225915544"></p>
<center>图一</center>

<p>图一红框的<strong>get和set方法</strong>即为 <strong>获取name属性</strong>和<strong>给name属性赋值</strong>时调用的方法</p>
<p>Vue是通过<span style='color:red'><code>Object.defineProperty()</code></span><strong>重写对象属性的get和set方法</strong>来实现数据劫持的</p>
<span id="more"></span>

<h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a><code>Object.defineProperty()</code></h2><ul>
<li><p><code>Object.defineProperty(Obj,&#39;property&#39;,descriptor) </code></p>
<ul>
<li><p>作用：给对象<strong>添加属性</strong>或者<strong>修改属性</strong></p>
</li>
<li><p>参数：</p>
<ul>
<li><strong>obj：</strong>操作的对象</li>
<li><strong>property：</strong>操作的对象属性</li>
<li><strong>descriptor：</strong>定义或修改的<strong>属性描述符</strong>(对象)。(分为<strong>数据描述符</strong>和<strong>存取描述符</strong>，只能是两者其中之一)<ul>
<li>数据/存取描述符<strong>共用键值</strong>：<ul>
<li><code>configurable</code>：属性能否被删除，描述符能否被改变 (默认值false)</li>
<li><code>enumerable</code>：该属性是否可枚举 (默认值false)</li>
</ul>
</li>
<li>数据描述符<strong>可选键值</strong>：<ul>
<li><code>value</code>：定义属性的值 (默认值<code>undefined</code>)</li>
<li><code>writable</code>：属性值是否可修改 (默认值false)</li>
</ul>
</li>
<li>存取描述符<strong>可选键值</strong>：<ul>
<li><code>get(函数)</code>：获取属性值时被调用，<strong>返回值作为属性的值</strong> (默认值<code>undefined</code>)</li>
<li><code>set(函数)</code>：属性被赋值时调用，参数为**属性的新值 **(默认值<code>undefined</code>)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Book = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="comment">//修改Book对象的name属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Book, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">//给name赋值时调用</span></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        name = value;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;你取了一个书名叫做&#x27;</span> + value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//获取name属性时调用</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;《&#x27;</span> + name + <span class="string">&#x27;》&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Book.name = <span class="string">&#x27;vue权威指南&#x27;</span>;  <span class="comment">// 你取了一个书名叫做vue权威指南</span></span><br><span class="line"><span class="built_in">console</span>.log(Book.name);  <span class="comment">// 《vue权威指南》</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对Book对象的name属性的get和set方法进行重写</li>
<li>在get和set方法中可以实现Vue的双向数据绑定（修改数据时影响视图，修改视图时影响数据）</li>
</ul>
<h2 id="修改视图时更新模板数据"><a href="#修改视图时更新模板数据" class="headerlink" title="修改视图时更新模板数据"></a>修改视图时更新模板数据</h2><p>可以通过<strong>事件监听</strong>的方式在<strong>用户修改视图时</strong>修改对应模板数据</p>
<p>例如：文本框输入时触发input事件，然后<strong>获取输入域内容</strong>后<strong>更新Vue实例中的数据</strong></p>
<h2 id="修改模板数据更新视图"><a href="#修改模板数据更新视图" class="headerlink" title="修改模板数据更新视图"></a>修改模板数据更新视图</h2><p>通过<code>Object.defineProperty( )</code>对属性设置一个set函数</p>
<p>当<strong>模板数据被修改时会触发对应属性的set方法</strong></p>
<p>在<strong>set方法中定义更新视图的操作</strong>即可实现模板数据修改更新视图</p>
<br>

<ul>
<li><p>用<code>Object.defineProperty()</code>重写set和get方法<strong>实现数据劫持</strong></p>
</li>
<li><p>如果<strong>数据发生变化了即触发set方法，相当于消息发布，此时就需要</strong>告诉订阅者Watcher看是否需要更新。</p>
</li>
<li><p>此时当<strong>订阅者Watcher接收到相应数据的变化</strong>，就会<strong>执行对应的更新函数，从而更新视图</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>07-Vue.use和Vue.prototype.$xx的区别</title>
    <url>/2022/12/11/07-Vue.use%E5%92%8CVue.prototype.$xx%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="Vue-use和Vue-prototype-xx的区别"><a href="#Vue-use和Vue-prototype-xx的区别" class="headerlink" title="Vue.use和Vue.prototype.$xx的区别"></a>Vue.use和Vue.prototype.$xx的区别</h1><p>在开发Vue项目的过程中</p>
<p>发现<code>Element-UI</code>组件库的一些组件在挂载时使用<code>Vue.use(&#39;组件名&#39;)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Button)</span><br></pre></td></tr></table></figure>

<br>

<p>而<code>Element-UI</code>的<strong>message组件</strong>和<strong>axios等模块</strong></p>
<p>在挂载时使用<code>Vue.prototype.$xxx = ’组件/模块‘</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$message = Message</span><br><span class="line"></span><br><span class="line">Vue.prototype.$http = axios</span><br></pre></td></tr></table></figure>

<br>

<span id="more"></span>

<h2 id="Vue-use"><a href="#Vue-use" class="headerlink" title="Vue.use"></a>Vue.use</h2><p>Vue.use的使用与Vue插件注册有关</p>
<p>官方对于Vue.js的说明如下：</p>
<ul>
<li><p>通过全局方法 <code>Vue.use()</code> 使用插件</p>
</li>
<li><p>Vue.use 会<strong>自动阻止多次注册相同插件</strong></p>
</li>
<li><p>它需要在你<strong>调用 new Vue() 启动应用之前</strong>完成</p>
</li>
<li><p><code>Vue.use()</code> 方法至少传入一个参数，该参数类型必须是 <strong>Object</strong> 或 <strong>Function</strong>，如果是 Object 那么这个 Object 需要定义一个 <strong>install</strong> 方法，如果是 Function 那么这个函数就被当做 install 方法。在 <code>Vue.use()</code> 执行时 install 会默认执行，当 install 执行时第一个参数就是 Vue，其他参数是 <code>Vue.use()</code> 执行时传入的其他参数。</p>
</li>
</ul>
<h2 id="Vue-prototype-xxx"><a href="#Vue-prototype-xxx" class="headerlink" title="Vue.prototype.$xxx"></a>Vue.prototype.$xxx</h2><p>一些本来不是专门为Vue开发的插件中<strong>没有install方法</strong></p>
<p>使用这些插件时</p>
<ul>
<li>可以将其<strong>挂载在Vue的原型对象上</strong>，这样所有Vue实例都可以通过原型链查找的方式使用插件</li>
<li>也可以<strong>手动将这些插件的业务逻辑封装在install方法</strong>中，达到使用<code>Vue.use</code>注册插件的目的</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>05-Vue的生命周期</title>
    <url>/2022/12/11/05-Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h1><p><strong>生命周期</strong>：Vue实例<strong>从创建到销毁的过程</strong>称为Vue实例的生命周期</p>
<p><strong>Vue实例的生命周期钩子函数</strong>：是Vue实例<strong>生命周期执行到特定时刻</strong>调用的函数，可以在生命周期<strong>特定时期进行操作</strong>。</p>
<ul>
<li>生命周期钩子函数的<strong>this指向本实例</strong>，钩子函数不要使用箭头函数（会导致this指向混乱）</li>
<li>生命周期钩子函数为<strong>配置对象的属性</strong>，与data和methods等同级</li>
</ul>
<span id="more"></span>

<p><img data-src="/images/05-Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/20171026193015421.png" alt="20171026193015421"></p>
<h2 id="beforeCreate钩子函数"><a href="#beforeCreate钩子函数" class="headerlink" title="beforeCreate钩子函数"></a>beforeCreate钩子函数</h2><p>在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置<strong>之前</strong>被调用。</p>
<p>在beforeCreate钩子函数中不能使用<strong>模板数据(data)、方法(method)和侦听器(watch)</strong></p>
<p>因为此时尚未进行<strong>数据观测</strong>和<strong>方法、事件配置</strong></p>
<br>

<h2 id="created钩子函数"><a href="#created钩子函数" class="headerlink" title="created钩子函数"></a>created钩子函数</h2><p>实例已经<strong>创建完成之后</strong>被调用。</p>
<p>在这一步，实例已完成以下的配置：</p>
<ul>
<li>数据观测(data observer)，属性和方法的运算， </li>
<li>watch/event 事件回调。</li>
</ul>
<br>

<p>然而，<strong>挂载阶段还没开始</strong>，$el 属性目前不可见。<br><strong>主要应用：</strong>调用数据，调用方法，调用异步函数</p>
<p>created钩子可以:</p>
<ul>
<li>获取Vue的data，调用Vue方法，</li>
<li>获取原本HTML上的直接加载出来的DOM，</li>
<li>但是<strong>无法获取到通过挂载模板生成的DOM</strong>（例如：v-for循环遍历list数组生成li标签）</li>
</ul>
<br>

<h2 id="beforeMount钩子函数"><a href="#beforeMount钩子函数" class="headerlink" title="beforeMount钩子函数"></a>beforeMount钩子函数</h2><p>在<strong>挂载开始之前</strong>被调用：此时模板中生成的html元素还没有挂载到真实DOM上</p>
<p>例如通过v-for生成的html还没有被挂载到页面上</p>
<br>

<h2 id="mounted钩子函数"><a href="#mounted钩子函数" class="headerlink" title="mounted钩子函数"></a>mounted钩子函数</h2><p>el 被新创建的 <code>vm.$el</code> 替换，并<strong>挂载到真实DOM元素上去之后</strong>调用该钩子。<br><strong>有初始值的DOM渲染，例如我们的初始数据list,渲染出来的li，在这里可以获取</strong></p>
<p>挂载：将Vue实例<strong>template字段生成的html代码</strong>挂载到<strong>el属性所指示的真实DOM元素下</strong></p>
<br>

<h2 id="beforeUpdate钩子函数"><a href="#beforeUpdate钩子函数" class="headerlink" title="beforeUpdate钩子函数"></a>beforeUpdate钩子函数</h2><p><strong>数据更新</strong>时调用，发生在<strong>虚拟 DOM 重新渲染和打补丁之前</strong>。</p>
<p>你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程</p>
<p><strong>更改Vue的任何数据</strong>均会触发beforeUpdate钩子</p>
<br>

<h2 id="updated钩子函数"><a href="#updated钩子函数" class="headerlink" title="updated钩子函数"></a>updated钩子函数</h2><p><strong>虚拟 DOM 重新渲染和打补丁之后</strong>会调用该钩子。<br>当这个钩子被调用时，<strong>组件 DOM 已经更新</strong>，所以你现在可以执行依赖于 DOM 的操作。</p>
<p>然而在大多数情况下，你应该避免在此期间更改状态，因为这<strong>可能会导致更新无限循环</strong>。</p>
<br>

<h2 id="beforeDestroy钩子"><a href="#beforeDestroy钩子" class="headerlink" title="beforeDestroy钩子"></a>beforeDestroy钩子</h2><p>实例销毁之前调用。在这一步，实例仍然完全可用。</p>
<br>

<h2 id="destroyed钩子"><a href="#destroyed钩子" class="headerlink" title="destroyed钩子"></a>destroyed钩子</h2><p>Vue 实例销毁后调用。<strong>调用之后</strong>，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</p>
<p>注意：<strong>在<code>destroyed</code>钩子函数内部仍可以访问实例的属性和方法</strong>，该函数执行完毕则销毁实例，结束生命周期</p>
<br>

<h2 id="Vue实例挂载的两种方式"><a href="#Vue实例挂载的两种方式" class="headerlink" title="Vue实例挂载的两种方式"></a>Vue实例挂载的两种方式</h2><ol>
<li><p>在vue实例配置对象中使用el属性指定挂载位置</p>
</li>
<li><p>配置对象没有设置el时，可以使用实例方法<code>$mount()</code>进行挂载</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data:&#123;</span><br><span class="line">            message:<span class="string">&#x27;this is mseeage&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>若$mount()方法没有传递参数，则Vue根实例将被渲染为<strong>document文档之外的元素</strong></p>
<ul>
<li><p>需要手动使用<code>DOM API</code>将其添加到document中</p>
</li>
<li><p>```js<br>var vm = new Vue({</p>
<pre><code>data:&#123;&#125;,
methods:&#123;&#125;,
components:&#123;
    &#39;child-com&#39;:child,
&#125;,
template:`&lt;div&gt;&lt;child-com&gt;&lt;/child-com&gt;&lt;/div&gt;`,
</code></pre>
<p>}).$mount()<br>document.getElementById(‘app’).appendChild(vm.$el)    //手动添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - &#96;vm.$el&#96;即为vue实例(vm)使用的根DOM元素</span><br><span class="line"></span><br><span class="line">  - &#96;$mount&#96;方法返回vue实例，可以链式调用其他方法</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">## Vue父子组件生命周期的执行顺序</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;button id&#x3D;&quot;des&quot;&gt;销毁组件&lt;&#x2F;button&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        window.onload &#x3D; function()&#123;</span><br><span class="line">            var child &#x3D; &#123;</span><br><span class="line">                data()&#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        childmsg:&#39;this is childComponents&#39;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                template:&#96;&lt;div&gt;&#123;&#123;childmsg&#125;&#125;&lt;&#x2F;div&gt;&#96;,</span><br><span class="line">                beforeCreate() &#123;</span><br><span class="line">                    console.log(&#39;child_beforeCreate&#39;);</span><br><span class="line">                &#125;,</span><br><span class="line">                created() &#123;</span><br><span class="line">                    console.log(&#39;child_created&#39;);</span><br><span class="line">                &#125;,</span><br><span class="line">                beforeMount() &#123;</span><br><span class="line">                    console.log(&#39;child_beforeMount&#39;);</span><br><span class="line">                &#125;,</span><br><span class="line">                mounted() &#123;</span><br><span class="line">                    console.log(&#39;child_mounted&#39;);</span><br><span class="line">                &#125;,</span><br><span class="line">                beforeDestroy() &#123;</span><br><span class="line">                    console.log(&#39;child_beforeDestroy&#39;);</span><br><span class="line">                &#125;,</span><br><span class="line">                destroyed() &#123;</span><br><span class="line">                    console.log(&#39;child_destroyed&#39;);</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            var vm &#x3D; new Vue(&#123;</span><br><span class="line">                el:&#39;#app&#39;,</span><br><span class="line">                data:&#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;,</span><br><span class="line">                methods:&#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;,</span><br><span class="line">                components:&#123;</span><br><span class="line">                    &#39;child-com&#39;:child,</span><br><span class="line">                &#125;,</span><br><span class="line">                template:&#96;&lt;div&gt;&lt;child-com&gt;&lt;&#x2F;child-com&gt;&lt;&#x2F;div&gt;&#96;,</span><br><span class="line">                beforeCreate() &#123;</span><br><span class="line">                    console.log(&#39;father_beforeCreate&#39;);</span><br><span class="line">                &#125;,</span><br><span class="line">                created() &#123;</span><br><span class="line">                    console.log(&#39;father_created&#39;);</span><br><span class="line">                &#125;,</span><br><span class="line">                beforeMount() &#123;</span><br><span class="line">                    console.log(&#39;father_beforeMount&#39;);</span><br><span class="line">                &#125;,</span><br><span class="line">                mounted() &#123;</span><br><span class="line">                    console.log(&#39;father_mounted&#39;);</span><br><span class="line">                &#125;,</span><br><span class="line">                beforeDestroy() &#123;</span><br><span class="line">                    console.log(&#39;father_beforeDestroy&#39;);</span><br><span class="line">                &#125;,</span><br><span class="line">                destroyed() &#123;</span><br><span class="line">                    console.log(&#39;father_destroyed&#39;);</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;销毁按钮</span><br><span class="line">            var des &#x3D; document.querySelector(&#39;#des&#39;)</span><br><span class="line">            des.onclick&#x3D;function()&#123;</span><br><span class="line">                vm.$destroy()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><img data-src="/images/05-Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20211106213936247.png" alt="image-20211106213936247"></p>
<ul>
<li>所有的其他<strong>Vue组件</strong>都作为Vue<strong>根实例(vm)的子组件</strong></li>
</ul>
<p><img data-src="/images/05-Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20211106214039601.png" alt="image-20211106214039601"></p>
<ul>
<li>子组件更新</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">子beforeUpdate -&gt; 子updated</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/05-Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/image-20211106214130466.png" alt="image-20211106214130466"></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>06-Vue的watch和computed的区别</title>
    <url>/2022/12/11/06-Vue%E7%9A%84watch%E5%92%8Ccomputed%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="Vue的watch和computed的区别"><a href="#Vue的watch和computed的区别" class="headerlink" title="Vue的watch和computed的区别"></a>Vue的watch和computed的区别</h1><h2 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed"></a>计算属性computed</h2><ol>
<li><strong>支持缓存</strong>，只有依赖数据发生改变，才会重新进行计算</li>
<li><strong>不支持异步</strong>，当computed内有异步操作时无效，无法监听数据的变化</li>
<li>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</li>
<li>应用场景：如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</li>
<li>如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</li>
</ol>
<span id="more"></span>

<h2 id="监听器属性watch"><a href="#监听器属性watch" class="headerlink" title="监听器属性watch"></a>监听器属性watch</h2><ol>
<li><p><strong>不支持缓存</strong>，数据变，直接会触发相应的操作</p>
</li>
<li><p>watch<strong>支持异步</strong></p>
</li>
<li><p>监听的函数接收两个参数，<strong>第一个参数是最新的值</strong>；<strong>第二个参数是变化之前的值</strong></p>
</li>
<li><p>当一个属性发生变化时，需要执行对应的操作；一对多</p>
</li>
<li><p>监听数据必须是<strong>data中声明过</strong>或者<strong>父组件传递过来的props中的数据</strong>，当数据变化时，触发其他操作，watch监听的属性对象可以设置两个参数：</p>
<ul>
<li><p><strong>immediate：组件加载立即触发回调函数执行</strong></p>
</li>
<li><p>```js<br>watch: {<br>  firstName: {</p>
<pre><code>handler(newName, oldName) &#123;
  this.fullName = newName + &#39; &#39; + this.lastName;
&#125;,
// 代表在wacth里声明了firstName这个方法之后立即执行handler方法
immediate: true
</code></pre>
<p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **deep: 深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，修改obj里面任何一个属性都会触发这个监听器里的 回调函数**</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;js</span><br><span class="line">  watch: &#123;</span><br><span class="line">    obj: &#123;</span><br><span class="line">      handler(newName, oldName) &#123;</span><br><span class="line">        console.log(&#39;obj.a changed&#39;);</span><br><span class="line">      &#125;,</span><br><span class="line">      immediate: true,</span><br><span class="line">      deep: true	&#x2F;&#x2F;对象内部的每一个属性都会被监听</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用<strong>字符串的形式</strong>监听对象中的某一个属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  <span class="comment">//vue解析遇到obj对象中的a属性，给a属性添加监听器</span></span><br><span class="line">  <span class="string">&#x27;obj.a&#x27;</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">handler</span>(<span class="params">newName, oldName</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;obj.a changed&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    immediate: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>01-浏览器地址栏输入URL回车会发生什么</title>
    <url>/2021/04/13/01-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%9B%9E%E8%BD%A6%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h1 id="浏览器地址栏输入URL回车会发生什么"><a href="#浏览器地址栏输入URL回车会发生什么" class="headerlink" title="浏览器地址栏输入URL回车会发生什么"></a>浏览器地址栏输入URL回车会发生什么</h1><ol>
<li><strong>寻找URL中域名对应的ip地址</strong>，先寻找缓存，若缓存中没有则查询DNS服务器解析DNS得到ip地址</li>
<li>浏览器根据ip地址和相应的端口号，<strong>构造HTTP请求</strong></li>
<li><strong>将HTTP请求发送到服务器</strong>，将HTTP请求封装在TCP包中，建立TCP连接后依次经过 传输层 网络层 数据链路层 物理层 到达服务器端，服务器对接受的数据进行层层解封后获得HTTP请求</li>
<li>服务器解析HTTP请求后<strong>将响应数据（HTML文档）返回给客户端浏览器</strong>，传输过程即为第三步的逆过程</li>
<li>浏览器根据这个html文档来<strong>构建DOM树</strong>，在dom树的构建过程中如果<strong>遇到JS脚本和外部JS连接</strong>，则会<strong>停止构建DOM树来执行和下载相应的代码，这会造成阻塞</strong>，所以建议js文件和代码放在html代码后面</li>
<li>之后根据外部样式，内部样式，内联样式构建一个<strong>CSS对象模型树CSSOM树</strong>，<strong>构建完成后和DOM树合并为渲染树</strong>，这里主要做的是排除非视觉节点，比如script，meta标签和排除display为none的节点，</li>
<li>之后进行布局，布局主要是确定各个元素的位置和尺寸，</li>
<li>最后是渲染页面，因为html文件中会含有图片，视频，音频等资源，在解析DOM的过程中，遇到这些都会进行并行下载，浏览器对每个域的<strong>并行下载数量有一定的限制</strong>，一般是4-6个</li>
</ol>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>02-Web性能优化</title>
    <url>/2021/04/13/02-Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Web性能优化"><a href="#Web性能优化" class="headerlink" title="Web性能优化"></a>Web性能优化</h1><ul>
<li><p><strong>降低请求量</strong>：</p>
<ul>
<li>合并资源，降低HTTP请求数量</li>
<li>删除不必要的注释和重复代码，降低文件大小</li>
<li>使用GZIP压缩文件，降低响应文件大小</li>
</ul>
</li>
<li><p><strong>使用缓存</strong>：</p>
</li>
<li><p>HTTP协议缓存请求，<strong>请求未变更的资源时直接调用缓存</strong></p>
</li>
<li><p>本地存储localStorage</p>
</li>
<li><p><strong>渲染</strong>：优化加载顺序（js文件放在html代码后面等）</p>
</li>
</ul>
<span id="more"></span>

<h1 id="页面卡顿的原因"><a href="#页面卡顿的原因" class="headerlink" title="页面卡顿的原因"></a>页面卡顿的原因</h1><p>从<strong>渲染机制</strong>和<strong>运行</strong>上可以分为两大类，分别是：</p>
<ul>
<li><strong>渲染不及时，页面掉帧</strong></li>
<li><strong>网页内存占用过高，运行卡顿</strong></li>
</ul>
<h2 id="1-渲染不及时导致掉帧卡顿"><a href="#1-渲染不及时导致掉帧卡顿" class="headerlink" title="1. 渲染不及时导致掉帧卡顿"></a>1. 渲染不及时导致掉帧卡顿</h2><p>页面的流畅性通过<strong>刷新率</strong>（FPS）进行衡量</p>
<h3 id="刷新率FPS"><a href="#刷新率FPS" class="headerlink" title="刷新率FPS"></a>刷新率FPS</h3><p>FPS 表示的是<strong>每秒钟画面更新次数</strong>，当今大多数设备的屏幕刷新率都是<strong>60次/秒</strong>（60帧）</p>
<p>浏览器渲染动画或页面的每一帧的速率，也需要跟设备的刷新率保持一致</p>
<p>浏览器对每一帧画面的渲染工作需要在<strong>16ms</strong>（1000ms/60）之内完成，也就是说每一次渲染都要在 16ms才不会掉帧。</p>
<p>假如第一次渲染耗时20ms，则渲染的结果不会在第一帧16ms时显示，而是会在第二帧即32ms时显示，这样就会掉帧</p>
<p><strong>在这16ms 内浏览器要完成的工作有：</strong></p>
<ul>
<li>脚本执行（JavaScript）：脚本造成了需要重绘的改动，比如增删 DOM、请求动画等</li>
<li>样式计算（CSS Object Model）：级联地生成每个节点的生效样式。</li>
<li>布局（Layout）：计算布局，执行渲染算法</li>
<li>重绘（Paint）：各层分别进行绘制（比如 3D 动画）</li>
<li>合成（Composite）：将位图发送给合成线程。</li>
</ul>
<p><span style="color:red">当js脚本执行耗时太长时，会导致渲染不及时，出现页面卡顿。</span></p>
<p><span style="color:red">页面回流和重绘较多时，浏览器在一帧时间要进行多次布局（Layout），可能导致渲染不及时而卡顿</span></p>
<h2 id="2-内存占用过大导致页面卡顿"><a href="#2-内存占用过大导致页面卡顿" class="headerlink" title="2. 内存占用过大导致页面卡顿"></a>2. 内存占用过大导致页面卡顿</h2><p>浏览器有自己的一套垃圾回收机制，但<strong>某些情况下的变量不会被回收</strong>，这些变量占用的内存越来越大就会导致<strong>内存泄漏而卡顿</strong></p>
<p><span style="color:red">闭包引起的内存泄露</span></p>
<p><span style="color:red">被遗忘的定时器<code>SetInterval</code>（每隔设定的时间执行回调）</span></p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>04-浏览器缓存机制</title>
    <url>/2021/04/13/04-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h1><p>缓存分为两种：<strong>强制缓存</strong> 和 <strong>协商缓存</strong></p>
<p>强缓存：是否使用缓存<strong>不经过</strong>远端服务器判断</p>
<p>协商缓存：是否使用缓存<strong>要经过</strong>服务器判断</p>
<h2 id="1-缓存过程分析"><a href="#1-缓存过程分析" class="headerlink" title="1. 缓存过程分析"></a>1. 缓存过程分析</h2><p><img data-src="/images/04-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/image-20211013171655206.png" alt="image-20211013171655206"></p>
<p>1、浏览器每次发起请求，都会<strong>先在浏览器缓存中查找该请求的 结果缓存</strong>，根据查找结果判断下一步操作(向服务器发请求或直接使用缓存)</p>
<p>2、浏览器每次拿到返回的请求结果都会<strong>根据响应头中的缓存规则字段 判断怎样进行缓存</strong></p>
<span id="more"></span>

<br>

<h2 id="2-缓存策略的定义"><a href="#2-缓存策略的定义" class="headerlink" title="2. 缓存策略的定义"></a>2. 缓存策略的定义</h2><h3 id="2-1-cache-control字段"><a href="#2-1-cache-control字段" class="headerlink" title="2.1 cache-control字段"></a>2.1 cache-control字段</h3><p>通过该字段的值<strong>定义缓存策略</strong></p>
<p><span style="color:red;">HTTP/1.1定义的通用消息字段头(请求、响应均可使用)</span></p>
<p>如果在<code>Cache-Control</code>响应头设置了 “max-age” 或者 “s-max-age” 指令，那么 <code>Expires</code> 头会被忽略。</p>
<p><code>cache-control</code>多条指令通过<code>,</code>分隔，例如：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Cache-Control: private,max-age=3600</span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-缓存请求指令"><a href="#2-1-1-缓存请求指令" class="headerlink" title="2.1.1 缓存请求指令"></a>2.1.1 缓存请求指令</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Cache-Control: max-age=&lt;seconds&gt;</span><br><span class="line">Cache-Control: max-stale[=&lt;seconds&gt;]</span><br><span class="line">Cache-Control: min-fresh=&lt;seconds&gt;</span><br><span class="line">Cache-control: no-cache</span><br><span class="line">Cache-control: no-store</span><br><span class="line">Cache-control: no-transform</span><br><span class="line">Cache-control: only-if-cached</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-缓存响应指令"><a href="#2-1-2-缓存响应指令" class="headerlink" title="2.1.2 缓存响应指令"></a>2.1.2 缓存响应指令</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Cache-control: must-revalidate</span><br><span class="line">Cache-control: no-cache</span><br><span class="line">Cache-control: no-store</span><br><span class="line">Cache-control: no-transform</span><br><span class="line">Cache-control: public</span><br><span class="line">Cache-control: private</span><br><span class="line">Cache-control: proxy-revalidate</span><br><span class="line">Cache-Control: max-age=&lt;seconds&gt;</span><br><span class="line">Cache-control: s-maxage=&lt;seconds&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-Cache-Control常用指令"><a href="#2-1-3-Cache-Control常用指令" class="headerlink" title="2.1.3 Cache-Control常用指令"></a>2.1.3 Cache-Control常用指令</h4><p>（1）<strong>public</strong>：所有内容都将被缓存（客户端和代理服务器都可缓存，验证信息如账户密码可以被代理服务器缓存）</p>
<p>（2）<strong>private</strong>：所有内容只有客户端可以缓存，<strong>Cache-Control的默认取值</strong></p>
<p>（3）<strong>no-cache</strong>：客户端缓存内容，但是是否使用缓存则需要<strong>经过协商缓存来验证决定</strong></p>
<p>（4）<strong>no-store</strong>：所有内容都不会被缓存，即<strong>不使用任何缓存</strong></p>
<p>（5）**max-age=xxx **：缓存内容将在xxx秒后失效</p>
<br>

<h2 id="3-强制缓存"><a href="#3-强制缓存" class="headerlink" title="3. 强制缓存"></a>3. 强制缓存</h2><p>在<strong>浏览器缓存</strong>查找结果后决定是否使用缓存<span style="color:red;">(不经过服务器判断)</span></p>
<h3 id="3-1-Expires字段"><a href="#3-1-Expires字段" class="headerlink" title="3.1 Expires字段"></a>3.1 Expires字段</h3><p><strong>响应头</strong>字段，<strong>HTTP/1.0</strong>控制网页缓存的字段</p>
<ul>
<li><p>值：表示绝对时间的GMT格式的时间字符串</p>
</li>
<li><p>含义：该响应结果缓存的<strong>过期时间</strong></p>
</li>
<li><p><strong>缺点：</strong>expires控制缓存的原理是使用<strong>客户端的时间</strong>与<strong>expires</strong>时间值做对比，如果客户端与服务端的时间由于某些原因（时区不同；客户端和服务端有一方的时间不准确）发生误差，那么缓存直接失效</p>
</li>
</ul>
<p>强缓存中，浏览器发起请求，将<strong>当前时间</strong>与<strong>上次请求返回的Expires字段值</strong>进行比较，从而判断该请求的结果缓存是否失效。</p>
<ul>
<li>缓存失效：向服务器发起请求。</li>
<li>缓存有效：直接使用浏览器缓存的数据，不会向服务器发起请求。</li>
</ul>
<p><span style="color:red">注意：</span>如果在<code>Cache-Control</code>响应头设置了 “max-age” 或者 “s-max-age” 指令，那么 <code>Expires</code> 头会被忽略。</p>
<br>

<h2 id="4-协商缓存"><a href="#4-协商缓存" class="headerlink" title="4. 协商缓存"></a>4. 协商缓存</h2><p>浏览器携带<strong>缓存标识</strong>向服务器发起请求，<span style="color:red">经服务器判断后</span>，根据服务器响应决定是否使用缓存。</p>
<h3 id="4-1-协商缓存的两种情况"><a href="#4-1-协商缓存的两种情况" class="headerlink" title="4.1 协商缓存的两种情况"></a>4.1 协商缓存的两种情况</h3><ol>
<li><p>携带缓存标识的HTTP请求发送到服务器，服务器资源<strong>文件没有更新</strong>，返回<strong>状态码304，使用浏览器缓存</strong></p>
</li>
<li><p>…，服务器资源<strong>文件更新</strong>，缓存失效，返回<strong>新的请求结果和200状态码</strong></p>
</li>
</ol>
<p><img data-src="/images/04-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/image-20211013202650610.png" alt="image-20211013202650610"></p>
<h3 id="4-2-缓存验证字段"><a href="#4-2-缓存验证字段" class="headerlink" title="4.2 缓存验证字段"></a>4.2 缓存验证字段</h3><p><strong>1. Last-Modified</strong> / <strong>If-Modified-Since</strong></p>
<p>弱校验器，只能精确到1秒，精确度比<code>Etag</code>低，是<strong>备用缓存验证机制</strong></p>
<p><code>Last-Modified</code>是<strong>响应头</strong>字段，返回该资源文件<strong>在服务器最后被修改的时间</strong></p>
<p><code>If-Modified-Since</code>是<strong>请求头</strong>字段，客户端发起请求时，携带<strong>上次请求</strong>返回的<code>Last-Modified</code>值，服务器根据此字段值验证缓存是否失效。</p>
<p><code>If-Modified-Since</code>字段值与服务器该资源<strong>最后修改时间</strong>对比</p>
<ul>
<li><p>若最后修改时间大于<code>If-Modified-Since</code>则说明缓存失效，重新返回结果和200状态码。</p>
</li>
<li><p>否则，说明资源文件未修改，缓存有效，返回304状态码（资源未更新，响应体为空），从浏览器缓存获取请求结果。</p>
</li>
</ul>
<br>

<p><strong>2. Etag</strong> / <strong>If-None-Match</strong></p>
<p>强校验器</p>
<p><code>Etag</code>是<strong>响应头</strong>字段，返回当前资源文件的一个<strong>唯一标识</strong>(由服务器生成)</p>
<p><code>If-None-Match</code>是<strong>请求头</strong>字段，客户端发起请求时，携带上次请求返回的唯一标识<code>Etag</code>值，服务器根据此字段值验证缓存是否失效。</p>
<p>服务器对比<code>If-None-Match</code>字段值与该资源的唯一标识</p>
<ul>
<li><p>若不同则说明文件修改，返回新结果和200</p>
</li>
<li><p>否则，资源未修改，返回304，从缓存获取结果</p>
</li>
</ul>
<p><span style="color:red">Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。</span></p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>03-浏览器回流(Reflow)和重绘(Repaint)</title>
    <url>/2021/04/13/03-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/</url>
    <content><![CDATA[<h1 id="浏览器回流-Reflow-和重绘-Repaint"><a href="#浏览器回流-Reflow-和重绘-Repaint" class="headerlink" title="浏览器回流(Reflow)和重绘(Repaint)"></a>浏览器回流(Reflow)和重绘(Repaint)</h1><p><strong>回流必将引起重绘，重绘不一定会引起回流。</strong></p>
<h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><p>当页面中<strong>元素样式的改变并不影响它在文档流中的位置时</strong>（例如：color、background-color、visibility 等），浏览器会将<strong>新样式赋予给元素</strong>并<span style="color:red">重新绘制</span>它，这个过程称为重绘。</p>
<br>

<h2 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h2><p>当 Render Tree <strong>(渲染树 由DOM树和CSS对象模型树组成)<strong>中部分或全部元素的</strong>尺寸、结构、或某些属性发生改变时</strong>，浏览器<strong>重新生成渲染树</strong>并<span style="color:red">重新进行布局渲染</span>的过程称为回流</p>
<br>

<span id="more"></span>

<h2 id="会导致回流的操作"><a href="#会导致回流的操作" class="headerlink" title="会导致回流的操作"></a>会导致回流的操作</h2><ul>
<li><p>页面首次渲染</p>
</li>
<li><p>浏览器窗口大小发生改变</p>
</li>
<li><p>元素尺寸或位置发生改变，例如元素内容变化（文字数量或图片大小等等）</p>
</li>
<li><p>元素字体大小变化</p>
</li>
<li><p>添加或者删除可见的 DOM 元素</p>
</li>
<li><pre><code class="text">一些常用且会导致回流的属性和方法
clientWidth、clientHeight、clientTop、clientLeftoffsetWidth、offsetHeight、offsetTop、offsetLeftscrollWidth、scrollHeight、scrollTop、scrollLeftscrollIntoView()、scrollIntoViewIfNeeded()、getComputedStyle()、
getBoundingClientRect()、scrollTo()
</code></pre>
</li>
</ul>
<h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><p>因为频繁的回流和重绘会<strong>降低性能</strong>，并且<strong>回流对性能的影响比重绘更大</strong></p>
<p>需<strong>要避免浏览器频繁回流</strong></p>
<h3 id="css方面"><a href="#css方面" class="headerlink" title="css方面"></a><strong>css方面</strong></h3><ul>
<li>尽可能在 DOM 树的最末端改变 class。</li>
<li>避免设置多层内联样式。</li>
</ul>
<h3 id="js方面"><a href="#js方面" class="headerlink" title="js方面"></a>js方面</h3><ul>
<li><strong>避免频繁操作使元素的结构和尺寸变化的样式</strong>，最好一次性重写 style 属性，或者将修改后的样式列表定义为 class 并一次性更改 class 属性。</li>
<li><strong>避免频繁读取会引发回流/重绘的属性</strong>，如果确实需要多次使用，就用一个变量缓存起来。</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>07-浏览器中的同源政策</title>
    <url>/2021/04/13/07-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E5%8F%8A%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="浏览器中的同源政策"><a href="#浏览器中的同源政策" class="headerlink" title="浏览器中的同源政策"></a>浏览器中的同源政策</h1><p>同源指的是<strong>三个相同</strong></p>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
<p>当两个网页的URL中<strong>上述任意一个不同</strong>，则两个网页<strong>不同源</strong></p>
<ul>
<li>不同源的网页被限制不能访问修改对方网页，即<strong>不同源的网页不能通信</strong></li>
</ul>
<p>浏览器安全的基石是<strong>“同源政策”</strong></p>
<span id="more"></span>

<h2 id="同源的目的"><a href="#同源的目的" class="headerlink" title="同源的目的"></a>同源的目的</h2><p>同源政策的目的：是为了保证用户信息的安全，<strong>防止恶意的网站窃取数据。</strong></p>
<p>例如：用户访问A网站后A网站设置了一个cookie，接着用户访问B网页，如果没有同源政策限制，B网站就可以获取A网站设置的cookie，<strong>从而冒充用户</strong>（cookie一般保存用户的登录信息）</p>
<p>由此可见同源政策对于防止其他恶意网站是必须的</p>
<h2 id="非同源时的限制"><a href="#非同源时的限制" class="headerlink" title="非同源时的限制"></a>非同源时的限制</h2><p>非同源时<strong>三种行为受到限制</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">（1） 无法读取非同源网页的 Cookie、LocalStorage </span><br><span class="line"></span><br><span class="line">（2） 无法接触非同源网页的 DOM。</span><br><span class="line"></span><br><span class="line">（3） 无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。</span><br></pre></td></tr></table></figure>

<p>同源策略虽然可以防止恶意网站窃取数据</p>
<ul>
<li>但一些<strong>合理的跨域操作</strong>也会因为同源策略而失败</li>
<li>例如：需要<strong>使用AJAX请求一个不同源URL所指定的资源</strong>时会因为浏览器同源策略的限制而失败</li>
</ul>
<h2 id="跨源-域-通信的方法"><a href="#跨源-域-通信的方法" class="headerlink" title="跨源(域)通信的方法"></a>跨源(域)通信的方法</h2><p>浏览器同源政策会<strong>限制所有的非同源通信</strong></p>
<p>而<strong>合理的非同源通信需要跨域进行通信</strong></p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP 是服务器与客户端<strong>跨源通信的常用方法</strong>。最大特点就是<strong>简单适用</strong>，老式浏览器全部支持，服务端改造非常小。</p>
<p>它的<strong>基本思想是</strong>：</p>
<ul>
<li>网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器<strong>请求 JSON 数据</strong>，这种做法不受同源政策限制；</li>
<li>服务器收到请求后，返回数据在url中设置的回调函数中处理</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScriptTag</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//动态添加一个script标签</span></span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.setAttribute(<span class="string">&quot;type&quot;</span>,<span class="string">&quot;text/javascript&quot;</span>);</span><br><span class="line">  <span class="comment">//src为服务器端URL，以此发送请求</span></span><br><span class="line">  script.src = src;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//URL最后参数使用一个回调函数foo接受服务器返回的数据</span></span><br><span class="line">  addScriptTag(<span class="string">&#x27;http://example.com/ip?callback=foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//data参数即为服务器响应的JSON数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Your public IP address is: &#x27;</span> + data.ip);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//foo(&#123;</span></span><br><span class="line">  <span class="comment">//&quot;ip&quot;: &quot;8.8.8.8&quot;</span></span><br><span class="line"><span class="comment">//&#125;);</span></span><br></pre></td></tr></table></figure>

<ul>
<li>动态的script标签<strong>执行后立即调用回调函数foo</strong></li>
<li>回调函数foo的<strong>参数data即为服务器返回的JSON数据</strong></li>
<li>JSON数据直接被视为<strong>JavaScript对象</strong></li>
</ul>
<p>缺点：JSONP只能发送<strong>GET请求</strong></p>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS 是<strong>跨源资源分享</strong>（Cross-Origin Resource Sharing）的缩写。</p>
<p>允许浏览器向跨域的服务器，发出<code>XMLHttpRequest</code>请求，从而<strong>克服了AJAX只能同源使用的限制</strong>。</p>
<ul>
<li>它是 W3C 标准</li>
<li>属于<strong>跨源 AJAX 请求的根本解决方法</strong>。</li>
<li>相比 JSONP 只能发<code>GET</code>请求，<strong>CORS 允许任何类型的请求。</strong></li>
</ul>
<p>实现 CORS 通信的关键是服务器。只要<strong>服务器实现了 CORS 接口</strong>，就可以跨域通信。</p>
<p>需要<strong>服务端指定许可的URL</strong>（发送方的URL）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//api.bob.com</span></span><br></pre></td></tr></table></figure>

<ul>
<li>允许<code>http://api.bob.com</code>向服务器发送跨域请求</li>
</ul>
<h2 id="两种CORS请求"><a href="#两种CORS请求" class="headerlink" title="两种CORS请求"></a>两种CORS请求</h2><p>简单请求 和 非简单请求</p>
<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>只要<strong>同时满足以下两大条件</strong>，就属于简单请求。</p>
<p>（1）请求方法是以下三种方法之一。</p>
<blockquote>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
</blockquote>
<p>（2）HTTP 的头信息不超出以下几种字段。</p>
<blockquote>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
</blockquote>
<p>凡是不同时满足上面两个条件，就属于<strong>非简单请求</strong>。一句话，简单请求就是简单的 HTTP 方法与简单的 HTTP 头信息的结合。</p>
<ul>
<li>表单在历史上一直可以跨域发出请求。表单请求就是简单请求</li>
</ul>
<h3 id="简单请求发送"><a href="#简单请求发送" class="headerlink" title="简单请求发送"></a>简单请求发送</h3><p>简单请求，浏览器<strong>直接发出 CORS 请求</strong>。</p>
<p>具体来说，就是在头信息之中，<span style='color:red;'>增加一个<code>Origin</code>字段。</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GET /cors HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: http:<span class="comment">//api.bob.com	//请求头增加一个origin字段</span></span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure>

<p>Origin字段说明<strong>本次请求来自哪个域（协议+域名+端口）</strong></p>
<ul>
<li>如果<code>Origin</code>指定的源，不在服务器许可范围内，服务器会返回一个正常的 HTTP 回应。这个回应的头信息<span style='color:red;'>没有包含<code>Access-Control-Allow-Origin</code>字段</span></li>
</ul>
<p>浏览器发现回应中少了<code>Access-Control-Allow-Origin</code>字段，就会<strong>报错</strong></p>
<BR>

<ul>
<li>如果<code>Origin</code>指定的域名<strong>在许可范围内</strong>，服务器返回的响应，会多出几个头信息字段。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多出的信息字段</span></span><br><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line"></span><br><span class="line">Content-Type: text/html; charset=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>上面的头信息之中，有三个与 CORS 请求相关的字段，都以<code>Access-Control-</code>开头。</p>
<p><strong>（1）<code>Access-Control-Allow-Origin</code></strong></p>
<p>该字段是必须的。<strong>服务器端手动设置</strong>。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>
<p><strong>（2）<code>Access-Control-Allow-Credentials</code></strong></p>
<p>该字段可选。它的值是一个布尔值，表示<strong>是否允许发送 Cookie</strong>。默认情况下，Cookie 不包括在 CORS 请求之中。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送 Cookie，不发送该字段即可。</p>
<ul>
<li>允许发送Cookie时，开发者必须在 AJAX 请求中<span style='color:red'>打开<code>withCredentials</code>属性。</span></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials &#x3D; true;</span><br></pre></td></tr></table></figure>

<p>否则，即使服务器要求发送 Cookie，浏览器<strong>也不会发送</strong>。或者，服务器要求设置 Cookie，浏览器也不会处理。</p>
<p><strong>（3）<code>Access-Control-Expose-Headers</code></strong></p>
<p>该字段可选。</p>
<p>CORS 请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到<strong>6个服务器返回的基本字段</strong>：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。</p>
<p>如果想<strong>拿到其他字段</strong>，就必须在服务端字段<code>Access-Control-Expose-Headers</code>里面指定。</p>
<p>上面的例子指定，可以返回<code>FooBar</code>字段的值。</p>
<h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3>]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>08-跨域中的option请求</title>
    <url>/2021/04/13/08-%E8%B7%A8%E5%9F%9F%E4%B8%AD%E7%9A%84option%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h1 id="跨域中的option请求"><a href="#跨域中的option请求" class="headerlink" title="跨域中的option请求"></a>跨域中的option请求</h1><p>当使用CORS进行跨域时，CORS请求分为 <strong>简单请求和非简单请求</strong></p>
<p>当发送跨域的<strong>非简单请求</strong>时，浏览器会在正式发送跨域请求前<strong>预先发送一个option方式的请求</strong></p>
<h2 id="option请求"><a href="#option请求" class="headerlink" title="option请求"></a>option请求</h2><p>options请求是浏览器自发起的**preflight request(预检请求)**，以检测实际请求的是否可以被服务器接受。</p>
<p>这个option方式的请求用来<strong>让服务端返回允许的请求方法</strong>（如get、post），<strong>允许跨域访问的客户端Origin</strong>（来源，或者域），还有是否需要Credentials(认证信息）</p>
<span id="more"></span>

<br>

<p>preflight request请求报文中有两个需要关注的首部字段：</p>
<p>（1）Access-Control-Request-Method：告知服务器实际<strong>请求所使用的HTTP方法</strong>；</p>
<p>（2）Access-Control-Request-Headers：告知服务器<strong>实际请求所携带的自定义首部字段</strong>。</p>
<p>同时请求也会添加origin请求头,告知服务器实际请求的客户端的地址。服务器<strong>基于从预检请求获得的信息来判断</strong>，是否接受接下来的实际请求。</p>
<br>

<h2 id="为什么跨域的非简单请求需要preflight-request？"><a href="#为什么跨域的非简单请求需要preflight-request？" class="headerlink" title="为什么跨域的非简单请求需要preflight request？"></a>为什么跨域的非简单请求需要preflight request？</h2><p>非简单请求可能对服务器数据产生副作用。例如delete或者put,都会对服务器数据进行修改,所以在<strong>请求之前都要先询问服务器</strong>，<strong>当前网页所在域名是否在服务器的许可名单中</strong>，服务器允许后，浏览器才会发出正式的请求，否则不发送正式请求。</p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>06-XSS攻击和CRSF攻击</title>
    <url>/2021/04/13/06-XSS%E6%94%BB%E5%87%BB%E5%92%8CCRSF%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id="XSS攻击和CRSF攻击"><a href="#XSS攻击和CRSF攻击" class="headerlink" title="XSS攻击和CRSF攻击"></a>XSS攻击和CRSF攻击</h1><h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><p>XSS, 即为（Cross Site Scripting）, 中文名为<strong>跨站脚本</strong>, 是<strong>发生在目标用户的浏览器层面上的</strong>，当<strong>渲染DOM树的过程中发生了不在预期内执行的JS代码时</strong>，就发生了XSS攻击。大多数XSS攻击的主要方式是嵌入一段远程或者第三方域上的JS代码。实际上是在目标网站的作用域下执行了这段js代码。</p>
<h3 id="XSS攻击的危害"><a href="#XSS攻击的危害" class="headerlink" title="XSS攻击的危害"></a>XSS攻击的危害</h3><ol>
<li><p>窃取cookie</p>
<p>第三方的js代码运行在用户访问的域名下，可以通过 document.cookie <strong>获得用户的 Cookie 信息。</strong></p>
</li>
<li><p>未授权操作</p>
<p>利用js的特性，代替用户在页面中进行一些操作，比如<strong>代替用户发送微博</strong>等</p>
</li>
<li><p>按键记录和钓鱼</p>
<p>利用js<strong>记录用户输入的账号密码等</strong>，通过js修改DOM，<strong>伪造一个登录框或者链接诱导用户点击</strong></p>
</li>
</ol>
<span id="more"></span>

<h3 id="防御XSS攻击"><a href="#防御XSS攻击" class="headerlink" title="防御XSS攻击"></a>防御XSS攻击</h3><ol>
<li><p>输入验证和输出验证</p>
</li>
<li><p>编码</p>
</li>
<li><p>检测和过滤</p>
</li>
<li><p><strong>CSP-内容安全策略</strong></p>
</li>
</ol>
<h3 id="CSP-内容安全策略"><a href="#CSP-内容安全策略" class="headerlink" title="CSP-内容安全策略"></a>CSP-内容安全策略</h3><p>使浏览器自动禁止外部注入恶意脚本</p>
<p>CSP 的实质就是<strong>白名单制度</strong>，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。</p>
<p>两种方法可以<strong>启用 CSP</strong>。</p>
<ul>
<li><p>一种是通过 HTTP 头信息的<code>Content-Security-Policy</code>的字段。</p>
<p><img data-src="/images/06-XSS%E6%94%BB%E5%87%BB%E5%92%8CCRSF%E6%94%BB%E5%87%BB/bg2016091305.jpg" alt="img"></p>
</li>
<li><p>另一种是通过网页的<code>&lt;meta&gt;</code>标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;script-src &#x27;self&#x27;; object-src &#x27;none&#x27;; style-src cdn.example.org third-party.org; child-src https:&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，CSP 做了如下配置。</p>
<blockquote>
<ul>
<li>脚本：只信任当前域名</li>
<li><code>&lt;object&gt;</code>标签：不信任任何URL，即不加载任何资源</li>
<li>样式表：只信任<code>cdn.example.org</code>和<code>third-party.org</code></li>
<li>框架（frame）：必须使用HTTPS协议加载</li>
<li>其他资源：没有限制</li>
</ul>
</blockquote>
<p>启用后，不符合 CSP 的外部资源就会被阻止加载</p>
</li>
</ul>
<br>



<h2 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h2><p>CSRF（Cross Site Request Forgery，<strong>跨站请求伪造</strong>）</p>
<p>用户登录了网站A，网站A将用户的sessionId保存在客户端本地的cookie中，此时<strong>用户在没有退出网站A的情况下访问了网站B</strong>，网站B响应给浏览器攻击代码，并发出请求访问网站A，浏览器接收到攻击性代码后，在<strong>用户不知情的状况下</strong>携带cookie访问网站A，网站A认为这是用户的正常操作，执行了攻击性代码。（冒充用户身份执行一系列攻击操作）</p>
<h3 id="防御CRSF攻击"><a href="#防御CRSF攻击" class="headerlink" title="防御CRSF攻击"></a>防御CRSF攻击</h3><p>防御CSRF 攻击主要有三种策略：</p>
<ul>
<li>验证 <strong>HTTP Referer</strong> 字段；<ul>
<li>HTTP请求头字段Referer的值为<strong>请求发起者的URL</strong>，若为CSRF攻击发起的请求，则Referer值与用户主机的URL不同，拒绝请求。(攻击请求是在恶意网站B上构建的，Referer字段的值为网站B的URL)</li>
</ul>
</li>
<li>在请求地址中<strong>添加 token 并验证</strong>；<ul>
<li>CSRF攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中<strong>所有的用户验证信息都是存在于cookie中</strong>，黑客可以在不知道cookie的情况下直接利用用户cookie通过安全验证。</li>
<li>使用token在<strong>HTTP请求头字段设置令牌</strong>，黑客不能获取令牌的值，导致攻击请求不能通过token验证而被拒绝。</li>
</ul>
</li>
<li>在 HTTP 头中<strong>自定义属性并验证</strong>。</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>09-浏览器中的进程与线程</title>
    <url>/2021/04/13/09-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="浏览器中的进程与线程"><a href="#浏览器中的进程与线程" class="headerlink" title="浏览器中的进程与线程"></a>浏览器中的进程与线程</h1><p>以Chrome浏览器为例</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p><strong>1、进程</strong></p>
<ul>
<li>进程是计算机中程序的一次运行活动，是<strong>系统进行资源分配的基本单位</strong>。通常我们启动一个程序，CPU便会开启一个进程，并给这个进程分配内存资源。</li>
<li>任一时刻，<strong>一个CPU核心只能运行一个进程</strong>，其他进程处于挂起状态。（关于多进程，只是多个进程轮流占用CPU，且每次占用很短时间，这就是并行）</li>
<li><strong>进程之间相互独立，互不影响，一个进程不能直接访问其他进程中的资源。</strong></li>
</ul>
<p><strong>2、线程</strong></p>
<ul>
<li>线程是<strong>程序执行的最小单元</strong>。通常<strong>一个进程中包含了一个或多个线程</strong>。</li>
<li><strong>同一进程中的线程共享资源</strong>，且可以并行执行。</li>
<li>某些线程之间存在相互制约的关系。</li>
</ul>
<br>

<span id="more"></span>

<h2 id="Chrome浏览器中的多进程和多线程"><a href="#Chrome浏览器中的多进程和多线程" class="headerlink" title="Chrome浏览器中的多进程和多线程"></a>Chrome浏览器中的多进程和多线程</h2><p>浏览器有多进程和多线程之分。</p>
<p>Chrome是多进程浏览器，<strong>一个标签页</strong>就可以看作一个进程，有时候多个标签页（如空白页）会合并到一个进程。除了管理标签页的Renderer进程外，还有<strong>Browser进程</strong>、<strong>GPU进程</strong>等其他多个进程。</p>
<p>通过浏览器中的 更多工具-任务管理器 可以看到如下图：</p>
<p><img data-src="/images/09-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1223432-20180313000050110-163146273.png" alt="img"></p>
<p><strong>1、为什么采用多进程架构</strong></p>
<ul>
<li>如果所有标签页在同一个进程中，那么<strong>某个标签页的崩溃会影响整个浏览器</strong>。而多个进程间独占资源，相互隔离，便可避免这个问题</li>
<li>同样<strong>避免第三方插件崩溃</strong>而影响整个浏览器</li>
<li>多进程充分利用<strong>多核优势</strong></li>
<li>由一个<strong>主进程来管理和控制其他进程对操作系统资源的访问</strong>，具有一定的安全性。</li>
</ul>
<br>

<p><strong>2、浏览器中的多进程</strong></p>
<p>　　1、Browser进程（主进程）</p>
<p>　　　　浏览器主界面显示，处理用户交互，如前进后退</p>
<p>　　　　管理其他进程，如创建和销毁其他进程，给其他进程分配资源</p>
<p>　　　　将Renderer进程得到的内存中的Bitmap，绘制到用户界面中</p>
<p>　　　　管理网络资源，如下载</p>
<p>　　2、第三方插件进程</p>
<p>　　　　通常一个插件对应一个进程，仅当使用该插件时才创建</p>
<p>　　3、GPU进程</p>
<p>　　　　最多一个，用于图形处理，3D绘制等</p>
<p>　　4、Renderer进程（渲染进程、渲染引擎、浏览器内核）</p>
<p>　　　　通常一个标签页对应一个Renderer进程</p>
<p>　　　　从主进程中获取页面资源</p>
<p>　　　　解析并渲染页面</p>
<p>　　　　处理JavaScript脚本等</p>
 <br>

<p><strong>3、浏览器中的多线程</strong></p>
<p>　　例如Browser进程、Renderer进程等，内部有那么多任务，为了保证运行速度，进程中会有多个线程并行工作。</p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>05-浏览器的垃圾回收机制</title>
    <url>/2021/04/13/05-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="浏览器的垃圾回收机制"><a href="#浏览器的垃圾回收机制" class="headerlink" title="浏览器的垃圾回收机制"></a>浏览器的垃圾回收机制</h1><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。</p>
<p>对于持续运行的服务进程（daemon），必须<strong>及时释放不再用到的内存</strong>。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p>
<p><span style="color:red">不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。</span></p>
<h3 id="常见的内存泄漏案例"><a href="#常见的内存泄漏案例" class="headerlink" title="常见的内存泄漏案例"></a>常见的内存泄漏案例</h3><h4 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1. 全局变量"></a>1. 全局变量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    bar1 &#x3D; &#39;some text&#39;; &#x2F;&#x2F; 没有声明变量 实际上是全局变量 &#x3D;&gt; window.bar1</span><br><span class="line">    this.bar2 &#x3D; &#39;some text&#39; &#x2F;&#x2F; 全局变量 &#x3D;&gt; window.bar2</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>意外的创建了两个全局变量 bar1 和 bar2</p>
<p>全局变量不会被垃圾回收机制回收</p>
<span id="more"></span>

<h4 id="2-未销毁的定时器和回调函数"><a href="#2-未销毁的定时器和回调函数" class="headerlink" title="2. 未销毁的定时器和回调函数"></a>2. 未销毁的定时器和回调函数</h4><p>在很多库中, 如果使用了观察者模式, 都会提供回调方法, 来调用一些回调函数。 要记得回收这些回调函数。举一个 <code>setInterval</code> 的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var serverData &#x3D; loadData();</span><br><span class="line">setInterval(function() &#123;</span><br><span class="line">    var renderer &#x3D; document.getElementById(&#39;renderer&#39;);</span><br><span class="line">    if(renderer) &#123;</span><br><span class="line">        renderer.innerHTML &#x3D; JSON.stringify(serverData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 5000); &#x2F;&#x2F; 每 5 秒调用一次</span><br></pre></td></tr></table></figure>

<p>如果后续 <strong>renderer 元素被移除</strong>，整个定时器实际上没有任何作用。 但如果你没有回收定时器，<strong>整个定时器依然有效</strong>, 不但定时器无法被内存回收， <strong>定时器函数中的依赖</strong>也无法回收。在这个案例中的 <code>serverData</code> 也无法被回收。</p>
<h4 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3. 闭包"></a>3. 闭包</h4><p>在 JS 开发中，我们会经常用到闭包，通过闭包可以在函数外部获取函数内部的局部变量。 下面这种情况下，闭包也会造成内存泄露:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var closure &#x3D; function()&#123;</span><br><span class="line">    var count &#x3D; 0;</span><br><span class="line">    return function()&#123;</span><br><span class="line">       return count ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const fn &#x3D; closure(); </span><br><span class="line">console.log(fn()); &#x2F;&#x2F; 0</span><br><span class="line">console.log(fn()); &#x2F;&#x2F; 1</span><br><span class="line">console.log(fn()); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>每次调用fn时，count值都基于上一次的值增加1，说明<strong>count的引用一直保存在内存中得不到销毁</strong>。</p>
<p>只能在使用完后手动进行销毁</p>
<ul>
<li>销毁对返回值函数的引用<code>fn=null</code>;</li>
<li>或者手动销毁<code>count</code>局部变量 <code>count = undefined;</code></li>
</ul>
<h4 id="4-DOM-引用"><a href="#4-DOM-引用" class="headerlink" title="4. DOM 引用"></a>4. DOM 引用</h4><p>很多时候, 我们对 Dom 的操作, 会把 Dom 的引用保存在一个数组或者 Map 中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &#123;</span><br><span class="line">    image: <span class="built_in">document</span>.getElementById(<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    elements.image.src = <span class="string">&#x27;http://example.com/image_name.png&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeImage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;image&#x27;</span>));</span><br><span class="line">    <span class="comment">// 这个时候我们对于 #image 仍然有一个引用, image 元素, 仍然无法被内存回收.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述案例中, 即使我们对于 image 元素进行了移除, 但是仍然有对 image 元素的引用, 依然无法对其进行内存回收</p>
<h2 id="ES6中的WeakMap和WeakSet"><a href="#ES6中的WeakMap和WeakSet" class="headerlink" title="ES6中的WeakMap和WeakSet"></a>ES6中的WeakMap和WeakSet</h2><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>WeakSet 结构与 Set 类似，也是<strong>不重复的值的集合</strong>。但是，它与 Set 有<strong>两个区别</strong>。</p>
<ul>
<li>首先，WeakSet 的<strong>成员只能是对象</strong>，而不能是其他类型的值。</li>
<li>其次，WeakSet 中的对象都是<strong>弱引用</strong>，即<strong>垃圾回收机制不考虑 WeakSet 对该对象的引用</strong>，也就是说，<span style="color:red">如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</span></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">ws.add(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used in weak set</span></span><br><span class="line">ws.add(<span class="built_in">Symbol</span>())</span><br><span class="line"><span class="comment">// TypeError: invalid value used in weak set</span></span><br></pre></td></tr></table></figure>

<p>向WeakSet实例中<strong>添加非对象报错</strong></p>
<br>

<p>结束使用一个值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。</p>
<p>WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</p>
<p>ES6 规定 WeakSet 不可遍历。</p>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合。</p>
<p><code>WeakMap</code>与<code>Map</code>的区别有两点。</p>
<ul>
<li><code>WeakMap</code>只接受<strong>对象作为键名</strong>（<code>null</code>除外)</li>
<li><code>WeakMap</code>的键名所指向的对象，此引用不计入垃圾回收机制。**(弱引用)**</li>
</ul>
<p><code>WeakMap</code>的<span style="color:red">设计目的在于</span>：有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> e1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> e2 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  [e1, <span class="string">&#x27;foo 元素&#x27;</span>],</span><br><span class="line">  [e2, <span class="string">&#x27;bar 元素&#x27;</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>上述代码使用arr数组对两个对象e1和e2添加说明信息，<strong>形成了arr对e1和e2的引用</strong></p>
<p>当不需要e1和e2时，需要<strong>手动删除这两个引用</strong></p>
<ul>
<li>```js<br>// 不需要 e1 和 e2 的时候<br>// 必须手动删除引用<br>arr [0] = null;<br>arr [1] = null;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">上述手动删除引用不方便，而且容易**忘记删除引用造成内存泄漏**</span><br><span class="line"></span><br><span class="line">**WeakMap 就是为了解决这个问题而诞生的**</span><br><span class="line"></span><br><span class="line">WeakMap的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的**其他引用都被清除**，垃圾回收机制就会释放该对象所占用的内存。WeakMap 里面的**键名对象和所对应的键值对会自动回收消失**，不用手动删除引用。</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">基本上，如果你要**往对象上添加说明数据，又不想干扰垃圾回收机制**，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用&#96;WeakMap&#96;结构。当**该 DOM 元素被清除(其他位置对其引用被清除)**，其所对应的&#96;WeakMap&#96;记录就会**自动被移除。**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;javascript</span><br><span class="line">const wm &#x3D; new WeakMap();</span><br><span class="line"></span><br><span class="line">const element &#x3D; document.getElementById(&#39;example&#39;);</span><br><span class="line"></span><br><span class="line">wm.set(element, &#39;some information&#39;);</span><br><span class="line">wm.get(element) &#x2F;&#x2F; &quot;some information&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意，WeakMap <strong>弱引用的只是键名</strong>，而不是键值。<span style='color:red'>键值依然是正常引用。</span></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> key = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">wm.set(key, obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">wm.get(key)</span><br><span class="line"><span class="comment">// Object &#123;foo: 1&#125;</span></span><br></pre></td></tr></table></figure>

<p>上述代码对于<code>&#123;foo: 1&#125;</code>对象存在<strong>两个正常引用</strong></p>
<ul>
<li>obj对象引用<code>&#123;foo: 1&#125;</code></li>
<li>WeakMap实例的键值引用<code>&#123;foo: 1&#125;</code>，<span style='color:red'>非弱引用（会计入垃圾回收机制）</span></li>
</ul>
<br>

<h2 id="浏览器垃圾回收机制"><a href="#浏览器垃圾回收机制" class="headerlink" title="浏览器垃圾回收机制"></a>浏览器垃圾回收机制</h2><p>浏览器通过垃圾回收机制，判断哪些内存不再使用，并释放不再使用的内存</p>
<p>浏览器的垃圾回收机制<strong>主要使用两种方法</strong>：</p>
<ul>
<li>引用计数</li>
<li>标记清除</li>
</ul>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p><strong>初级的垃圾回收算法</strong></p>
<p>语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的<strong>引用次数</strong>。如果一个值的引用次数是<code>0</code>，就表示这个值不再用到了，因此可以将这块内存释放。</p>
<p>如果一个值不再需要了，引用数却不为<code>0</code>，垃圾回收机制无法释放这块内存，从而<strong>导致内存泄漏</strong>。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hello world&#x27;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，数组<code>[1, 2, 3, 4]</code>是一个值，会占用内存。全局变量<code>arr</code>是仅有的对这个值的引用，因此引用次数为<code>1</code>。尽管后面的代码没有用到<code>arr</code>，它还是会持续占用内存。</p>
<p>如果增加一行代码，解除<code>arr</code>对<code>[1, 2, 3, 4]</code>引用，这块内存就可以被垃圾回收机制释放了。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">arr = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>arr</code>重置为<code>undefined</code>，就解除了对<code>[1, 2, 3, 4]</code>的引用，引用次数变成了<code>0</code>，内存就可以释放出来了。</p>
<p><span style="color:red">缺点：循环引用的对象占用的内存不能被回收</span></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">  var o &#x3D; &#123;&#125;;</span><br><span class="line">  var o2 &#x3D; &#123;&#125;;</span><br><span class="line">  o.a &#x3D; o2; &#x2F;&#x2F; o 引用 o2</span><br><span class="line">  o2.a &#x3D; o; &#x2F;&#x2F; o2 引用 o</span><br><span class="line"></span><br><span class="line">  return &quot;azerty&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure>

<ul>
<li>上述两个局部变量 o 和 o2为两个对象，这两个对象互相引用</li>
<li>在<code>f()</code>执行后本应销毁局部变量o和o2，但是因为循环引用，导致o和o2都至少有一次引用，不能被引用计数的垃圾回收机制回收</li>
</ul>
<h3 id="标记清除-（现在大部分浏览器使用）"><a href="#标记清除-（现在大部分浏览器使用）" class="headerlink" title="标记清除 （现在大部分浏览器使用）"></a>标记清除 （现在大部分浏览器使用）</h3><p>现在大部分浏览器使用<strong>标记清除</strong>的垃圾回收算法</p>
<p>标记清除算法将“不再使用的对象”定义为<strong>“无法到达的对象”</strong>。 </p>
<p>简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。 </p>
<ul>
<li>凡是能从根部到达的对象，都是还需要使用的。</li>
<li>那些<strong>无法由根部出发触及到的对象</strong>被标记为不再使用，<strong>稍后进行回收</strong>。 从这个概念可以看出，无法触及的对象包含了没有引用的对象这个概念（没有任何引用的对象也是无法触及的对象）。 但反之未必成立。</li>
</ul>
<p>工作流程：</p>
<ol>
<li>垃圾收集器会在运行的时候给存储在内存中的<strong>所有变量都加上标记</strong>。</li>
<li>从根部出发<strong>将能触及到的对象的标记清除</strong>。</li>
<li>那些<strong>还存在标记的变量</strong>被视为准备删除的变量。</li>
<li>最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间。</li>
</ol>
<p><span style="color:red">循环引用不再是问题了</span>，<strong>两个循环引用的对象在垃圾收集时从全局对象出发无法再获取他们的引用</strong>。 因此，他们将会被垃圾回收器回收。</p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>知识点汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>03-Ajax和JSONP</title>
    <url>/2021/04/13/03-ajax%E5%92%8CJsonp/</url>
    <content><![CDATA[<h1 id="Ajax和JSONP"><a href="#Ajax和JSONP" class="headerlink" title="Ajax和JSONP"></a>Ajax和JSONP</h1><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>ajax 全称为 async JavaScript and xml （<strong>异步的js和xml</strong>）</p>
<ul>
<li>不是一种新技术，是使用<strong>现有技术集合</strong>的一种方法</li>
<li>使用ajax可以快速将增量更新显示在页面上，而<strong>不必刷新整个页面</strong></li>
<li>X代表XML，但是由于<strong>JSON在javascript中的优势</strong>（轻量化，作为js的一部分），JSON的使用比XML的使用更加普遍<ul>
<li>JSON和XML都用于在Ajax模型中<strong>打包信息</strong></li>
</ul>
</li>
</ul>
<span id="more"></span>

<h3 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h3><p>XMLHttpRequest对象是Ajax的核心，用于与服务器交互</p>
<p>通过 XMLHttpRequest 可以在<strong>不刷新页面的情况下请求特定 URL，获取数据</strong>，不影响用户操作的情况<strong>更新页面的局部部分</strong></p>
<ul>
<li><code>XMLHttpRequest</code> 可以用于获取<strong>任何类型的数据</strong>，而不仅仅是 XML<ul>
<li>比如<strong>JSON和纯文本Text</strong>等</li>
</ul>
</li>
</ul>
<h3 id="XMLHttpRequest对象的属性"><a href="#XMLHttpRequest对象的属性" class="headerlink" title="XMLHttpRequest对象的属性"></a>XMLHttpRequest对象的属性</h3><h4 id="XMLHttpRequest-readyState"><a href="#XMLHttpRequest-readyState" class="headerlink" title="XMLHttpRequest.readyState"></a>XMLHttpRequest.readyState</h4><p>XMLHttpRequest.readyState 属性返回一个 XMLHttpRequest 代理<strong>当前所处的状态</strong>。一个 XHR 代理<strong>总是处于下列状态中的一个</strong>：</p>
<p><img data-src="/images/03-ajax%E5%92%8CJsonp/image-20210927170414424.png" alt="image-20210927170414424"></p>
<p>当<code>XMLHttpRequest.readyState</code><strong>值为4时</strong>，即已经接受到服务器发来的响应，可以进行响应数据的处理工作</p>
<br>

<h4 id="XMLHttpRequest-status"><a href="#XMLHttpRequest-status" class="headerlink" title="XMLHttpRequest.status"></a>XMLHttpRequest.status</h4><p>返回请求的<strong>HTTP响应状态码</strong></p>
<p>如 200 等</p>
<br>

<h4 id="XMLHttpRequest-onreadystatechange"><a href="#XMLHttpRequest-onreadystatechange" class="headerlink" title="XMLHttpRequest.onreadystatechange"></a>XMLHttpRequest.onreadystatechange</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XMLHttpRequest.onreadystatechange &#x3D; callback;</span><br></pre></td></tr></table></figure>

<p>当<code>readyState</code>值改变时，触发回调函数</p>
<p><code>readyState = 4</code> 时，可以在回调函数中处理响应结果</p>
<br>

<h4 id="XMLHttpRequest-responseType"><a href="#XMLHttpRequest-responseType" class="headerlink" title="XMLHttpRequest.responseType"></a>XMLHttpRequest.responseType</h4><p>获取响应数据类型</p>
<br>

<h4 id="XMLHttpRequest-responseText"><a href="#XMLHttpRequest-responseText" class="headerlink" title="XMLHttpRequest.responseText"></a>XMLHttpRequest.responseText</h4><p>只读属性 接受服务端返回的文本数据</p>
<p>在一个请求被发送后，从服务器端<strong>返回文本</strong>。</p>
<p>值为null时代表<strong>请求失败</strong></p>
<p>值为<code>“”</code>空字符串时，代表<strong>请求还未使用send()方法发出</strong></p>
<br>

<h4 id="XMLHttpRequest-responseXML"><a href="#XMLHttpRequest-responseXML" class="headerlink" title="XMLHttpRequest.responseXML"></a>XMLHttpRequest.responseXML</h4><p>只读属性</p>
<p>返回一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document"><code>Document</code></a> （文档），其中包含该请求的响应，如果<strong>请求未成功</strong>、<strong>尚未发送</strong>或是<strong>不能被解析为 XML 或 HTML</strong>，则返回 <code>null</code>。</p>
<br>

<h3 id="XMLHttpRequest对象的-方法"><a href="#XMLHttpRequest对象的-方法" class="headerlink" title="XMLHttpRequest对象的 方法"></a>XMLHttpRequest对象的 方法</h3><h4 id="XMLHttpRequest-open"><a href="#XMLHttpRequest-open" class="headerlink" title="XMLHttpRequest.open()"></a>XMLHttpRequest.open()</h4><p>初始化一个请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XHR.open(method, url, async);</span><br></pre></td></tr></table></figure>

<ul>
<li>method：HTTP请求方式 （GET,POST等）</li>
<li>url：请求URL</li>
<li>async：布尔值，true（默认值）代表异步，false代表同步</li>
</ul>
<br>

<h4 id="XMLHttpRequest-send"><a href="#XMLHttpRequest-send" class="headerlink" title="XMLHttpRequest.send()"></a>XMLHttpRequest.send()</h4><p>发送初始化的请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XMLHttpRequest.send(body)</span><br></pre></td></tr></table></figure>

<p><code>body</code> 可选</p>
<p>在请求中<strong>要发送的数据体</strong>（请求参数）. 可以是:</p>
<ul>
<li><p><code>FormData</code></p>
</li>
<li><p>可以为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document"><code>Document</code></a>, 在这种情况下，它在发送之前被序列化.</p>
</li>
<li><p><code>null</code></p>
<ul>
<li>如果请求方法是 GET 或者 HEAD，则应将请求参数主体设置为 null。</li>
</ul>
</li>
</ul>
<p>如果body没有指定值，则默认值为 <code>null</code> .</p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON：全称为 JavaScript Object Notation <strong>(js对象标记法</strong>)</p>
<p>是一种存储数据的<strong>语法</strong></p>
<p>基于 JavaScript 语法，但与之不同：<strong>JavaScript不是JSON，JSON也不是JavaScript</strong></p>
<ul>
<li>JSON对象 属性名称必须是<strong>双引号括起来的字符串</strong>；最后一个属性后不能有逗号。<ul>
<li><code>&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;</code></li>
</ul>
</li>
</ul>
<p>两个方法：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse"><code>JSON.parse()</code></a>: 解析JSON字符串并返回对应的值 <strong>(JSON字符串转JSON对象)</strong></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><code>JSON.stringify()</code></a>：返回与指定值对应的JSON字符串 （<strong>JSON对象转字符串</strong>）</li>
</ul>
<br>

<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p><strong>JSONP 是一种无需考虑跨域问题即可传送 JSON 数据的方法。</strong></p>
<p><strong>JSONP 不使用 XMLHttpRequest 对象。</strong></p>
<p><strong>JSONP 使用<code>&lt;script&gt;</code>标签取而代之。</strong></p>
<p>在script标签的<strong>src属性</strong>中写请求地址并使用回调函数处理响应数据，以此避开同源策略的限制</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
        <tag>JSONP</tag>
      </tags>
  </entry>
  <entry>
    <title>04-token</title>
    <url>/2021/04/13/04-token/</url>
    <content><![CDATA[<h1 id="token（令牌）"><a href="#token（令牌）" class="headerlink" title="token（令牌）"></a>token（令牌）</h1><p>token的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。</p>
<p>当用户第一次登录后，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可。</p>
<p><strong>JSON Web Token</strong>（缩写 JWT）是目前最流行的跨域认证解决方案</p>
<span id="more"></span>

<h2 id="token出现之前的一般session认证流程"><a href="#token出现之前的一般session认证流程" class="headerlink" title="token出现之前的一般session认证流程"></a>token出现之前的一般session认证流程</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1、用户向服务器发送用户名和密码。</span><br><span class="line"></span><br><span class="line">2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</span><br><span class="line"></span><br><span class="line">3、服务器向用户返回一个 session_id，写入用户的 Cookie。</span><br><span class="line"></span><br><span class="line">4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</span><br><span class="line"></span><br><span class="line">5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</span><br></pre></td></tr></table></figure>

<p>这样的认证流程会导致一些问题</p>
<ul>
<li><p>在服务端内存使用session存储登录信息，<span style="color:red">服务器扩展性不好</span></p>
</li>
<li><p>每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加，最终导致性能下降</p>
</li>
<li><p>CSRF(跨站请求伪造)：用户在访问银行等网站时，他们容易受到跨站请求伪造的攻击，被恶意网站冒充身份（认证信息保存在cookie中）</p>
</li>
</ul>
<p>上述问题中最突出的问题为<span style="color:red">服务器扩展性不好</span></p>
<h2 id="解决session认证的服务端扩展性问题"><a href="#解决session认证的服务端扩展性问题" class="headerlink" title="解决session认证的服务端扩展性问题"></a>解决session认证的服务端扩展性问题</h2><p>如果是服务器集群，就要求 session 数据共享，每台服务器都能够读取 session。</p>
<ul>
<li><p>一种解决方案是 session <strong>数据持久化</strong>：写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。</p>
<ul>
<li>这种方案的<strong>优点是架构清晰</strong>，</li>
<li><strong>缺点是工程量比较大</strong>。另外，持久层万一挂了，就会单点失败。</li>
</ul>
</li>
<li><p>另外一种解决方案<strong>不保存session数据</strong>，所有认证数据都保存在客户端，每次请求都将认证数据发回服务器。<span style="color:red">JWT 就是这种方案的一个代表。</span></p>
</li>
</ul>
<br>

<h2 id="JWT原理"><a href="#JWT原理" class="headerlink" title="JWT原理"></a>JWT原理</h2><p>JWT 的原理是，服务器认证以后，<strong>生成一个 JSON 对象，发回给用户</strong></p>
<p>以后，用户与服务端通信的时候，都要<strong>发回这个 JSON 对象</strong>。服务器完全<strong>只靠这个对象认定用户身份</strong>。为了防止用户篡改数据，服务器在生成这个对象的时候，会<strong>加上签名</strong></p>
<p>这样服务器不保存任何session数据，变成无状态，扩展起来比较容易</p>
<p><img data-src="/images/04-token/image-20211019205115264.png" alt="image-20211019205115264"></p>
<h3 id="JWT的数据结构"><a href="#JWT的数据结构" class="headerlink" title="JWT的数据结构"></a>JWT的数据结构</h3><p>是一个很长的字符串，用<code>&#39;.&#39;</code>分隔为三部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Header.Payload.Signature</span><br></pre></td></tr></table></figure>

<h4 id="Header头部"><a href="#Header头部" class="headerlink" title="Header头部"></a>Header头部</h4><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>alg</code>属性表示<strong>签名的算法</strong>（algorithm），默认是 HMAC SHA256（写成 HS256）</p>
</li>
<li><p><code>typ</code>属性表示<strong>这个令牌（token）的类型</strong>（type），JWT 令牌统一写为<code>JWT</code>。</p>
</li>
</ul>
<p>将上面的 JSON 对象使用 Base64URL 算法<strong>转成字符串</strong>。</p>
<h4 id="Payload负载"><a href="#Payload负载" class="headerlink" title="Payload负载"></a>Payload负载</h4><p>Payload 部分也是一个 JSON 对象，用来存放<strong>实际需要传递的数据</strong>。JWT 规定了7个官方字段，供选用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iss (issuer)：签发人</span><br><span class="line">exp (expiration time)：过期时间</span><br><span class="line">sub (subject)：主题</span><br><span class="line">aud (audience)：受众</span><br><span class="line">nbf (Not Before)：生效时间</span><br><span class="line">iat (Issued At)：签发时间</span><br><span class="line">jti (JWT ID)：编号</span><br></pre></td></tr></table></figure>

<p>除了七个官方字段，还可以<strong>自定义私有字段</strong></p>
<p>JWT <span style="color:red">默认是不加密的</span>，任何人都可以读到，所以不要把秘密信息放在这个部分。</p>
<p>这个 JSON 对象也要使用 Base64URL 算法<strong>转成字符串</strong>。</p>
<h4 id="Signature签名"><a href="#Signature签名" class="headerlink" title="Signature签名"></a>Signature签名</h4><p>Signature 部分是对前两部分的签名，防止数据篡改。</p>
<p>指定一个密钥（secret）**,密钥只有服务器知道**，根据Header头部指定的签名算法计算签名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>

<p>得到签名后把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p>
<h3 id="客户端对JWT的处理"><a href="#客户端对JWT的处理" class="headerlink" title="客户端对JWT的处理"></a>客户端对JWT的处理</h3><p>客户端收到服务器返回的 JWT，可以储存在 <strong>Cookie</strong> 里面，也可以储存在 <strong>localStorage</strong>。</p>
<p>此后，客户端每次与服务器通信，都要带上这个 JWT。</p>
<ul>
<li><p>你可以把它放在 Cookie 里面自动发送，但是这样不能跨域(跨域时需要手动操作以允许发送cookie)，</p>
</li>
<li><p>所以更好的做法是<span style="color:red;">放在 HTTP 请求的头信息<code>Authorization</code>字段里面。</span></p>
</li>
<li><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p>
</li>
</ul>
<h4 id="客户端发送请求时加入token的方式"><a href="#客户端发送请求时加入token的方式" class="headerlink" title="客户端发送请求时加入token的方式"></a>客户端发送请求时加入token的方式</h4><ul>
<li>将token放入请求头</li>
</ul>
<p><img data-src="/images/04-token/image-20211015162235342.png" alt="image-20211015162235342"></p>
<ul>
<li>发送请求前设置请求头</li>
</ul>
<p><img data-src="/images/04-token/image-20211015162324665.png" alt="image-20211015162324665"></p>
<h2 id="JWT特点"><a href="#JWT特点" class="headerlink" title="JWT特点"></a>JWT特点</h2><p><strong>JWT存在有效期</strong></p>
<p>（1）JWT <strong>默认是不加密，但也是可以加密的</strong>。生成原始 Token 以后，可以用密钥再加密一次。</p>
<p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p>
<p>（3）JWT <strong>不仅可以用于认证，也可以用于交换信息</strong>。有效使用 JWT，可以降低服务器查询数据库的次数。</p>
<p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，<strong>一旦 JWT 签发了，在到期之前就会始终有效</strong>，除非服务器部署额外的逻辑。</p>
<p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用<strong>，JWT 的有效期应该设置得比较短</strong>。对于一些比较重要的权限，使用时应该<strong>再次对用户进行认证。</strong></p>
<p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，<strong>要使用 HTTPS 协议传输。</strong></p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title>01-cookie/webStorage/session</title>
    <url>/2021/04/13/01-cookie%E5%92%8Csession%E5%92%8CwebStorage/</url>
    <content><![CDATA[<h1 id="cookie、webStorage、session"><a href="#cookie、webStorage、session" class="headerlink" title="cookie、webStorage、session"></a>cookie、webStorage、session</h1><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul>
<li><p>数据存储在<strong>客户端浏览器上</strong></p>
</li>
<li><p>cookie数据在<strong>同源的http请求中</strong>携带（在同源窗口中共享）</p>
<ul>
<li>同源url：协议域名端口相同</li>
</ul>
</li>
<li><p>cookie数据还可以<strong>限制路径</strong>，让cookie只属于该路径下</p>
</li>
<li><p>存储<strong>大小限制4KB</strong></p>
</li>
<li><p><strong>过期时间</strong>到后会自动删除，没有到期即使关闭浏览器也不会删除</p>
</li>
<li><p><strong>只能保存字符串</strong></p>
</li>
<li><p>支持跨域名访问</p>
</li>
<li><p>不安全，他人可以分析存放在客户端本地的Cookie进行cookie欺骗</p>
</li>
<li><p>很多浏览器限制一个站点<strong>最多保存20个cookie</strong></p>
</li>
</ul>
<span id="more"></span>

<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><ul>
<li>数据存储在<strong>服务器端</strong></li>
<li>session可以<strong>存储用户的信息</strong>，每一个用户都会产生一个session，当<strong>并发访问量大时，影响服务器性能</strong></li>
<li>session对于用户不可见，不存在信息泄露风险</li>
<li><strong>不支持跨域名访问</strong>，只在所在地域名中有效</li>
<li><strong>可以存储各类对象</strong></li>
</ul>
<h2 id="WebStorage"><a href="#WebStorage" class="headerlink" title="WebStorage"></a>WebStorage</h2><p>早些时候本地存储会话数据的方式只有cookie</p>
<p><strong>HTML5提供了WebStorage</strong>，可以在本地存储用户的浏览数据并<strong>克服了cookie的一些限制</strong></p>
<ul>
<li>不会随请求发送到服务端</li>
<li>存储数据的量大于cookie，<strong>一般大于5MB</strong></li>
</ul>
<p><strong>WebStorage分为两种</strong></p>
<ul>
<li><p>sessionStorage</p>
</li>
<li><p>localStorage</p>
</li>
</ul>
<h3 id="使用WebStorage的优势"><a href="#使用WebStorage的优势" class="headerlink" title="使用WebStorage的优势"></a>使用WebStorage的优势</h3><ul>
<li><strong>离线浏览</strong></li>
<li><strong>提升加载速度</strong>，已缓存资源加载更快</li>
<li><strong>减少服务器负载</strong>，浏览器只从服务器下载更新过的资源</li>
</ul>
<h3 id="sessionStorage会话级存储"><a href="#sessionStorage会话级存储" class="headerlink" title="sessionStorage会话级存储"></a>sessionStorage会话级存储</h3><ul>
<li>在<strong>浏览器窗口</strong>关闭前其数据一直是存在的，窗口关闭即删除数据</li>
<li>其中的数据在<strong>浏览器页面刷新后依旧存在</strong></li>
<li>浏览器支持的情况下，当浏览器崩溃重启后依然可用</li>
<li>sessionStorage在<strong>两个浏览器窗口存储的数据不共享</strong><ul>
<li>打开<strong>多个相同的URL的页面</strong>，会创建各自的<code>sessionStorage</code>。</li>
</ul>
</li>
</ul>
<h3 id="localStorage本地-跨会话级存储"><a href="#localStorage本地-跨会话级存储" class="headerlink" title="localStorage本地/跨会话级存储"></a>localStorage本地/跨会话级存储</h3><ul>
<li>持久化数据存储，在浏览器关闭后一直存在，除非手动删除</li>
<li>在所有同源的浏览器窗口中共享数据</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器数据存储方式</tag>
      </tags>
  </entry>
  <entry>
    <title>05-express-session模块</title>
    <url>/2021/04/13/05-express-session%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="express-session模块设置cookie和session"><a href="#express-session模块设置cookie和session" class="headerlink" title="express-session模块设置cookie和session"></a>express-session模块设置cookie和session</h1><p><code>express-session</code>为express框架的一个模块</p>
<p>用来<strong>设置服务端session</strong>和<strong>向客户端传送cookie信息</strong></p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">&#x27;express-session&#x27;</span>);</span><br><span class="line"></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">	name:<span class="string">&#x27;sid&#x27;</span>,					<span class="comment">//设定客户端cookie名字，默认为connect.sid</span></span><br><span class="line">	secret: <span class="string">&#x27;keyboard cat&#x27;</span>,		<span class="comment">//对cookie进行签名的密钥</span></span><br><span class="line">	resave: <span class="literal">false</span>,				<span class="comment">//是否强制保存会话，即使未修改</span></span><br><span class="line">	saveUninitialized: <span class="literal">true</span>,	<span class="comment">//是否存储未初始化的cookie</span></span><br><span class="line">	cookie:&#123;					<span class="comment">//对cookie进行设置</span></span><br><span class="line">        path: <span class="regexp">/,				/</span><span class="regexp">/设置路径</span></span><br><span class="line"><span class="regexp">		maxAge:10*1000			/</span><span class="regexp">/设置过期时间</span></span><br><span class="line"><span class="regexp">	&#125;,</span></span><br><span class="line"><span class="regexp">	unset:&#x27;destroy&#x27;				/</span><span class="regexp">/对于未初始化的session对象在响应结束后删除</span></span><br><span class="line"><span class="regexp">&#125;));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">app.post(&#x27;/</span>login<span class="string">&#x27;, (req, res) =&gt; &#123;</span></span><br><span class="line"><span class="string">	// 创建表单解析对象</span></span><br><span class="line"><span class="string">	var form = formidable.IncomingForm();</span></span><br><span class="line"><span class="string">	// 解析表单</span></span><br><span class="line"><span class="string">	form.parse(req, (err, fields, file) =&gt; &#123;</span></span><br><span class="line"><span class="string">		// 接收客户端传递过来的用户名和密码</span></span><br><span class="line"><span class="string">		const &#123; username, password &#125; = fields;</span></span><br><span class="line"><span class="string">		// 用户名密码比对</span></span><br><span class="line"><span class="string">		if (username == &#x27;</span>itheima<span class="string">&#x27; &amp;&amp; password == &#x27;</span><span class="number">123456</span><span class="string">&#x27;) &#123;</span></span><br><span class="line"><span class="string">			// 设置session</span></span><br><span class="line"><span class="string">			req.session.isLogin = true;		//给session对象设置属性进行初始化</span></span><br><span class="line"><span class="string">			res.send(&#123;message: &#x27;</span>登录成功<span class="string">&#x27;&#125;);</span></span><br><span class="line"><span class="string">		&#125; else &#123;</span></span><br><span class="line"><span class="string">			res.send((&#123;message: &#x27;</span>登录失败, 用户名或密码错误<span class="string">&#x27;&#125;));</span></span><br><span class="line"><span class="string">			req.session.destroy()	//删除未初始化的session对象（手动）</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;)</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述代码使用app.use方法<strong>拦截所有请求设置session</strong></p>
<ul>
<li>此时的session对象只有sessionID，是未初始化的session对象</li>
</ul>
</li>
<li><p><code>resave</code>配置项：代表<strong>是否强制保存会话</strong>，当值为true时，两个并行请求可能会发生覆盖</p>
</li>
<li><p><code>saveUninitialized</code>配置项：若值为false，则<strong>未初始化的session</strong>不会将其id保存在客户端（即客户端不会保存未初始化的session对象的cookie）</p>
</li>
<li><p><code>unset</code>配置项：对于未初始化的session，在响应结束时删除。（删除需要手动进行）</p>
</li>
<li><p><code>cookie</code>配置项：对设置在客户端的cookie进行配置</p>
<ul>
<li>expires：以时间格式设置过期时间（GMT格式等）</li>
<li>maxAge：以毫秒数设置过期时间（会被自动转换为GMZ格林威治时间）</li>
<li>domain：所属域名</li>
<li>path：所属路径</li>
</ul>
</li>
</ul>
<br>

<p><img data-src="/images/05-express-session%E6%A8%A1%E5%9D%97/image-20211106144240442.png" alt="image-20211106144240442"></p>
<ul>
<li><p>上图为客户端存储的cookie信息</p>
</li>
<li><p>sid为设置的cookie名字</p>
</li>
<li><p>Expires/Max-Age为过期时间</p>
<ul>
<li>末尾的<span style="color:red">Z代表格林威治时间，比北京时间少8h</span></li>
<li>此时以格林威治时间记录过期时间</li>
</ul>
</li>
<li><p>cookie过期后刷新页面，cookie就会消失</p>
</li>
</ul>
<br>

<p><span style="color:red">注意：</span></p>
<p>使用<code>express-session</code>进行session身份认证时</p>
<ul>
<li>实际对于<strong>所有请求</strong>都设置了session（但未初始化的session在响应时不设置cookie）</li>
<li>身份认证时通过<strong>初始化的session对象中的属性</strong>（例如<code>req.session.isLogin</code>）进行判断</li>
</ul>
<br>

<h2 id="跨域请求需要在xhr对象和服务端进行配置才能发送cookie"><a href="#跨域请求需要在xhr对象和服务端进行配置才能发送cookie" class="headerlink" title="跨域请求需要在xhr对象和服务端进行配置才能发送cookie"></a>跨域请求需要在xhr对象和服务端进行配置才能发送cookie</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当发送跨域请求时，携带cookie信息</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<center>客户端xhr对象设置</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 允许客户端发送跨域请求时携带cookie信息</span></span><br><span class="line">res.header(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<center>服务端设置</center>]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>express-session</tag>
      </tags>
  </entry>
</search>
