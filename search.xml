<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01-什么是Node</title>
    <url>/2021/04/13/01-%E4%BB%80%E4%B9%88%E6%98%AFNode.js/</url>
    <content><![CDATA[<h1 id="1-Node-js介绍"><a href="#1-Node-js介绍" class="headerlink" title="1.Node.js介绍"></a>1.Node.js介绍</h1><h2 id="1-1学习Node-js的目的"><a href="#1-1学习Node-js的目的" class="headerlink" title="1.1学习Node.js的目的"></a>1.1学习Node.js的目的</h2><p>用来<strong>操作使用WEB后台服务器</strong></p>
<p>了解后台服务器才能更好的与后端开发人员协同开发</p>
<p>能够实现同样功能的后台语言还有java、python、php等</p>
<p>学习Node.js实际上就是在学习<strong>WEB服务器开发</strong></p>
<span id="more"></span>

<h2 id="1-2什么是Node-js"><a href="#1-2什么是Node-js" class="headerlink" title="1.2什么是Node.js"></a>1.2什么是Node.js</h2><p>Node.js官网<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p>
<p>官网对于Node.js的描述：</p>
<ul>
<li><p>Node.js® is a JavaScript runtime built on <a href="https://v8.dev/">Chrome’s V8 JavaScript engine</a>.</p>
<ul>
<li><p>Node.js是一个基于Chrome V8引擎的<strong>javaScript运行环境</strong></p>
</li>
<li><p>基于Chrome V8引擎</p>
<ul>
<li>代码只是具有特定格式的字符串</li>
<li>引擎可以帮我们去解释执行这些代码</li>
<li>Google Chrome 的V8引擎是当前公认的解释执行JavaScript最快的</li>
<li>Node.js的作者把Google Chrome的<strong>V8引擎移植出来</strong>，开发了一个<strong>独立的JavaScript运行环境</strong></li>
</ul>
</li>
<li><p>Node.js<strong>不是一门语言</strong></p>
</li>
<li><p>Node.js<strong>不是库、不是框架</strong></p>
</li>
<li><p>Node.js可以解析执行JavaScript代码</p>
</li>
<li><p>以前只有浏览器可以解释执行JavaScript代码</p>
</li>
<li><p>现在Node.js可以使JavaScript脱离浏览器解释执行</p>
</li>
<li><p>浏览器中的JavaScript</p>
<ul>
<li>ECMAScript(基本的语法)</li>
<li>DOM</li>
<li>BOM</li>
</ul>
</li>
<li><p>Node.js中的JavaScript</p>
<ul>
<li><p><strong>不同于原来浏览器中的JavaScript</strong></p>
</li>
<li><p><strong>没有DOM、BOM</strong></p>
</li>
<li><p>有ECMAScript</p>
</li>
<li><p>Node.js这个JavaScript运行环境为JavaScript提供了一些服务器级别的操作API(应用编程接口)</p>
<ul>
<li>例如文件读写</li>
<li>网络服务构建</li>
<li>网络通信</li>
<li>http服务器等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Node.js uses an event-driven,non-blocking I/O model that makes it lightweight and efficient.</p>
<ul>
<li><p>Node.js的<strong>特性</strong></p>
</li>
<li><p>1、event-driven 事件驱动</p>
</li>
<li><p>2、non-blocking I/O model 无阻塞的I/O模组 (异步)</p>
</li>
<li><p>lightweight and efficient 轻量化和高效的</p>
</li>
</ul>
</li>
<li><p>Node.js’ package ecosystem,npm,is the largest ecosystem of open source libraries in the world.</p>
<ul>
<li>Node.js包生态系统——npm，是世界上最大的开源库生态系统</li>
<li>绝大多数JavaScript相关的包(第三方包等)都存放在npm上，为了让开发人员更方便的下载使用</li>
<li>例如使用 <code>npm install jquery</code>就可以下载jQuery的npm包</li>
</ul>
</li>
</ul>
<h2 id="1-3Node-js能做什么"><a href="#1-3Node-js能做什么" class="headerlink" title="1.3Node.js能做什么"></a>1.3Node.js能做什么</h2><ul>
<li>WEB服务器后台</li>
<li>命令行工具<ul>
<li>npm(Node开发)</li>
<li>git(C语言开发)</li>
<li>hexo(Node开发)</li>
<li>。。。</li>
</ul>
</li>
<li>对于前端工程师来说，接触Node最多的就是它的命令行工具<ul>
<li>主要是使用别人开发的第三方命令行工具<ul>
<li>webpack</li>
<li>gulp</li>
<li>。。。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-4学习资源"><a href="#1-4学习资源" class="headerlink" title="1.4学习资源"></a>1.4学习资源</h2><ul>
<li><p>《深入浅出Node.js》</p>
<ul>
<li>作者：朴(piao)灵</li>
<li>偏理论、没有实例性内容</li>
<li>对于理解底层原理有帮助</li>
<li>结合其他实例来学习更好</li>
</ul>
</li>
<li><p>《Node.js权威指南》</p>
<ul>
<li>API讲解</li>
<li>没有实例</li>
</ul>
</li>
<li><p>CNODE社区：<a href="https://cnodejs.org/">https://cnodejs.org</a></p>
<ul>
<li>其中新手入门有一些参考资料</li>
</ul>
</li>
</ul>
<h2 id="1-5学习Node-js得到什么"><a href="#1-5学习Node-js得到什么" class="headerlink" title="1.5学习Node.js得到什么"></a>1.5学习Node.js得到什么</h2><ul>
<li><p>操作使用WEB服务器后台</p>
</li>
<li><p>B/S编程模型</p>
<ul>
<li>Browser-Server 浏览器-服务器模型</li>
<li>back-end 后端</li>
<li>任何服务器端技术这种B/S编程模型都是一样的</li>
</ul>
</li>
<li><p>Node只是作为我们学习这种B/S编程模型的工具</p>
</li>
<li><p>模块化编程</p>
<ul>
<li>Node中可以像 <code>@import()</code>一样引用加载JavaScript脚本文件</li>
</ul>
</li>
<li><p>Node常用API</p>
</li>
<li><p>异步编程</p>
<ul>
<li>promise</li>
<li>回调函数</li>
<li>async</li>
<li>generator</li>
</ul>
</li>
<li><p>Express Web开发框架</p>
</li>
<li><p>ES6(穿插讲解)</p>
</li>
<li><p>为以后学习Vue，React，angular前端框架打基础</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>02-Nodejs中的JavaScript</title>
    <url>/2021/04/13/02-nodejs%E4%B8%AD%E7%9A%84JavaScript/</url>
    <content><![CDATA[<h1 id="1-Nodejs中的JavaScript"><a href="#1-Nodejs中的JavaScript" class="headerlink" title="1.Nodejs中的JavaScript"></a>1.Nodejs中的JavaScript</h1><ul>
<li><p>ECMAScript</p>
<ul>
<li>没有BOM和DOM</li>
</ul>
</li>
<li><p>核心模块(fs,http等)</p>
</li>
<li><p>第三方模块</p>
</li>
<li><p>用户自定义模块(即自己写的.js文件)</p>
<span id="more"></span></li>
</ul>
<h2 id="1-1核心模块"><a href="#1-1核心模块" class="headerlink" title="1.1核心模块"></a>1.1核心模块</h2><p>Nodejs为JavaScript提供了很多服务器级别的API，这些API绝大多数都被封装到一个具有名字的核心模块中。</p>
<p>如文件操作的<code>fs</code>模块，http服务构建的 <code>http</code>模块，<code>path</code> 路径操作模块，<code>os</code>操作系统信息模块等。。。</p>
<h3 id="1-1-1使用核心模块必须先加载模块"><a href="#1-1-1使用核心模块必须先加载模块" class="headerlink" title="1.1.1使用核心模块必须先加载模块"></a>1.1.1使用核心模块必须先加载模块</h3><p>形如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//require()方法用来加载模块</span></span><br><span class="line"><span class="keyword">var</span> fs=<span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="1-2用户自定义模块"><a href="#1-2用户自定义模块" class="headerlink" title="1.2用户自定义模块"></a>1.2用户自定义模块</h2><p>用户自定义模块：即自己写的.js文件</p>
<h3 id="1-2-1实现简单的模块化"><a href="#1-2-1实现简单的模块化" class="headerlink" title="1.2.1实现简单的模块化"></a>1.2.1实现简单的模块化</h3><p>a.js文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//require()方法会执行相应模块中的代码</span></span><br><span class="line"><span class="comment">//在a.js文件中调用执行b.js自定义模块</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;./b.js&quot;</span>);<span class="comment">//执行b.js后会输出&quot;b.js被执行了&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>b.js文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;b.js被执行了&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>执行a.js文件后输出结果为</p>
<p><img src="/images/02-nodejs%E4%B8%AD%E7%9A%84JavaScript/image-20210412112221108.png" alt="image-20210412112221108"></p>
<h3 id="1-2-2Nodejs中没有全局作用域，只有模块作用域"><a href="#1-2-2Nodejs中没有全局作用域，只有模块作用域" class="headerlink" title="1.2.2Nodejs中没有全局作用域，只有模块作用域"></a>1.2.2Nodejs中没有全局作用域，只有模块作用域</h3><ul>
<li><p>模块作用域</p>
<ul>
<li><p>内部访问不到外部</p>
</li>
<li><p>外部也访问不到内部</p>
</li>
</ul>
</li>
</ul>
<p>a.js文件</p>
<p>在a.js中定义的变量foo只在a.js**文件(模块)**中生效</p>
<p>同样a.js中定义的函数也只能在a.js文件中调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在a.js文件中定义了变量foo，这个foo文件只在a.js这个文件(模块)中生效</span></span><br><span class="line"><span class="keyword">var</span> foo=<span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//require()调用模块时，.js后缀名可以省略</span></span><br><span class="line"><span class="comment">//相对路径的./不能省略</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;./b.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里输出的foo是a.js中的foo=&quot;aaa&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>b.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b.js中定义的foo变量只在b.js文件中生效</span></span><br><span class="line"><span class="comment">//不会影响a.js文件中的foo变量</span></span><br><span class="line"><span class="keyword">var</span> foo=<span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;b.js被执行了&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>运行a.js结果</p>
<p><code>console.log(foo);</code>执行结果为aaa</p>
<p><img src="/images/02-nodejs%E4%B8%AD%E7%9A%84JavaScript/image-20210412113217274.png" alt="image-20210412113217274"></p>
<h3 id="1-2-3模块之间怎样通信"><a href="#1-2-3模块之间怎样通信" class="headerlink" title="1.2.3模块之间怎样通信"></a>1.2.3模块之间怎样通信</h3><ul>
<li>模块作用域默认是互相隔绝的</li>
<li><strong>我们可以使用require实现模块间的通信</strong></li>
</ul>
<p>require()方法有<strong>两个作用</strong></p>
<p>1.加载文件模块并执行其中的代码</p>
<p><strong>2.拿到被加载文件模块导出的接口对象</strong></p>
<ul>
<li><p>require()方法返回被调用模块的导出接口对象exports</p>
</li>
<li><p>每个文件模块中都提供一个对象：exports     (exports意为导出，出口)</p>
</li>
<li><p>exports默认是一个空对象</p>
<ul>
<li>将本模块中<strong>需要被其他模块访问的属性和方法</strong>挂载在exports对象下</li>
<li>其他模块通过require()方法获取本模块的exports对象后就可以访问</li>
</ul>
</li>
</ul>
<p>a.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.js文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//require()方法返回被调用模块的导出接口对象exports</span></span><br><span class="line"><span class="keyword">var</span> ex=<span class="built_in">require</span>(<span class="string">&quot;./b&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用ex.&quot;属性，方法&quot;就可以访问b.js中导出的属性和方法</span></span><br><span class="line"><span class="built_in">console</span>.log(ex.age);</span><br><span class="line"><span class="built_in">console</span>.log(ex.add(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>b.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b.js文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> age=<span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将需要导出的属性和方法挂载在exports对象下</span></span><br><span class="line"><span class="built_in">exports</span>.age=age;</span><br><span class="line"><span class="built_in">exports</span>.add=add;</span><br></pre></td></tr></table></figure>

<p>执行a.js结果为</p>
<p><img src="/images/02-nodejs%E4%B8%AD%E7%9A%84JavaScript/image-20210412120622983.png" alt="image-20210412120622983"></p>
<p><strong>同理</strong></p>
<p><strong>fs和http等核心模块加载后就可以使用其中导出的方法如fs.readFile()等</strong></p>
]]></content>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>03-http核心模块构建简单WEB服务器</title>
    <url>/2021/04/13/03-http%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E6%9E%84%E5%BB%BA%E7%AE%80%E5%8D%95WEB%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="1-http核心模块构建简单WEB服务器"><a href="#1-http核心模块构建简单WEB服务器" class="headerlink" title="1.http核心模块构建简单WEB服务器"></a>1.http核心模块构建简单WEB服务器</h1><span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.引入核心模块http</span></span><br><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建一个WEB服务器</span></span><br><span class="line"><span class="keyword">var</span> server=http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.注册request请求事件</span></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;接受到请求，请求路径为：&quot;</span>+request.url);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> url=request.url;</span><br><span class="line">    <span class="comment">//判断url不同 响应不同的数据</span></span><br><span class="line">    <span class="keyword">if</span>(url==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//可以使用end()直接响应数据后结束</span></span><br><span class="line">            <span class="comment">//响应内容只能是 字符串和二进制数串</span></span><br><span class="line">            <span class="comment">//数字，布尔值，数组，对象等需要使用JSON转换成字符串</span></span><br><span class="line">        response.end(<span class="string">&quot;hello nodejs&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(url==<span class="string">&quot;/login&quot;</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//浏览器在nodejs中没有声明编码格式时按照本机的语言编码进行解析 中文会乱码</span></span><br><span class="line">        <span class="comment">//添加utf-8头部后可以正常显示中文</span></span><br><span class="line">        <span class="comment">// response.write(&#x27;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;/head&gt;&#x27;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//也可以通过如下方式让浏览器按照utf-8编码格式解析执行</span></span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/plain; charset=utf-8&quot;</span>)</span><br><span class="line">        response.end(<span class="string">&quot;登陆页面&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(url==<span class="string">&quot;/shuzu&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">        <span class="comment">//响应字符串&quot;[1,2,3,4]&quot;</span></span><br><span class="line">        response.end(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(url==<span class="string">&quot;/html&quot;</span>)&#123;</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/html; charset=utf-8&quot;</span>) </span><br><span class="line">        <span class="comment">//因为设置了text/html，所以html标签会被浏览器解释执行</span></span><br><span class="line">        response.end(<span class="string">&quot;&lt;p&gt;你好&lt;a&gt;点击超链接&lt;/a&gt;&lt;/p&gt;&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        response.end(<span class="string">&quot;404 Not Found.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.绑定端口号，启动服务器</span></span><br><span class="line">server.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;服务器启动成功，可以通过http://127.0.0.1/3000/访问&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="1-1搭建服务器时的IP和端口号简单解释"><a href="#1-1搭建服务器时的IP和端口号简单解释" class="headerlink" title="1.1搭建服务器时的IP和端口号简单解释"></a>1.1搭建服务器时的IP和端口号简单解释</h2><p>在端口3000上打开服务器</p>
<p>IP标识一台计算机</p>
<p>端口标识一个应用程序</p>
<p>IP:端口号 可以<strong>唯一标识一台计算机上的一个应用程序</strong></p>
<p>这里localhost:3000即为本机上的由<code>nodejs</code>搭建的服务器应用程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.listen(3000,function()&#123;  </span><br><span class="line">    console.log(&quot;服务器启动成功，可以通过http:&#x2F;&#x2F;127.0.0.1&#x2F;3000&#x2F;访问&quot;);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="1-2中文乱码的解决方法"><a href="#1-2中文乱码的解决方法" class="headerlink" title="1.2中文乱码的解决方法"></a>1.2中文乱码的解决方法</h2><p>​    加上头部让浏览器明确以utf-8编码格式解析</p>
<ul>
<li><p>第一种方法</p>
<p>加上<code>response.write(&#39;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;/head&gt;&#39;);</code></p>
</li>
<li><p>第二种方法</p>
<p>加上<code>response.setHeader(&quot;Content-Type&quot;,&quot;text/plain; charset=utf-8&quot;)</code></p>
<p><strong>不同响应内容对应的响应类型是不一样的</strong> 例如text/plain 或 text/html</p>
<p>第二种方法加上的头部可以在浏览器中查看</p>
<p>F12 Network下查看</p>
<p><img src="/images/03-http%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E6%9E%84%E5%BB%BA%E7%AE%80%E5%8D%95WEB%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20210412202501529.png" alt="image-20210412202501529"></p>
<p><img src="/images/03-http%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E6%9E%84%E5%BB%BA%E7%AE%80%E5%8D%95WEB%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20210412202544524.png" alt="image-20210412202544524"></p>
</li>
</ul>
<h2 id="1-3-setHeader-方法"><a href="#1-3-setHeader-方法" class="headerlink" title="1.3 setHeader()方法"></a>1.3 setHeader()方法</h2><p>在响应头部添加响应类型字段</p>
<p><code>res.setHeader(&quot;Content-Type&quot;,&quot;text/plain; charset=utf-8&quot;)</code></p>
<ul>
<li><p>Content-Type，<strong>响应内容类型</strong></p>
<ul>
<li><p>不同的响应内容要填入不同的类型(text/plain、text/html等)</p>
</li>
<li><p>text/plain，为响应数据的格式，text/plain为普通文本，响应的数据会被当作<strong>普通文本</strong>处理(html标签也会被当作普通文本)</p>
</li>
<li><p>text/html，为<strong>html文本</strong>，响应数据中的<strong>html标签会被浏览器自动识别并解释执行</strong></p>
</li>
</ul>
</li>
<li><p>charset=utf-8，指明返回的数据是utf-8格式编码，解决中文乱码问题 </p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>04-web服务器响应文件中的数据</title>
    <url>/2021/04/13/04-web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="web服务器响应文件中的数据"><a href="#web服务器响应文件中的数据" class="headerlink" title="web服务器响应文件中的数据"></a>web服务器响应文件中的数据</h1><h2 id="1-1Nodejs构建web服务器代码如下"><a href="#1-1Nodejs构建web服务器代码如下" class="headerlink" title="1.1Nodejs构建web服务器代码如下"></a>1.1Nodejs构建web服务器代码如下</h2><span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入核心模块http和fs</span></span><br><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs=<span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务器</span></span><br><span class="line"><span class="keyword">var</span> server=http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> url=req.url;</span><br><span class="line">    <span class="keyword">if</span>(url==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//请求时响应html文件</span></span><br><span class="line">        fs.readFile(<span class="string">&quot;todoList.html&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//请求失败时响应普通文本</span></span><br><span class="line">                res.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/plain; charset=utf-8&quot;</span>) </span><br><span class="line">                res.end(<span class="string">&quot;文件读取失败&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//请求成功时响应html文本</span></span><br><span class="line">                res.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/html; charset=utf-8&quot;</span>) </span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//因为html文件中引用了jQuery.js文件，所以要手动添加这个文件的访问路径</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(url==<span class="string">&quot;/jQuery.js&quot;</span>)&#123;</span><br><span class="line">        fs.readFile(<span class="string">&quot;jQuery.js&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)</span><br><span class="line">            &#123;</span><br><span class="line">                res.end(<span class="string">&quot;load faild&quot;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">&quot;3000&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;服务器启动成功,可以访问3000端口&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打开文件中的数据使用fs核心模块的<code>fs.readFile()</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">&quot;todoList.html&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>将返回的文件中数据data用res.end(data)响应给浏览器并加上相应格式的响应类型Content-Type</p>
<p><strong>注意这里的data直接响应给浏览器解释执行，不需要呈现出来查看，所以不需要toString()方法转换为可识别字符串</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/html; charset=utf-8&quot;</span>) </span><br><span class="line">res.end(data);</span><br></pre></td></tr></table></figure>

<p>在浏览器中访问如下</p>
<p><img src="/images/04-web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/image-20210412223931130.png" alt="image-20210412223931130"></p>
<h2 id="1-2如果响应的html文件中有外部引入的文件如css样式或者js文件，则需要手动添加到这些文件的请求url"><a href="#1-2如果响应的html文件中有外部引入的文件如css样式或者js文件，则需要手动添加到这些文件的请求url" class="headerlink" title="1.2如果响应的html文件中有外部引入的文件如css样式或者js文件，则需要手动添加到这些文件的请求url"></a>1.2如果响应的html文件中有外部引入的文件如css样式或者js文件，则需要手动添加到这些文件的请求url</h2><p><img src="/images/04-web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/image-20210412223645626.png" alt="image-20210412223645626"></p>
<p>例如html文件中有外部引入的jQuery.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;./jQuery.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>则需要手动添加到jQuery.js文件的请求url</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(url==<span class="string">&quot;/jQuery.js&quot;</span>)&#123;</span><br><span class="line">        fs.readFile(<span class="string">&quot;jQuery.js&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)</span><br><span class="line">            &#123;</span><br><span class="line">                res.end(<span class="string">&quot;load faild&quot;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="Content-Type内容类型"><a href="#Content-Type内容类型" class="headerlink" title="Content-Type内容类型"></a>Content-Type内容类型</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/plain; charset=utf-8&quot;</span>) </span><br></pre></td></tr></table></figure>

<p>不同的响应内容要填入不同的类型(text/plain、text/html等)</p>
<p><a href="http://tool.oschina.net/commons">http://tool.oschina.net/commons</a></p>
<p>上面的网址可以查看不同类型的数据使用什么响应类型</p>
]]></content>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
</search>
