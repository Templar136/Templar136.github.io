<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01-什么是Node</title>
    <url>/2021/04/13/01-%E4%BB%80%E4%B9%88%E6%98%AFNode.js/</url>
    <content><![CDATA[<h1 id="1-Node-js介绍"><a href="#1-Node-js介绍" class="headerlink" title="1.Node.js介绍"></a>1.Node.js介绍</h1><h2 id="1-1学习Node-js的目的"><a href="#1-1学习Node-js的目的" class="headerlink" title="1.1学习Node.js的目的"></a>1.1学习Node.js的目的</h2><ul>
<li><p>用来<strong>操作使用WEB后台服务器</strong>(能够实现同样功能的后台语言还有java、python、php等)</p>
</li>
<li><p>了解后台服务器才能更好的与后端开发人员协同开发</p>
</li>
<li><p>生态系统活跃，有许多开源库可以使用</p>
</li>
<li><p>前端开发工具大多基于Node开发</p>
</li>
<li><p>学习Node.js实际上就是在学习<strong>WEB服务器开发</strong></p>
</li>
</ul>
<span id="more"></span>

<h2 id="1-2什么是Node-js"><a href="#1-2什么是Node-js" class="headerlink" title="1.2什么是Node.js"></a>1.2什么是Node.js</h2><p>Node.js官网<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p>
<p>官网对于Node.js的描述：</p>
<ul>
<li><p>Node.js® is a JavaScript runtime built on <a href="https://v8.dev/">Chrome’s V8 JavaScript engine</a>.</p>
<ul>
<li><p>Node.js是一个基于Chrome V8引擎的<strong>javaScript运行环境</strong></p>
</li>
<li><p>基于Chrome V8引擎</p>
<ul>
<li>代码只是具有特定格式的字符串</li>
<li>引擎可以帮我们去解释执行这些代码</li>
<li>Google Chrome 的V8引擎是当前公认的解释执行JavaScript最快的</li>
<li>Node.js的作者把Google Chrome的<strong>V8引擎移植出来</strong>，开发了一个<strong>独立的JavaScript运行环境</strong></li>
</ul>
</li>
<li><p>Node.js<strong>不是一门语言</strong></p>
</li>
<li><p>Node.js<strong>不是库、不是框架</strong></p>
</li>
<li><p>Node.js可以解析执行JavaScript代码</p>
</li>
<li><p>以前只有浏览器可以解释执行JavaScript代码</p>
</li>
<li><p>现在Node.js可以使JavaScript脱离浏览器解释执行</p>
</li>
<li><p>浏览器中的JavaScript</p>
<ul>
<li>ECMAScript(基本的语法)</li>
<li>DOM</li>
<li>BOM</li>
<li>DOM和BOM是浏览器给JavaScript提供的API</li>
</ul>
</li>
<li><p>Node.js中的JavaScript</p>
<ul>
<li><p><strong>不同于原来浏览器中的JavaScript</strong></p>
</li>
<li><p><strong>没有DOM、BOM</strong></p>
</li>
<li><p>由<strong>ECMAScript</strong>以及Node环境提供的一些<strong>附加API</strong>组成</p>
</li>
<li><p>Node.js这个JavaScript运行环境为JavaScript提供了一些服务器级别的操作API(应用编程接口)</p>
<ul>
<li>例如文件读写</li>
<li>网络服务构建</li>
<li>网络通信</li>
<li>http服务器等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Node.js uses an event-driven,non-blocking I/O model that makes it lightweight and efficient.</p>
<ul>
<li><p>Node.js的<strong>特性</strong></p>
</li>
<li><p>1、event-driven 事件驱动</p>
</li>
<li><p>2、non-blocking I/O model 无阻塞的I/O模组 (异步)</p>
</li>
<li><p>lightweight and efficient 轻量化和高效的</p>
</li>
</ul>
</li>
<li><p>Node.js’ package ecosystem,npm,is the largest ecosystem of open source libraries in the world.</p>
<ul>
<li>Node.js包生态系统——npm，是世界上最大的开源库生态系统</li>
<li>绝大多数JavaScript相关的包(第三方包等)都存放在npm上，为了让开发人员更方便的下载使用</li>
<li>例如使用 <code>npm install jquery</code>就可以下载jQuery的npm包</li>
</ul>
</li>
</ul>
<h2 id="1-3Node-js能做什么"><a href="#1-3Node-js能做什么" class="headerlink" title="1.3Node.js能做什么"></a>1.3Node.js能做什么</h2><ul>
<li>WEB服务器后台</li>
<li>命令行工具<ul>
<li>npm(Node开发)</li>
<li>git(C语言开发)</li>
<li>hexo(Node开发)</li>
<li>。。。</li>
</ul>
</li>
<li>对于前端工程师来说，接触Node最多的就是它的命令行工具<ul>
<li>主要是使用别人开发的第三方命令行工具<ul>
<li>webpack</li>
<li>gulp</li>
<li>。。。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-4学习资源"><a href="#1-4学习资源" class="headerlink" title="1.4学习资源"></a>1.4学习资源</h2><ul>
<li><p>《深入浅出Node.js》</p>
<ul>
<li>作者：朴(piao)灵</li>
<li>偏理论、没有实例性内容</li>
<li>对于理解底层原理有帮助</li>
<li>结合其他实例来学习更好</li>
</ul>
</li>
<li><p>《Node.js权威指南》</p>
<ul>
<li>API讲解</li>
<li>没有实例</li>
</ul>
</li>
<li><p>CNODE社区：<a href="https://cnodejs.org/">https://cnodejs.org</a></p>
<ul>
<li>其中新手入门有一些参考资料</li>
</ul>
</li>
</ul>
<h2 id="1-5学习Node-js得到什么"><a href="#1-5学习Node-js得到什么" class="headerlink" title="1.5学习Node.js得到什么"></a>1.5学习Node.js得到什么</h2><ul>
<li><p>操作使用WEB服务器后台</p>
</li>
<li><p>B/S编程模型</p>
<ul>
<li>Browser-Server 浏览器-服务器模型</li>
<li>back-end 后端</li>
<li>任何服务器端技术这种B/S编程模型都是一样的</li>
</ul>
</li>
<li><p>Node只是作为我们学习这种B/S编程模型的工具</p>
</li>
<li><p>模块化编程</p>
<ul>
<li>Node中可以像 <code>@import()</code>一样引用加载JavaScript脚本文件</li>
</ul>
</li>
<li><p>Node常用API</p>
</li>
<li><p>异步编程</p>
<ul>
<li>promise</li>
<li>回调函数</li>
<li>async</li>
<li>generator</li>
</ul>
</li>
<li><p>Express Web开发框架</p>
</li>
<li><p>ES6(穿插讲解)</p>
</li>
<li><p>为以后学习Vue，React，angular前端框架打基础</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>02-02-第三方模块</title>
    <url>/2021/04/19/02-02-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h1><p><a href="https://www.npmjs.com/">npmjs.com</a>: 第三方模块的存储和分发仓库</p>
<h2 id="1-第三方模块-nodemon"><a href="#1-第三方模块-nodemon" class="headerlink" title="1.第三方模块 nodemon"></a>1.第三方模块 nodemon</h2><p>nodemon是命令行工具，辅助项目开发</p>
<p>在Node.js中，每次修改文件都需要重新执行文件，比较繁琐</p>
<p>nodemon可以在保存时自动执行文件</p>
<span id="more"></span>

<h3 id="1-2使用"><a href="#1-2使用" class="headerlink" title="1.2使用"></a>1.2使用</h3><ul>
<li><p>安装</p>
<ul>
<li><p><code>npm install nodemon -g</code></p>
</li>
<li><p>命令行工具全局安装使用 -g</p>
</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li>在命令行工具中使用<code>nodemon</code>替代<code>node</code>执行nodejs文件</li>
</ul>
</li>
</ul>
<p><img data-src="/images/02-02-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/image-20210419110644336.png" alt="image-20210419110644336"></p>
<p>执行完文件后会将命令行窗口挂起，等待执行的文件保存，保存文件后会<strong>自动执行文件</strong>，使用Ctrl+C可以退出nodemon</p>
<p>现在在文件中添加一个输出后保存，效果如下</p>
<p><img data-src="/images/02-02-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/image-20210419111005039.png" alt="image-20210419111005039"></p>
<h2 id="2-第三方模块nrm"><a href="#2-第三方模块nrm" class="headerlink" title="2.第三方模块nrm"></a>2.第三方模块nrm</h2><p>nrm(npm registry manager)：npm下载地址切换工具</p>
<p>npm默认下载地址在国外，下载速度较慢，经常断线</p>
<p>nrm可以将下载地址切换为为国内的服务器</p>
<ul>
<li>如阿里巴巴就有这样的服务器，每隔10分钟与官方的node服务器同步一次</li>
<li>使用国内服务器就可以加快下载速度，与使用官方服务器下载的包是一样的</li>
</ul>
<h3 id="2-1下载使用"><a href="#2-1下载使用" class="headerlink" title="2.1下载使用"></a>2.1下载使用</h3><ol>
<li><code>npm install nrm -g </code>   全局安装</li>
<li>使用nrm ls 查询可用下载地址列表<ul>
<li>npm为国外官方下载地址</li>
<li>带*号的是当前选择的下载地址</li>
</ul>
</li>
<li>切换npm下载地址为国内服务器 <code>nrm use 下载地址名称</code><ul>
<li>这里选择阿里巴巴的taobao</li>
</ul>
</li>
</ol>
<p><img data-src="/images/02-02-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/image-20210419113538099.png" alt="image-20210419113538099"></p>
<h2 id="3-第三方模块Gulp"><a href="#3-第三方模块Gulp" class="headerlink" title="3.第三方模块Gulp"></a>3.第三方模块Gulp</h2><p>gulp是一种基于Node平台开发的前端构建工具</p>
<p>可以将机械化的操作编写成任务，在执行时只需要在命令行输入编写好的命令任务就可以。</p>
<p>机器代替手工，加开效率</p>
<h4 id="3-1Gulp能做什么"><a href="#3-1Gulp能做什么" class="headerlink" title="3.1Gulp能做什么"></a>3.1Gulp能做什么</h4><ul>
<li>项目上线时，HTML，CSS，JS代码压缩合并</li>
<li>语法转换(es6转es5，less转css等)</li>
<li>公共文件抽离(修改时只需要修改抽离的文件)</li>
<li>修改文件浏览器自动刷新(之前修改完需要手动刷新)</li>
</ul>
<h4 id="3-2使用Gulp"><a href="#3-2使用Gulp" class="headerlink" title="3.2使用Gulp"></a>3.2使用Gulp</h4><p>下载</p>
<p><code>npm install gulp</code>下载<strong>库文件</strong>，库文件是本地安装，只有当前项目能用</p>
<p>使用</p>
<ol>
<li>在项目根目录下新建gulpfile.js文件(文件名不能随意更改)</li>
<li>重构项目的文件夹结构，src目录下放置源代码文件，dist目录放置构建后的文件</li>
<li>在gulpfile.js中编写任务</li>
<li>在命令行工具中执行gulp任务</li>
</ol>
<h4 id="3-3Gulp提供了哪些编写任务的API"><a href="#3-3Gulp提供了哪些编写任务的API" class="headerlink" title="3.3Gulp提供了哪些编写任务的API"></a>3.3Gulp提供了哪些编写任务的API</h4><ul>
<li>gulp.src()：获取任务要处理的文件</li>
<li>gulp.dest()：输出文件</li>
<li>gulp.task()：建立gulp任务</li>
<li>gulp.watch()：监控文件变化</li>
</ul>
<h4 id="3-4第一个gulp任务"><a href="#3-4第一个gulp任务" class="headerlink" title="3.4第一个gulp任务"></a>3.4第一个gulp任务</h4><p>gulp任务写在gulpfile.js文件中</p>
<p><strong>1.使用 <code>gulp.task(&#39;任务名&#39;,callback</code>)  创建任务</strong></p>
<ul>
<li>两个参数<ul>
<li>任务名，标识任务时使用</li>
<li>回调函数，执行任务就是执行这个函数</li>
</ul>
</li>
</ul>
<p><strong>2.完成复制文件的操作</strong></p>
<ul>
<li>使用 <code>gulp.src(&#39;文件路径/文件名&#39;)</code> 获取文件</li>
<li>在   <code>.pipe()</code> 中写处理代码 </li>
<li><code>.pipe(gulp.dest(&#39;路径/文件名&#39;))</code> 这里将base.css这个文件复制到<code>dist/css</code>文件夹下(css文件夹会自动创建)</li>
</ul>
<p><img data-src="/images/02-02-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/image-20210419193029547.png" alt="image-20210419193029547"></p>
<p><strong>3.执行这个gulp任务需要用到与gulp库文件同名的gulp命令行工具</strong></p>
<p>执行的不是gulpfile.js这个文件，而是文件中的 ‘first’ 任务</p>
<p>所以需要使用gulp命令行工具</p>
<p>1.安装gulp命令行工具</p>
<p><code>npm install gulp-cli -g</code>    命令行工具全局安装</p>
<p>2.使用gulp命令执行gulp任务</p>
<p><code>gulp first</code>  即执行了名为first的任务</p>
<p><img data-src="/images/02-02-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/image-20210419194002502.png" alt="image-20210419194002502"></p>
<ul>
<li><p>输出了<code>我的第一个gulp任务</code></p>
</li>
<li><p>接着在 <code>./dist/css</code>文件夹下也发现了复制的base.css文件</p>
</li>
<li><p>执行成功</p>
</li>
<li><p>Using gulpfile代表使用了gulpfile.js文件</p>
</li>
<li><p>Starting ‘first’ 开始执行first任务</p>
</li>
</ul>
<p><strong>但是在执行时出现了两行红字</strong></p>
<ul>
<li>因为任务可能包含异步代码，所以必须在任务完成执行时发出信号（“异步完成”）。</li>
</ul>
<p>在“Gulp3.x”中，你可以不做这个就离开。如果您没有显式地发出异步完成的信号，那么Gulp只会假定您的任务是同步的，</p>
<p>并且一旦您的任务函数返回，它就完成了。<strong>Gulp4.x在这方面更严格。你必须明确地发出任务完成的信号。</strong></p>
<p>这里我是用的gulp版本为4.0.2，需要明确发出任务完成的信号。</p>
<p><strong>解决办法</strong></p>
<p>在callback回调函数中使用一个done形参，在函数内部的最后加上<code>done()</code> 来标识<strong>异步任务结束</strong></p>
<p><img data-src="/images/02-02-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/image-20210419195502159.png" alt="image-20210419195502159"></p>
<p>此时不再报错</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>02-nodejs中JavaScript的模块化</title>
    <url>/2021/04/13/02-nodejs%E4%B8%ADJavaScript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Nodejs的模块化"><a href="#Nodejs的模块化" class="headerlink" title="Nodejs的模块化"></a>Nodejs的模块化</h1><h2 id="1-浏览器JavaScript开发弊端"><a href="#1-浏览器JavaScript开发弊端" class="headerlink" title="1.浏览器JavaScript开发弊端"></a>1.浏览器JavaScript开发弊端</h2><p>浏览器JavaScript在使用时存在两大问题</p>
<ul>
<li>文件依赖<ul>
<li>通过script标签引入的多个js文件的依赖关系不明确，查找依赖关系不便</li>
</ul>
</li>
<li>命名冲突<ul>
<li>浏览器JavaScript通过script引入的多个js文件是<strong>完全开放</strong>的，例如a.js里声明的变量可以在b.js中访问</li>
<li>如果在后续引入的js文件中声明了一个之前引入的js文件中已有的变量，就会导致之前的变量声明被后来的覆盖</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="2-软件中的模块化"><a href="#2-软件中的模块化" class="headerlink" title="2.软件中的模块化"></a>2.软件中的模块化</h2><p>一个功能就是一个模块，多个模块可以组成完整的应用，抽离一个模块不会影响其他功能的运行。</p>
<p>比如用户页面有增加用户和删除用户两个模块</p>
<p>​    抽离删除用户的模块并不会影响增加用户的功能</p>
<h2 id="3-Nodejs模块化开发"><a href="#3-Nodejs模块化开发" class="headerlink" title="3.Nodejs模块化开发"></a>3.Nodejs模块化开发</h2><p>Nodejs的模块化开发可以解决浏览器中JavaScript开发的两大弊端</p>
<h3 id="3-1Nodejs的模块化开发规范"><a href="#3-1Nodejs的模块化开发规范" class="headerlink" title="3.1Nodejs的模块化开发规范"></a>3.1Nodejs的模块化开发规范</h3><p>Nodejs规定<strong>一个JavaScript文件就是一个模块</strong>。</p>
<p>Nodejs中引入的多个模块(JS文件)处于<strong>半封闭状态。</strong></p>
<p>Nodejs中导入模块使用require()方法</p>
<ul>
<li>require(“导入模块的路径”)</li>
<li>模块的”.js”后缀可以省略，require(a)就代表导入当前目录下的a.js模块</li>
</ul>
<h4 id="3-1-1模块成员导出的两种方式"><a href="#3-1-1模块成员导出的两种方式" class="headerlink" title="3.1.1模块成员导出的两种方式"></a>3.1.1模块成员导出的两种方式</h4><p>半封闭的模块可以将<strong>希望被外界访问的成员</strong>导出</p>
<ol>
<li><p>通过<strong>exports</strong>导出接口对象</p>
<ul>
<li><p>只有挂载在<strong>exports导出接口对象</strong>上的成员才能被外界访问</p>
</li>
<li><p>使用require()方法可以导入其他模块</p>
<ul>
<li><p>require()方法有<strong>两个作用</strong></p>
<p>**1.**加载模块并执行其中的代码</p>
<p><strong>2.<strong>拿到被加载模块的</strong>导出接口对象exports</strong>(require的返回值）</p>
<ul>
<li>通过<code>require的返回值.成员</code>即可访问导出的成员</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>通过<strong>module.exports</strong>导出接口对象</p>
<ul>
<li>挂载在<strong>module.exports导出接口对象</strong>上的成员也能被外界访问</li>
</ul>
</li>
</ol>
<h4 id="3-1-2两种导出方式的区别"><a href="#3-1-2两种导出方式的区别" class="headerlink" title="3.1.2两种导出方式的区别"></a>3.1.2两种导出方式的区别</h4><p>exports是module.exports的别名(地址引用关系，内存空间相同)</p>
<p>若两者指向的内存空间变化后不再相同，此时导出对象<strong>最终以module.exports为准</strong></p>
<ul>
<li>例如我们手动操作<code>module.exports=&#123;name:&#39;yangxiao&#39;&#125;</code></li>
<li>此时更改了module.exports对象指向的内存空间，此时module.exports和exports指向不同的内存空间</li>
<li>这时候导出接口对象以module.exports为准，exports不再作为导出接口对象</li>
</ul>
<h3 id="3-2核心-系统-模块"><a href="#3-2核心-系统-模块" class="headerlink" title="3.2核心(系统)模块"></a>3.2核心(系统)模块</h3><p>Nodejs的模块包含：</p>
<ul>
<li>核心(系统)模块(fs,http等)</li>
<li>用户自定义模块(即自己写的.js文件)</li>
<li>第三方模块</li>
</ul>
<p><strong>Node运行环境为JavaScript提供</strong>了很多服务器级别的API，这些API绝大多数都被封装到一个具有名字的<strong>核心模块</strong>中。</p>
<p>如文件操作的<code>fs</code>模块，http服务构建的 <code>http</code>模块，<code>path</code> 路径操作模块，<code>os</code>操作系统信息模块等。。。</p>
<h4 id="3-2-1使用核心模块必须先加载模块"><a href="#3-2-1使用核心模块必须先加载模块" class="headerlink" title="3.2.1使用核心模块必须先加载模块"></a>3.2.1使用核心模块必须先加载模块</h4><p>形如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//require()方法用来加载模块</span></span><br><span class="line"><span class="keyword">var</span> fs=<span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http);</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3用户自定义模块"><a href="#3-3用户自定义模块" class="headerlink" title="3.3用户自定义模块"></a>3.3用户自定义模块</h3><p>用户自定义模块：即自己写的.js文件</p>
<h3 id="3-4第三方模块"><a href="#3-4第三方模块" class="headerlink" title="3.4第三方模块"></a>3.4第三方模块</h3><p>第三方模块是别人写好的，具有特定功能的，我们可以直接使用的模块。</p>
<p>第三方模块通常<strong>由多个文件组成并且放在文件夹中</strong>，所以又名<strong>包</strong>。</p>
<h4 id="3-4-1第三方模块的两种存在方式"><a href="#3-4-1第三方模块的两种存在方式" class="headerlink" title="3.4.1第三方模块的两种存在方式"></a>3.4.1第三方模块的两种存在方式</h4><ul>
<li>以<strong>js文件</strong>存在，提供实现项目具体功能的API。</li>
<li>以<strong>命令行工具</strong>形式存在，辅助项目开发。</li>
</ul>
<h4 id="3-4-2获取第三方模块"><a href="#3-4-2获取第三方模块" class="headerlink" title="3.4.2获取第三方模块"></a>3.4.2获取第三方模块</h4><p><a href="https://www.npmjs.com/">npmjs.com</a>: 第三方模块的存储和分发仓库</p>
<p>npm: Node的包(第三方模块)管理工具，npm本身也是Node的第三方模块，npm在Node安装时就自动安装</p>
<p>使用npm获取第三方模块：</p>
<ul>
<li><strong>下载</strong> <code>npm install 模块名</code><ul>
<li>下载到命令行工具的当前目录下</li>
<li>在当前目录自动创建一个node_modules文件夹，下载的包就存放在这个文件夹下</li>
<li>还会在当前目录创建一个package-lock.json文件</li>
</ul>
</li>
<li><strong>卸载</strong> <code>npm uninstall package 模块名</code><ul>
<li>若删除包后node_modules文件夹为空，则会自动删除node_modules文件夹</li>
</ul>
</li>
<li><strong>全局安装</strong>和<strong>本地安装</strong><ul>
<li>本地安装：将模块下载到当前项目中，仅供<strong>当前项目</strong>使用<ul>
<li>一般将<strong>库文件</strong>本地安装</li>
</ul>
</li>
<li>全局安装：将项目安装到一个公共目录，<strong>所有的项目</strong>都可以使用<ul>
<li>一般将<strong>命令行工具</strong>全局安装</li>
</ul>
</li>
<li>上面给出的下载命令<code>npm install 模块名</code>是本地安装</li>
</ul>
</li>
</ul>
<h2 id="4-实现简单的模块化"><a href="#4-实现简单的模块化" class="headerlink" title="4.实现简单的模块化"></a>4.实现简单的模块化</h2><p>a.js文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//require()方法会执行相应模块中的代码</span></span><br><span class="line"><span class="comment">//在a.js文件中调用执行b.js自定义模块</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;./b.js&quot;</span>);<span class="comment">//执行b.js后会输出&quot;b.js被执行了&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>b.js文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;b.js被执行了&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>执行a.js文件后输出结果为</p>
<p><img data-src="/images/02-nodejs%E4%B8%ADJavaScript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/image-20210412112221108.png" alt="image-20210412112221108"></p>
<h3 id="4-1Nodejs中没有全局作用域，只有模块作用域"><a href="#4-1Nodejs中没有全局作用域，只有模块作用域" class="headerlink" title="4.1Nodejs中没有全局作用域，只有模块作用域"></a>4.1Nodejs中没有全局作用域，只有模块作用域</h3><ul>
<li><p>模块作用域</p>
<ul>
<li><p>内部访问不到外部</p>
</li>
<li><p>外部也访问不到内部</p>
</li>
</ul>
</li>
</ul>
<p>a.js文件</p>
<p>在a.js中定义的变量foo只在a.js**文件(模块)**中生效</p>
<p>同样a.js中定义的函数也只能在a.js文件中调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在a.js文件中定义了变量foo，这个foo文件只在a.js这个文件(模块)中生效</span></span><br><span class="line"><span class="keyword">var</span> foo=<span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//require()调用模块时，.js后缀名可以省略</span></span><br><span class="line"><span class="comment">//相对路径的./不能省略</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;./b.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里输出的foo是a.js中的foo=&quot;aaa&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>b.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b.js中定义的foo变量只在b.js文件中生效</span></span><br><span class="line"><span class="comment">//不会影响a.js文件中的foo变量</span></span><br><span class="line"><span class="keyword">var</span> foo=<span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;b.js被执行了&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>运行a.js结果</p>
<p><code>console.log(foo);</code>执行结果为aaa</p>
<p><img data-src="/images/02-nodejs%E4%B8%ADJavaScript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/image-20210412113217274.png" alt="image-20210412113217274"></p>
<h3 id="4-2模块之间怎样通信"><a href="#4-2模块之间怎样通信" class="headerlink" title="4.2模块之间怎样通信"></a>4.2模块之间怎样通信</h3><ul>
<li><p>模块作用域默认是半封闭</p>
</li>
<li><p>我们可以使用<strong>exports导出接口对象</strong>实现模块间的通信</p>
<ul>
<li>require()方法返回被调用模块的导出接口对象exports</li>
<li>每个文件模块中都提供一个对象：<strong>exports</strong>     (exports意为导出，出口)</li>
</ul>
</li>
<li><p>exports默认是一个空对象</p>
<ul>
<li>将本模块中<strong>需要被其他模块访问的属性和方法</strong>挂载在exports对象下</li>
<li>其他模块通过require()方法获取本模块的exports对象后就可以访问</li>
</ul>
</li>
</ul>
<p>a.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.js文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//require()方法返回被调用模块的导出接口对象exports</span></span><br><span class="line"><span class="keyword">var</span> ex=<span class="built_in">require</span>(<span class="string">&quot;./b&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用ex.&quot;属性，方法&quot;就可以访问b.js中导出的属性和方法</span></span><br><span class="line"><span class="built_in">console</span>.log(ex.age);</span><br><span class="line"><span class="built_in">console</span>.log(ex.add(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>b.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b.js文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> age=<span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将需要导出的属性和方法挂载在exports对象下</span></span><br><span class="line"><span class="built_in">exports</span>.age=age;</span><br><span class="line"><span class="built_in">exports</span>.add=add;</span><br></pre></td></tr></table></figure>

<p>执行a.js结果为</p>
<p><img data-src="/images/02-nodejs%E4%B8%ADJavaScript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/image-20210412120622983.png" alt="image-20210412120622983"></p>
<p><strong>同理</strong></p>
<p><strong>fs和http等核心模块加载后就可以使用其中导出的方法如fs.readFile()等</strong></p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>02-01-系统核心模块</title>
    <url>/2021/04/15/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="系统-核心-模块"><a href="#系统-核心-模块" class="headerlink" title="系统(核心)模块"></a>系统(核心)模块</h1><h2 id="1-fs模块"><a href="#1-fs模块" class="headerlink" title="1.fs模块"></a>1.fs模块</h2><p>文件系统file system模块</p>
<h3 id="1-1-fs-read-方法"><a href="#1-1-fs-read-方法" class="headerlink" title="1.1 fs.read()方法"></a>1.1 fs.read()方法</h3><p>读取文件数据方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.read(<span class="string">&quot;文件路径/文件名&quot;</span>[,<span class="string">&quot;文件编码格式&quot;</span>],callback)</span><br></pre></td></tr></table></figure>

<p>文件路径：文件存放路径</p>
<span id="more"></span>

<p>文件编码格式：utf-8等</p>
<p>callback回调函数：</p>
<ul>
<li>有两个参数err和data<ul>
<li>err错误对象<ul>
<li>如果读取出错则err为错误对象</li>
<li>如果正确则err为null</li>
</ul>
</li>
<li>data文件数据<ul>
<li>默认以二进制数串的16进制形式保存</li>
<li>如果指定了”文件编码格式“就按照编码格式输出</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;./fs.txt&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;文件读取出错&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;以二进制数串的16进制表示文件数据&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;./fs.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;文件读取出错&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;以utf-8编码格式打印文件数据&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210415211208528.png" alt="image-20210415211208528"></p>
<h3 id="1-2-插入-Nodejs中的回调函数callback"><a href="#1-2-插入-Nodejs中的回调函数callback" class="headerlink" title="1.2(插入)Nodejs中的回调函数callback"></a>1.2(插入)Nodejs中的回调函数callback</h3><p>Nodejs中所有API的回调函数的第一个参数一定是err</p>
<ul>
<li>在发生错误时err为错误对象</li>
<li>正确执行时err为null</li>
</ul>
<p>所以Nodejs中的回调函数又被称为错误优先的回调函数</p>
<h3 id="1-3-fs-writeFile-方法"><a href="#1-3-fs-writeFile-方法" class="headerlink" title="1.3 fs.writeFile()方法"></a>1.3 fs.writeFile()方法</h3><p>写入文件方法</p>
<p>文件不存在时会自动创建</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.writeFile(<span class="string">&#x27;文件路径/文件名&#x27;</span>,<span class="string">&#x27;写入的数据&#x27;</span>,callback)</span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<p>​    程序运行报错时，自动将报错信息写入错误日志(一个文件)中</p>
<p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.writeFile(<span class="string">&#x27;./fs.writeFile.txt&#x27;</span>,<span class="string">&#x27;写入fs.writeFile.txt中的数据&#x27;</span>,<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err!==<span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;写入失败&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;写入成功&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210415212815487.png" alt="image-20210415212815487"></p>
<p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210415212837679.png" alt="image-20210415212837679"></p>
<h2 id="2-path模块"><a href="#2-path模块" class="headerlink" title="2. path模块"></a>2. path模块</h2><p>路径操作</p>
<h3 id="2-1为什么要进行路径拼接"><a href="#2-1为什么要进行路径拼接" class="headerlink" title="2.1为什么要进行路径拼接"></a>2.1为什么要进行路径拼接</h3><p>不同操作系统的路径分隔符不同</p>
<ul>
<li>window使用 / 或 \</li>
<li>Linux只能使用 /</li>
</ul>
<p>Nodejs写的代码可能要在不同的操作系统上使用，所以要明确使用什么路径分隔符</p>
<h3 id="2-2-path-join"><a href="#2-2-path-join" class="headerlink" title="2.2 path.join()"></a>2.2 path.join()</h3><p>路径拼接API</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">path.join(<span class="string">&#x27;路径&#x27;</span>,<span class="string">&#x27;路径&#x27;</span>,...)</span><br></pre></td></tr></table></figure>

<p>这个API会自动检测当前系统并使用合适的分隔符</p>
<p>返回拼接之后的结果</p>
<p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前是windows系统，采用&#x27;\&#x27;作为分隔符</span></span><br><span class="line"><span class="comment">//输出a\b\c.txt</span></span><br><span class="line"><span class="built_in">console</span>.log(path.join(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c.txt&#x27;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210415220350958.png" alt="image-20210415220350958"></p>
<h3 id="2-3相对路径和绝对路径"><a href="#2-3相对路径和绝对路径" class="headerlink" title="2.3相对路径和绝对路径"></a>2.3相对路径和绝对路径</h3><ul>
<li><p>大多数情况使用绝对路径</p>
</li>
<li><p>相对路径有时候相对的是命令行工具的当前目录</p>
</li>
<li><p>读取文件和设置文件时都选择绝对路径</p>
</li>
<li><p>使用__dirname可以获取当前文件所在目录的绝对路径</p>
</li>
</ul>
<h4 id="1-相对路径有时候相对的是命令行工具的当前目录"><a href="#1-相对路径有时候相对的是命令行工具的当前目录" class="headerlink" title="1.相对路径有时候相对的是命令行工具的当前目录"></a>1.相对路径有时候相对的是命令行工具的当前目录</h4><h5 id="1-1命令行工具当前目录与执行的文件所在目录相同时"><a href="#1-1命令行工具当前目录与执行的文件所在目录相同时" class="headerlink" title="1.1命令行工具当前目录与执行的文件所在目录相同时"></a>1.1命令行工具当前目录与执行的文件所在目录相同时</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path=<span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时使用相对路径打开当前目录下的01-path。。。文件</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;./01-path.join.js&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210416110904752.png" alt="image-20210416110904752"></p>
<p>此时在<strong>02-绝对路径和相对路径.js</strong>使用相对路径打开当前目录下的<strong>01-path.join.js</strong>文件</p>
<p>由于命令行工具的当前目录就是执行文件的目录</p>
<p>所以readFile()中<code>./01-path.join.js</code>实际打开的文件为<strong>E:\HTML_CSS_JS学习\nodejs\new\02-核心模块path\01-path.join.js</strong></p>
<p>所以此时使用相对路径不会引起问题</p>
<h5 id="1-2命令行工具当前目录与执行的文件所在目录不同时"><a href="#1-2命令行工具当前目录与执行的文件所在目录不同时" class="headerlink" title="1.2命令行工具当前目录与执行的文件所在目录不同时"></a>1.2命令行工具当前目录与执行的文件所在目录不同时</h5><p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210416111449458.png" alt="image-20210416111449458"></p>
<p>此时命令行工具的当前目录为E:\HTML_CSS_JS学习\nodejs\new</p>
<p>执行文件所在目录为E:\HTML_CSS_JS学习\nodejs\new\02-核心模块path</p>
<p>两个目录所在位置不同</p>
<p>readFile()方法中的url如果写相对路径，则这个<strong>相对路径就相对于命令行工具目录</strong></p>
<p>此时readFile()中<code>./01-path.join.js</code>实际打开的文件为<strong>E:\HTML_CSS_JS学习\nodejs\new\01-path.join.js</strong></p>
<p>即相对路径相对于命令行工具的当前目录（上图红框）</p>
<p>此时因为找不到<strong>E:\HTML_CSS_JS学习\nodejs\new\01-path.join.js</strong>文件，会报错<code>no such file or directory</code></p>
<p>所以打开或设置文件时使用相对路径是<strong>不安全的</strong>，容易导致错误</p>
<h4 id="2-在require-中的相对路径比较特殊，就是相对于当前执行文件所在的目录"><a href="#2-在require-中的相对路径比较特殊，就是相对于当前执行文件所在的目录" class="headerlink" title="2.在require()中的相对路径比较特殊，就是相对于当前执行文件所在的目录"></a><strong>2.在require()中的相对路径比较特殊，就是相对于当前执行文件所在的目录</strong></h4><h4 id="3-读取文件和设置文件时都选择绝对路径"><a href="#3-读取文件和设置文件时都选择绝对路径" class="headerlink" title="3.读取文件和设置文件时都选择绝对路径"></a>3.读取文件和设置文件时都选择绝对路径</h4><p>nodejs中使用<code>__dirname</code>可以获取当前文件所在目录的绝对路径</p>
<p>使用<code>__dirname</code>和当前文件名进行路径拼接就可以<strong>方便的得到当前文件的绝对路径</strong></p>
<p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210416113339756.png" alt="image-20210416113339756"></p>
<p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210416113325415.png" alt="image-20210416113325415"></p>
<p>此时红框中第一行即为<code>__dirname</code>,当前执行文件所在目录</p>
<p>红框第二行即为拼接后的要打开文件的绝对路径</p>
<p>此时命令行工具目录与执行文件所在目录不同</p>
<p>因为代码使用了绝对路径，不会发生找不到文件的错误</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>03-第三方模块Gulp</title>
    <url>/2021/04/19/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/</url>
    <content><![CDATA[<h1 id="Gulp第三方模块"><a href="#Gulp第三方模块" class="headerlink" title="Gulp第三方模块"></a>Gulp第三方模块</h1><h2 id="Gulp的插件"><a href="#Gulp的插件" class="headerlink" title="Gulp的插件"></a>Gulp的插件</h2><p>Gulp是轻内核级第三方插件，本身提供的方法很少，只有几种</p>
<ul>
<li>gulp.src()：获取任务要处理的文件</li>
<li>gulp.dest()：输出文件</li>
<li>gulp.task()：建立gulp任务</li>
<li>gulp.watch()：监控文件变化</li>
</ul>
<span id="more"></span>

<p>其他的功能都是<strong>通过插件的形式</strong>实现的</p>
<ul>
<li>gulp-htmlmin：html文件压缩</li>
<li>gulp-csso：css文件压缩</li>
<li>gulp-babel：JavaScript语法转化 (ES6 -&gt; ES5)</li>
<li>gulp-less：less转换为css</li>
<li>broswersync：浏览器实时同步</li>
<li>gulp-file-include：提取公共文件</li>
</ul>
<h3 id="1-Gulp插件使用"><a href="#1-Gulp插件使用" class="headerlink" title="1.Gulp插件使用"></a>1.Gulp插件使用</h3><ol>
<li>下载<ul>
<li>在<a href="https://www.npmjs.com/">npmjs.com</a>官网中可以搜索gulp模块的插件 (有完整使用说明)</li>
<li>使用npm命令安装</li>
</ul>
</li>
<li>在gulpfile.js文件中引入插件<ul>
<li>require()方法</li>
</ul>
</li>
<li>调用插件</li>
</ol>
<h4 id="1-1HTML操作插件"><a href="#1-1HTML操作插件" class="headerlink" title="1.1HTML操作插件"></a>1.1HTML操作插件</h4><h5 id="1-html文件代码压缩任务"><a href="#1-html文件代码压缩任务" class="headerlink" title="1.html文件代码压缩任务"></a>1.html文件代码压缩任务</h5><p>在项目上线服务器运行时代码一般要经过压缩</p>
<p>安装html压缩插件</p>
<p><code>npm install gulp-htmlmin</code>  </p>
<p>创建任务</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//压缩html文件代码任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入gulp的htmlmin插件</span></span><br><span class="line"><span class="keyword">const</span> htmlmin=<span class="built_in">require</span>(<span class="string">&#x27;gulp-htmlmin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">&#x27;htmlmin&#x27;</span>, <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//&#x27;*&#x27;匹配所有html文件</span></span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/*.html&#x27;</span>)</span><br><span class="line">    <span class="comment">//使用插件的方法压缩html文件</span></span><br><span class="line">    <span class="comment">//collapseWhitespace意为压缩空格</span></span><br><span class="line">    .pipe(htmlmin(&#123; <span class="attr">collapseWhitespace</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">    <span class="comment">//输出到dist文件夹</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在powershell中执行后，./dist文件夹下产生两个同名的html文件，里面的代码都被压缩为1行显示</p>
<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210419212228699.png" alt="image-20210419212228699"></p>
<h5 id="2-提取html文件中的公共代码"><a href="#2-提取html文件中的公共代码" class="headerlink" title="2.提取html文件中的公共代码"></a>2.提取html文件中的公共代码</h5><p>提取公共代码可以在代码变化时只需要修改公共代码，而不用修改每一个html文件，提高效率</p>
<ul>
<li>下载插件</li>
</ul>
<p><code>npm install gulp-file-include</code></p>
<ul>
<li>找到公共代码</li>
</ul>
<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210419213419546.png" alt="image-20210419213419546"></p>
<p>两个html文件同属一个网站，他们的头部框架都是相同的，头部框架就是<strong>公共代码</strong></p>
<ul>
<li>提取公共代码</li>
</ul>
<p>在src文件夹下创建common文件夹，文件夹中创建header.html用来存放两个html的公共代码</p>
<p>将公共代码即头部框架剪切到header.html文件中，删除html文件中的公共代码(后面通过header.html引回)</p>
<p>在gulpfile.js中引入模块插件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fileinclude = <span class="built_in">require</span>(<span class="string">&#x27;gulp-file-include&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>gulpfile.js的任务代码，两个功能(提取代码，压缩html)合并为一个任务</p>
<p>任务中使用插件方法<code>fileinclude()</code></p>
<p>具体插件使用方法<a href="https://www.npmjs.com/package/gulp-file-include">gulp-file-include</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.压缩html文件代码任务</span></span><br><span class="line"><span class="comment">//2.抽取html文件的公共代码</span></span><br><span class="line"><span class="comment">//在压缩前先提取公共代码</span></span><br><span class="line">gulp.task(<span class="string">&#x27;htmlmin&#x27;</span>, <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//&#x27;*&#x27;匹配所有html文件</span></span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/*.html&#x27;</span>)</span><br><span class="line">    <span class="comment">//使用插件抽取公共代码</span></span><br><span class="line">    .pipe(fileinclude())</span><br><span class="line">    <span class="comment">//使用插件的方法压缩html文件</span></span><br><span class="line">    .pipe(htmlmin(&#123; <span class="attr">collapseWhitespace</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">    <span class="comment">//输出到dist文件夹</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在html文件中使用<code>@@include(&#39;./common/header.html&#39;)</code> ， 将公共代码引回文件中</p>
<p>gulpfile.js文件中的任务使用了<code>fileinclude()</code>插件方法后，才能在html文件中使用<code>@@include(&#39;公共代码文件路径&#39;)</code></p>
<p>此时执行<code>htmlmin</code>任务，<strong>公共代码被引回html文件</strong>，并且<strong>html文件被压缩为一行</strong></p>
<h4 id="1-2-CSS和less操作插件"><a href="#1-2-CSS和less操作插件" class="headerlink" title="1.2 CSS和less操作插件"></a>1.2 CSS和less操作插件</h4><h5 id="1-less语法转换"><a href="#1-less语法转换" class="headerlink" title="1.less语法转换"></a>1.less语法转换</h5><p>下载将less文件转换为css的gulp插件</p>
<p><a href="https://www.npmjs.com/package/gulp-less">gulp-less官方文档</a></p>
<p><code>npm install gulp-less</code></p>
<p>在gulpfiles.js文件中引入插件并编写任务</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入less代码转css代码的插件</span></span><br><span class="line"><span class="keyword">const</span> less = <span class="built_in">require</span>(<span class="string">&#x27;gulp-less&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.less代码转css代码</span></span><br><span class="line"><span class="comment">//2.压缩css代码</span></span><br><span class="line">gulp.task(<span class="string">&#x27;cssmin&#x27;</span>,<span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//取src目录下所有less文件</span></span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/*.less&#x27;</span>)</span><br><span class="line">    .pipe(less())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./dist/css&#x27;</span>))</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>a.less文件被转换为a.css文件</p>
<center>a.less文件</center>

<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210425172427623.png" alt="image-20210425172427623"></p>
<center>a.css文件</center>

<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210425172652353.png" alt="image-20210425172652353"></p>
<h5 id="2-css代码压缩"><a href="#2-css代码压缩" class="headerlink" title="2.css代码压缩"></a>2.css代码压缩</h5><p><code>gulp.src([&#39;路径&#39;,&#39;路径])</code>的参数可以传递一个数组，数组中的每个元素是一个路径，将这些路径指示的文件全部获取。</p>
<p>下载gulp-csso插件</p>
<p><a href="https://www.npmjs.com/package/gulp-csso">gulp-csso官方文档</a></p>
<p><code>npm install gulp-csso</code></p>
<p>代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//css压缩</span></span><br><span class="line"><span class="keyword">const</span> csso = <span class="built_in">require</span>(<span class="string">&#x27;gulp-csso&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.less代码转css代码</span></span><br><span class="line"><span class="comment">//2.压缩css代码</span></span><br><span class="line">gulp.task(<span class="string">&#x27;cssmin&#x27;</span>,<span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//取src/css目录下所有less文件</span></span><br><span class="line">    gulp.src([<span class="string">&#x27;./src/css/*.less&#x27;</span>,<span class="string">&#x27;./src/css/*.css&#x27;</span>])</span><br><span class="line">    <span class="comment">//less代码转换</span></span><br><span class="line">    .pipe(less())</span><br><span class="line">    <span class="comment">//css压缩</span></span><br><span class="line">    .pipe(csso())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./dist/css&#x27;</span>))</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>压缩后代码</center>

<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210425173744670.png" alt="image-20210425173744670"></p>
<h4 id="1-3JS操作插件"><a href="#1-3JS操作插件" class="headerlink" title="1.3JS操作插件"></a>1.3JS操作插件</h4><p>下载插件</p>
<p><a href="https://www.npmjs.com/package/gulp-babel">gulp-babel官方文档</a></p>
<p><code>npm install gulp-babel @babel/core @babel/preset-env</code></p>
<p>@babel/core 和 @babel/preset-env 是gulp-babel依赖的包，一起下载</p>
<h5 id="1-ES6代码转换"><a href="#1-ES6代码转换" class="headerlink" title="1.ES6代码转换"></a>1.ES6代码转换</h5><p>代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//js任务</span></span><br><span class="line"><span class="comment">//1.ES6代码转换</span></span><br><span class="line"><span class="comment">//2.js代码压缩</span></span><br><span class="line">gulp.task(<span class="string">&#x27;jsmin&#x27;</span>,<span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/js/*.js&#x27;</span>)</span><br><span class="line">    .pipe(babel(&#123;</span><br><span class="line">        <span class="comment">//presets 自动判断当前环境，将代码转换为当前支持的格式</span></span><br><span class="line">        presets: [<span class="string">&#x27;@babel/env&#x27;</span>]</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./dist/js&#x27;</span>))</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center><strong>转换结果</strong></center>

<p>将右侧的ES6代码转换为左侧的<strong>严格模式的ES5代码</strong></p>
<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210425175329969.png" alt="image-20210425175329969"></p>
<h5 id="2-js代码压缩"><a href="#2-js代码压缩" class="headerlink" title="2.js代码压缩"></a>2.js代码压缩</h5><p>gulp-uglify 插件 ：压缩js代码</p>
<p>下载插件</p>
<p><a href="https://www.npmjs.com/package/gulp-uglify">gulp-uglify官方文档</a></p>
<p><code>npm install gulp-uglify</code></p>
<p>代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//js代码压缩</span></span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">&#x27;gulp-uglify&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//js任务</span></span><br><span class="line"><span class="comment">//1.ES6代码转换</span></span><br><span class="line"><span class="comment">//2.js代码压缩</span></span><br><span class="line">gulp.task(<span class="string">&#x27;jsmin&#x27;</span>,<span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/js/*.js&#x27;</span>)</span><br><span class="line">    <span class="comment">//ES6转换</span></span><br><span class="line">    .pipe(babel(&#123;</span><br><span class="line">        <span class="comment">//presets 自动判断当前环境，将代码转换为当前支持的格式</span></span><br><span class="line">        presets: [<span class="string">&#x27;@babel/env&#x27;</span>]</span><br><span class="line">    &#125;))</span><br><span class="line">    <span class="comment">//js代码压缩</span></span><br><span class="line">    .pipe(uglify())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./dist/js&#x27;</span>))</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<center>ES6转换并压缩后文件</center>

<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210425180011653.png" alt="image-20210425180011653"></p>
<h4 id="1-4文件拷背"><a href="#1-4文件拷背" class="headerlink" title="1.4文件拷背"></a>1.4文件拷背</h4><p>代码</p>
<ul>
<li>此处/*代表匹配一级的所有文件和目录<ul>
<li>若使用images/*来匹配images/a/b.jpg ，则<strong>只能匹配到images/a这个文件夹</strong>，不会匹配到b.jpg</li>
<li>此时匹配获取文件后输出的images/a文件夹是空的</li>
</ul>
</li>
<li>lib/**/*代表匹配lib文件夹下的所有目录<strong>及其子目录</strong>中的文件<ul>
<li>**代表匹配所有目录及其子目录</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将剩下的images文件夹和lib文件夹拷贝到dist文件夹下</span></span><br><span class="line">gulp.task(<span class="string">&#x27;copy&#x27;</span>,<span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/images/*&#x27;</span>)</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./dist/images&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/lib/**/*&#x27;</span>)</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./dist/lib&#x27;</span>))</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="1-5一次执行多个任务"><a href="#1-5一次执行多个任务" class="headerlink" title="1.5一次执行多个任务"></a>1.5一次执行多个任务</h4><p>代码</p>
<p>执行default任务时依次执行后面数组中的每个任务</p>
<ul>
<li><strong>gulp4.0及更高版本</strong>需要使用<code>gulp.parallel(&#39;任务名&#39;,&#39;任务名&#39;,...)</code>来执行多个任务</li>
<li>gulp4.0之前的版本可以使用<code>gulp.task(&#39;default&#39;,[&#39;任务名&#39;,&#39;任务名&#39;,...])</code>来执行多个任务</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">&#x27;default&#x27;</span>,gulp.parallel(<span class="string">&#x27;htmlmin&#x27;</span>,<span class="string">&#x27;cssmin&#x27;</span>,<span class="string">&#x27;jsmin&#x27;</span>,<span class="string">&#x27;copy&#x27;</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>在命令行中执行gulp命令，gulp会自动在gulpfile.js文件中寻找名为default的任务并执行</li>
<li>在命令行中执行<code>gulp</code>相当于执行<code>gulp default</code></li>
</ul>
<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210426112637572.png" alt="image-20210426112637572"></p>
<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210426112702650.png" alt="image-20210426112702650"></p>
<ul>
<li>此时只需执行default任务就可以执行项目中所有的任务</li>
</ul>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>http核心模块构建简单WEB服务器</title>
    <url>/2021/04/13/http%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E6%9E%84%E5%BB%BA%E7%AE%80%E5%8D%95WEB%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="1-http核心模块构建简单WEB服务器"><a href="#1-http核心模块构建简单WEB服务器" class="headerlink" title="1.http核心模块构建简单WEB服务器"></a>1.http核心模块构建简单WEB服务器</h1><span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Node中有一个核心模块：http</span></span><br><span class="line"><span class="comment">//这个模块就是用来创建编写服务器的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器</span></span><br><span class="line">    <span class="comment">//接受请求</span></span><br><span class="line">    <span class="comment">//处理请求</span></span><br><span class="line">    <span class="comment">//给出响应(反馈)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.引入核心模块http</span></span><br><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用http.createServer()创建一个WEB服务器</span></span><br><span class="line"><span class="comment">//      方法返回一个Server实例</span></span><br><span class="line"><span class="keyword">var</span> server=http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.注册request请求事件，当浏览器请求发向服务器时触发</span></span><br><span class="line"><span class="comment">//第二个参数是事件处理函数</span></span><br><span class="line">    <span class="comment">//请求处理函数中接收两个参数</span></span><br><span class="line">        <span class="comment">//Request   请求对象</span></span><br><span class="line">            <span class="comment">//获取客户端的一些请求信息，例如请求路径</span></span><br><span class="line">        <span class="comment">//Response  响应对象</span></span><br><span class="line">            <span class="comment">//用来给客户端发送响应信息</span></span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//服务器接收到客户端请求后就在后台输出 请求的url(路径)</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;接受到请求，请求路径为：&quot;</span>+request.url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//response对象的write()方法可以给客户端发送响应数据</span></span><br><span class="line">        <span class="comment">//此时客户端访问http://127.0.0.1/3000/ 时会返回hello nodejs</span></span><br><span class="line">    response.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    response.write(<span class="string">&quot; nodejs&quot;</span>);</span><br><span class="line">    <span class="comment">//可以有多个write()但最后必须有一个end()结束响应 否则客户端会一直等待</span></span><br><span class="line">    response.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.绑定端口号，启动服务器</span></span><br><span class="line"><span class="comment">//第二个参数的函数在服务器启动时执行(起日志作用)</span></span><br><span class="line">server.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//在3000端口启动服务器</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;服务器启动成功，可以通过http://127.0.0.1/3000/访问&quot;</span>);</span><br><span class="line">    <span class="comment">//127.0.0.1也可以换成localhost</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="1-1搭建服务器时的IP和端口号简单解释"><a href="#1-1搭建服务器时的IP和端口号简单解释" class="headerlink" title="1.1搭建服务器时的IP和端口号简单解释"></a>1.1搭建服务器时的IP和端口号简单解释</h2><p>在端口3000上打开服务器</p>
<p>IP标识一台计算机</p>
<p>端口标识一个应用程序</p>
<p>IP:端口号 可以<strong>唯一标识一台计算机上的一个应用程序</strong></p>
<p>这里localhost:3000即为本机上的由<code>nodejs</code>搭建的服务器应用程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.listen(3000,function()&#123;  </span><br><span class="line">    console.log(&quot;服务器启动成功，可以通过http:&#x2F;&#x2F;127.0.0.1&#x2F;3000&#x2F;访问&quot;);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="1-2中文乱码的解决方法"><a href="#1-2中文乱码的解决方法" class="headerlink" title="1.2中文乱码的解决方法"></a>1.2中文乱码的解决方法</h2><p>​    加上头部让浏览器明确以utf-8编码格式解析</p>
<ul>
<li><p>第一种方法</p>
<p>通过meta元数据声明当前文本的编码格式为utf-8</p>
<p>加上<code>response.write(&#39;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;/head&gt;&#39;);</code></p>
</li>
<li><p>第二种方法</p>
<p>加上<code>response.setHeader(&quot;Content-Type&quot;,&quot;text/plain; charset=utf-8&quot;)</code></p>
<p><strong>不同响应内容对应的响应类型是不一样的</strong> 例如text/plain 或 text/html</p>
<p>第二种方法加上的头部可以在浏览器中查看</p>
<p>F12 Network下查看</p>
<p><img data-src="/images/http%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E6%9E%84%E5%BB%BA%E7%AE%80%E5%8D%95WEB%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20210412202501529.png" alt="image-20210412202501529"></p>
<p><img data-src="/images/http%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E6%9E%84%E5%BB%BA%E7%AE%80%E5%8D%95WEB%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20210412202544524.png" alt="image-20210412202544524"></p>
</li>
</ul>
<h2 id="1-3-setHeader-方法"><a href="#1-3-setHeader-方法" class="headerlink" title="1.3 setHeader()方法"></a>1.3 setHeader()方法</h2><p>在响应头部添加响应类型字段</p>
<p><code>res.setHeader(&quot;Content-Type&quot;,&quot;text/plain; charset=utf-8&quot;)</code></p>
<ul>
<li><p>Content-Type，<strong>响应内容类型</strong></p>
<ul>
<li><p>不同的响应内容要填入不同的类型(text/plain、text/html等)</p>
</li>
<li><p>text/plain，为响应数据的格式，text/plain为普通文本，响应的数据会被当作<strong>普通文本</strong>处理(html标签也会被当作普通文本)</p>
</li>
<li><p>text/html，为<strong>html文本</strong>，响应数据中的<strong>html标签会被浏览器自动识别并解释执行</strong></p>
</li>
</ul>
</li>
<li><p>charset=utf-8，指明返回的数据是utf-8格式编码，解决中文乱码问题 </p>
</li>
</ul>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>web服务器响应文件中的数据</title>
    <url>/2021/04/13/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="1-web服务器响应文件中的数据"><a href="#1-web服务器响应文件中的数据" class="headerlink" title="1.web服务器响应文件中的数据"></a>1.web服务器响应文件中的数据</h1><h2 id="1-1Nodejs构建web服务器代码如下"><a href="#1-1Nodejs构建web服务器代码如下" class="headerlink" title="1.1Nodejs构建web服务器代码如下"></a>1.1Nodejs构建web服务器代码如下</h2><span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入核心模块http和fs</span></span><br><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs=<span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务器</span></span><br><span class="line"><span class="keyword">var</span> server=http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> url=req.url;</span><br><span class="line">    <span class="keyword">if</span>(url==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//请求时响应html文件</span></span><br><span class="line">        fs.readFile(<span class="string">&quot;todoList.html&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//请求失败时响应普通文本</span></span><br><span class="line">                res.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/plain; charset=utf-8&quot;</span>) </span><br><span class="line">                res.end(<span class="string">&quot;文件读取失败&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//请求成功时响应html文本</span></span><br><span class="line">                res.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/html; charset=utf-8&quot;</span>) </span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//因为html文件中引用了jQuery.js文件，所以要手动添加这个文件的访问路径</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(url==<span class="string">&quot;/jQuery.js&quot;</span>)&#123;</span><br><span class="line">        fs.readFile(<span class="string">&quot;jQuery.js&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)</span><br><span class="line">            &#123;</span><br><span class="line">                res.end(<span class="string">&quot;load faild&quot;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">&quot;3000&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;服务器启动成功,可以访问3000端口&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打开文件中的数据使用fs核心模块的<code>fs.readFile()</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">&quot;todoList.html&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>nodejs将文件中的<strong>数据</strong>响应给浏览器</p>
<p>将<code>fs.readFile</code>返回的文件中数据data用res.end(data)响应给浏览器并加上相应格式的响应类型Content-Type</p>
<p><strong>注意这里的data直接响应给浏览器解释执行，不需要呈现出来查看，所以不需要toString()方法转换为可识别字符串</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/html; charset=utf-8&quot;</span>) </span><br><span class="line">res.end(data);</span><br></pre></td></tr></table></figure>

<p>在浏览器中访问如下</p>
<p><img data-src="/images/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/image-20210412223931130.png" alt="image-20210412223931130"></p>
<h2 id="1-2如果响应的html文件中有外部引入的文件如css样式或者js文件，则需要手动添加到这些文件的请求url"><a href="#1-2如果响应的html文件中有外部引入的文件如css样式或者js文件，则需要手动添加到这些文件的请求url" class="headerlink" title="1.2如果响应的html文件中有外部引入的文件如css样式或者js文件，则需要手动添加到这些文件的请求url"></a>1.2如果响应的html文件中有外部引入的文件如css样式或者js文件，则需要手动添加到这些文件的请求url</h2><p><img data-src="/images/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/image-20210412223645626.png" alt="image-20210412223645626"></p>
<p>例如html文件中有外部引入的jQuery.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;./jQuery.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>则需要手动添加到jQuery.js文件的请求url</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(url==<span class="string">&quot;/jQuery.js&quot;</span>)&#123;</span><br><span class="line">        fs.readFile(<span class="string">&quot;jQuery.js&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)</span><br><span class="line">            &#123;</span><br><span class="line">                res.end(<span class="string">&quot;load faild&quot;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-Content-Type内容类型"><a href="#2-Content-Type内容类型" class="headerlink" title="2.Content-Type内容类型"></a>2.Content-Type内容类型</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/plain; charset=utf-8&quot;</span>) </span><br></pre></td></tr></table></figure>

<p>不同的响应内容要填入不同的类型(text/plain、text/html等)</p>
<p><a href="http://tool.oschina.net/commons">http://tool.oschina.net/commons</a></p>
<p>上面的网址可以查看不同类型的数据使用什么响应类型</p>
<h1 id="3-服务器根据不同的请求URL可以返回不同的数据"><a href="#3-服务器根据不同的请求URL可以返回不同的数据" class="headerlink" title="3.服务器根据不同的请求URL可以返回不同的数据"></a>3.服务器根据不同的请求URL可以返回不同的数据</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.on(<span class="string">&quot;request&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;接受到请求，请求路径为：&quot;</span>+request.url);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> url=request.url;</span><br><span class="line">    <span class="comment">//判断url不同 响应不同的数据</span></span><br><span class="line">    <span class="keyword">if</span>(url==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//可以使用end()直接响应数据后结束</span></span><br><span class="line">            <span class="comment">//响应内容只能是 字符串和二进制数串</span></span><br><span class="line">            <span class="comment">//数字，布尔值，数组，对象等需要使用JSON转换成字符串</span></span><br><span class="line">        response.end(<span class="string">&quot;hello nodejs&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当url为&quot;/login&quot;时</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(url==<span class="string">&quot;/login&quot;</span>)&#123;</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/plain; charset=utf-8&quot;</span>)</span><br><span class="line">        response.end(<span class="string">&quot;登陆页面&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当url为&quot;/shuzu&quot;时</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(url==<span class="string">&quot;/shuzu&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">        <span class="comment">//响应经过JSON转换后的字符串&quot;[1,2,3,4]&quot;</span></span><br><span class="line">        response.end(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当url为&quot;/html&quot;时</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(url==<span class="string">&quot;/html&quot;</span>)&#123;</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/html; charset=utf-8&quot;</span>) </span><br><span class="line">        response.end(<span class="string">&quot;&lt;p&gt;你好&lt;a href=&#x27;#&#x27;&gt;点击超链接&lt;/a&gt;&lt;/p&gt;&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//其他url返回&quot;404 Not Found.&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        response.end(<span class="string">&quot;404 Not Found.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>URL为/html时</p>
<p><img data-src="/images/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/image-20210414200745087.png" alt="image-20210414200745087"></p>
<p>URL为/login时</p>
<p><img data-src="/images/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/image-20210414200823281.png" alt="image-20210414200823281"></p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>04-node_modules文件夹的问题</title>
    <url>/2021/04/26/04-node_modules%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="node-modules文件夹的问题"><a href="#node-modules文件夹的问题" class="headerlink" title="node_modules文件夹的问题"></a>node_modules文件夹的问题</h1><ul>
<li>文件夹下的文件过多过碎，<strong>拷贝项目时速度慢</strong></li>
<li>复杂的<strong>模块依赖关系</strong>以及<strong>模块的版本号</strong>需要被记录，避免拷贝后模块版本号不同而导致运行报错</li>
</ul>
<h2 id="1-package-json文件"><a href="#1-package-json文件" class="headerlink" title="1.package.json文件"></a>1.package.json文件</h2><ul>
<li><strong>拷贝项目给他人时不需要拷贝node_modules文件夹，只需要拷贝package.json文件</strong></li>
<li>package.json项目描述文件会记录当前项目依赖的第三方模块及其版本号和项目名称等一系列项目信息</li>
<li>别人根据package.json文件就可以下载对应的依赖第三方模块</li>
</ul>
<span id="more"></span>

<h3 id="创建package-json文件"><a href="#创建package-json文件" class="headerlink" title="创建package.json文件"></a>创建package.json文件</h3><p><strong>1.使用<code>npm init -y</code>命令在项目根目录下生成package.json文件</strong></p>
<ul>
<li><code>npm init</code> 命令执行时会询问要填写的项目基本信息，如项目名称，版本等</li>
<li><code>npm init -y</code>   <strong>-y</strong>  即意味着所有询问的信息全部采用默认值</li>
</ul>
<center>创建package.json文件</center>

<p><img data-src="/images/04-node_modules%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E9%97%AE%E9%A2%98/image-20210426115738307.png" alt="image-20210426115738307"></p>
<ul>
<li>main ：项目的主模块</li>
<li>script：命令别名</li>
<li>keywords：项目关键字</li>
<li>author：作者</li>
<li>license：协议，ISC是开放源代码协议</li>
</ul>
<p><strong>2.创建好package.json文件后，使用npm命令下载第三方模块时，该模块的版本号等信息就会被自动记录在package.json文件中</strong></p>
<p>此处使用<code>npm install formidable mime</code>命令下载两个模块</p>
<p>package.json文件中的license字段下新增independencies字段</p>
<p>该字段中就保存了项目依赖的模块名字与版本信息</p>
<p><img data-src="/images/04-node_modules%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E9%97%AE%E9%A2%98/image-20210426120400050.png" alt="image-20210426120400050"></p>
<h2 id="2-别人拿到拷贝的package-json文件如何使用"><a href="#2-别人拿到拷贝的package-json文件如何使用" class="headerlink" title="2.别人拿到拷贝的package.json文件如何使用"></a>2.别人拿到拷贝的package.json文件如何使用</h2><ul>
<li>在项目根目录下执行<code>npm Install</code>命令</li>
<li>npm会在项目根目录下找到package.json文件中的independencies字段</li>
<li>将其中的依赖模块<strong>自动按版本号进行下载</strong></li>
<li>下载完毕后根目录下会自动生成node_modules文件夹，其中就存放着下载的依赖模块</li>
</ul>
<h2 id="3-项目-开发依赖"><a href="#3-项目-开发依赖" class="headerlink" title="3.项目/开发依赖"></a>3.项目/开发依赖</h2><ul>
<li>项目依赖：即开发和上线运行都需要的第三方模块</li>
<li>开发依赖：只在开发过程需要，在<strong>上线运行时不需要</strong>的第三方模块</li>
</ul>
<p>安装npm包时</p>
<ul>
<li>使用<code>npm install 包名</code>，此时安装的包信息自动添加到package.json文件中的<strong>independencies字段</strong>，属于<strong>项目依赖</strong></li>
<li>使用 <code>npm install 包名 --save-dev</code> ，此时安装的包信息添加到package.json文件中的<strong>devDependencies字段</strong>，属于<strong>开发依赖</strong></li>
</ul>
<p>例如gulp第三发模块就是<strong>开发依赖</strong>，只在开发阶段使用。</p>
<p>使用 <code>npm install gulp --save-dev</code>安装后，package.json文件如下</p>
<p>在<strong>devDependencies字段</strong>中出现gulp的模块名和版本信息</p>
<p><img data-src="/images/04-node_modules%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E9%97%AE%E9%A2%98/image-20210426195127018.png" alt="image-20210426195127018"></p>
<p>根据package.json文件安装依赖时</p>
<ul>
<li>使用 <code>npm install</code>命令会安装package.json文件中<strong>所有的依赖</strong>，包括项目和开发依赖</li>
<li>使用 <code>npm install --production</code>命令只会安装package.json文件中的<strong>项目依赖</strong>，即<strong>independencies字段</strong>中的第三方模块</li>
</ul>
<h2 id="4-package-lock-json文件"><a href="#4-package-lock-json文件" class="headerlink" title="4.package-lock.json文件"></a>4.package-lock.json文件</h2><p><strong>记录模块与模块之间复杂的依赖关系</strong></p>
<p>下载模块时在目录下<strong>自动生成</strong>package-lock.json文件</p>
<p>详细记录了包的信息，如下载地址、版本和依赖关系等</p>
<p><img data-src="/images/04-node_modules%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E9%97%AE%E9%A2%98/image-20210426200058484.png" alt="image-20210426200058484"></p>
<h3 id="package-lock-json文件的作用"><a href="#package-lock-json文件的作用" class="headerlink" title="package-lock.json文件的作用"></a>package-lock.json文件的作用</h3><ul>
<li>详细记录了包的版本等信息，确保再次下载时不会下载错误的版本</li>
<li>加快下载速度，文件中记录了包的下载地址及项目依赖的第三方包的树状结构，重新下载时不需要做额外工作</li>
</ul>
<h2 id="5-package-json中scripts字段的作用"><a href="#5-package-json中scripts字段的作用" class="headerlink" title="5.package.json中scripts字段的作用"></a>5.package.json中scripts字段的作用</h2><p>scripts字段可以给常用的较长的命令起别名，提升开发效率</p>
<p>使用别名执行命令：<code>npm run &quot;别名&quot;</code></p>
<p>例如 <code>nodemon a.js</code> 这个命令经常执行</p>
<p>可以在scripts字段中添加以下代码</p>
<p><img data-src="/images/04-node_modules%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E9%97%AE%E9%A2%98/image-20210426200608237.png" alt="image-20210426200608237"></p>
<p>即给<code>nodemon a.js</code>这个命令起了一个别名 build</p>
<p>之后可以使用 <code>npm run build</code>命令来代替<code>nodemon a.js</code>命令</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>05-nodejs中的模块加载机制</title>
    <url>/2021/04/26/05-nodejs%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="nodejs中的模块加载机制"><a href="#nodejs中的模块加载机制" class="headerlink" title="nodejs中的模块加载机制"></a>nodejs中的模块加载机制</h1><p>nodejs使用<code>require(&#39;&#39;)</code>方法来加载模块，参数即为模块名或者路径</p>
<h2 id="require-查找模块"><a href="#require-查找模块" class="headerlink" title="require()查找模块"></a>require()查找模块</h2><h3 id="1-拥有完整路径-有路径但没有模块后缀"><a href="#1-拥有完整路径-有路径但没有模块后缀" class="headerlink" title="1.拥有完整路径/有路径但没有模块后缀"></a>1.拥有完整路径/有路径但没有模块后缀</h3><p>1.如果<code>require(&#39;模块&#39;)</code>参数中使用完整路径，则直接按照路径引入，找不到文件则报错</p>
<ul>
<li>例如 <code>require(&#39;./find.js&#39;)</code></li>
<li>完整模块路径可以是<strong>相对/绝对路径</strong></li>
<li>此时执行<code>require(&#39;./find.js&#39;)</code>代码时，会在相应的目录下找对应的find.js文件引入执行</li>
</ul>
<span id="more"></span>

<p>2.如果参数中模块后缀省略，先找相应的同名js文件，再找同名的文件夹</p>
<ul>
<li>例如 <code>require(&#39;./find&#39;)</code></li>
<li>先找对应目录下的find.js文件</li>
<li>找不到就找同名的find文件夹</li>
</ul>
<p>3.如果找到同名文件夹则引入执行文件夹中的<strong>index.js模块</strong></p>
<ul>
<li>找不到同名文件夹则报错</li>
</ul>
<p>4.如果文件夹中没有index.js模块，就会找当前文件夹(与参数中模块同名的文件夹)下的package.json文件,并引入执行其中main字段的主/入口模块</p>
<p>5.如果没有指定的入口模块或者入口模块找不到，则报错</p>
<h3 id="2-没有路径且没有后缀"><a href="#2-没有路径且没有后缀" class="headerlink" title="2.没有路径且没有后缀"></a>2.没有路径且没有后缀</h3><p>例如：<code>require(&#39;find&#39;)</code></p>
<p>1.nodejs先假设find模块为系统模块，在系统模块中查找</p>
<p>2.系统模块查找不到就进入当前目录的node_modules文件夹中</p>
<p>3.在node_modules文件夹中首先查找同名js文件</p>
<p>4.查找不到同名文件则查找同名文件夹(find文件夹)</p>
<p>5.引入执行同名文件夹(find文件夹)中的index.js模块</p>
<p>6.如果没有index.js模块，则查看当前文件夹(find文件夹)下的package.json文件中main字段指示的入口模块</p>
<p>7.引入执行package.json文件中main字段指示的入口模块</p>
<p>8.若没有main字段，或者入口模块找不到则报错</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>06-服务器端基本概念</title>
    <url>/2021/04/26/06-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="服务器端基本概念"><a href="#服务器端基本概念" class="headerlink" title="服务器端基本概念"></a>服务器端基本概念</h1><h2 id="1-URL"><a href="#1-URL" class="headerlink" title="1.URL"></a>1.URL</h2><p><strong>URL：统一资源定位符，标识internet网上资源的一种编码方式</strong></p>
<p>使用URL可以唯一标识网络上的一个资源</p>
<p>URL组成：</p>
<ul>
<li><strong>传输协议</strong>://<strong>服务器IP或域名:端口号</strong>/<strong>资源所在位置的标识</strong></li>
<li>例如: <code>http://www.baidu.com/news/a.html</code></li>
<li>即使用http协议访问域名为<code>www.baidu.com</code>，端口号为默认80的这个web服务器上的news文件夹下的a.html文件</li>
<li>http：超文本传输协议，一种发布和接收html文件的方法</li>
<li>IP或域名可以找到网络上的一台服务器，端口则代表这台服务器上的应用程序提供的服务，http默认端口为80</li>
<li>资源所在位置标识：<strong>不一定是服务器上资源的路径</strong>，请求提交给服务器后，服务器可以根据位置标识做出其他的操作，服务器给客户端返回什么资源是服务器自身决定的</li>
</ul>
<span id="more"></span>

<h2 id="2-开发过程客户端和服务端说明"><a href="#2-开发过程客户端和服务端说明" class="headerlink" title="2.开发过程客户端和服务端说明"></a>2.开发过程客户端和服务端说明</h2><p>开发过程中，客户端和服务端使用同一台电脑，即开发人员的电脑</p>
<p>开发人员电脑上的<strong>浏览器</strong>即为<strong>客户端</strong></p>
<p>开发人员电脑上的Node可以编写服务器，可以作为<strong>服务端</strong>，即软件层面的服务器</p>
<p>本机域名：localhost</p>
<p>本机IP：127.0.0.1</p>
<p>使用本机IP/域名就可以使用本机的客户端访问本机的服务端</p>
<h2 id="3-nodejs构建简单web服务器"><a href="#3-nodejs构建简单web服务器" class="headerlink" title="3.nodejs构建简单web服务器"></a>3.nodejs构建简单web服务器</h2><p>server.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Node中有一个核心模块：http</span></span><br><span class="line"><span class="comment">//这个模块就是用来创建编写服务器的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器</span></span><br><span class="line">    <span class="comment">//接受请求</span></span><br><span class="line">    <span class="comment">//处理请求</span></span><br><span class="line">    <span class="comment">//给出响应(反馈)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.引入核心模块http</span></span><br><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用http.createServer()创建一个WEB服务器</span></span><br><span class="line"><span class="comment">//      方法返回一个Server实例</span></span><br><span class="line"><span class="keyword">var</span> server=http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.注册request请求事件，当浏览器请求发向服务器时触发</span></span><br><span class="line"><span class="comment">//第二个参数是事件处理函数</span></span><br><span class="line">    <span class="comment">//请求处理函数中接收两个参数</span></span><br><span class="line">        <span class="comment">//Request   请求对象</span></span><br><span class="line">            <span class="comment">//获取客户端的一些请求信息，例如请求路径</span></span><br><span class="line">        <span class="comment">//Response  响应对象</span></span><br><span class="line">            <span class="comment">//用来给客户端发送响应信息</span></span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//服务器接收到客户端请求后就在后台输出 请求的url(路径)</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;接受到请求，请求路径为：&quot;</span>+request.url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//response对象的write()方法可以给客户端发送响应数据</span></span><br><span class="line">        <span class="comment">//此时客户端访问http://127.0.0.1/3000/ 时会返回hello nodejs</span></span><br><span class="line">    response.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    response.write(<span class="string">&quot; nodejs&quot;</span>);</span><br><span class="line">    <span class="comment">//可以有多个write()但最后必须有一个end()结束响应 否则客户端会一直等待</span></span><br><span class="line">    <span class="comment">//也可以直接使用end()返回响应数据</span></span><br><span class="line">    response.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.绑定端口号，启动服务器</span></span><br><span class="line"><span class="comment">//第二个参数的函数在服务器启动时执行(起日志作用)</span></span><br><span class="line">server.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//在3000端口启动服务器</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;服务器启动成功，可以通过http://127.0.0.1/3000/访问&quot;</span>);</span><br><span class="line">    <span class="comment">//127.0.0.1也可以换成localhost</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>请求处理函数中接收两个参数</p>
<ul>
<li>Request   请求对象：获取客户端的一些请求信息，例如请求路径等</li>
<li>Response  响应对象：用来给客户端发送响应信息<ul>
<li>第一个<code>response.end()</code>执行完后，服务器就已经结束响应</li>
<li>后面代码中的<code>response.end()</code>将不再向浏览器响应数据</li>
</ul>
</li>
</ul>
<p>node执行这个文件</p>
<p><img data-src="/images/06-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20210426213253506.png" alt="image-20210426213253506"></p>
<p>浏览器访问结果</p>
<p><img data-src="/images/06-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20210426213340606.png" alt="image-20210426213340606"></p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>07-HTTP协议</title>
    <url>/2021/04/26/07-HTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><h2 id="1-HTTP协议概念"><a href="#1-HTTP协议概念" class="headerlink" title="1.HTTP协议概念"></a>1.HTTP协议概念</h2><p>HTTP(Hyper Text Transfer Protocol)：超文本传输协议,规定如何从服务器传输超文本文件(HTML文件)到浏览器，基于浏览器-服务器(B-S)架构工作，是客户端和服务器请求和应答的标准</p>
<p>超文本(HTML)：在文本中不仅仅能包含文字，还可以包含音频视频图像等资源</p>
<h2 id="2-报文"><a href="#2-报文" class="headerlink" title="2.报文"></a>2.报文</h2><p>HTTP<strong>请求和响应的数据块</strong>被称为报文，包括要传送的数据和一些附加信息，并且遵守规定好的格式</p>
<p><strong>请求报文</strong>：浏览器发给服务器的HTTP请求报文</p>
<p><strong>响应报文</strong>：服务器发给浏览器的HTTP响应报文</p>
<span id="more"></span>

<center>利用浏览器的开发者工具可以看到浏览器和服务器进行通信的请求和响应报文</center>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426214103527.png" alt="image-20210426214103527"></p>
<p>Network选项卡可以看到当前浏览器和服务器之间的通信情况</p>
<p>下面的localhost和favicon.ico即为浏览器向服务器发送的两个HTTP请求</p>
<ul>
<li>localhost即为我们输出网址回车后发出的请求</li>
<li>favicon.ico为浏览器默认的请求，请求该网页的标识小图标</li>
</ul>
<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426214318773.png" alt="image-20210426214318773"></p>
<center>点击请求可以看到更详细的信息</center>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426214439234.png" alt="image-20210426214439234"></p>
<p>Headers选项卡展示了请求和响应的头部等信息，General中显示了请求和响应中的重要信息</p>
<ul>
<li>报文头部中的信息以<code>:</code>分隔的键值对表示，键值对之间使用 <code>,</code>分隔</li>
</ul>
<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426222733888.png" alt="image-20210426222733888"></p>
<p>Response中则展示了服务器实际响应的数据</p>
<h3 id="1-请求报文"><a href="#1-请求报文" class="headerlink" title="1.请求报文"></a>1.请求报文</h3><h4 id="1-请求方式-Request-Method"><a href="#1-请求方式-Request-Method" class="headerlink" title="1.请求方式(Request Method)"></a>1.请求方式(Request Method)</h4><ul>
<li><strong>GET</strong>: 一般用来获取数据，也可以向服务器发送少量数据(发送的数据大小有限制)，但是不安全</li>
<li><strong>POST</strong>: 一般用来向服务器发送数据(可以发送大量数据)，网站的一般逻辑操作也使用POST方法，POST方法比GET方法安全性高</li>
</ul>
<p><strong>例如：直接在浏览器输入网址访问服务器默认发送的是GET请求</strong></p>
<p>服务器端可以获取浏览器的请求方式</p>
<p><code>request.method</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取请求方式 在服务器后输出</span></span><br><span class="line"><span class="built_in">console</span>.log(request.method);</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426215848666.png" alt="image-20210426215848666"></p>
<p>使用浏览器输入网址访问服务器</p>
<p>服务器后台输出两个GET，代表localhost请求和favicon.ico请求均为GET请求</p>
<br>

<p><strong>例如：html文件中表格form提交时可以指定提交方式，指定为POST即使用POST方式请求</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">       action:提交到哪个服务器</span></span><br><span class="line"><span class="comment">       method：提交采用什么方式</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:3000&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<center>服务器后台显示</center>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426220411454.png" alt="image-20210426220411454"></p>
<p>此处第一次表格提交为POST请求，第二次请求页面小图标favicon.ico为GET请求</p>
<p><strong>服务器可以根据对同一网址的不同请求方式做出不同响应</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当请求方式为GET时</span></span><br><span class="line"><span class="keyword">if</span>(request.method == <span class="string">&#x27;GET&#x27;</span>)&#123;</span><br><span class="line">        response.end(<span class="string">&quot;GET&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(request.method == <span class="string">&#x27;POST&#x27;</span>)&#123;</span><br><span class="line">        response.end(<span class="string">&quot;POST&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        response.end(<span class="string">&quot;hello nodejs&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码会根据请求方式不同，给浏览器响应不同的数据</p>
<p>例如：直接按网址访问服务器会响应’GET’，点击表单提交按钮访问服务器会响应’POST’</p>
<h4 id="2-请求URL"><a href="#2-请求URL" class="headerlink" title="2.请求URL"></a>2.请求URL</h4><p><code>request.url</code>获取浏览器请求URL中从 ‘/‘ 开始的资源标识符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取请求URL根据请求URL返回不同的数据</span></span><br><span class="line">    <span class="keyword">if</span>(request.url == <span class="string">&#x27;/index&#x27;</span>|| request.url == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">        response.end(<span class="string">&#x27;index&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (request.url == <span class="string">&#x27;/list&#x27;</span>)&#123;</span><br><span class="line">        response.end(<span class="string">&#x27;list&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        response.end(<span class="string">&#x27;404NotFound!&#x27;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当请求地址为<code>http://localhost:3000</code>时，浏览器给服务器发送的请求会自动在url末尾加上 ‘/‘ </li>
<li>实际发送的url为<code>http://localhost:3000/</code>，所以服务器request.url获取的值都是以 ‘/‘ 开头的</li>
</ul>
<h4 id="3-请求头部Headers"><a href="#3-请求头部Headers" class="headerlink" title="3.请求头部Headers"></a>3.请求头部Headers</h4><p><code>request.headers</code> 获取请求报文的请求头</p>
<p><code>request.headers[&#39;字段名&#39;]</code>获取请求头中特定字段的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将请求头信息在后台输出</span></span><br><span class="line"><span class="built_in">console</span>.log(request.headers);</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426223953815.png" alt="image-20210426223953815"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回请求头中&#x27;accept&#x27;字段的值</span></span><br><span class="line"><span class="built_in">console</span>.log(request.headers[<span class="string">&#x27;accept&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426224158174.png" alt="image-20210426224158174"></p>
<br>

<h3 id="2-响应报文"><a href="#2-响应报文" class="headerlink" title="2.响应报文"></a>2.响应报文</h3><h4 id="1-HTTP状态码"><a href="#1-HTTP状态码" class="headerlink" title="1.HTTP状态码"></a>1.HTTP状态码</h4><ul>
<li>200 OK 代表请求成功</li>
<li>300 重定向</li>
<li>404 请求资源没找到</li>
<li>500 服务器端错误(服务器代码报错等)</li>
<li>400 客户端请求有语法错误等</li>
</ul>
<p>在浏览器开发者工具中可以看到HTTP响应的状态码</p>
<p>在服务器端可以使用<code>response.writeHead(HTTP状态码)</code> 指定响应时的状态码</p>
<p>如设置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">response.writeHead(<span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<p>服务器返回的响应报文中HTTP状态码就为200 OK</p>
<h4 id="2-内容类型"><a href="#2-内容类型" class="headerlink" title="2.内容类型"></a>2.内容类型</h4><p>响应数据时需要设定响应数据的类型，以便浏览器根据数据类型对返回的数据进行解析</p>
<ul>
<li>text/plain    纯文本 (默认的内容类型，不指定时默认纯文本) </li>
<li>text/html    html文本(浏览器自动解析其中的html代码)</li>
<li>text/css       css文本</li>
<li>application/javascript   javascript文本</li>
<li>application/json   json文本</li>
<li>image/jpeg     .jpeg格式的图片</li>
</ul>
<p>使用如下代码设置内容类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">response.writeHead(HTTP状态码,&#123;</span><br><span class="line">	<span class="string">&#x27;content-type&#x27;</span>:<span class="string">&#x27;text/plain;charset=utf-8&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其中<code>charset=utf-8</code>代表指明响应给浏览器的数据的编码格式，utf-8编码可以解析中文</p>
<h2 id="3-HTTP请求与响应处理"><a href="#3-HTTP请求与响应处理" class="headerlink" title="3.HTTP请求与响应处理"></a>3.HTTP请求与响应处理</h2><h3 id="1-请求参数"><a href="#1-请求参数" class="headerlink" title="1.请求参数"></a>1.请求参数</h3><p>客户端向服务端发送请求时，有时需要<strong>向服务端传递一些数据</strong>，这些数据通过<strong>请求参数的方式</strong>传递到服务端，例如登陆操作</p>
<h4 id="1-GET请求参数"><a href="#1-GET请求参数" class="headerlink" title="1.GET请求参数"></a>1.GET请求参数</h4><p>参数被放置在浏览器地址栏(URL)中，例如<strong><code>http://localhost:3000/?name=yang&amp;age=20</code></strong></p>
<p>这里的<code>name=yang&amp;age=20</code>就为请求参数</p>
<ul>
<li>请求参数使用<code>?</code>与URL隔开</li>
<li>请求参数中的不同参数使用<code>&amp;</code>分隔</li>
<li>请求参数以键值对的形式表示如： <code>name=yang</code>，键值之间使用<code>=</code>分隔</li>
</ul>
<h5 id="1-服务端如何获取GET请求参数"><a href="#1-服务端如何获取GET请求参数" class="headerlink" title="1.服务端如何获取GET请求参数"></a>1.服务端如何获取GET请求参数</h5><p>使用<code>request.url</code>可以获取请求URL，如果有请求参数，res.url会一并获取请求参数</p>
<center>获取的请求URL(带请求参数)</center>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210427214415414.png" alt="image-20210427214415414"></p>
<ul>
<li>可以通过字符串截取的方式获得？后的请求参数</li>
<li>node中内置了<strong>url系统模块</strong>，可以用来处理请求URL和请求参数</li>
</ul>
<br>

<p>url模块中的<code>url.parse(&#39;URL&#39;)</code>方法可以将URL的详细信息以对象的形式返回</p>
<p><strong>url.parse()</strong></p>
<ul>
<li>第一个参数为请求URL</li>
<li>第二个参数为true/false<ul>
<li>true意为<strong>将请求参数解析为对象形式</strong>(返回的URL对象的query属性为一个对象)</li>
<li>false意为请求参数以字符串返回(query属性为一个字符串)</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> url=<span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="comment">//获取url后以对象形式返回并在后台输出</span></span><br><span class="line"><span class="built_in">console</span>.log(url.parse(request.url));</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210427215213302.png" alt="image-20210427215213302"></p>
<p>query属性为<strong>字符串形式的请求参数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(url.parse(request.url,<span class="literal">true</span>));</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210427220107218.png" alt="image-20210427220107218"></p>
<p>query属性为<strong>对象形式的请求参数</strong></p>
<p>使用如下代码即可获取请求参数中的数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> query = url.parse(request.url,<span class="literal">true</span>).query</span><br><span class="line">    <span class="built_in">console</span>.log(query.name);</span><br><span class="line">    <span class="built_in">console</span>.log(query.age);</span><br></pre></td></tr></table></figure>

<h5 id="2-URL中加入请求参数后判断请求的资源标识符"><a href="#2-URL中加入请求参数后判断请求的资源标识符" class="headerlink" title="2.URL中加入请求参数后判断请求的资源标识符"></a>2.URL中加入请求参数后判断请求的资源标识符</h5><p>URL中加入请求参数后原来使用<code>request.url</code>判断请求资源标识符的方法需要修改</p>
<p><code>url.parse()</code>返回的对象中的<strong>pathname属性</strong>即为不带请求参数的请求资源标识符</p>
<p>使用ES6对象解构的方式获得query和pathname</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;query,pathname&#125; = url.parse(request.url,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>使用pathname判断请求资源标识符就可以解决这个问题</p>
<h4 id="2-POST请求参数"><a href="#2-POST请求参数" class="headerlink" title="2.POST请求参数"></a>2.POST请求参数</h4><p>一般在<strong>提交表单时</strong>请求参数使用POST方式发送</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:3000&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>POST方式的请求参数放在<strong>请求报文中</strong>，不在URL中</p>
<p>POST和GET方式的请求参数格式是<strong>一样</strong>的</p>
<p>表单中请求参数的名字写在<code>input</code>标签中，如<code>name=&quot;username&quot;</code></p>
<p><code>&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;</code></p>
<center>POST请求，请求报文中的请求参数，浏览器开发者工具查看</center>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210427222838580.png" alt="image-20210427222838580"></p>
<h5 id="1-服务端获取POST请求参数"><a href="#1-服务端获取POST请求参数" class="headerlink" title="1.服务端获取POST请求参数"></a>1.服务端获取POST请求参数</h5><p>POST请求参数通过request对象的事件接收</p>
<ul>
<li>data事件  当请求参数传递时触发(POST请求传递的数据理论上可以<strong>无限制</strong>，服务端可能需要<strong>分批接收</strong>)</li>
<li>end事件   当请求参数传递完毕时触发</li>
<li>request的data和end事件注册写在<strong>服务器的request请求事件中</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.on(<span class="string">&quot;request&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//创建变量接收POST请求参数</span></span><br><span class="line">    <span class="keyword">let</span> datasum=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">//data事件注册 params参数即为传来的参数</span></span><br><span class="line">    request.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//可能分批接收，所以使用+=接收所有数据</span></span><br><span class="line">        datasum+=params</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//end事件注册</span></span><br><span class="line">    request.on(<span class="string">&#x27;end&#x27;</span>,<span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(datasum);</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    response.end(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>将传来的数据在后台输出如下</center>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210427225303155.png" alt="image-20210427225303155"></p>
<br>

<h5 id="2-将获取的字符串格式的POST请求参数转换为对象格式"><a href="#2-将获取的字符串格式的POST请求参数转换为对象格式" class="headerlink" title="2.将获取的字符串格式的POST请求参数转换为对象格式"></a>2.将获取的字符串格式的POST请求参数转换为对象格式</h5><p>使用node系统模块<code>queryString</code>的<code>parse()</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入queryString模块转换请求参数格式</span></span><br><span class="line"><span class="keyword">const</span> queryString = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串格式的请求参数转换为对象格式并在后台输出</span></span><br><span class="line"><span class="comment">//此代码写在request对象的end事件中</span></span><br><span class="line"><span class="built_in">console</span>.log(queryString.parse(datasum));</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210427225733016.png" alt="image-20210427225733016"></p>
<h3 id="2-路由"><a href="#2-路由" class="headerlink" title="2.路由"></a>2.路由</h3><p>路由是指客户端<strong>请求地址</strong>与服务端<strong>程序代码</strong>的对应关系</p>
<p>简单来说即客户端请求什么，服务器响应什么</p>
<p>例如：</p>
<ul>
<li>客户端请求<code>http://localhost:3000/index.html</code>，服务端返回index.html</li>
<li>对于普不同的请求方式GET和POST，服务器也可以根据请求方式做出不同的响应</li>
</ul>
<h3 id="3-静态资源"><a href="#3-静态资源" class="headerlink" title="3.静态资源"></a>3.静态资源</h3><p>服务器端不需要处理，可以直接响应给客户端的资源被称为静态资源，例如CSS,JS,HTML文件</p>
<p>静态资源响应的例子：</p>
<p><strong>URL中的资源标识符不一定要写服务器端资源的路径</strong></p>
<ul>
<li>服务器端可以获取资源标识符后自己指定资源地址</li>
<li>此处就使用了字符串拼接<code>path.join</code>自己指定public文件夹下的静态资源</li>
</ul>
<br>

<p><strong>响应文件时需要在响应头中指定内容类型</strong><code>content-type</code></p>
<ul>
<li>在高级浏览器中即使不指定内容类型也可以正常解析文件，但一些浏览器可能发生错误</li>
<li>html文件通过<code>readFile()</code>方法获取，html文件中<strong>从外部引入的CSS等文件</strong>也是通过<code>readFile()</code>方法获取</li>
<li>在设置响应头中的<code>content-type</code>时，需要<strong>得知当前获取的文件类型</strong><ul>
<li>可以使用<strong>第三方模块mime</strong></li>
<li>mime模块的<code>getTaype(&quot;资源路径&quot;)</code>方法可以根据资源路径返回对应的文件类型</li>
<li>使用获取的文件类型设置<code>content-type</code></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> url=<span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">//引入第三方模块MIME 根据路径获取文件类型</span></span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">&#x27;mime&#x27;</span>)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//获取请求资源的标识符</span></span><br><span class="line">    <span class="keyword">let</span> pathname = url.parse(req.url).pathname</span><br><span class="line">    <span class="comment">//拼接路径</span></span><br><span class="line">    <span class="keyword">let</span> filepath = path.join(__dirname,<span class="string">&#x27;public&#x27;</span>+pathname)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> type = mime.getType(filepath)</span><br><span class="line">    <span class="comment">//获取对应文件</span></span><br><span class="line">    fs.readFile(filepath,<span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(err != <span class="literal">null</span>)&#123;</span><br><span class="line">            res.writeHead(<span class="number">404</span>,&#123;</span><br><span class="line">                <span class="string">&#x27;content-type&#x27;</span>:<span class="string">&#x27;text/plain;charset=utf-8&#x27;</span></span><br><span class="line">            &#125;)</span><br><span class="line">            res.end(<span class="string">&#x27;文件找不到&#x27;</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.writeHead(<span class="number">200</span>,&#123;</span><br><span class="line">                <span class="string">&#x27;content-type&#x27;</span>:type</span><br><span class="line">            &#125;)</span><br><span class="line">            res.end(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此处使用<code>http://localhost:3000/default.html</code>访问服务器的静态资源如下</p>
<ul>
<li>此处的URI：/default.html并不是资源在服务器路径</li>
<li>URI：统一资源<strong>标识符</strong></li>
<li>URL：统一资源<strong>定位符</strong></li>
</ul>
<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210428195929316.png" alt="image-20210428195929316"></p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>08-node中的同步异步API</title>
    <url>/2021/04/28/08-node%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5API/</url>
    <content><![CDATA[<h1 id="node中的同步和异步API"><a href="#node中的同步和异步API" class="headerlink" title="node中的同步和异步API"></a>node中的同步和异步API</h1><p>nodejs中的API，拿到他们执行结果的方式有两种</p>
<ul>
<li>通过<strong>返回值</strong>的方式得到API执行结果<ul>
<li>比如<code>path.join()</code>等API</li>
</ul>
</li>
<li>通过<strong>函数</strong>的方式得到API执行结果<ul>
<li>比如<code>fs.readFile()</code> API，这个API执行的结果在其第二个参数<strong>回调函数中的data参数中</strong></li>
</ul>
</li>
</ul>
<span id="more"></span>

<br>

<p>由此引出同步和异步API</p>
<ul>
<li><strong>同步API</strong>：按顺序执行，只有上一个API执行完毕，下一个API才开始执行</li>
<li><strong>异步API</strong>：异步API的执行不会阻塞后续其他代码的执行 ，<strong>async</strong>即为异步</li>
</ul>
<p>例如下面这段代码执行结果为先输出before，再输出after，等待2s后再输出last</p>
<p>这里的<code>setTimeout()</code> API就是异步API，不会阻塞后续代码执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;before&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;last&#x27;</span>)</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;after&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="同步异步API的区别"><a href="#同步异步API的区别" class="headerlink" title="同步异步API的区别"></a>同步异步API的区别</h2><h3 id="1-获取执行结果"><a href="#1-获取执行结果" class="headerlink" title="1.获取执行结果"></a>1.获取执行结果</h3><ul>
<li><p>同步API可以通过<strong>返回值</strong>拿到API执行的结果</p>
</li>
<li><p>异步API不能通过返回值拿到API执行结果，可以通过<strong>回调函数的方式</strong>得到执行结果</p>
</li>
</ul>
<p><strong>同步API</strong></p>
<p>通过返回值拿到结果 30</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> datasum = sum(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="comment">//输出30</span></span><br><span class="line"><span class="built_in">console</span>.log(datasum);</span><br></pre></td></tr></table></figure>

<p><strong>异步API</strong></p>
<p>res输出为undefined</p>
<p>执行到定时器时因为定时器为异步API，不会阻塞下面代码的执行，所以早在2s前，msg函数就已经默认返回undefined，此时res输出为undefined，而2s后定时器中的函数才执行</p>
<p>异步API的执行结果<strong>不能通过返回值得到</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">msg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">name</span>:<span class="string">&quot;yang&quot;</span>&#125;</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = msg()</span><br><span class="line"><span class="comment">//输出undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure>

<br>

<p><strong>异步API的执行结果可以通过回调函数得到</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">msg</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        callback(&#123;<span class="attr">name</span>:<span class="string">&quot;yang&quot;</span>&#125;) </span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//输出对象&#123;name:&#x27;yang&#x27;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过给msg函数使用回调函数将异步API的执行结果作为参数传递给回调函数，然后在回调函数中处理异步API的结果</p>
<br>

<h3 id="2-执行顺序"><a href="#2-执行顺序" class="headerlink" title="2.执行顺序"></a>2.执行顺序</h3><p><strong>同步API</strong></p>
<p>同步API按代码编写顺序执行，上一个API执行完毕，下一个API才开始执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;循环后代码&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>对于上述代码，由于是同步API，会先输出0-99999这100000个数字，然后再输出”循环后代码”</p>
<p><strong>异步API</strong></p>
<p>异步API不会阻塞后续代码执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;开始&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;2s&quot;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;0s&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;结束&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>对于上述代码，两个定时器为异步API，不会阻塞后续代码执行</p>
<p>最后结果为：</p>
<ul>
<li><p>“开始”</p>
</li>
<li><p>“结束”</p>
</li>
<li><p>“0s”</p>
</li>
<li><p>“2s”</p>
</li>
</ul>
<p><strong>异步API执行机制</strong>：</p>
<ul>
<li><p>首先执行所有的同步代码，碰到异步代码就先放入<strong>异步任务队列</strong>中(只放入，不执行)</p>
</li>
<li><p>当所有同步代码执行完毕后，开始执行异步任务队列中的异步代码</p>
<ul>
<li>在此处例子中，执行异步代码创建两个定时器，一个定时0s，一个定时2s，并将他们的回调函数放入<strong>回调函数队列</strong>中等待执行</li>
</ul>
</li>
<li><p>异步代码执行完毕后进入回调函数队列，待满足条件时将回调函数队列中的回调函数<strong>调入同步代码执行区</strong>执行</p>
<ul>
<li>经过0s时执行0s定时器的回调函数先输出”0s”</li>
<li>经过2s时再执行2s定时器的回调函数再输出”2s”</li>
</ul>
</li>
<li><p>接着执行<strong>事件循环(eventloop)机制</strong>：循环等待直到有新的异步任务添加到异步任务队列中时，继续执行异步代码</p>
</li>
</ul>
<p><img data-src="/images/08-node%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5API/image-20210428213248420.png" alt="image-20210428213248420"></p>
<h2 id="nodejs中的常见异步API"><a href="#nodejs中的常见异步API" class="headerlink" title="nodejs中的常见异步API"></a>nodejs中的常见异步API</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打开文件是异步API</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;./demo.txt&#x27;</span>,<span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//事件处理函数也是异步API</span></span><br><span class="line"><span class="keyword">var</span> server = http.creatServer();</span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>上述两个异步API执行的结果只能通过<strong>回调函数</strong>获取</p>
<p>异步API不会阻塞后续代码的执行</p>
<br>

<h2 id="后续代码需要使用前面异步API的执行结果"><a href="#后续代码需要使用前面异步API的执行结果" class="headerlink" title="后续代码需要使用前面异步API的执行结果"></a>后续代码需要使用前面异步API的执行结果</h2><p>如果异步API后面代码的执行需要使用前面异步API的结果，但是实际后续代码执行时前面的异步API还没有执行，如何解决这个问题?</p>
<ul>
<li>可以将<strong>后续代码写在异步API的回调函数中</strong></li>
</ul>
<p>例如：需要依次打开三个文件，可以使用回调函数嵌套的方式完成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;./1.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">err , data1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data1);</span><br><span class="line">    <span class="comment">//嵌套在上一个readFile API的回调函数中</span></span><br><span class="line">    fs.readFile(<span class="string">&#x27;./2.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">err , data2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data2);</span><br><span class="line">        fs.readFile(<span class="string">&#x27;./3.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">err , data3</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(data3);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/08-node%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5API/image-20210506201909805.png" alt="image-20210506201909805"></p>
<p>使用这种方式可以解决后续代码使用前面异步API的执行结果的问题</p>
<p>但是会引入<strong>新的问题</strong>：嵌套层数过多导致<strong>维护困难</strong></p>
<p>回调嵌套回调被称为<strong>回调地狱</strong></p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>JS执行机制(同步异步)</title>
    <url>/2021/04/13/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6(%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5)/</url>
    <content><![CDATA[<h1 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h1><h2 id="1-JS是单线程"><a href="#1-JS是单线程" class="headerlink" title="1.JS是单线程"></a>1.JS是单线程</h2><ul>
<li>JavaScript语言的一大特点就是<strong>单线程</strong>，同一时间只能做一件事。</li>
</ul>
<p>这是因为JavaScript诞生的目的所致——JavaScript是为了处理页面中用户的交互，以及操作DOM而诞生的。</p>
<p>我们对一个DOM元素进行操作时，<strong>不能同时进行多种操作</strong>，而只能先添加，再修改，然后删除。</p>
<ul>
<li>单线程意味着任务需要排队，前一个任务结束，后一个任务才开始。这样如果JS的执行时间过长就会导致页面渲染不连贯。导致页面渲染呈现阻塞的感觉。</li>
</ul>
<span id="more"></span>

<h2 id="2-同步和异步"><a href="#2-同步和异步" class="headerlink" title="2.同步和异步"></a>2.同步和异步</h2><ul>
<li>为了解决JS单线程导致的任务排队问题，利用多核CPU的计算能力，H5提出了Web Worker标准，允许JavaScript脚本<strong>创建多个线程</strong>。于是JS中出现了<strong>同步</strong>和<strong>异步</strong>。</li>
</ul>
<p><img data-src="/images/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6(%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5)/image-20210408185914871.png" alt="image-20210408185914871"></p>
<p>上面这段代码按照单线程的思路：先输出1 等待1s后输出2 再输出3，如果定时器等待时间过长就会出现渲染阻塞的感觉。</p>
<p>而允许JavaScript创建多个线程后，输出顺序变成了先输出1和3，等待1s后再输出2</p>
<ul>
<li>同步异步的<strong>本质区别</strong>：各个流程的执行顺序不同。</li>
</ul>
<h3 id="2-1同步"><a href="#2-1同步" class="headerlink" title="2.1同步"></a>2.1同步</h3><ul>
<li>同步：<strong>前一个任务执行完毕再开始执行下一个任务</strong>，程序的执行顺序与任务的排列顺序是一致的、同步的。</li>
</ul>
<h3 id="2-2异步"><a href="#2-2异步" class="headerlink" title="2.2异步"></a>2.2异步</h3><ul>
<li>异步：同时可以执行多个任务，下一个任务不必等待上一个任务执行完。</li>
</ul>
<h3 id="2-3同步任务和异步任务"><a href="#2-3同步任务和异步任务" class="headerlink" title="2.3同步任务和异步任务"></a>2.3同步任务和异步任务</h3><ul>
<li><p>同步任务：同步任务都在<strong>主线程</strong>上执行，形成一个执行栈</p>
</li>
<li><p>异步任务：JS的异步是通过回调函数实现的</p>
<ul>
<li>常见的异步任务有以下几类</li>
</ul>
<ol>
<li><strong>普通事件</strong>中的回调函数，如click、resize等事件中的回调函数</li>
<li><strong>资源加载</strong>中的回调函数，如load、error等事件中的回调函数</li>
<li><strong>定时器</strong>中的回调函数，如setTimeout、setInterval等定时器中的回调函数</li>
</ol>
<ul>
<li>异步任务相关的<strong>回调函数</strong>添加到<strong>回调函数队列</strong>(消息队列)中</li>
</ul>
</li>
</ul>
<p><img data-src="/images/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6(%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5)/image-20210408205300165.png" alt="image-20210408205300165"></p>
<p>上图的<code>console.log(1)</code>和<code>console.log(2)</code>都是<strong>同步任务</strong></p>
<p>定时器setTimeout()属于<strong>异步任务</strong></p>
<p>定时器中的回调函数即<code>function()&#123;console.log(3)&#125;</code> 要在<strong>异步任务队列</strong>中的定时器代码被执行时加入<strong>回调函数队列</strong></p>
<p><img data-src="/images/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6(%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5)/image-20210428214905524.png" alt="image-20210428214905524"></p>
<h3 id="2-4JS执行机制"><a href="#2-4JS执行机制" class="headerlink" title="2.4JS执行机制"></a>2.4JS执行机制</h3><ol>
<li><p>先按顺序执行代码，<strong>同步任务放入同步代码执行区中执行</strong></p>
</li>
<li><p>将遇到的异步任务放入异步代码执行区中，此时<strong>不执行异步任务</strong>(等待同步任务执行完后开始执行)</p>
<ul>
<li>此处将setTimeout定时器代码放入异步代码执行区中</li>
<li>然后继续执行下面的同步任务</li>
</ul>
</li>
<li><p>一旦同步代码执行区中的同步任务执行完毕后，系统就会进入异步代码执行区开始执行异步任务</p>
<ul>
<li>此处设定0s的定时器并将回调函数放入回调函数队列中</li>
</ul>
</li>
<li><p>当回调函数队列中的回调函数满足条件后就调入同步代码执行区执行</p>
<ul>
<li>此处经过0s后将<code>console.log(3)</code>回调函数调入同步代码执行区执行</li>
</ul>
</li>
<li><p>当前同步任务和异步任务都执行完毕后，通过<strong>事件循环</strong>继续查看任务队列，若有新的异步任务就继续执行</p>
<p>上图的输出次序为1、2、3</p>
</li>
</ol>
<ul>
<li><strong>事件循环</strong>(event loop)：同步代码执行区不断的重复获取任务、执行任务、再获取任务、再执行，这种循环<strong>机制</strong>被称为事件循环</li>
</ul>
<h4 id="2-4-1有多个异步任务时的执行机制"><a href="#2-4-1有多个异步任务时的执行机制" class="headerlink" title="2.4.1有多个异步任务时的执行机制"></a>2.4.1有多个异步任务时的执行机制</h4><p><img data-src="/images/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6(%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5)/image-20210428215837351.png" alt="image-20210428215837351"></p>
<p>此时有两个同步任务</p>
<ol>
<li>console.log(1);</li>
<li>console.log(2);</li>
</ol>
<p>两个异步任务</p>
<ol>
<li>onclick</li>
<li>setTimeout</li>
</ol>
<ul>
<li>第1个异步任务的回调函数只有当<strong>点击事件发生时</strong>，才被调入同步代码执行区执行</li>
<li>第2个异步任务的回调函数，<strong>等经过3s后</strong>才被调入同步任务执行区执行</li>
<li>这两个异步任务的回调函数<strong>执行顺序取决于点击事件发生的时间</strong></li>
<li>同步代码执行区中的同步任务执行完后，会通过事件循环不断地查看异步代码执行区是否有新的异步任务，有就继续执行异步任务。<ul>
<li>例如在当前所有同步、异步任务执行完毕后，又触发了一次点击事件，此时通过事件循环发现任务队列中有一个等待的异步任务，就将这个异步任务的回调函数放入回调函数队列中并直接调入同步代码执行区执行。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>10-ES7异步函数</title>
    <url>/2021/05/06/10-ES7%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="ES7异步函数"><a href="#ES7异步函数" class="headerlink" title="ES7异步函数"></a>ES7异步函数</h1><p>在09-promise对象中，学习到使用promise对象可以对异步编程语法进行<strong>改进</strong></p>
<ul>
<li>可以将异步API的执行和结果处理分离</li>
<li>可以解决异步API回调函数嵌套的<strong>维护困难</strong>和<strong>回调地狱</strong>问题</li>
</ul>
<p>但是promise对象在处理较多的需要顺序执行的异步API时<strong>仍然比较繁琐</strong></p>
<span id="more"></span>

<ul>
<li>需要使用promise对象将每一个异步API包裹起来</li>
<li>需要使用函数将每一个promise对象包裹以实现顺序调用</li>
<li>获取异步API<strong>结果</strong>和<strong>错误信息</strong>时还要在promise对象中使用resolve和reject两个参数函数<ul>
<li>并在promise对象外部使用promise.then 和 promise.catch 两个方法进行接收</li>
</ul>
</li>
<li>这使得代码比较臃肿繁琐</li>
</ul>
<p>在ES7中定义的<strong>异步函数</strong>可以在实现promise对象功能的基础上使得代码更加的简洁明了</p>
<h2 id="1-异步函数"><a href="#1-异步函数" class="headerlink" title="1.异步函数"></a>1.异步函数</h2><p>异步函数实际上就是基于promise对象，将一些比较繁琐的promise方法进行了封装</p>
<p>然后开放一些简单的关键字代替这些繁琐的操作</p>
<br>

<p><strong>异步函数是异步编程语法的终极解决方案，它可以将异步代码写成同步的形式，消除代码的回调函数嵌套。</strong></p>
<h2 id="2-异步函数使用"><a href="#2-异步函数使用" class="headerlink" title="2.异步函数使用"></a>2.异步函数使用</h2><h3 id="在普通函数的前面加上async，即可创建异步函数"><a href="#在普通函数的前面加上async，即可创建异步函数" class="headerlink" title="在普通函数的前面加上async，即可创建异步函数"></a>在普通函数的前面加上<code>async</code>，即可创建异步函数</h3><p>async即异步的意思</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fn()函数即为一个异步函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn());</span><br><span class="line">fn().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="异步函数的默认返回值为一个promise对象"><a href="#异步函数的默认返回值为一个promise对象" class="headerlink" title="异步函数的默认返回值为一个promise对象"></a>异步函数的默认返回值为一个<strong>promise对象</strong></h3><p>在异步函数中使用return进行结果的返回</p>
<p><code>console.log(fn());</code>返回的结果如下</p>
<p><img data-src="/images/10-ES7%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/image-20210506214213554.png" alt="image-20210506214213554"></p>
<p>将123包裹在promise对象中进行返回</p>
<p>此处异步函数的<strong>return 即替代了promise对象的resolve函数</strong></p>
<br>

<p>可以使用promise对象的then()方法获取执行结果</p>
<p>即使用<code>fn().then()</code>方法，输出123</p>
<br>

<h3 id="异步函数使用throw抛出错误信息"><a href="#异步函数使用throw抛出错误信息" class="headerlink" title="异步函数使用throw抛出错误信息"></a>异步函数使用throw抛出错误信息</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="string">&#x27;错误&#x27;</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line">fn().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用promise对象的<strong>catch方法</strong>即可获取错误信息<code>&#39;错误&#39;</code></p>
<p>此处throw语句后的return语句不再生效</p>
<p><strong>throw即替代了promise对象中的reject函数</strong></p>
<br>

<h3 id="异步函数的await关键字"><a href="#异步函数的await关键字" class="headerlink" title="异步函数的await关键字"></a>异步函数的await关键字</h3><ul>
<li>他只能出现在异步函数中</li>
<li>await promise可以<strong>暂停异步函数的执行</strong>，等待promise对象返回结果后再继续执行</li>
<li>await可以<strong>直接获取promise对象中的异步数据</strong>，代替了then方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">p1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;p1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">p2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;p2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">p3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;p3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> r1=<span class="keyword">await</span> p1()</span><br><span class="line">    <span class="comment">//r1即为&#x27;p1&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(r1);</span><br><span class="line">    <span class="keyword">let</span> r2=<span class="keyword">await</span> p2()</span><br><span class="line">    <span class="built_in">console</span>.log(r2);</span><br><span class="line">    <span class="keyword">let</span> r3=<span class="keyword">await</span> p3()</span><br><span class="line">    <span class="built_in">console</span>.log(r3);</span><br><span class="line">&#125;</span><br><span class="line">run()</span><br></pre></td></tr></table></figure>

<p>此处有三个异步函数p1()，p2()，p3()需要顺序执行</p>
<p>将三个函数放入run()异步函数中加上await关键字执行</p>
<p>只有当p1()函数执行后的promise对象返回结果后，代码才继续执行</p>
<p>同时可以利用await关键字直接获取返回的promise对象中的异步数据</p>
<br>

<h2 id="3-异步函数在nodejs中的应用"><a href="#3-异步函数在nodejs中的应用" class="headerlink" title="3.异步函数在nodejs中的应用"></a>3.异步函数在nodejs中的应用</h2><p>nodejs中的异步API使用<strong>回调函数</strong>来获取执行结果</p>
<p>因为使用回调函数获取结果，所以<strong>不能使用异步函数中的await关键字</strong></p>
<ul>
<li>await关键字后必须跟一个promise对象</li>
</ul>
<br>

<h3 id="util核心模块的promisify方法"><a href="#util核心模块的promisify方法" class="headerlink" title="util核心模块的promisify方法"></a><code>util</code>核心模块的promisify方法</h3><p>nodejs核心模块util的promisify方法可以<strong>改造异步API</strong></p>
<ul>
<li>在原异步API的基础上，产生一个新的异步API</li>
<li>新的异步API将执行结果包裹在promise对象中返回</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入util模块的promisify方法</span></span><br><span class="line"><span class="keyword">var</span> promisify = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>).promisify</span><br><span class="line"></span><br><span class="line"><span class="comment">//将要改造的异步API包裹在promisify方法中，形成一个新的异步API</span></span><br><span class="line"><span class="keyword">var</span> readFile = promisify(fs.readFile)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用新异步API</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> r1 = <span class="keyword">await</span> readFile(<span class="string">&#x27;./1.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">   <span class="built_in">console</span>.log(r1);</span><br><span class="line">&#125;</span><br><span class="line">run()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>readFile</code> 即为基于<code>fs.readFile</code>改造后的新异步API</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>09-promise对象</title>
    <url>/2021/05/06/09-promise%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>promise对象出现的目的是解决nodejs中异步编程中<a href="08-node%E3%80%82%E3%80%82%E3%80%82">回调地狱</a>的问题。</p>
<p>promise并<strong>没有提供新的功能</strong>，它是一种异步编程<strong>语法上的改进</strong></p>
<p>可以将异步API的<strong>执行</strong>和<strong>结果的处理</strong>进行分离</p>
<p>promise是一种构造函数，使用时需要new 生成对象实例</p>
<span id="more"></span>

<br>

<h2 id="Promise基本使用"><a href="#Promise基本使用" class="headerlink" title="Promise基本使用"></a>Promise基本使用</h2><p>new Promise()中传入匿名函数<code>(resolve,reject) =&gt; &#123;&#125;</code></p>
<p>匿名函数的两个参数resolve，reject</p>
<ul>
<li>resolve 函数：当异步API执行成功时调用这个函数</li>
<li>reject函数：异步API执行失败时调用这个函数</li>
</ul>
<p>在匿名函数<code>(resolve,reject) =&gt; &#123;&#125;</code>中书写异步API代码</p>
<ul>
<li>在匿名函数中完成异步API的执行</li>
<li>利用resolve和reject这两个参数函数，在Promise实例对象外部处理异步API的结果</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Promise实例对象</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve , reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//匿名函数中书写异步API代码</span></span><br><span class="line">    fs.readFile(<span class="string">&#x27;./1.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">err , data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(err != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//文件打开失败调用reject函数</span></span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Promise实例对象外部处理异步API的结果</span></span><br><span class="line"><span class="comment">//在promise实例对象内部调用resolve函数即为调用promise.then()中的匿名函数，参数传递给then()中的匿名函数</span></span><br><span class="line">promise.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//调用reject函数即为调用下面promise.catch()中的匿名函数，此处使用了链式编程省略了promise</span></span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h2 id="Promise解决回调地狱"><a href="#Promise解决回调地狱" class="headerlink" title="Promise解决回调地狱"></a>Promise解决回调地狱</h2><ul>
<li><p>使用三个Promise对象包裹需要顺序执行的三个打开文件的异步API</p>
</li>
<li><p>将三个Promise对象分别用函数包裹保证执行时按函数调用的顺序执行</p>
</li>
<li><p>在使用<code>promise.then()</code>处理异步API结果时</p>
<ul>
<li>```js<br>p1().then((data) =&gt; {<pre><code>console.log(data)
return p2();
</code></pre>
})<br>.then((data) =&gt; {})<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 上面第一个&#96;p1().then()&#96;方法中的&#96;return p2()&#96;，会使**下一个链式编程的then方法变为p2().then**</span><br><span class="line"></span><br><span class="line">  - 即第二个链式编程的then()处理的是**第二个promise对象中的异步API**</span><br><span class="line"></span><br><span class="line">  - 第三个链式编程的then()同理，处理的是**第三个promise对象中的异步API**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用函数包裹Promise对象，保证执行时按函数调用的顺序执行</span><br><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">        fs.readFile(&#39;.&#x2F;1.txt&#39;,&#39;utf8&#39;,(err,data) &#x3D;&gt; &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function p2() &#123;</span><br><span class="line">    return new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">        fs.readFile(&#39;.&#x2F;2.txt&#39;,&#39;utf8&#39;,(err,data) &#x3D;&gt; &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function p3() &#123;</span><br><span class="line">    return new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">        fs.readFile(&#39;.&#x2F;3.txt&#39;,&#39;utf8&#39;,(err,data) &#x3D;&gt; &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;p1()的返回值即为第一个promise对象</span><br><span class="line">p1().then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">    &#x2F;&#x2F;此处return p2()，下一个链式编程的then方法即为p2()的返回值的then方法</span><br><span class="line">    return p2()</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;此处即为p2().then()方法</span><br><span class="line">.then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">    return p3()</span><br><span class="line">&#125;)</span><br><span class="line">.then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><img data-src="/images/09-promise%E5%AF%B9%E8%B1%A1/image-20210506211329533.png" alt="image-20210506211329533"></p>
<p>输出结果即为顺序的1 2 3</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>12-数据库相关概念</title>
    <url>/2021/05/11/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h1><h2 id="1-使用MongoDB数据库"><a href="#1-使用MongoDB数据库" class="headerlink" title="1.使用MongoDB数据库"></a>1.使用MongoDB数据库</h2><p>MongoDB数据库<strong>可以使用js语法操作</strong>，前端开发人员更容易上手学习</p>
<p>其他的数据库如MySQL、SQLServer等，都可以使用与它们契合度更高的语言进行操作</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511201521744.png" alt="image-20210511201521744"></p>
<span id="more"></span>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511201756252.png" alt="image-20210511201756252"></p>
<ul>
<li><p>此处页面中的admin和api等都是database</p>
<ul>
<li>Mongedb数据库软件中有三个默认的数据库：<strong>config，admin，local</strong></li>
</ul>
</li>
<li><p>roles是collection，一组数据的集合</p>
</li>
<li><p>右边显示的三条数据即为roles这个集合中的具体数据——<strong>文档document</strong></p>
<ul>
<li>每个文档实际上就是一个<strong>JSON对象</strong></li>
</ul>
</li>
<li><p>此处显示的文档中有三个<strong>字段field</strong></p>
</li>
</ul>
<h2 id="2-Nodejs操作数据库"><a href="#2-Nodejs操作数据库" class="headerlink" title="2.Nodejs操作数据库"></a>2.Nodejs操作数据库</h2><p>nodejs操作数据库需要第三方模块 <strong>mongoose模块</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//安装第三方模块</span></span><br><span class="line">npm install mongoose</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入mongoose模块</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-1打开数据库"><a href="#2-1打开数据库" class="headerlink" title="2.1打开数据库"></a>2.1打开数据库</h3><p>Mongodb数据库软件在安装时选择<strong>作为服务</strong>安装</p>
<p>可以直接通过打开服务的方式打开Mongodb数据库软件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">net start mongodb<span class="comment">//打开数据库</span></span><br><span class="line">net stop mongodb<span class="comment">//关闭数据库</span></span><br></pre></td></tr></table></figure>

<p>以管理员身份在CMD中开启关闭服务</p>
<h3 id="2-2数据库连接"><a href="#2-2数据库连接" class="headerlink" title="2.2数据库连接"></a>2.2数据库连接</h3><p>nodejs使用mongoose模块的<code>connect()</code>方法连接数据库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>)</span><br><span class="line"></span><br><span class="line">mongoose.connect(<span class="string">&#x27;mongodb://localhost/test&#x27;</span>)</span><br><span class="line">    .then(<span class="built_in">console</span>.log(<span class="string">&#x27;数据库开启成功&#x27;</span>))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;数据库开启失败&#x27;</span>,err))</span><br></pre></td></tr></table></figure>

<p>connect()方法返回一个<strong>promise对象</strong>，使用promise对象的**then()<strong>和</strong>catch()**方法接收结果和处理错误</p>
<p>connect()方法的参数为一个URL</p>
<ul>
<li>这个URL使用mongodb作为协议名</li>
<li>localhost即为主机的名字(IP/域名)，此处因为数据库运行在本机所以使用localhost</li>
<li>/test即为数据库名字(mongodb数据库会<strong>自动创建不存在的数据库</strong>，所以不需要显式的创建数据库)</li>
</ul>
<center>运行这个js文件显示如下</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511205146851.png" alt="image-20210511205146851"></p>
<p>将<code>&#123;useNewUrlParser:true,useUnifiedTopology:true&#125;</code>作为connect()方法的第二个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mongoose.connect(<span class="string">&#x27;mongodb://localhost/test&#x27;</span>,&#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> ,<span class="attr">useUnifiedTopology</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511205344686.png" alt="image-20210511205344686"></p>
<h3 id="2-3创建数据库"><a href="#2-3创建数据库" class="headerlink" title="2.3创建数据库"></a>2.3创建数据库</h3><p>MongoDB中不需要显式的创建数据库，<strong>不存在的数据库会被自动创建</strong></p>
<h3 id="2-4数据库的增添"><a href="#2-4数据库的增添" class="headerlink" title="2.4数据库的增添"></a>2.4数据库的增添</h3><h4 id="2-4-1创建集合"><a href="#2-4-1创建集合" class="headerlink" title="2.4.1创建集合"></a>2.4.1创建集合</h4><p>创建集合分两步</p>
<ul>
<li>1.设定集合规则</li>
<li>2.应用集合规则创建集合</li>
</ul>
<p><strong>设定集合规则</strong></p>
<p>使用<code>mongoose.Schema()</code><strong>构造函数</strong>创建实例对象来设定集合规则</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数传入一个JSON对象做为参数</span></span><br><span class="line"><span class="comment">//JSON对象中的属性即为文档中字段的名字和类型</span></span><br><span class="line"><span class="keyword">const</span> courseSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    teacher:<span class="built_in">String</span>,</span><br><span class="line">    isPublished:<span class="built_in">Boolean</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>创建的集合中的文档有三个字段</p>
<ul>
<li>name字段，数据类型为String</li>
<li>teacher字段，数据类型为String</li>
<li>isPublished字段，数据类型为Boolean</li>
</ul>
<p><strong>创建集合</strong></p>
<p>使用<code>mongoose.model()</code>方法创建集合</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个参数为集合名称</span></span><br><span class="line">    <span class="comment">//集合名称首字母大写</span></span><br><span class="line">    <span class="comment">//集合在数据库中实际的名称为courses</span></span><br><span class="line"><span class="comment">//第二个参数为应用的集合规则</span></span><br><span class="line"><span class="keyword">const</span> Course = mongoose.model(<span class="string">&#x27;Course&#x27;</span>,courseSchema);</span><br></pre></td></tr></table></figure>

<p>集合名称为Course，在数据库中实际创建的集合名称为<strong>courses</strong></p>
<p> <code>mongoose.model()</code>方法返回当前集合的构造函数</p>
<p>即上述代码的Course即为<strong>集合的构造函数</strong></p>
<p>集合的构造函数中的方法可以操作集合</p>
<p><strong>创建的新数据库如果没有文档数据，MongoDB中是不会创建这个数据库的，compass可视化软件中自然也看不到新数据库</strong></p>
<h4 id="2-4-2创建文档"><a href="#2-4-2创建文档" class="headerlink" title="2.4.2创建文档"></a>2.4.2创建文档</h4><p>创建文档向集合中插入数据分两步</p>
<ul>
<li>创建集合实例，写入新文档的数据</li>
<li>调用集合实例对象的save方法将文档保存在数据库中</li>
</ul>
<br>

<p><strong>创建集合实例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建集合的实例对象</span></span><br><span class="line"><span class="comment">//作为参数的JSON对象的属性即为文档中的字段和值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> courseDoc = <span class="keyword">new</span> Course(&#123;</span><br><span class="line">  name : <span class="string">&#x27;Node.js&#x27;</span>,</span><br><span class="line">  teacher:<span class="string">&#x27;黑马讲师&#x27;</span>,</span><br><span class="line">  isPublished: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>创建了一个集合实例(<strong>文档</strong>)</p>
<ul>
<li><p>name字段值为：’Node.js’</p>
</li>
<li><p>teacher字段值为：’黑马讲师’</p>
</li>
<li><p>isPublished字段值为：true</p>
<br></li>
</ul>
<p><strong>将集合保存到数据库</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保存数据到数据库</span></span><br><span class="line">courseDoc.save()</span><br></pre></td></tr></table></figure>

<p>调用创建的集合实例的save方法将新建的文档保存到数据库</p>
<br>

<center>在compass可视化软件中查看</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511214047191.png" alt="image-20210511214047191"></p>
<p>test数据库下的courses集合中有一个文档</p>
<p>_id字段是MongoDB数据库为每一个文档自动添加的唯一标识ID，类型为ObjectId</p>
<h4 id="2-4-3创建文档的另一种方式"><a href="#2-4-3创建文档的另一种方式" class="headerlink" title="2.4.3创建文档的另一种方式"></a>2.4.3创建文档的另一种方式</h4><p>使用集合构造函数的create()方法创建文档</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用集合构造函数的creat方法创建文档</span></span><br><span class="line"><span class="comment">//第一个参数为新建文档数据的JSON对象表示</span></span><br><span class="line"><span class="comment">//第二个参数为回调函数</span></span><br><span class="line">Course.create(&#123;<span class="attr">name</span>:<span class="string">&#x27;Javascript&#x27;</span>, <span class="attr">teacher</span>:<span class="string">&#x27;黑马讲师&#x27;</span>,<span class="attr">isPublished</span>:<span class="literal">false</span>&#125;, <span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>成功添加文档</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511215734414.png" alt="image-20210511215734414"></p>
<br>

<h5 id="Nodejs中对数据库的所有操作都是异步操作"><a href="#Nodejs中对数据库的所有操作都是异步操作" class="headerlink" title="Nodejs中对数据库的所有操作都是异步操作"></a>Nodejs中对数据库的所有操作都是异步操作</h5><ul>
<li><p>包括连接数据库，创建数据库和创建文档都是<strong>异步API</strong></p>
</li>
<li><p>其中返回promise对象的异步API可以应用<strong>异步函数</strong>编程的方法</p>
<br></li>
</ul>
<p>create()方法获取异步API结果的方式有两种</p>
<ul>
<li><p>利用<strong>回调函数</strong>得到，形如上述2.4.3代码</p>
</li>
<li><p>create()方法返回<strong>promise对象</strong>，使用promise对象的then()和catch()方法获取结果和处理错误信息</p>
<br></li>
</ul>
<p><strong>利用create()方法返回的promise对象来获取异步API结果</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用promise对象获取异步API的结果</span></span><br><span class="line"><span class="comment">//链式编程</span></span><br><span class="line">Course.create(&#123;<span class="attr">name</span>:<span class="string">&#x27;Javascript123&#x27;</span>, <span class="attr">teacher</span>:<span class="string">&#x27;黑马讲师&#x27;</span>,<span class="attr">isPublished</span>:<span class="literal">false</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure>

<center>后台返回数据</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511220815270.png" alt="image-20210511220815270"></p>
<center>compass显示</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511220907741.png" alt="image-20210511220907741"></p>
<h4 id="2-4-4MongoDB数据库导入数据"><a href="#2-4-4MongoDB数据库导入数据" class="headerlink" title="2.4.4MongoDB数据库导入数据"></a>2.4.4MongoDB数据库导入数据</h4><p>使用MongoDB提供的<code>mongoimport</code>命令导入文件中数据</p>
<p><code>mongoimport -d &#39;数据库名称&#39; -c &#39;集合名称&#39; --file &#39;要导入的文件路径&#39;</code></p>
<p><code>mongoimport -d &#39;数据库名称&#39; -c &#39;集合名称&#39; --jsonArray &#39;要导入的文件路径&#39;</code></p>
<br>

<p>因为mongoimport.exe这个文件路径不在系统环境变量的路径中</p>
<p><strong>需要我们手动添加文件的路径</strong></p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511231654210.png" alt="image-20210511231654210"></p>
<p>我在本机MongoDB安装目录下的bin文件夹中没有找到mongoimport.exe这个文件</p>
<p>所以在<a href="https://www.mongodb.com/try/download/database-tools?tck=docs_databasetools">MongoDB官网下载Tools</a></p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511231935779.png" alt="image-20210511231935779"></p>
<p>将压缩包中的<code>命令.exe</code>文件复制到环境变量设置的目录下，就可以使用这些命令</p>
<br>

<p><strong>导入user.json文件中的数据</strong></p>
<p>此处test数据库中不存在users集合</p>
<p>使用mongoimport命令会<strong>自动创建users集合</strong></p>
<ul>
<li>集合规则根据json文件中的json对象设置</li>
</ul>
<p>此处json文件中是一个包含三个json对象作为元素的数组</p>
<ul>
<li>所以使用<code>--jsonArray</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mongoimport -d test -c users --jsonArray .\要导入的文件\user.json</span><br></pre></td></tr></table></figure>

<center>.json文件内容</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511233918423.png" alt="image-20210511233918423"></p>
<center>导入成功</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511234355272.png" alt="image-20210511234355272"></p>
<center>compass软件</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511234514655.png" alt="image-20210511234514655"></p>
<p>test数据库下自动创建users集合并写入3个文档</p>
<br>

<p><strong>当json文件中存放单个json对象时，导入命令如下</strong></p>
<p>使用–file</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mongoimport -d test -c users --file .\要导入的文件\user.json</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511234828596.png" alt="image-20210511234828596"></p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511234837217.png" alt="image-20210511234837217"></p>
<br>

<h3 id="2-5数据库的查询"><a href="#2-5数据库的查询" class="headerlink" title="2.5数据库的查询"></a>2.5数据库的查询</h3><p>查询文档两种方式：</p>
<ul>
<li>使用集合构造函数的<strong>find()方法</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Course为集合的构造函数</span></span><br><span class="line"><span class="keyword">const</span> Course = mongoose.model(<span class="string">&#x27;Course&#x27;</span>,courseSchema);<span class="comment">//courses</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查询集合中所有的文档(当find方法没有参数时)</span></span><br><span class="line">Course.find().then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p>find()方法<strong>默认返回promise对象</strong></p>
<p>promise对象的then方法接收的<strong>查询结果为一个数组</strong></p>
<p>数组中的元素为查询到的文档的JSON对象表示，当查询不到任何文档时返回空数组</p>
<p>find()方法使用<strong>一个JSON对象作为参数</strong>，json对象中属性即为查找条件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Course.find(&#123;<span class="attr">name</span>: <span class="string">&quot;Javascript&quot;</span>&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p><code>&#123;name: &quot;Javascript&quot;&#125;</code>即为查找name字段值为Javascript的文档</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512213042106.png" alt="image-20210512213042106"></p>
<br>

<ul>
<li><p>使用集合构造函数的<strong>findOne()方法</strong></p>
<ul>
<li><p>findOne()方法<strong>查询结果为一个JSON对象</strong>，而find()方法<strong>查询结果为一个包含0或多个JSON对象的数组</strong></p>
</li>
<li><p>findOne()方法和find()方法都默认返回promise对象，使用promise对象的then方法获取执行结果</p>
</li>
<li><p>findOne()方法和find()方法的参数设置格式相同</p>
</li>
<li><p>当findOne()方法<strong>没有参数时</strong>返回集合中的第一个文档的JSON对象</p>
</li>
<li><p><strong>有参数时</strong>会返回满足参数条件的第一个文档的JSON对象</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Course.findOne(&#123;<span class="attr">name</span>: <span class="string">&quot;Javascript123&quot;</span>&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512213745252.png" alt="image-20210512213745252"></p>
<br>

<h4 id="2-5-1按范围查询"><a href="#2-5-1按范围查询" class="headerlink" title="2.5.1按范围查询"></a>2.5.1按范围查询</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.find(&#123;<span class="attr">age</span>:&#123;<span class="attr">$gt</span>:<span class="number">21</span>,<span class="attr">$lt</span>:<span class="number">23</span>&#125;&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p>将作为find()方法参数的JSON对象中的<strong>属性值改为表示匹配信息JSON的对象</strong></p>
<p><code>&#123;age:&#123;$gt:21,$lt:23&#125;&#125;</code></p>
<ul>
<li>$gt代表大于</li>
<li>$lt代表小于</li>
</ul>
<p>表示匹配age字段值大于21，小于23的文档</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512221148976.png" alt="image-20210512221148976"></p>
<br>

<h4 id="2-5-2按匹配包含查询"><a href="#2-5-2按匹配包含查询" class="headerlink" title="2.5.2按匹配包含查询"></a>2.5.2按匹配包含查询</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.find(&#123;<span class="attr">hobbies</span>:&#123;<span class="attr">$in</span>:[<span class="string">&#x27;篮球&#x27;</span>]&#125;&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p><code>&#123;hobbies:&#123;$in:[&#39;篮球&#39;]&#125;&#125;</code></p>
<p>匹配hobbies字段中包含篮球的文档，数组中可以填写多个包含项</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512221742490.png" alt="image-20210512221742490"></p>
<br>

<h4 id="2-5-3选择查询的字段"><a href="#2-5-3选择查询的字段" class="headerlink" title="2.5.3选择查询的字段"></a>2.5.3选择查询的字段</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.find().select(<span class="string">&quot;name age&quot;</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p>对find()方法<strong>返回的promise对象使用select()方法</strong>选择要查询的字段名</p>
<ul>
<li><p>_id字段是每次查询时默认要查询的字段</p>
</li>
<li><p>在select方法的参数字段名前加<code>-</code>意味着查询时不显示这个字段</p>
</li>
<li><p><code>select(&quot;name age -_id&quot;)</code>即意味着查询name，age字段，不查询_id字段</p>
</li>
</ul>
<p><code>&quot;name age&quot;</code>要查询的字段名作为select方法的参数，字段名用空格隔开</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512222153159.png" alt="image-20210512222153159"></p>
<br>

<h4 id="2-5-4对查询结果按照某字段排序"><a href="#2-5-4对查询结果按照某字段排序" class="headerlink" title="2.5.4对查询结果按照某字段排序"></a>2.5.4对查询结果按照某字段排序</h4><p>查询商品的信息时会使用排序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.find().sort(<span class="string">&quot;age&quot;</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p>对find()方法<strong>返回的promise对象使用sort()方法</strong>进行排序</p>
<ul>
<li>按照sort()方法的参数填写的字段名排序<ul>
<li>字段名前加<code>-</code>即意为降序排序</li>
<li>不加<code>-</code>即意为升序排序</li>
</ul>
</li>
</ul>
<center>按年龄升序排序</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512222459529.png" alt="image-20210512222459529"></p>
<br>

<center>年龄降序排序</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.find().sort(<span class="string">&quot;-age&quot;</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512222552276.png" alt="image-20210512222552276"></p>
<br>

<h4 id="2-5-5查询时跳过数据，限制查询数量"><a href="#2-5-5查询时跳过数据，限制查询数量" class="headerlink" title="2.5.5查询时跳过数据，限制查询数量"></a>2.5.5查询时跳过数据，限制查询数量</h4><p>limit()和skip()方法结合使用可以实现分页功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//跳过第1条文档，查询最多2条文档</span></span><br><span class="line">User.find().skip(<span class="number">1</span>).limit(<span class="number">2</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p>对find()方法<strong>返回的promise对象</strong></p>
<ul>
<li>使用skip()方法设置<strong>跳过多少条数据</strong></li>
<li>使用limit()方法设置<strong>最多查询多少条数据</strong></li>
</ul>
<center>总共四条数据，跳过一条查询两条</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512222941101.png" alt="image-20210512222941101"></p>
<br>

<h3 id="2-6数据库文档的删除"><a href="#2-6数据库文档的删除" class="headerlink" title="2.6数据库文档的删除"></a>2.6数据库文档的删除</h3><h4 id="2-6-1删除单个文档"><a href="#2-6-1删除单个文档" class="headerlink" title="2.6.1删除单个文档"></a>2.6.1删除单个文档</h4><p>使用集合构造函数的findOneAndDelete()方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找并删除匹配的第一条文档</span></span><br><span class="line">User.findOneAndDelete(&#123;<span class="attr">_id</span>:<span class="string">&#x27;609bdfc298ed4e560fe78266&#x27;</span>&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<ul>
<li>查找并删除<strong>匹配的第一条文档</strong></li>
<li>此例删除_id字段为’609bdfc298ed4e560fe78266’的文档</li>
<li>result为被删除文档的<strong>JSON对象</strong></li>
<li>参数为空则会删除集合中的第一个元素</li>
</ul>
<br>

<h4 id="2-6-2删除多个文档"><a href="#2-6-2删除多个文档" class="headerlink" title="2.6.2删除多个文档"></a>2.6.2删除多个文档</h4><p>使用集合构造函数的deleteMany()方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.deleteMany(&#123;<span class="attr">hobbies</span>:&#123;<span class="attr">$in</span>:<span class="string">&#x27;足球&#x27;</span>&#125;&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<ul>
<li>一次删除满足条件的所有文档</li>
<li>本例删除所有hobbies字段中<strong>包含’足球’的文档</strong></li>
<li>参数为空时会<strong>删除集合中所有文档</strong></li>
<li>result为一个对象，包含<strong>三个属性</strong><ul>
<li>ok: 1，值为1即表示删除成功</li>
<li>n: 2，2即表示删除了两个文档</li>
<li>deleteCount：2，删除计数为2</li>
</ul>
</li>
</ul>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210513224626695.png" alt="image-20210513224626695"></p>
<br>

<h3 id="2-7数据库文档修改"><a href="#2-7数据库文档修改" class="headerlink" title="2.7数据库文档修改"></a>2.7数据库文档修改</h3><h4 id="2-7-1修改单个文档"><a href="#2-7-1修改单个文档" class="headerlink" title="2.7.1修改单个文档"></a>2.7.1修改单个文档</h4><p>使用集合构造函数的<code>updateOne()</code>方法</p>
<ul>
<li>updateOne(‘查询条件’,’要修改的值’)</li>
<li>只能修改一个匹配文档</li>
<li>返回promise对象</li>
<li>执行结果result为一个对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.updateOne(&#123;<span class="attr">name</span>:<span class="string">&quot;杨启明&quot;</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&quot;杨启明1&quot;</span>&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p>找到name字段值为杨启明的文档，修改其name字段值为杨启明1</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517212114554.png" alt="image-20210517212114554"></p>
<center>上图红框即为result表示的对象</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517212203837.png" alt="image-20210517212203837"></p>
<h4 id="2-7-2修改多个文档"><a href="#2-7-2修改多个文档" class="headerlink" title="2.7.2修改多个文档"></a>2.7.2修改多个文档</h4><p>集合构造函数的updateMany()方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.updateMany(&#123;&#125;,&#123;<span class="attr">age</span>:<span class="number">18</span>&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p>第一个参数为空对象即为修改集合中的所有文档</p>
<p>将集合中所有文档中的age字段值改为18</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517212536168.png" alt="image-20210517212536168"></p>
<br>

<h3 id="2-8Mongoose验证"><a href="#2-8Mongoose验证" class="headerlink" title="2.8Mongoose验证"></a>2.8Mongoose验证</h3><p>Mongoose在创建集合规则时可以<strong>为文档的字段设定验证条件</strong>，不满足验证条件的文档在存入数据库时会报错</p>
<p>字段的验证条件在<strong>设定集合规则</strong>时指定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> postSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    <span class="comment">//name:&#123;&#125; JSON对象中写name字段的具体验证要求</span></span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        required:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-8-1-required规则"><a href="#2-8-1-required规则" class="headerlink" title="2.8.1 required规则"></a>2.8.1 required规则</h4><p>required规则取值可以有两种</p>
<ul>
<li>boolean值</li>
<li>数组(数组中可以自定义报错信息)</li>
</ul>
<p><strong>1.require规则值为boolean值</strong></p>
<p><code>required:true</code>代表该字段是必须的(mongoose默认规定字段可以为空)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将一个空文档存入数据库</span></span><br><span class="line">Post.create(&#123;&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517214350607.png" alt="image-20210517214350607"></p>
<center>红框报错，name字段是必须的</center>

<br>

<p><strong>当没有设置required字段为true时</strong></p>
<p>将空文档存入数据库也不会报错</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517214658740.png" alt="image-20210517214658740"></p>
<center>红框即为存入的空文档</center>

<br>

<p><strong>2.required规则值为数组</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> postSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    <span class="comment">//name:&#123;&#125; JSON对象中写name字段的具体验证要求</span></span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">//required规则值为数组</span></span><br><span class="line">        required:[</span><br><span class="line">            <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&#x27;请填入必填项标题&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>数组第一个元素为是否为必填项</p>
<p>第二个参数为报错信息</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517215346089.png" alt="image-20210517215346089"></p>
<center>报错信息变为'请填入必填项标题'</center>

<h4 id="2-8-2-字段长度限制"><a href="#2-8-2-字段长度限制" class="headerlink" title="2.8.2 字段长度限制"></a>2.8.2 字段长度限制</h4><p><strong>针对于type为String的字段值</strong></p>
<p><strong>minlength</strong>规则：限制最小长度</p>
<p><strong>maxlength</strong>规则：限制最大长度</p>
<p>同样规则值可以为数组，第二个元素为报错信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> postSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    <span class="comment">//name:&#123;&#125; JSON对象中写name字段的具体验证要求</span></span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        required:[</span><br><span class="line">            <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&#x27;请填入必填项标题&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">//最小长度为2</span></span><br><span class="line">        minlength:[<span class="number">2</span>,<span class="string">&#x27;输入值小于最小长度2&#x27;</span>],</span><br><span class="line">        <span class="comment">//最大长度为5</span></span><br><span class="line">        maxlength:[<span class="number">5</span>,<span class="string">&#x27;输入值大于最大长度5&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个文档name字段值为&#x27;helloworld&#x27;，并存入数据库</span></span><br><span class="line">Post.create(&#123;<span class="attr">name</span>:<span class="string">&#x27;helloworld&#x27;</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517215830774.png" alt="image-20210517215830774"></p>
<center>长度大于5报错</center>

<br>

<h4 id="2-8-3-trim规则"><a href="#2-8-3-trim规则" class="headerlink" title="2.8.3 trim规则"></a>2.8.3 trim规则</h4><p>trim：规定是否去除字符串两边多余的空格</p>
<p>trim规则的值为boolean值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> postSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    <span class="comment">//name:&#123;&#125; JSON对象中写name字段的具体验证要求</span></span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        required:[</span><br><span class="line">            <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&#x27;请填入必填项标题&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">        minlength:[<span class="number">2</span>,<span class="string">&#x27;输入值小于最小长度2&#x27;</span>],</span><br><span class="line">        maxlength:[<span class="number">5</span>,<span class="string">&#x27;输入值大于最大长度5&#x27;</span>],</span><br><span class="line">        trim:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//name字段值为&#x27;   a bc  &#x27;</span></span><br><span class="line">Post.create(&#123;<span class="attr">name</span>:<span class="string">&#x27;   a bc  &#x27;</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br></pre></td></tr></table></figure>

<p>代码中设置name字段值为’       a bc   ‘</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517220251295.png" alt="image-20210517220251295"></p>
<center>消除多余空格后的文档数据</center>

<br>

<h4 id="2-8-4数值大小限制"><a href="#2-8-4数值大小限制" class="headerlink" title="2.8.4数值大小限制"></a>2.8.4数值大小限制</h4><p>针对于type为Number的字段值</p>
<p>min：最小数值</p>
<p>max：最大数值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">age:&#123;</span><br><span class="line">       type:<span class="built_in">Number</span>,</span><br><span class="line">       <span class="comment">//数值最小值  Number类型</span></span><br><span class="line">       min:<span class="number">18</span>,</span><br><span class="line">       <span class="comment">//数值最大值</span></span><br><span class="line">       max:<span class="number">70</span>,</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>

<br>

<h4 id="2-8-5默认值设置"><a href="#2-8-5默认值设置" class="headerlink" title="2.8.5默认值设置"></a>2.8.5默认值设置</h4><p>使用<strong>default</strong>设置字段默认值，在没有显式创建这个字段时，字段会使用默认值创建</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">publishDate:&#123;</span><br><span class="line"></span><br><span class="line">    type:<span class="built_in">Date</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:<span class="built_in">Date</span>.now</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>publishDate字段的默认值为当前时间</p>
<p>Date内置对象的now属性可以获取当前时间</p>
<br>

<h4 id="2-8-6枚举设置"><a href="#2-8-6枚举设置" class="headerlink" title="2.8.6枚举设置"></a>2.8.6枚举设置</h4><p>使用enmu设置字段<strong>可选的值</strong>，字段的值<strong>不在enmu设定的值中会报错</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">category:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">//枚举值(该字段可选的值)</span></span><br><span class="line">        enum:[<span class="string">&#x27;小说&#x27;</span>,<span class="string">&#x27;散文&#x27;</span>,<span class="string">&#x27;说明文&#x27;</span>]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>category字段的可选值为小说、散文和说明文</p>
<br>

<h4 id="2-8-7自定义验证规则"><a href="#2-8-7自定义验证规则" class="headerlink" title="*2.8.7自定义验证规则"></a>*2.8.7自定义验证规则</h4><p>validate：自定义规则,为一个JSON对象</p>
<p>validator：自定义规则验证函数，是validate的元素</p>
<ul>
<li>返回boolean值</li>
<li>true代表验证成功，false代表失败</li>
<li>v即为要验证的字段值</li>
</ul>
<p>message：自定义报错信息，是validate的元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">author:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">//自定义验证规则</span></span><br><span class="line">        validate:&#123;</span><br><span class="line">            <span class="comment">//进行验证的函数</span></span><br><span class="line">            validator:<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//返回boolean值</span></span><br><span class="line">                <span class="comment">//true代表验证成功，false代表失败</span></span><br><span class="line">                <span class="comment">//v即为要验证的字段值</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//v的值小于4即验证通过</span></span><br><span class="line">                <span class="keyword">return</span> v &amp;&amp; v.length&lt;<span class="number">4</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//自定义规则报错信息</span></span><br><span class="line">            message:<span class="string">&#x27;不满足作者字段验证条件&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Post.create(&#123;<span class="attr">name</span>:<span class="string">&#x27;01&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">category</span>:<span class="string">&#x27;小说&#x27;</span>,<span class="attr">author</span>:<span class="string">&#x27;abc&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br></pre></td></tr></table></figure>

<center>创建并保存包含4个字段的文档</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517224430291.png" alt="image-20210517224430291"></p>
<center>保存成功</center>

<ul>
<li>name字段：必填项验证</li>
<li>age字段：数值大小验证</li>
<li>category字段：enmu枚举验证</li>
<li>author字段：自定义验证(长度小于4)</li>
<li>publishDate字段：没有显式创建，使用默认值自动创建</li>
</ul>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Mongodb数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>11-nodejs全局对象global</title>
    <url>/2021/05/10/11-nodejs%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1global/</url>
    <content><![CDATA[<h1 id="nodejs全局对象global"><a href="#nodejs全局对象global" class="headerlink" title="nodejs全局对象global"></a>nodejs全局对象global</h1><p>浏览器BOM中的全局对象是<strong>window</strong></p>
<p>Node中全局对象是<strong>global</strong></p>
<p>Node全局对象global有许多和window对象相同的方法</p>
<p>使用global对象的方法可以省略global</p>
<ul>
<li>console.log() 在控制台输出</li>
<li>setTimeout() 设置定时器(定时触发一次)</li>
<li>clearTimeout() 清除定时器</li>
<li>setInterval() 设置定时器(每经过设定的时间就触发)</li>
<li>等等</li>
</ul>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
</search>
