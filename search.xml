<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>00-浏览器调试js程序代码</title>
    <url>/2021/04/13/00-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95js%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="浏览器调试JS程序代码（chrome浏览器）"><a href="#浏览器调试JS程序代码（chrome浏览器）" class="headerlink" title="浏览器调试JS程序代码（chrome浏览器）"></a>浏览器调试JS程序代码（chrome浏览器）</h1><ul>
<li><p><strong>-将js代码写在html文件的script标签中</strong></p>
</li>
<li><p>在浏览器打开html文件</p>
</li>
<li><p>点击检查中的<strong>Sources选项</strong></p>
</li>
<li><p>点击代码前面序号<strong>设置断点</strong></p>
</li>
<li><p>刷新当前页面<strong>执行js代码</strong></p>
</li>
<li><p>代码中<code>console.log</code>语句的<strong>输出结果显示在Console选项中</strong></p>
</li>
</ul>
<span id="more"></span>

<p><img data-src="/images/00-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95js%E7%A8%8B%E5%BA%8F/image-20210914163555091.png" alt="image-20210914163555091"></p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>01-树相关算法</title>
    <url>/2021/09/12/01-%E6%A0%91%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="树相关算法"><a href="#树相关算法" class="headerlink" title="树相关算法"></a>树相关算法</h1><h2 id="1-树的先中后序遍历"><a href="#1-树的先中后序遍历" class="headerlink" title="1.树的先中后序遍历"></a>1.树的先中后序遍历</h2><span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单二叉树为&#123;1,2,3&#125;</span></span><br><span class="line"><span class="keyword">var</span> root = &#123;</span><br><span class="line">    val:<span class="number">1</span>,</span><br><span class="line">    left:&#123;</span><br><span class="line">        val:<span class="number">2</span>,</span><br><span class="line">        left:<span class="literal">null</span>,</span><br><span class="line">        right:<span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    right:&#123;</span><br><span class="line">        val:<span class="number">3</span>,</span><br><span class="line">        left:<span class="literal">null</span>,</span><br><span class="line">        right:<span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归完成</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">threeOrder</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = []</span><br><span class="line">    <span class="keyword">let</span> pre = []</span><br><span class="line">    <span class="keyword">let</span> mid = []</span><br><span class="line">    <span class="keyword">let</span> next = []</span><br><span class="line">    <span class="comment">//先序</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> []</span><br><span class="line">        pre.push(root.val)</span><br><span class="line">        first(root.left)</span><br><span class="line">        first(root.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">middle</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> []</span><br><span class="line">        middle(root.left)</span><br><span class="line">        mid.push(root.val)</span><br><span class="line">        middle(root.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">nextS</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> []</span><br><span class="line">        nextS(root.left)</span><br><span class="line">        nextS(root.right)</span><br><span class="line">        next.push(root.val)</span><br><span class="line">    &#125;</span><br><span class="line">    first(root)</span><br><span class="line">    middle(root)</span><br><span class="line">    nextS(root)</span><br><span class="line">    result[<span class="number">0</span>]=pre</span><br><span class="line">    result[<span class="number">1</span>]=mid</span><br><span class="line">    result[<span class="number">2</span>]=next</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(threeOrder(root));</span><br></pre></td></tr></table></figure>

<br>

<h2 id="2-树的层序遍历"><a href="#2-树的层序遍历" class="headerlink" title="2.树的层序遍历"></a>2.树的层序遍历</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//节点格式</span></span><br><span class="line"><span class="comment">// * function TreeNode(x) &#123;</span></span><br><span class="line"><span class="comment">//     *   this.val = x;</span></span><br><span class="line"><span class="comment">//     *   this.left = null;</span></span><br><span class="line"><span class="comment">//     *   this.right = null;</span></span><br><span class="line"><span class="comment">//     * &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入     * @param root TreeNode类 </span></span><br><span class="line"><span class="comment">//      * @return int整型二维数组</span></span><br><span class="line"><span class="comment">//      或者</span></span><br><span class="line"><span class="comment">//      * @return int整型一维数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//循环实现层序遍历</span></span><br><span class="line"><span class="comment">//输出一个二维数组，每一个元素为一层的遍历数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">levelOrder</span>(<span class="params"> root </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">let</span> now = [root]    <span class="comment">//当前正在遍历层使用的数组</span></span><br><span class="line">    <span class="keyword">let</span> temp = []       <span class="comment">//下一层节点 因为每一层用一个数组保存所以多用一个数组</span></span><br><span class="line">    <span class="keyword">let</span> res = []    <span class="comment">//当前遍历层结果</span></span><br><span class="line">    <span class="keyword">while</span>(now.length &gt; <span class="number">0</span> || temp.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(now.length == <span class="number">0</span>)&#123;</span><br><span class="line">            result.push(res)</span><br><span class="line">            now = temp</span><br><span class="line">            temp = []</span><br><span class="line">            res = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> node = now.shift()</span><br><span class="line">        <span class="keyword">if</span>(node)&#123;</span><br><span class="line">            res.push(node.val)</span><br><span class="line">            temp.push(node.left)</span><br><span class="line">            temp.push(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环实现 </span></span><br><span class="line"><span class="comment">//结果输出为一维数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">levelOrder</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> result</span><br><span class="line">    res.push(root)</span><br><span class="line">    <span class="keyword">while</span>(res.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = res.shift()</span><br><span class="line">        result.push(node.val)</span><br><span class="line">        <span class="keyword">if</span>(node.left) res.push(node.left)</span><br><span class="line">        <span class="keyword">if</span>(node.right) res.push(node.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归实现 输出二维数组</span></span><br><span class="line"><span class="comment">//使用先序遍历的流程 通过判断层数索引index与结果数组的大小来确定当前节点放在哪一层数组中</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [], index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">index, root</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">        <span class="comment">//例如index=1 &gt;= res.length =1 说明当前遍历的节点在第二层，而结果数组中只保存了第一层的数组，需要新建数组</span></span><br><span class="line">      <span class="keyword">if</span> (index &gt;= res.length) res[index] = []</span><br><span class="line">      res[index].push(root.val)</span><br><span class="line">      dfs(index + <span class="number">1</span>, root.left)</span><br><span class="line">      dfs(index + <span class="number">1</span>, root.right)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(index, root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>01-什么是Node</title>
    <url>/2021/04/13/01-%E4%BB%80%E4%B9%88%E6%98%AFNode.js/</url>
    <content><![CDATA[<h1 id="1-Node-js介绍"><a href="#1-Node-js介绍" class="headerlink" title="1.Node.js介绍"></a>1.Node.js介绍</h1><h2 id="1-1学习Node-js的目的"><a href="#1-1学习Node-js的目的" class="headerlink" title="1.1学习Node.js的目的"></a>1.1学习Node.js的目的</h2><ul>
<li><p>用来<strong>操作使用WEB后台服务器</strong>(能够实现同样功能的后台语言还有java、python、php等)</p>
</li>
<li><p>了解后台服务器才能更好的与后端开发人员协同开发</p>
</li>
<li><p>生态系统活跃，有许多开源库可以使用</p>
</li>
<li><p>前端开发工具大多基于Node开发</p>
</li>
<li><p>学习Node.js实际上就是在学习<strong>WEB服务器开发</strong></p>
</li>
</ul>
<span id="more"></span>

<h2 id="1-2什么是Node-js"><a href="#1-2什么是Node-js" class="headerlink" title="1.2什么是Node.js"></a>1.2什么是Node.js</h2><p>Node.js官网<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p>
<p>官网对于Node.js的描述：</p>
<ul>
<li><p>Node.js® is a JavaScript runtime built on <a href="https://v8.dev/">Chrome’s V8 JavaScript engine</a>.</p>
<ul>
<li><p>Node.js是一个基于Chrome V8引擎的<strong>javaScript运行环境</strong></p>
</li>
<li><p>基于Chrome V8引擎</p>
<ul>
<li>代码只是具有特定格式的字符串</li>
<li>引擎可以帮我们去解释执行这些代码</li>
<li>Google Chrome 的V8引擎是当前公认的解释执行JavaScript最快的</li>
<li>Node.js的作者把Google Chrome的<strong>V8引擎移植出来</strong>，开发了一个<strong>独立的JavaScript运行环境</strong></li>
</ul>
</li>
<li><p>Node.js<strong>不是一门语言</strong></p>
</li>
<li><p>Node.js<strong>不是库、不是框架</strong></p>
</li>
<li><p>Node.js可以解析执行JavaScript代码</p>
</li>
<li><p>以前只有浏览器可以解释执行JavaScript代码</p>
</li>
<li><p>现在Node.js可以使JavaScript脱离浏览器解释执行</p>
</li>
<li><p>浏览器中的JavaScript</p>
<ul>
<li>ECMAScript(基本的语法)</li>
<li>DOM</li>
<li>BOM</li>
<li>DOM和BOM是浏览器给JavaScript提供的API</li>
</ul>
</li>
<li><p>Node.js中的JavaScript</p>
<ul>
<li><p><strong>不同于原来浏览器中的JavaScript</strong></p>
</li>
<li><p><strong>没有DOM、BOM</strong></p>
</li>
<li><p>由<strong>ECMAScript</strong>以及Node环境提供的一些<strong>附加API</strong>组成</p>
</li>
<li><p>Node.js这个JavaScript运行环境为JavaScript提供了一些服务器级别的操作API(应用编程接口)</p>
<ul>
<li>例如文件读写</li>
<li>网络服务构建</li>
<li>网络通信</li>
<li>http服务器等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Node.js uses an event-driven,non-blocking I/O model that makes it lightweight and efficient.</p>
<ul>
<li><p>Node.js的<strong>特性</strong></p>
</li>
<li><p>1、event-driven 事件驱动</p>
</li>
<li><p>2、non-blocking I/O model 无阻塞的I/O模组 (异步)</p>
</li>
<li><p>lightweight and efficient 轻量化和高效的</p>
</li>
</ul>
</li>
<li><p>Node.js’ package ecosystem,npm,is the largest ecosystem of open source libraries in the world.</p>
<ul>
<li>Node.js包生态系统——npm，是世界上最大的开源库生态系统</li>
<li>绝大多数JavaScript相关的包(第三方包等)都存放在npm上，为了让开发人员更方便的下载使用</li>
<li>例如使用 <code>npm install jquery</code>就可以下载jQuery的npm包</li>
</ul>
</li>
</ul>
<h2 id="1-3Node-js能做什么"><a href="#1-3Node-js能做什么" class="headerlink" title="1.3Node.js能做什么"></a>1.3Node.js能做什么</h2><ul>
<li>WEB服务器后台</li>
<li>命令行工具<ul>
<li>npm(Node开发)</li>
<li>git(C语言开发)</li>
<li>hexo(Node开发)</li>
<li>。。。</li>
</ul>
</li>
<li>对于前端工程师来说，接触Node最多的就是它的命令行工具<ul>
<li>主要是使用别人开发的第三方命令行工具<ul>
<li>webpack</li>
<li>gulp</li>
<li>。。。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-4学习资源"><a href="#1-4学习资源" class="headerlink" title="1.4学习资源"></a>1.4学习资源</h2><ul>
<li><p>《深入浅出Node.js》</p>
<ul>
<li>作者：朴(piao)灵</li>
<li>偏理论、没有实例性内容</li>
<li>对于理解底层原理有帮助</li>
<li>结合其他实例来学习更好</li>
</ul>
</li>
<li><p>《Node.js权威指南》</p>
<ul>
<li>API讲解</li>
<li>没有实例</li>
</ul>
</li>
<li><p>CNODE社区：<a href="https://cnodejs.org/">https://cnodejs.org</a></p>
<ul>
<li>其中新手入门有一些参考资料</li>
</ul>
</li>
</ul>
<h2 id="1-5学习Node-js得到什么"><a href="#1-5学习Node-js得到什么" class="headerlink" title="1.5学习Node.js得到什么"></a>1.5学习Node.js得到什么</h2><ul>
<li><p>操作使用WEB服务器后台</p>
</li>
<li><p>B/S编程模型</p>
<ul>
<li>Browser-Server 浏览器-服务器模型</li>
<li>back-end 后端</li>
<li>任何服务器端技术这种B/S编程模型都是一样的</li>
</ul>
</li>
<li><p>Node只是作为我们学习这种B/S编程模型的工具</p>
</li>
<li><p>模块化编程</p>
<ul>
<li>Node中可以像 <code>@import()</code>一样引用加载JavaScript脚本文件</li>
</ul>
</li>
<li><p>Node常用API</p>
</li>
<li><p>异步编程</p>
<ul>
<li>promise</li>
<li>回调函数</li>
<li>async</li>
<li>generator</li>
</ul>
</li>
<li><p>Express Web开发框架</p>
</li>
<li><p>ES6(穿插讲解)</p>
</li>
<li><p>为以后学习Vue，React，angular前端框架打基础</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>02-01-系统核心模块</title>
    <url>/2021/04/15/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="系统-核心-模块"><a href="#系统-核心-模块" class="headerlink" title="系统(核心)模块"></a>系统(核心)模块</h1><h2 id="1-fs模块"><a href="#1-fs模块" class="headerlink" title="1.fs模块"></a>1.fs模块</h2><p>文件系统file system模块</p>
<h3 id="1-1-fs-readFile-方法"><a href="#1-1-fs-readFile-方法" class="headerlink" title="1.1 fs.readFile()方法"></a>1.1 fs.readFile()方法</h3><p>读取文件数据方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">&quot;文件路径/文件名&quot;</span>[,<span class="string">&quot;文件编码格式&quot;</span>],callback)</span><br></pre></td></tr></table></figure>

<p>文件路径：文件存放路径</p>
<span id="more"></span>

<p>文件编码格式：utf-8等</p>
<p>callback回调函数：</p>
<ul>
<li>有两个参数err和data<ul>
<li>err错误对象<ul>
<li>如果读取出错则err为错误对象</li>
<li>如果正确则err为null</li>
</ul>
</li>
<li>data文件数据<ul>
<li>默认以二进制数串的16进制形式保存</li>
<li>如果指定了”文件编码格式“就按照编码格式输出</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;./fs.txt&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;文件读取出错&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;以二进制数串的16进制表示文件数据&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;./fs.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;文件读取出错&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;以utf-8编码格式打印文件数据&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210415211208528.png" alt="image-20210415211208528"></p>
<h3 id="1-2-插入-Nodejs中的回调函数callback"><a href="#1-2-插入-Nodejs中的回调函数callback" class="headerlink" title="1.2(插入)Nodejs中的回调函数callback"></a>1.2(插入)Nodejs中的回调函数callback</h3><p>Nodejs中所有API的回调函数的第一个参数一定是err</p>
<ul>
<li>在发生错误时err为错误对象</li>
<li>正确执行时err为null</li>
</ul>
<p>所以Nodejs中的回调函数又被称为错误优先的回调函数</p>
<h3 id="1-3-fs-writeFile-方法"><a href="#1-3-fs-writeFile-方法" class="headerlink" title="1.3 fs.writeFile()方法"></a>1.3 fs.writeFile()方法</h3><p>写入文件方法</p>
<p>文件不存在时会自动创建</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.writeFile(<span class="string">&#x27;文件路径/文件名&#x27;</span>,<span class="string">&#x27;写入的数据&#x27;</span>,callback)</span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<p>​    程序运行报错时，自动将报错信息写入错误日志(一个文件)中</p>
<p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.writeFile(<span class="string">&#x27;./fs.writeFile.txt&#x27;</span>,<span class="string">&#x27;写入fs.writeFile.txt中的数据&#x27;</span>,<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err!==<span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;写入失败&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;写入成功&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210415212815487.png" alt="image-20210415212815487"></p>
<p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210415212837679.png" alt="image-20210415212837679"></p>
<h2 id="2-path模块"><a href="#2-path模块" class="headerlink" title="2. path模块"></a>2. path模块</h2><p>路径操作</p>
<h3 id="2-1为什么要进行路径拼接"><a href="#2-1为什么要进行路径拼接" class="headerlink" title="2.1为什么要进行路径拼接"></a>2.1为什么要进行路径拼接</h3><p>不同操作系统的路径分隔符不同</p>
<ul>
<li>window使用 / 或 \</li>
<li>Linux只能使用 /</li>
</ul>
<p>Nodejs写的代码可能要在不同的操作系统上使用，所以要明确使用什么路径分隔符</p>
<h3 id="2-2-path-join"><a href="#2-2-path-join" class="headerlink" title="2.2 path.join()"></a>2.2 path.join()</h3><p>路径拼接API</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">path.join(<span class="string">&#x27;路径&#x27;</span>,<span class="string">&#x27;路径&#x27;</span>,...)</span><br></pre></td></tr></table></figure>

<p>这个API会自动检测当前系统并使用合适的分隔符</p>
<p>返回拼接之后的结果</p>
<p>示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前是windows系统，采用&#x27;\&#x27;作为分隔符</span></span><br><span class="line"><span class="comment">//输出a\b\c.txt</span></span><br><span class="line"><span class="built_in">console</span>.log(path.join(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c.txt&#x27;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210415220350958.png" alt="image-20210415220350958"></p>
<h3 id="2-3相对路径和绝对路径"><a href="#2-3相对路径和绝对路径" class="headerlink" title="2.3相对路径和绝对路径"></a>2.3相对路径和绝对路径</h3><ul>
<li><p>大多数情况使用绝对路径</p>
</li>
<li><p>相对路径有时候相对的是命令行工具的当前目录</p>
</li>
<li><p>读取文件和设置文件时都选择绝对路径</p>
</li>
<li><p>使用__dirname可以获取当前文件所在目录的绝对路径</p>
</li>
</ul>
<h4 id="1-相对路径有时候相对的是命令行工具的当前目录"><a href="#1-相对路径有时候相对的是命令行工具的当前目录" class="headerlink" title="1.相对路径有时候相对的是命令行工具的当前目录"></a>1.相对路径有时候相对的是命令行工具的当前目录</h4><h5 id="1-1命令行工具当前目录与执行的文件所在目录相同时"><a href="#1-1命令行工具当前目录与执行的文件所在目录相同时" class="headerlink" title="1.1命令行工具当前目录与执行的文件所在目录相同时"></a>1.1命令行工具当前目录与执行的文件所在目录相同时</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path=<span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时使用相对路径打开当前目录下的01-path。。。文件</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;./01-path.join.js&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210416110904752.png" alt="image-20210416110904752"></p>
<p>此时在<strong>02-绝对路径和相对路径.js</strong>使用相对路径打开当前目录下的<strong>01-path.join.js</strong>文件</p>
<p>由于命令行工具的当前目录就是执行文件的目录</p>
<p>所以readFile()中<code>./01-path.join.js</code>实际打开的文件为<strong>E:\HTML_CSS_JS学习\nodejs\new\02-核心模块path\01-path.join.js</strong></p>
<p>所以此时使用相对路径不会引起问题</p>
<h5 id="1-2命令行工具当前目录与执行的文件所在目录不同时"><a href="#1-2命令行工具当前目录与执行的文件所在目录不同时" class="headerlink" title="1.2命令行工具当前目录与执行的文件所在目录不同时"></a>1.2命令行工具当前目录与执行的文件所在目录不同时</h5><p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210416111449458.png" alt="image-20210416111449458"></p>
<p>此时命令行工具的当前目录为E:\HTML_CSS_JS学习\nodejs\new</p>
<p>执行文件所在目录为E:\HTML_CSS_JS学习\nodejs\new\02-核心模块path</p>
<p>两个目录所在位置不同</p>
<p>readFile()方法中的url如果写相对路径，则这个<strong>相对路径就相对于命令行工具目录</strong></p>
<p>此时readFile()中<code>./01-path.join.js</code>实际打开的文件为<strong>E:\HTML_CSS_JS学习\nodejs\new\01-path.join.js</strong></p>
<p>即相对路径相对于命令行工具的当前目录（上图红框）</p>
<p>此时因为找不到<strong>E:\HTML_CSS_JS学习\nodejs\new\01-path.join.js</strong>文件，会报错<code>no such file or directory</code></p>
<p>所以打开或设置文件时使用相对路径是<strong>不安全的</strong>，容易导致错误</p>
<h4 id="2-在require-中的相对路径比较特殊，就是相对于当前执行文件所在的目录"><a href="#2-在require-中的相对路径比较特殊，就是相对于当前执行文件所在的目录" class="headerlink" title="2.在require()中的相对路径比较特殊，就是相对于当前执行文件所在的目录"></a><strong>2.在require()中的相对路径比较特殊，就是相对于当前执行文件所在的目录</strong></h4><h4 id="3-读取文件和设置文件时都选择绝对路径"><a href="#3-读取文件和设置文件时都选择绝对路径" class="headerlink" title="3.读取文件和设置文件时都选择绝对路径"></a>3.读取文件和设置文件时都选择绝对路径</h4><p>nodejs中使用<code>__dirname</code>可以获取当前文件所在目录的绝对路径</p>
<p>使用<code>__dirname</code>和当前文件名进行路径拼接就可以<strong>方便的得到当前文件的绝对路径</strong></p>
<p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210416113339756.png" alt="image-20210416113339756"></p>
<p><img data-src="/images/02-01-%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/image-20210416113325415.png" alt="image-20210416113325415"></p>
<p>此时红框中第一行即为<code>__dirname</code>,当前执行文件所在目录</p>
<p>红框第二行即为拼接后的要打开文件的绝对路径</p>
<p>此时命令行工具目录与执行文件所在目录不同</p>
<p>因为代码使用了绝对路径，不会发生找不到文件的错误</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>02-nodejs中JavaScript的模块化</title>
    <url>/2021/04/13/02-nodejs%E4%B8%ADJavaScript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Nodejs的模块化"><a href="#Nodejs的模块化" class="headerlink" title="Nodejs的模块化"></a>Nodejs的模块化</h1><h2 id="1-浏览器JavaScript开发弊端"><a href="#1-浏览器JavaScript开发弊端" class="headerlink" title="1.浏览器JavaScript开发弊端"></a>1.浏览器JavaScript开发弊端</h2><p>浏览器JavaScript在使用时存在两大问题</p>
<ul>
<li>文件依赖<ul>
<li>通过script标签引入的多个js文件的依赖关系不明确，查找依赖关系不便</li>
</ul>
</li>
<li>命名冲突<ul>
<li>浏览器JavaScript通过script引入的多个js文件是<strong>完全开放</strong>的，例如a.js里声明的变量可以在b.js中访问</li>
<li>如果在后续引入的js文件中声明了一个之前引入的js文件中已有的变量，就会导致之前的变量声明被后来的覆盖</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="2-软件中的模块化"><a href="#2-软件中的模块化" class="headerlink" title="2.软件中的模块化"></a>2.软件中的模块化</h2><p>一个功能就是一个模块，多个模块可以组成完整的应用，抽离一个模块不会影响其他功能的运行。</p>
<p>比如用户页面有增加用户和删除用户两个模块</p>
<p>​    抽离删除用户的模块并不会影响增加用户的功能</p>
<h2 id="3-Nodejs模块化开发"><a href="#3-Nodejs模块化开发" class="headerlink" title="3.Nodejs模块化开发"></a>3.Nodejs模块化开发</h2><p>Nodejs的模块化开发可以解决浏览器中JavaScript开发的两大弊端</p>
<h3 id="3-1Nodejs的模块化开发规范"><a href="#3-1Nodejs的模块化开发规范" class="headerlink" title="3.1Nodejs的模块化开发规范"></a>3.1Nodejs的模块化开发规范</h3><p>Nodejs规定<strong>一个JavaScript文件就是一个模块</strong>。</p>
<p>Nodejs中引入的多个模块(JS文件)处于<strong>半封闭状态。</strong></p>
<p>Nodejs中导入模块使用require()方法</p>
<ul>
<li>require(“导入模块的路径”)</li>
<li>模块的”.js”后缀可以省略，require(a)就代表导入当前目录下的a.js模块</li>
</ul>
<h4 id="3-1-1模块成员导出的两种方式"><a href="#3-1-1模块成员导出的两种方式" class="headerlink" title="3.1.1模块成员导出的两种方式"></a>3.1.1模块成员导出的两种方式</h4><p>半封闭的模块可以将<strong>希望被外界访问的成员</strong>导出</p>
<ol>
<li><p>通过<strong>exports</strong>导出接口对象</p>
<ul>
<li><p>只有挂载在<strong>exports导出接口对象</strong>上的成员才能被外界访问</p>
</li>
<li><p>使用require()方法可以导入其他模块</p>
<ul>
<li><p>require()方法有<strong>两个作用</strong></p>
<p>**1.**加载模块并执行其中的代码</p>
<p><strong>2.<strong>拿到被加载模块的</strong>导出接口对象exports</strong>(require的返回值）</p>
<ul>
<li>通过<code>require的返回值.成员</code>即可访问导出的成员</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>通过<strong>module.exports</strong>导出接口对象</p>
<ul>
<li>挂载在<strong>module.exports导出接口对象</strong>上的成员也能被外界访问</li>
</ul>
</li>
</ol>
<h4 id="3-1-2两种导出方式的区别"><a href="#3-1-2两种导出方式的区别" class="headerlink" title="3.1.2两种导出方式的区别"></a>3.1.2两种导出方式的区别</h4><p>exports是module.exports的别名(地址引用关系，内存空间相同)</p>
<p>若两者指向的内存空间变化后不再相同，此时导出对象<strong>最终以module.exports为准</strong></p>
<ul>
<li>例如我们手动操作<code>module.exports=&#123;name:&#39;yangxiao&#39;&#125;</code></li>
<li>此时更改了module.exports对象指向的内存空间，此时module.exports和exports指向不同的内存空间</li>
<li>这时候导出接口对象以module.exports为准，exports不再作为导出接口对象</li>
</ul>
<h3 id="3-2核心-系统-模块"><a href="#3-2核心-系统-模块" class="headerlink" title="3.2核心(系统)模块"></a>3.2核心(系统)模块</h3><p>Nodejs的模块包含：</p>
<ul>
<li>核心(系统)模块(fs,http等)</li>
<li>用户自定义模块(即自己写的.js文件)</li>
<li>第三方模块</li>
</ul>
<p><strong>Node运行环境为JavaScript提供</strong>了很多服务器级别的API，这些API绝大多数都被封装到一个具有名字的<strong>核心模块</strong>中。</p>
<p>如文件操作的<code>fs</code>模块，http服务构建的 <code>http</code>模块，<code>path</code> 路径操作模块，<code>os</code>操作系统信息模块等。。。</p>
<h4 id="3-2-1使用核心模块必须先加载模块"><a href="#3-2-1使用核心模块必须先加载模块" class="headerlink" title="3.2.1使用核心模块必须先加载模块"></a>3.2.1使用核心模块必须先加载模块</h4><p>形如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//require()方法用来加载模块</span></span><br><span class="line"><span class="keyword">var</span> fs=<span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http);</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3用户自定义模块"><a href="#3-3用户自定义模块" class="headerlink" title="3.3用户自定义模块"></a>3.3用户自定义模块</h3><p>用户自定义模块：即自己写的.js文件</p>
<h3 id="3-4第三方模块"><a href="#3-4第三方模块" class="headerlink" title="3.4第三方模块"></a>3.4第三方模块</h3><p>第三方模块是别人写好的，具有特定功能的，我们可以直接使用的模块。</p>
<p>第三方模块通常<strong>由多个文件组成并且放在文件夹中</strong>，所以又名<strong>包</strong>。</p>
<h4 id="3-4-1第三方模块的两种存在方式"><a href="#3-4-1第三方模块的两种存在方式" class="headerlink" title="3.4.1第三方模块的两种存在方式"></a>3.4.1第三方模块的两种存在方式</h4><ul>
<li>以<strong>js文件</strong>存在，提供实现项目具体功能的API。</li>
<li>以<strong>命令行工具</strong>形式存在，辅助项目开发。</li>
</ul>
<h4 id="3-4-2获取第三方模块"><a href="#3-4-2获取第三方模块" class="headerlink" title="3.4.2获取第三方模块"></a>3.4.2获取第三方模块</h4><p><a href="https://www.npmjs.com/">npmjs.com</a>: 第三方模块的存储和分发仓库</p>
<p>npm: Node的包(第三方模块)管理工具，npm本身也是Node的第三方模块，npm在Node安装时就自动安装</p>
<p>使用npm获取第三方模块：</p>
<ul>
<li><strong>下载</strong> <code>npm install 模块名</code><ul>
<li>下载到命令行工具的当前目录下</li>
<li>在当前目录自动创建一个node_modules文件夹，下载的包就存放在这个文件夹下</li>
<li>还会在当前目录创建一个package-lock.json文件</li>
</ul>
</li>
<li><strong>卸载</strong> <code>npm uninstall package 模块名</code><ul>
<li>若删除包后node_modules文件夹为空，则会自动删除node_modules文件夹</li>
</ul>
</li>
<li><strong>全局安装</strong>和<strong>本地安装</strong><ul>
<li>本地安装：将模块下载到当前项目中，仅供<strong>当前项目</strong>使用<ul>
<li>一般将<strong>库文件</strong>本地安装</li>
</ul>
</li>
<li>全局安装：将项目安装到一个公共目录，<strong>所有的项目</strong>都可以使用<ul>
<li>一般将<strong>命令行工具</strong>全局安装</li>
</ul>
</li>
<li>上面给出的下载命令<code>npm install 模块名</code>是本地安装</li>
</ul>
</li>
</ul>
<h2 id="4-实现简单的模块化"><a href="#4-实现简单的模块化" class="headerlink" title="4.实现简单的模块化"></a>4.实现简单的模块化</h2><p>a.js文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//require()方法会执行相应模块中的代码</span></span><br><span class="line"><span class="comment">//在a.js文件中调用执行b.js自定义模块</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;./b.js&quot;</span>);<span class="comment">//执行b.js后会输出&quot;b.js被执行了&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>b.js文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;b.js被执行了&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>执行a.js文件后输出结果为</p>
<p><img data-src="/images/02-nodejs%E4%B8%ADJavaScript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/image-20210412112221108.png" alt="image-20210412112221108"></p>
<h3 id="4-1Nodejs中没有全局作用域，只有模块作用域"><a href="#4-1Nodejs中没有全局作用域，只有模块作用域" class="headerlink" title="4.1Nodejs中没有全局作用域，只有模块作用域"></a>4.1Nodejs中没有全局作用域，只有模块作用域</h3><ul>
<li><p>模块作用域</p>
<ul>
<li><p>内部访问不到外部</p>
</li>
<li><p>外部也访问不到内部</p>
</li>
</ul>
</li>
</ul>
<p>a.js文件</p>
<p>在a.js中定义的变量foo只在a.js**文件(模块)**中生效</p>
<p>同样a.js中定义的函数也只能在a.js文件中调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在a.js文件中定义了变量foo，这个foo文件只在a.js这个文件(模块)中生效</span></span><br><span class="line"><span class="keyword">var</span> foo=<span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//require()调用模块时，.js后缀名可以省略</span></span><br><span class="line"><span class="comment">//相对路径的./不能省略</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;./b.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里输出的foo是a.js中的foo=&quot;aaa&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>b.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b.js中定义的foo变量只在b.js文件中生效</span></span><br><span class="line"><span class="comment">//不会影响a.js文件中的foo变量</span></span><br><span class="line"><span class="keyword">var</span> foo=<span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;b.js被执行了&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>运行a.js结果</p>
<p><code>console.log(foo);</code>执行结果为aaa</p>
<p><img data-src="/images/02-nodejs%E4%B8%ADJavaScript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/image-20210412113217274.png" alt="image-20210412113217274"></p>
<h3 id="4-2模块之间怎样通信"><a href="#4-2模块之间怎样通信" class="headerlink" title="4.2模块之间怎样通信"></a>4.2模块之间怎样通信</h3><ul>
<li><p>模块作用域默认是半封闭</p>
</li>
<li><p>我们可以使用<strong>exports导出接口对象</strong>实现模块间的通信</p>
<ul>
<li>require()方法返回被调用模块的导出接口对象exports</li>
<li>每个文件模块中都提供一个对象：<strong>exports</strong>     (exports意为导出，出口)</li>
</ul>
</li>
<li><p>exports默认是一个空对象</p>
<ul>
<li>将本模块中<strong>需要被其他模块访问的属性和方法</strong>挂载在exports对象下</li>
<li>其他模块通过require()方法获取本模块的exports对象后就可以访问</li>
</ul>
</li>
</ul>
<p>a.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.js文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//require()方法返回被调用模块的导出接口对象exports</span></span><br><span class="line"><span class="keyword">var</span> ex=<span class="built_in">require</span>(<span class="string">&quot;./b&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用ex.&quot;属性，方法&quot;就可以访问b.js中导出的属性和方法</span></span><br><span class="line"><span class="built_in">console</span>.log(ex.age);</span><br><span class="line"><span class="built_in">console</span>.log(ex.add(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>b.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b.js文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> age=<span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将需要导出的属性和方法挂载在exports对象下</span></span><br><span class="line"><span class="built_in">exports</span>.age=age;</span><br><span class="line"><span class="built_in">exports</span>.add=add;</span><br></pre></td></tr></table></figure>

<p>执行a.js结果为</p>
<p><img data-src="/images/02-nodejs%E4%B8%ADJavaScript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/image-20210412120622983.png" alt="image-20210412120622983"></p>
<p><strong>同理</strong></p>
<p><strong>fs和http等核心模块加载后就可以使用其中导出的方法如fs.readFile()等</strong></p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>02-Vue简单案例图书管理</title>
    <url>/2021/09/19/02-Vue%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="Vue图书管理简单案例"><a href="#Vue图书管理简单案例" class="headerlink" title="Vue图书管理简单案例"></a>Vue图书管理简单案例</h1><p><img data-src="/images/02-Vue%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86/image-20210919200854285.png" alt="效果图"></p>
<span id="more"></span>

<h2 id="1-数组更新检测"><a href="#1-数组更新检测" class="headerlink" title="1. 数组更新检测"></a>1. 数组更新检测</h2><p>Vue对于数据的处理默认都是<strong>响应式的</strong>，即修改模板中的数据，视图中显示的数据也会同步变化</p>
<p>但是<strong>对于数组来说</strong>，Vue使用一些数组方法<strong>将数组数据的修改变为响应式的</strong></p>
<h3 id="1-1-变更方法（影响原数组）"><a href="#1-1-变更方法（影响原数组）" class="headerlink" title="1.1 变更方法（影响原数组）"></a>1.1 变更方法（影响原数组）</h3><p>Vue 将被侦听的数组的变更方法进行了包裹，所以它们<strong>也将会触发视图更新</strong>。这些被包裹过的方法包括：</p>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>shift()</code></li>
<li><code>unshift()</code></li>
<li><code>splice()</code></li>
<li><code>sort()</code></li>
<li><code>reverse()</code></li>
</ul>
<h3 id="1-2-替换数组-（返回新数组）"><a href="#1-2-替换数组-（返回新数组）" class="headerlink" title="1.2 替换数组 （返回新数组）"></a>1.2 替换数组 （返回新数组）</h3><ul>
<li><code>filter()</code></li>
<li><code>concat()</code></li>
<li><code>slice()</code></li>
</ul>
]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>03-第三方模块Gulp</title>
    <url>/2021/04/19/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/</url>
    <content><![CDATA[<h1 id="Gulp第三方模块"><a href="#Gulp第三方模块" class="headerlink" title="Gulp第三方模块"></a>Gulp第三方模块</h1><p>Gulp的基础介绍在<strong>02-02第三方模块</strong>文章中</p>
<h2 id="Gulp的插件"><a href="#Gulp的插件" class="headerlink" title="Gulp的插件"></a>Gulp的插件</h2><p>Gulp是轻内核级第三方插件，本身提供的方法很少，只有几种</p>
<ul>
<li>gulp.src()：获取任务要处理的文件</li>
<li>gulp.dest()：输出文件</li>
<li>gulp.task()：建立gulp任务</li>
<li>gulp.watch()：监控文件变化</li>
</ul>
<span id="more"></span>

<p>其他的功能都是<strong>通过插件的形式</strong>实现的</p>
<ul>
<li>gulp-htmlmin：html文件压缩</li>
<li>gulp-csso：css文件压缩</li>
<li>gulp-babel：JavaScript语法转化 (ES6 -&gt; ES5)</li>
<li>gulp-less：less转换为css</li>
<li>broswersync：浏览器实时同步</li>
<li>gulp-file-include：提取公共文件</li>
</ul>
<h3 id="1-Gulp插件使用"><a href="#1-Gulp插件使用" class="headerlink" title="1.Gulp插件使用"></a>1.Gulp插件使用</h3><ol>
<li>下载<ul>
<li>在<a href="https://www.npmjs.com/">npmjs.com</a>官网中可以搜索gulp模块的插件 (有完整使用说明)</li>
<li>使用npm命令安装</li>
</ul>
</li>
<li>在gulpfile.js文件中引入插件<ul>
<li>require()方法</li>
</ul>
</li>
<li>调用插件</li>
</ol>
<h4 id="1-1HTML操作插件"><a href="#1-1HTML操作插件" class="headerlink" title="1.1HTML操作插件"></a>1.1HTML操作插件</h4><h5 id="1-html文件代码压缩任务"><a href="#1-html文件代码压缩任务" class="headerlink" title="1.html文件代码压缩任务"></a>1.html文件代码压缩任务</h5><p>在项目上线服务器运行时代码一般要经过压缩</p>
<p>安装html压缩插件</p>
<p><code>npm install gulp-htmlmin</code>  </p>
<p>创建任务</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//压缩html文件代码任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入gulp的htmlmin插件</span></span><br><span class="line"><span class="keyword">const</span> htmlmin=<span class="built_in">require</span>(<span class="string">&#x27;gulp-htmlmin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">&#x27;htmlmin&#x27;</span>, <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//&#x27;*&#x27;匹配所有html文件</span></span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/*.html&#x27;</span>)</span><br><span class="line">    <span class="comment">//使用插件的方法压缩html文件</span></span><br><span class="line">    <span class="comment">//collapseWhitespace意为压缩空格</span></span><br><span class="line">    .pipe(htmlmin(&#123; <span class="attr">collapseWhitespace</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">    <span class="comment">//输出到dist文件夹</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在powershell中执行后，./dist文件夹下产生两个同名的html文件，里面的代码都被压缩为1行显示</p>
<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210419212228699.png" alt="image-20210419212228699"></p>
<h5 id="2-提取html文件中的公共代码"><a href="#2-提取html文件中的公共代码" class="headerlink" title="2.提取html文件中的公共代码"></a>2.提取html文件中的公共代码</h5><p>提取公共代码可以在代码变化时只需要修改公共代码，而不用修改每一个html文件，提高效率</p>
<ul>
<li>下载插件</li>
</ul>
<p><code>npm install gulp-file-include</code></p>
<ul>
<li>找到公共代码</li>
</ul>
<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210419213419546.png" alt="image-20210419213419546"></p>
<p>两个html文件同属一个网站，他们的头部框架都是相同的，头部框架就是<strong>公共代码</strong></p>
<ul>
<li>提取公共代码</li>
</ul>
<p>在src文件夹下创建common文件夹，文件夹中创建header.html用来存放两个html的公共代码</p>
<p>将公共代码即头部框架剪切到header.html文件中，删除html文件中的公共代码(<strong>后面通过header.html引回</strong>)</p>
<p>在gulpfile.js中引入模块插件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fileinclude = <span class="built_in">require</span>(<span class="string">&#x27;gulp-file-include&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>gulpfile.js的任务代码，两个功能(提取代码，压缩html)合并为一个任务</p>
<p>任务中使用插件方法<code>fileinclude()</code></p>
<p>具体插件使用方法<a href="https://www.npmjs.com/package/gulp-file-include">gulp-file-include</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.压缩html文件代码任务</span></span><br><span class="line"><span class="comment">//2.抽取html文件的公共代码</span></span><br><span class="line"><span class="comment">//在压缩前先引回提取的公共代码</span></span><br><span class="line">gulp.task(<span class="string">&#x27;htmlmin&#x27;</span>, <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//&#x27;*&#x27;匹配所有html文件</span></span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/*.html&#x27;</span>)</span><br><span class="line">    <span class="comment">//使用插件引回提取的公共代码</span></span><br><span class="line">    .pipe(fileinclude())</span><br><span class="line">    <span class="comment">//使用插件的方法压缩html文件</span></span><br><span class="line">    .pipe(htmlmin(&#123; <span class="attr">collapseWhitespace</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">    <span class="comment">//输出到dist文件夹</span></span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在html文件中使用<code>@@include(&#39;./common/header.html&#39;)</code> ， 将公共代码引回文件中</p>
<p>gulpfile.js文件中的任务使用了<code>fileinclude()</code>插件方法后，才能在html文件中使用<code>@@include(&#39;公共代码文件路径&#39;)</code></p>
<p>此时执行<code>htmlmin</code>任务，<strong>公共代码被引回html文件</strong>，并且<strong>html文件被压缩为一行</strong></p>
<h4 id="1-2-CSS和less操作插件"><a href="#1-2-CSS和less操作插件" class="headerlink" title="1.2 CSS和less操作插件"></a>1.2 CSS和less操作插件</h4><h5 id="1-less语法转换"><a href="#1-less语法转换" class="headerlink" title="1.less语法转换"></a>1.less语法转换</h5><p>下载将less文件转换为css的gulp插件</p>
<p><a href="https://www.npmjs.com/package/gulp-less">gulp-less官方文档</a></p>
<p><code>npm install gulp-less</code></p>
<p>在gulpfiles.js文件中引入插件并编写任务</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入less代码转css代码的插件</span></span><br><span class="line"><span class="keyword">const</span> less = <span class="built_in">require</span>(<span class="string">&#x27;gulp-less&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.less代码转css代码</span></span><br><span class="line"><span class="comment">//2.压缩css代码</span></span><br><span class="line">gulp.task(<span class="string">&#x27;cssmin&#x27;</span>,<span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//取src目录下所有less文件</span></span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/*.less&#x27;</span>)</span><br><span class="line">    .pipe(less())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./dist/css&#x27;</span>))</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>a.less文件被转换为a.css文件</p>
<center>a.less文件</center>

<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210425172427623.png" alt="image-20210425172427623"></p>
<center>a.css文件</center>

<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210425172652353.png" alt="image-20210425172652353"></p>
<h5 id="2-css代码压缩"><a href="#2-css代码压缩" class="headerlink" title="2.css代码压缩"></a>2.css代码压缩</h5><p><code>gulp.src([&#39;路径&#39;,&#39;路径])</code>的参数可以传递一个数组，数组中的每个元素是一个路径，将这些路径指示的文件全部获取。</p>
<p>下载gulp-csso插件</p>
<p><a href="https://www.npmjs.com/package/gulp-csso">gulp-csso官方文档</a></p>
<p><code>npm install gulp-csso</code></p>
<p>代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//css压缩</span></span><br><span class="line"><span class="keyword">const</span> csso = <span class="built_in">require</span>(<span class="string">&#x27;gulp-csso&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.less代码转css代码</span></span><br><span class="line"><span class="comment">//2.压缩css代码</span></span><br><span class="line">gulp.task(<span class="string">&#x27;cssmin&#x27;</span>,<span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//取src/css目录下所有less文件</span></span><br><span class="line">    gulp.src([<span class="string">&#x27;./src/css/*.less&#x27;</span>,<span class="string">&#x27;./src/css/*.css&#x27;</span>])</span><br><span class="line">    <span class="comment">//less代码转换</span></span><br><span class="line">    .pipe(less())</span><br><span class="line">    <span class="comment">//css压缩</span></span><br><span class="line">    .pipe(csso())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./dist/css&#x27;</span>))</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>压缩后代码</center>

<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210425173744670.png" alt="image-20210425173744670"></p>
<h4 id="1-3JS操作插件"><a href="#1-3JS操作插件" class="headerlink" title="1.3JS操作插件"></a>1.3JS操作插件</h4><p>下载插件</p>
<p><a href="https://www.npmjs.com/package/gulp-babel">gulp-babel官方文档</a></p>
<p><code>npm install gulp-babel @babel/core @babel/preset-env</code></p>
<p>@babel/core 和 @babel/preset-env 是gulp-babel依赖的包，一起下载</p>
<h5 id="1-ES6代码转换"><a href="#1-ES6代码转换" class="headerlink" title="1.ES6代码转换"></a>1.ES6代码转换</h5><p>代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//js任务</span></span><br><span class="line"><span class="comment">//1.ES6代码转换</span></span><br><span class="line"><span class="comment">//2.js代码压缩</span></span><br><span class="line">gulp.task(<span class="string">&#x27;jsmin&#x27;</span>,<span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/js/*.js&#x27;</span>)</span><br><span class="line">    .pipe(babel(&#123;</span><br><span class="line">        <span class="comment">//presets 自动判断当前环境，将代码转换为当前支持的格式</span></span><br><span class="line">        presets: [<span class="string">&#x27;@babel/env&#x27;</span>]</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./dist/js&#x27;</span>))</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center><strong>转换结果</strong></center>

<p>将右侧的ES6代码转换为左侧的<strong>严格模式的ES5代码</strong></p>
<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210425175329969.png" alt="image-20210425175329969"></p>
<h5 id="2-js代码压缩"><a href="#2-js代码压缩" class="headerlink" title="2.js代码压缩"></a>2.js代码压缩</h5><p>gulp-uglify 插件 ：压缩js代码</p>
<p>下载插件</p>
<p><a href="https://www.npmjs.com/package/gulp-uglify">gulp-uglify官方文档</a></p>
<p><code>npm install gulp-uglify</code></p>
<p>代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//js代码压缩</span></span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">&#x27;gulp-uglify&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//js任务</span></span><br><span class="line"><span class="comment">//1.ES6代码转换</span></span><br><span class="line"><span class="comment">//2.js代码压缩</span></span><br><span class="line">gulp.task(<span class="string">&#x27;jsmin&#x27;</span>,<span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/js/*.js&#x27;</span>)</span><br><span class="line">    <span class="comment">//ES6转换</span></span><br><span class="line">    .pipe(babel(&#123;</span><br><span class="line">        <span class="comment">//presets 自动判断当前环境，将代码转换为当前支持的格式</span></span><br><span class="line">        presets: [<span class="string">&#x27;@babel/env&#x27;</span>]</span><br><span class="line">    &#125;))</span><br><span class="line">    <span class="comment">//js代码压缩</span></span><br><span class="line">    .pipe(uglify())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./dist/js&#x27;</span>))</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<center>ES6转换并压缩后文件</center>

<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210425180011653.png" alt="image-20210425180011653"></p>
<h4 id="1-4文件拷背"><a href="#1-4文件拷背" class="headerlink" title="1.4文件拷背"></a>1.4文件拷背</h4><p>代码</p>
<ul>
<li>此处/*代表匹配一级的所有文件和目录<ul>
<li>若使用images/*来匹配images/a/b.jpg ，则<strong>只能匹配到images/a这个文件夹</strong>，不会匹配到b.jpg</li>
<li>此时匹配获取文件后输出的images/a文件夹是空的</li>
</ul>
</li>
<li>lib/**/*代表匹配lib文件夹下的所有目录<strong>及其子目录</strong>中的文件<ul>
<li>**代表匹配所有目录及其子目录</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将剩下的images文件夹和lib文件夹拷贝到dist文件夹下</span></span><br><span class="line">gulp.task(<span class="string">&#x27;copy&#x27;</span>,<span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/images/*&#x27;</span>)</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./dist/images&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    gulp.src(<span class="string">&#x27;./src/lib/**/*&#x27;</span>)</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./dist/lib&#x27;</span>))</span><br><span class="line">    done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="1-5一次执行多个任务"><a href="#1-5一次执行多个任务" class="headerlink" title="1.5一次执行多个任务"></a>1.5一次执行多个任务</h4><p>代码</p>
<p>执行default任务时依次执行后面数组中的每个任务</p>
<ul>
<li><strong>gulp4.0及更高版本</strong>需要使用<code>gulp.parallel(&#39;任务名&#39;,&#39;任务名&#39;,...)</code>来执行多个任务</li>
<li>gulp4.0之前的版本可以使用<code>gulp.task(&#39;default&#39;,[&#39;任务名&#39;,&#39;任务名&#39;,...])</code>来执行多个任务</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gulp.task(<span class="string">&#x27;default&#x27;</span>,gulp.parallel(<span class="string">&#x27;htmlmin&#x27;</span>,<span class="string">&#x27;cssmin&#x27;</span>,<span class="string">&#x27;jsmin&#x27;</span>,<span class="string">&#x27;copy&#x27;</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>在命令行中执行gulp命令，gulp会自动在gulpfile.js文件中寻找名为default的任务并执行</li>
<li>在命令行中执行<code>gulp</code>相当于执行<code>gulp default</code></li>
</ul>
<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210426112637572.png" alt="image-20210426112637572"></p>
<p><img data-src="/images/03-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97Gulp/image-20210426112702650.png" alt="image-20210426112702650"></p>
<ul>
<li>此时只需执行default任务就可以执行项目中所有的任务</li>
</ul>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>04-node_modules文件夹的问题</title>
    <url>/2021/04/26/04-node_modules%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="node-modules文件夹的问题"><a href="#node-modules文件夹的问题" class="headerlink" title="node_modules文件夹的问题"></a>node_modules文件夹的问题</h1><ul>
<li>文件夹下的文件过多过碎，<strong>拷贝项目时速度慢</strong></li>
<li>复杂的<strong>模块依赖关系</strong>以及<strong>模块的版本号</strong>需要被记录，避免拷贝后模块版本号不同而导致运行报错</li>
</ul>
<h2 id="1-package-json文件"><a href="#1-package-json文件" class="headerlink" title="1.package.json文件"></a>1.package.json文件</h2><ul>
<li><strong>拷贝项目给他人时不需要拷贝node_modules文件夹，只需要拷贝package.json文件</strong></li>
<li>package.json项目描述文件会记录当前项目依赖的第三方模块及其版本号和项目名称等一系列项目信息</li>
<li>别人根据package.json文件就可以下载对应的依赖第三方模块</li>
</ul>
<span id="more"></span>

<h3 id="创建package-json文件"><a href="#创建package-json文件" class="headerlink" title="创建package.json文件"></a>创建package.json文件</h3><p><strong>1.使用<code>npm init -y</code>命令在项目根目录下生成package.json文件</strong></p>
<ul>
<li><code>npm init</code> 命令执行时会询问要填写的项目基本信息，如项目名称，版本等</li>
<li><code>npm init -y</code>   <strong>-y</strong>  即意味着所有询问的信息全部采用默认值</li>
</ul>
<center>创建package.json文件</center>

<p><img data-src="/images/04-node_modules%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E9%97%AE%E9%A2%98/image-20210426115738307.png" alt="image-20210426115738307"></p>
<ul>
<li>main ：项目的主模块</li>
<li>script：命令别名</li>
<li>keywords：项目关键字</li>
<li>author：作者</li>
<li>license：协议，ISC是开放源代码协议</li>
</ul>
<p><strong>2.创建好package.json文件后，使用npm命令下载第三方模块时，该模块的版本号等信息就会被自动记录在package.json文件中</strong></p>
<p>此处使用<code>npm install formidable mime</code>命令下载两个模块</p>
<p>package.json文件中的license字段下新增dependencies字段</p>
<p>该字段中就保存了项目依赖的模块名字与版本信息</p>
<p><img data-src="/images/04-node_modules%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E9%97%AE%E9%A2%98/image-20210426120400050.png" alt="image-20210426120400050"></p>
<h2 id="2-别人拿到拷贝的package-json文件如何使用"><a href="#2-别人拿到拷贝的package-json文件如何使用" class="headerlink" title="2.别人拿到拷贝的package.json文件如何使用"></a>2.别人拿到拷贝的package.json文件如何使用</h2><ul>
<li>在项目根目录下执行<code>npm Install</code>命令</li>
<li>npm会在项目根目录下找到package.json文件中的dependencies字段</li>
<li>将其中的依赖模块<strong>自动按版本号进行下载</strong></li>
<li>下载完毕后根目录下会自动生成node_modules文件夹，其中就存放着下载的依赖模块</li>
</ul>
<h2 id="3-项目-开发依赖"><a href="#3-项目-开发依赖" class="headerlink" title="3.项目/开发依赖"></a>3.项目/开发依赖</h2><ul>
<li>项目依赖：即开发和上线运行都需要的第三方模块</li>
<li>开发依赖：只在开发过程需要，在<strong>上线运行时不需要</strong>的第三方模块</li>
</ul>
<p>安装npm包时</p>
<ul>
<li>使用<code>npm install 包名</code>，此时安装的包信息自动添加到package.json文件中的<strong>dependencies字段</strong>，属于<strong>项目依赖</strong></li>
<li>使用 <code>npm install 包名 --save-dev</code> ，此时安装的包信息添加到package.json文件中的<strong>devDependencies字段</strong>，属于<strong>开发依赖</strong></li>
</ul>
<p>例如gulp第三发模块就是<strong>开发依赖</strong>，只在开发阶段使用。</p>
<p>使用 <code>npm install gulp --save-dev</code>安装后，package.json文件如下</p>
<p>在<strong>devDependencies字段</strong>中出现gulp的模块名和版本信息</p>
<p><img data-src="/images/04-node_modules%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E9%97%AE%E9%A2%98/image-20210426195127018.png" alt="image-20210426195127018"></p>
<p>根据package.json文件安装依赖时</p>
<ul>
<li>使用 <code>npm install</code>命令会安装package.json文件中<strong>所有的依赖</strong>，包括项目和开发依赖</li>
<li>使用 <code>npm install --production</code>命令只会安装package.json文件中的<strong>项目依赖</strong>，即<strong>independencies字段</strong>中的第三方模块</li>
</ul>
<h2 id="4-package-lock-json文件"><a href="#4-package-lock-json文件" class="headerlink" title="4.package-lock.json文件"></a>4.package-lock.json文件</h2><p><strong>记录模块与模块之间复杂的依赖关系</strong></p>
<p>下载模块时在目录下<strong>自动生成</strong>package-lock.json文件</p>
<p>详细记录了包的信息，如下载地址、版本和依赖关系等</p>
<p><img data-src="/images/04-node_modules%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E9%97%AE%E9%A2%98/image-20210426200058484.png" alt="image-20210426200058484"></p>
<h3 id="package-lock-json文件的作用"><a href="#package-lock-json文件的作用" class="headerlink" title="package-lock.json文件的作用"></a>package-lock.json文件的作用</h3><ul>
<li>详细记录了包的版本等信息，确保再次下载时不会下载错误的版本</li>
<li>加快下载速度，文件中记录了包的下载地址及项目依赖的第三方包的树状结构，重新下载时不需要做额外工作</li>
</ul>
<h2 id="5-package-json中scripts字段的作用"><a href="#5-package-json中scripts字段的作用" class="headerlink" title="5.package.json中scripts字段的作用"></a>5.package.json中scripts字段的作用</h2><p>scripts字段可以给常用的较长的命令起别名，提升开发效率</p>
<p>使用别名执行命令：<code>npm run &quot;别名&quot;</code></p>
<p>例如 <code>nodemon a.js</code> 这个命令经常执行</p>
<p>可以在scripts字段中添加以下代码</p>
<p><img data-src="/images/04-node_modules%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E9%97%AE%E9%A2%98/image-20210426200608237.png" alt="image-20210426200608237"></p>
<p>即给<code>nodemon a.js</code>这个命令起了一个别名 build</p>
<p>之后可以使用 <code>npm run build</code>命令来代替<code>nodemon a.js</code>命令</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>05-nodejs中的模块加载机制</title>
    <url>/2021/04/26/05-nodejs%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="nodejs中的模块加载机制"><a href="#nodejs中的模块加载机制" class="headerlink" title="nodejs中的模块加载机制"></a>nodejs中的模块加载机制</h1><p>nodejs使用<code>require(&#39;&#39;)</code>方法来加载模块，参数即为模块名或者路径</p>
<h2 id="require-查找模块"><a href="#require-查找模块" class="headerlink" title="require()查找模块"></a>require()查找模块</h2><h3 id="1-拥有完整路径-有路径但没有模块后缀"><a href="#1-拥有完整路径-有路径但没有模块后缀" class="headerlink" title="1.拥有完整路径/有路径但没有模块后缀"></a>1.拥有完整路径/有路径但没有模块后缀</h3><p>1.如果<code>require(&#39;模块&#39;)</code>参数中使用完整路径，则直接按照路径引入，找不到文件则报错</p>
<ul>
<li>例如 <code>require(&#39;./find.js&#39;)</code></li>
<li>完整模块路径可以是<strong>相对/绝对路径</strong></li>
<li>此时执行<code>require(&#39;./find.js&#39;)</code>代码时，会在相应的目录下找对应的find.js文件引入执行</li>
</ul>
<span id="more"></span>

<p>2.如果参数中模块后缀省略，先找相应的同名js文件，再找同名的文件夹</p>
<ul>
<li>例如 <code>require(&#39;./find&#39;)</code></li>
<li>先找对应目录下的find.js文件</li>
<li>找不到就找同名的find文件夹</li>
</ul>
<p>3.如果找到同名文件夹则引入执行文件夹中的<strong>index.js模块</strong></p>
<ul>
<li>找不到同名文件夹则报错</li>
</ul>
<p>4.如果文件夹中没有index.js模块，就会找当前文件夹(与参数中模块同名的文件夹)下的package.json文件,并引入执行其中main字段的主/入口模块</p>
<p>5.如果没有指定的入口模块或者入口模块找不到，则报错</p>
<h3 id="2-没有路径且没有后缀"><a href="#2-没有路径且没有后缀" class="headerlink" title="2.没有路径且没有后缀"></a>2.没有路径且没有后缀</h3><p>例如：<code>require(&#39;find&#39;)</code></p>
<p>1.nodejs先假设find模块为系统模块，在系统模块中查找</p>
<p>2.系统模块查找不到就进入当前目录的node_modules文件夹中</p>
<p>3.在node_modules文件夹中首先查找同名js文件</p>
<p>4.查找不到同名文件则查找同名文件夹(find文件夹)</p>
<p>5.引入执行同名文件夹(find文件夹)中的index.js模块</p>
<p>6.如果没有index.js模块，则查看当前文件夹(find文件夹)下的package.json文件中main字段指示的入口模块</p>
<p>7.引入执行package.json文件中main字段指示的入口模块</p>
<p>8.若没有main字段，或者入口模块找不到则报错</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>02-02-第三方模块</title>
    <url>/2021/04/19/02-02-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h1><p><a href="https://www.npmjs.com/">npmjs.com</a>: 第三方模块的存储和分发仓库</p>
<h2 id="1-第三方模块-nodemon"><a href="#1-第三方模块-nodemon" class="headerlink" title="1.第三方模块 nodemon"></a>1.第三方模块 nodemon</h2><p>nodemon是命令行工具，辅助项目开发</p>
<p>在Node.js中，每次修改文件都需要重新执行文件，比较繁琐</p>
<p>nodemon可以在保存时自动执行文件</p>
<span id="more"></span>

<h3 id="1-2使用"><a href="#1-2使用" class="headerlink" title="1.2使用"></a>1.2使用</h3><ul>
<li><p>安装</p>
<ul>
<li><p><code>npm install nodemon -g</code></p>
</li>
<li><p>命令行工具全局安装使用 -g</p>
</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li>在命令行工具中使用<code>nodemon</code>替代<code>node</code>执行nodejs文件</li>
</ul>
</li>
</ul>
<p><img data-src="/images/02-02-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/image-20210419110644336.png" alt="image-20210419110644336"></p>
<p>执行完文件后会将命令行窗口挂起，等待执行的文件保存，保存文件后会<strong>自动执行文件</strong>，使用Ctrl+C可以退出nodemon</p>
<p>现在在文件中添加一个输出后保存，效果如下</p>
<p><img data-src="/images/02-02-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/image-20210419111005039.png" alt="image-20210419111005039"></p>
<h2 id="2-第三方模块nrm"><a href="#2-第三方模块nrm" class="headerlink" title="2.第三方模块nrm"></a>2.第三方模块nrm</h2><p>nrm(npm registry manager)：npm下载地址切换工具</p>
<p>npm默认下载地址在国外，下载速度较慢，经常断线</p>
<p>nrm可以将下载地址切换为为国内的服务器</p>
<ul>
<li>如阿里巴巴就有这样的服务器，每隔10分钟与官方的node服务器同步一次</li>
<li>使用国内服务器就可以加快下载速度，与使用官方服务器下载的包是一样的</li>
</ul>
<h3 id="2-1下载使用"><a href="#2-1下载使用" class="headerlink" title="2.1下载使用"></a>2.1下载使用</h3><ol>
<li><code>npm install nrm -g </code>   全局安装</li>
<li>使用nrm ls 查询可用下载地址列表<ul>
<li>npm为国外官方下载地址</li>
<li>带*号的是当前选择的下载地址</li>
</ul>
</li>
<li>切换npm下载地址为国内服务器 <code>nrm use 下载地址名称</code><ul>
<li>这里选择阿里巴巴的taobao</li>
</ul>
</li>
</ol>
<p><img data-src="/images/02-02-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/image-20210419113538099.png" alt="image-20210419113538099"></p>
<h2 id="3-第三方模块Gulp"><a href="#3-第三方模块Gulp" class="headerlink" title="3.第三方模块Gulp"></a>3.第三方模块Gulp</h2><p>gulp是一种基于Node平台开发的前端构建工具</p>
<p>可以将机械化的操作编写成任务，在执行时只需要在命令行输入编写好的命令任务就可以。</p>
<p>机器代替手工，加开效率</p>
<h4 id="3-1Gulp能做什么"><a href="#3-1Gulp能做什么" class="headerlink" title="3.1Gulp能做什么"></a>3.1Gulp能做什么</h4><ul>
<li>项目上线时，HTML，CSS，JS代码压缩合并</li>
<li>语法转换(es6转es5，less转css等)</li>
<li>公共文件抽离(修改时只需要修改抽离的文件)</li>
<li>修改文件浏览器自动刷新(之前修改完需要手动刷新)</li>
</ul>
<h4 id="3-2使用Gulp"><a href="#3-2使用Gulp" class="headerlink" title="3.2使用Gulp"></a>3.2使用Gulp</h4><p>下载</p>
<p><code>npm install gulp</code>下载<strong>库文件</strong>，库文件是本地安装，只有当前项目能用</p>
<p>使用</p>
<ol>
<li>在项目根目录下新建gulpfile.js文件(文件名不能随意更改)</li>
<li>重构项目的文件夹结构，src目录下放置源代码文件，dist目录放置构建后的文件</li>
<li>在gulpfile.js中编写任务</li>
<li>在命令行工具中执行gulp任务</li>
</ol>
<h4 id="3-3Gulp提供了哪些编写任务的API"><a href="#3-3Gulp提供了哪些编写任务的API" class="headerlink" title="3.3Gulp提供了哪些编写任务的API"></a>3.3Gulp提供了哪些编写任务的API</h4><ul>
<li>gulp.src()：获取任务要处理的文件</li>
<li>gulp.dest()：输出文件</li>
<li>gulp.task()：建立gulp任务</li>
<li>gulp.watch()：监控文件变化</li>
</ul>
<h4 id="3-4第一个gulp任务"><a href="#3-4第一个gulp任务" class="headerlink" title="3.4第一个gulp任务"></a>3.4第一个gulp任务</h4><p>gulp任务写在gulpfile.js文件中</p>
<p><strong>1.使用 <code>gulp.task(&#39;任务名&#39;,callback</code>)  创建任务</strong></p>
<ul>
<li>两个参数<ul>
<li>任务名，标识任务时使用</li>
<li>回调函数，执行任务就是执行这个函数</li>
</ul>
</li>
</ul>
<p><strong>2.完成复制文件的操作</strong></p>
<ul>
<li>使用 <code>gulp.src(&#39;文件路径/文件名&#39;)</code> 获取文件</li>
<li>在   <code>.pipe()</code> 中写处理代码 </li>
<li><code>.pipe(gulp.dest(&#39;路径/文件名&#39;))</code> 这里将base.css这个文件复制到<code>dist/css</code>文件夹下(css文件夹会自动创建)</li>
</ul>
<p><img data-src="/images/02-02-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/image-20210419193029547.png" alt="image-20210419193029547"></p>
<p><strong>3.执行这个gulp任务需要用到与gulp库文件同名的gulp命令行工具</strong></p>
<p>执行的不是gulpfile.js这个文件，而是文件中的 ‘first’ 任务</p>
<p>所以需要使用gulp命令行工具</p>
<p>1.安装gulp命令行工具</p>
<p><code>npm install gulp-cli -g</code>    命令行工具全局安装</p>
<p>2.使用gulp命令执行gulp任务</p>
<p><code>gulp first</code>  即执行了名为first的任务</p>
<p><img data-src="/images/02-02-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/image-20210419194002502.png" alt="image-20210419194002502"></p>
<ul>
<li><p>输出了<code>我的第一个gulp任务</code></p>
</li>
<li><p>接着在 <code>./dist/css</code>文件夹下也发现了复制的base.css文件</p>
</li>
<li><p>执行成功</p>
</li>
<li><p>Using gulpfile代表使用了gulpfile.js文件</p>
</li>
<li><p>Starting ‘first’ 开始执行first任务</p>
</li>
</ul>
<p><strong>但是在执行时出现了两行红字</strong></p>
<ul>
<li>因为任务可能包含异步代码，所以必须在任务完成执行时发出信号（“异步完成”）。</li>
</ul>
<p>在“Gulp3.x”中，你可以不做这个就离开。如果您没有显式地发出异步完成的信号，那么Gulp只会假定您的任务是同步的，</p>
<p>并且一旦您的任务函数返回，它就完成了。<strong>Gulp4.x在这方面更严格。你必须明确地发出任务完成的信号。</strong></p>
<p>这里我是用的gulp版本为4.0.2，需要明确发出任务完成的信号。</p>
<p><strong>解决办法</strong></p>
<p>在callback回调函数中使用一个done形参，在函数内部的最后加上<code>done()</code> 来标识<strong>异步任务结束</strong></p>
<p><img data-src="/images/02-02-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/image-20210419195502159.png" alt="image-20210419195502159"></p>
<p>此时不再报错</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>06-服务器端基本概念</title>
    <url>/2021/04/26/06-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="服务器端基本概念"><a href="#服务器端基本概念" class="headerlink" title="服务器端基本概念"></a>服务器端基本概念</h1><h2 id="1-URL"><a href="#1-URL" class="headerlink" title="1.URL"></a>1.URL</h2><p><strong>URL：统一资源定位符，标识internet网上资源的一种编码方式</strong></p>
<p>使用URL可以唯一标识网络上的一个资源</p>
<p>URL组成：</p>
<ul>
<li><strong>传输协议</strong>://<strong>服务器IP或域名:端口号</strong>/<strong>资源所在位置的标识</strong></li>
<li>例如: <code>http://www.baidu.com/news/a.html</code></li>
<li>即使用http协议访问域名为<code>www.baidu.com</code>，端口号为默认80的这个web服务器上的news文件夹下的a.html文件</li>
<li>http：超文本传输协议，一种发布和接收html文件的方法</li>
<li>IP或域名可以找到网络上的一台服务器，端口则代表这台服务器上的应用程序提供的服务，http默认端口为80</li>
<li>资源所在位置标识：<strong>不一定是服务器上资源的路径</strong>，请求提交给服务器后，服务器可以根据位置标识做出其他的操作，服务器给客户端返回什么资源是服务器自身决定的</li>
</ul>
<span id="more"></span>

<h2 id="2-开发过程客户端和服务端说明"><a href="#2-开发过程客户端和服务端说明" class="headerlink" title="2.开发过程客户端和服务端说明"></a>2.开发过程客户端和服务端说明</h2><p>开发过程中，客户端和服务端使用同一台电脑，即开发人员的电脑</p>
<p>开发人员电脑上的<strong>浏览器</strong>即为<strong>客户端</strong></p>
<p>开发人员电脑上的Node可以编写服务器，可以作为<strong>服务端</strong>，即软件层面的服务器</p>
<p>本机域名：localhost</p>
<p>本机IP：127.0.0.1</p>
<p>使用本机IP/域名就可以使用本机的客户端访问本机的服务端</p>
<h2 id="3-nodejs构建简单web服务器"><a href="#3-nodejs构建简单web服务器" class="headerlink" title="3.nodejs构建简单web服务器"></a>3.nodejs构建简单web服务器</h2><p>server.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Node中有一个核心模块：http</span></span><br><span class="line"><span class="comment">//这个模块就是用来创建编写服务器的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器</span></span><br><span class="line">    <span class="comment">//接受请求</span></span><br><span class="line">    <span class="comment">//处理请求</span></span><br><span class="line">    <span class="comment">//给出响应(反馈)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.引入核心模块http</span></span><br><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用http.createServer()创建一个WEB服务器</span></span><br><span class="line"><span class="comment">//      方法返回一个Server实例</span></span><br><span class="line"><span class="keyword">var</span> server=http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.注册request请求事件，当浏览器请求发向服务器时触发</span></span><br><span class="line"><span class="comment">//第二个参数是事件处理函数</span></span><br><span class="line">    <span class="comment">//请求处理函数中接收两个参数</span></span><br><span class="line">        <span class="comment">//Request   请求对象</span></span><br><span class="line">            <span class="comment">//获取客户端的一些请求信息，例如请求路径</span></span><br><span class="line">        <span class="comment">//Response  响应对象</span></span><br><span class="line">            <span class="comment">//用来给客户端发送响应信息</span></span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//服务器接收到客户端请求后就在后台输出 请求的url(路径)</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;接受到请求，请求路径为：&quot;</span>+request.url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//response对象的write()方法可以给客户端发送响应数据</span></span><br><span class="line">        <span class="comment">//此时客户端访问http://127.0.0.1/3000/ 时会返回hello nodejs</span></span><br><span class="line">    response.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    response.write(<span class="string">&quot; nodejs&quot;</span>);</span><br><span class="line">    <span class="comment">//可以有多个write()但最后必须有一个end()结束响应 否则客户端会一直等待</span></span><br><span class="line">    <span class="comment">//也可以直接使用end()返回响应数据</span></span><br><span class="line">    response.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.绑定端口号，启动服务器</span></span><br><span class="line"><span class="comment">//第二个参数的函数在服务器启动时执行(起日志作用)</span></span><br><span class="line">server.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//在3000端口启动服务器</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;服务器启动成功，可以通过http://127.0.0.1/3000/访问&quot;</span>);</span><br><span class="line">    <span class="comment">//127.0.0.1也可以换成localhost</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>请求处理函数中接收两个参数</p>
<ul>
<li>Request   请求对象：获取客户端的一些请求信息，例如请求路径等</li>
<li>Response  响应对象：用来给客户端发送响应信息<ul>
<li>第一个<code>response.end()</code>执行完后，服务器就已经结束响应</li>
<li>后面代码中的<code>response.end()</code>将不再向浏览器响应数据</li>
</ul>
</li>
</ul>
<p>node执行这个文件</p>
<p><img data-src="/images/06-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20210426213253506.png" alt="image-20210426213253506"></p>
<p>浏览器访问结果</p>
<p><img data-src="/images/06-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20210426213340606.png" alt="image-20210426213340606"></p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>07-HTTP协议</title>
    <url>/2021/04/26/07-HTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><h2 id="1-HTTP协议概念"><a href="#1-HTTP协议概念" class="headerlink" title="1.HTTP协议概念"></a>1.HTTP协议概念</h2><p>HTTP(Hyper Text Transfer Protocol)：超文本传输协议,规定如何从服务器传输超文本文件(HTML文件)到浏览器，基于浏览器-服务器(B-S)架构工作，是客户端和服务器请求和应答的标准</p>
<p>超文本(HTML)：在文本中不仅仅能包含文字，还可以包含音频视频图像等资源</p>
<h2 id="2-报文"><a href="#2-报文" class="headerlink" title="2.报文"></a>2.报文</h2><p>HTTP<strong>请求和响应的数据块</strong>被称为报文，包括要传送的数据和一些附加信息，并且遵守规定好的格式</p>
<p><strong>请求报文</strong>：浏览器发给服务器的HTTP请求报文</p>
<p><strong>响应报文</strong>：服务器发给浏览器的HTTP响应报文</p>
<span id="more"></span>

<center>利用浏览器的开发者工具可以看到浏览器和服务器进行通信的请求和响应报文</center>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426214103527.png" alt="image-20210426214103527"></p>
<p>Network选项卡可以看到当前浏览器和服务器之间的通信情况</p>
<p>下面的localhost和favicon.ico即为浏览器向服务器发送的两个HTTP请求</p>
<ul>
<li>localhost即为我们输出网址回车后发出的请求</li>
<li>favicon.ico为浏览器默认的请求，请求该网页的标识小图标</li>
</ul>
<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426214318773.png" alt="image-20210426214318773"></p>
<center>点击请求可以看到更详细的信息</center>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426214439234.png" alt="image-20210426214439234"></p>
<p>Headers选项卡展示了请求和响应的头部等信息，General中显示了请求和响应中的重要信息</p>
<ul>
<li>报文头部中的信息以<code>:</code>分隔的键值对表示，键值对之间使用 <code>,</code>分隔</li>
</ul>
<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426222733888.png" alt="image-20210426222733888"></p>
<p>Response中则展示了服务器实际响应的数据</p>
<h3 id="1-请求报文"><a href="#1-请求报文" class="headerlink" title="1.请求报文"></a>1.请求报文</h3><h4 id="1-请求方式-Request-Method"><a href="#1-请求方式-Request-Method" class="headerlink" title="1.请求方式(Request Method)"></a>1.请求方式(Request Method)</h4><ul>
<li><strong>GET</strong>: 一般用来获取数据，也可以向服务器发送少量数据(发送的数据大小有限制)，但是不安全</li>
<li><strong>POST</strong>: 一般用来向服务器发送数据(可以发送大量数据)，网站的一般逻辑操作也使用POST方法，POST方法比GET方法安全性高</li>
</ul>
<p><strong>例如：直接在浏览器输入网址访问服务器默认发送的是GET请求</strong></p>
<p>服务器端可以获取浏览器的请求方式</p>
<p><code>request.method</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取请求方式 在服务器后输出</span></span><br><span class="line"><span class="built_in">console</span>.log(request.method);</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426215848666.png" alt="image-20210426215848666"></p>
<p>使用浏览器输入网址访问服务器</p>
<p>服务器后台输出两个GET，代表localhost请求和favicon.ico请求均为GET请求</p>
<br>

<p><strong>例如：html文件中表格form提交时可以指定提交方式，指定为POST即使用POST方式请求</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">       action:提交到哪个服务器</span></span><br><span class="line"><span class="comment">       method：提交采用什么方式</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:3000&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<center>服务器后台显示</center>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426220411454.png" alt="image-20210426220411454"></p>
<p>此处第一次表格提交为POST请求，第二次请求页面小图标favicon.ico为GET请求</p>
<p><strong>服务器可以根据对同一网址的不同请求方式做出不同响应</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当请求方式为GET时</span></span><br><span class="line"><span class="keyword">if</span>(request.method == <span class="string">&#x27;GET&#x27;</span>)&#123;</span><br><span class="line">        response.end(<span class="string">&quot;GET&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(request.method == <span class="string">&#x27;POST&#x27;</span>)&#123;</span><br><span class="line">        response.end(<span class="string">&quot;POST&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        response.end(<span class="string">&quot;hello nodejs&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码会根据请求方式不同，给浏览器响应不同的数据</p>
<p>例如：直接按网址访问服务器会响应’GET’，点击表单提交按钮访问服务器会响应’POST’</p>
<h4 id="2-请求URL"><a href="#2-请求URL" class="headerlink" title="2.请求URL"></a>2.请求URL</h4><p><code>request.url</code>获取浏览器请求URL中从 ‘/‘ 开始的资源标识符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取请求URL根据请求URL返回不同的数据</span></span><br><span class="line">    <span class="keyword">if</span>(request.url == <span class="string">&#x27;/index&#x27;</span>|| request.url == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">        response.end(<span class="string">&#x27;index&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (request.url == <span class="string">&#x27;/list&#x27;</span>)&#123;</span><br><span class="line">        response.end(<span class="string">&#x27;list&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        response.end(<span class="string">&#x27;404NotFound!&#x27;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当请求地址为<code>http://localhost:3000</code>时，浏览器给服务器发送的请求会自动在url末尾加上 ‘/‘ </li>
<li>实际发送的url为<code>http://localhost:3000/</code>，所以服务器request.url获取的值都是以 ‘/‘ 开头的</li>
</ul>
<h4 id="3-请求头部Headers"><a href="#3-请求头部Headers" class="headerlink" title="3.请求头部Headers"></a>3.请求头部Headers</h4><p><code>request.headers</code> 获取请求报文的请求头</p>
<p><code>request.headers[&#39;字段名&#39;]</code>获取请求头中特定字段的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将请求头信息在后台输出</span></span><br><span class="line"><span class="built_in">console</span>.log(request.headers);</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426223953815.png" alt="image-20210426223953815"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回请求头中&#x27;accept&#x27;字段的值</span></span><br><span class="line"><span class="built_in">console</span>.log(request.headers[<span class="string">&#x27;accept&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210426224158174.png" alt="image-20210426224158174"></p>
<br>

<h3 id="2-响应报文"><a href="#2-响应报文" class="headerlink" title="2.响应报文"></a>2.响应报文</h3><h4 id="1-HTTP状态码"><a href="#1-HTTP状态码" class="headerlink" title="1.HTTP状态码"></a>1.HTTP状态码</h4><ul>
<li>200 OK 代表请求成功</li>
<li>300 重定向</li>
<li>404 请求资源没找到</li>
<li>500 服务器端错误(服务器代码报错等)</li>
<li>400 客户端请求有语法错误等</li>
</ul>
<p>在浏览器开发者工具中可以看到HTTP响应的状态码</p>
<p>在服务器端可以使用<code>response.writeHead(HTTP状态码)</code> 指定响应时的状态码</p>
<p>如设置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">response.writeHead(<span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<p>服务器返回的响应报文中HTTP状态码就为200 OK</p>
<h4 id="2-内容类型"><a href="#2-内容类型" class="headerlink" title="2.内容类型"></a>2.内容类型</h4><p>响应数据时需要设定响应数据的类型，以便浏览器根据数据类型对返回的数据进行解析</p>
<ul>
<li>text/plain    纯文本 (默认的内容类型，不指定时默认纯文本) </li>
<li>text/html    html文本(浏览器自动解析其中的html代码)</li>
<li>text/css       css文本</li>
<li>application/javascript   javascript文本</li>
<li>application/json   json文本</li>
<li>image/jpeg     .jpeg格式的图片</li>
</ul>
<p>使用如下代码设置内容类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">response.writeHead(HTTP状态码,&#123;</span><br><span class="line">	<span class="string">&#x27;content-type&#x27;</span>:<span class="string">&#x27;text/plain;charset=utf-8&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其中<code>charset=utf-8</code>代表指明响应给浏览器的数据的编码格式，utf-8编码可以解析中文</p>
<h2 id="3-HTTP请求与响应处理"><a href="#3-HTTP请求与响应处理" class="headerlink" title="3.HTTP请求与响应处理"></a>3.HTTP请求与响应处理</h2><h3 id="1-请求参数"><a href="#1-请求参数" class="headerlink" title="1.请求参数"></a>1.请求参数</h3><p>客户端向服务端发送请求时，有时需要<strong>向服务端传递一些数据</strong>，这些数据通过<strong>请求参数的方式</strong>传递到服务端，例如登陆操作</p>
<h4 id="1-GET请求参数"><a href="#1-GET请求参数" class="headerlink" title="1.GET请求参数"></a>1.GET请求参数</h4><p>参数被放置在浏览器地址栏(URL)中，例如<strong><code>http://localhost:3000/?name=yang&amp;age=20</code></strong></p>
<p>这里的<code>name=yang&amp;age=20</code>就为请求参数</p>
<ul>
<li>请求参数使用<code>?</code>与URL隔开</li>
<li>请求参数中的不同参数使用<code>&amp;</code>分隔</li>
<li>请求参数以键值对的形式表示如： <code>name=yang</code>，键值之间使用<code>=</code>分隔</li>
</ul>
<h5 id="1-服务端如何获取GET请求参数"><a href="#1-服务端如何获取GET请求参数" class="headerlink" title="1.服务端如何获取GET请求参数"></a>1.服务端如何获取GET请求参数</h5><p>使用<code>request.url</code>可以获取请求URL，如果有请求参数，res.url会一并获取请求参数</p>
<center>获取的请求URL(带请求参数)</center>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210427214415414.png" alt="image-20210427214415414"></p>
<ul>
<li>可以通过字符串截取的方式获得？后的请求参数</li>
<li>node中内置了<strong>url系统模块</strong>，可以用来处理请求URL和请求参数</li>
</ul>
<br>

<p>url模块中的<code>url.parse(&#39;URL&#39;)</code>方法可以将URL的详细信息以对象的形式返回</p>
<p><strong>url.parse()</strong></p>
<ul>
<li>第一个参数为请求URL</li>
<li>第二个参数为true/false<ul>
<li>true意为<strong>将请求参数解析为对象形式</strong>(返回的URL对象的query属性为一个对象)</li>
<li>false意为请求参数以字符串返回(query属性为一个字符串)</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> url=<span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="comment">//获取url后以对象形式返回并在后台输出</span></span><br><span class="line"><span class="built_in">console</span>.log(url.parse(request.url));</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210427215213302.png" alt="image-20210427215213302"></p>
<p>query属性为<strong>字符串形式的请求参数</strong></p>
<br>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(url.parse(request.url,<span class="literal">true</span>));</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210427220107218.png" alt="image-20210427220107218"></p>
<p>query属性为<strong>对象形式的请求参数</strong></p>
<p>使用如下代码即可获取请求参数中的数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> query = url.parse(request.url,<span class="literal">true</span>).query</span><br><span class="line">    <span class="built_in">console</span>.log(query.name);</span><br><span class="line">    <span class="built_in">console</span>.log(query.age);</span><br></pre></td></tr></table></figure>

<h5 id="2-URL中加入请求参数后判断请求的资源标识符"><a href="#2-URL中加入请求参数后判断请求的资源标识符" class="headerlink" title="2.URL中加入请求参数后判断请求的资源标识符"></a>2.URL中加入请求参数后判断请求的资源标识符</h5><p>URL中加入请求参数后原来使用<code>request.url</code>判断请求资源标识符的方法需要修改</p>
<p><code>url.parse()</code>返回的对象中的<strong>pathname属性</strong>即为不带请求参数的请求资源标识符</p>
<p>使用ES6对象解构的方式获得query和pathname</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;query,pathname&#125; = url.parse(request.url,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>使用pathname判断请求资源标识符就可以解决这个问题</p>
<h4 id="2-POST请求参数"><a href="#2-POST请求参数" class="headerlink" title="2.POST请求参数"></a>2.POST请求参数</h4><p>一般在<strong>提交表单时</strong>请求参数使用POST方式发送</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:3000&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>POST方式的请求参数放在<strong>请求报文中</strong>，不在URL中</p>
<p>POST和GET方式的请求参数格式是<strong>一样</strong>的</p>
<p>表单中请求参数的名字写在<code>input</code>标签中，如<code>name=&quot;username&quot;</code></p>
<p><code>&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;</code></p>
<center>POST请求，请求报文中的请求参数，浏览器开发者工具查看</center>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210427222838580.png" alt="image-20210427222838580"></p>
<h5 id="1-服务端获取POST请求参数"><a href="#1-服务端获取POST请求参数" class="headerlink" title="1.服务端获取POST请求参数"></a>1.服务端获取POST请求参数</h5><p>POST请求参数通过request对象的事件接收</p>
<ul>
<li>data事件  当请求参数传递时触发(POST请求传递的数据理论上可以<strong>无限制</strong>，服务端可能需要<strong>分批接收</strong>)</li>
<li>end事件   当请求参数传递完毕时触发</li>
<li>request的data和end事件注册写在<strong>服务器的request请求事件中</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.on(<span class="string">&quot;request&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//创建变量接收POST请求参数</span></span><br><span class="line">    <span class="keyword">let</span> datasum=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">//data事件注册 params参数即为传来的参数</span></span><br><span class="line">    request.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//可能分批接收，所以使用+=接收所有数据</span></span><br><span class="line">        datasum+=params</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//end事件注册</span></span><br><span class="line">    request.on(<span class="string">&#x27;end&#x27;</span>,<span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(datasum);</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    response.end(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>将传来的数据在后台输出如下</center>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210427225303155.png" alt="image-20210427225303155"></p>
<br>

<h5 id="2-将获取的字符串格式的POST请求参数转换为对象格式"><a href="#2-将获取的字符串格式的POST请求参数转换为对象格式" class="headerlink" title="2.将获取的字符串格式的POST请求参数转换为对象格式"></a>2.将获取的字符串格式的POST请求参数转换为对象格式</h5><p>使用node系统模块<code>queryString</code>的<code>parse()</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入queryString模块转换请求参数格式</span></span><br><span class="line"><span class="keyword">const</span> queryString = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串格式的请求参数转换为对象格式并在后台输出</span></span><br><span class="line"><span class="comment">//此代码写在request对象的end事件中</span></span><br><span class="line"><span class="built_in">console</span>.log(queryString.parse(datasum));</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210427225733016.png" alt="image-20210427225733016"></p>
<h3 id="2-路由"><a href="#2-路由" class="headerlink" title="2.路由"></a>2.路由</h3><p>路由是指客户端<strong>请求地址</strong>与服务端<strong>程序代码</strong>的对应关系</p>
<p>简单来说即客户端请求什么，服务器响应什么</p>
<p>例如：</p>
<ul>
<li>客户端请求<code>http://localhost:3000/index.html</code>，服务端返回index.html</li>
<li>对于普不同的请求方式GET和POST，服务器也可以根据请求方式做出不同的响应</li>
</ul>
<h3 id="3-静态资源"><a href="#3-静态资源" class="headerlink" title="3.静态资源"></a>3.静态资源</h3><p>服务器端不需要处理，可以直接响应给客户端的资源被称为静态资源，例如CSS,JS,HTML文件</p>
<p>静态资源响应的例子：</p>
<p><strong>URL中的资源标识符不一定要写服务器端资源的路径</strong></p>
<ul>
<li>服务器端可以获取资源标识符后自己指定资源地址</li>
<li>此处就使用了字符串拼接<code>path.join</code>自己指定public文件夹下的静态资源</li>
</ul>
<br>

<p><strong>响应文件时需要在响应头中指定内容类型</strong><code>content-type</code></p>
<ul>
<li>在高级浏览器中即使不指定内容类型也可以正常解析文件，但一些浏览器可能发生错误</li>
<li>html文件通过<code>readFile()</code>方法获取，html文件中<strong>从外部引入的CSS等文件</strong>也是通过<code>readFile()</code>方法获取</li>
<li>在设置响应头中的<code>content-type</code>时，需要<strong>得知当前获取的文件类型</strong><ul>
<li>可以使用<strong>第三方模块mime</strong></li>
<li>mime模块的<code>getTaype(&quot;资源路径&quot;)</code>方法可以根据资源路径返回对应的文件类型</li>
<li>使用获取的文件类型设置<code>content-type</code></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> url=<span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">//引入第三方模块MIME 根据路径获取文件类型</span></span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">&#x27;mime&#x27;</span>)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//获取请求资源的标识符</span></span><br><span class="line">    <span class="keyword">let</span> pathname = url.parse(req.url).pathname</span><br><span class="line">    <span class="comment">//拼接路径</span></span><br><span class="line">    <span class="keyword">let</span> filepath = path.join(__dirname,<span class="string">&#x27;public&#x27;</span>+pathname)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> type = mime.getType(filepath)</span><br><span class="line">    <span class="comment">//获取对应文件</span></span><br><span class="line">    fs.readFile(filepath,<span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(err != <span class="literal">null</span>)&#123;</span><br><span class="line">            res.writeHead(<span class="number">404</span>,&#123;</span><br><span class="line">                <span class="string">&#x27;content-type&#x27;</span>:<span class="string">&#x27;text/plain;charset=utf-8&#x27;</span></span><br><span class="line">            &#125;)</span><br><span class="line">            res.end(<span class="string">&#x27;文件找不到&#x27;</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.writeHead(<span class="number">200</span>,&#123;</span><br><span class="line">                <span class="string">&#x27;content-type&#x27;</span>:type</span><br><span class="line">            &#125;)</span><br><span class="line">            res.end(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此处使用<code>http://localhost:3000/default.html</code>访问服务器的静态资源如下</p>
<ul>
<li>此处的URI：/default.html并不是资源在服务器路径</li>
<li>URI：统一资源<strong>标识符</strong></li>
<li>URL：统一资源<strong>定位符</strong></li>
</ul>
<p><img data-src="/images/07-HTTP%E5%8D%8F%E8%AE%AE/image-20210428195929316.png" alt="image-20210428195929316"></p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>08-node中的同步异步API</title>
    <url>/2021/04/28/08-node%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5API/</url>
    <content><![CDATA[<h1 id="node中的同步和异步API"><a href="#node中的同步和异步API" class="headerlink" title="node中的同步和异步API"></a>node中的同步和异步API</h1><p>nodejs中的API，拿到他们执行结果的方式有两种</p>
<ul>
<li>通过<strong>返回值</strong>的方式得到API执行结果<ul>
<li>比如<code>path.join()</code>等API</li>
</ul>
</li>
<li>通过<strong>函数</strong>的方式得到API执行结果<ul>
<li>比如<code>fs.readFile()</code> API，这个API执行的结果在其第二个参数<strong>回调函数中的data参数中</strong></li>
</ul>
</li>
</ul>
<span id="more"></span>

<br>

<p>由此引出同步和异步API</p>
<ul>
<li><strong>同步API</strong>：按顺序执行，只有上一个API执行完毕，下一个API才开始执行</li>
<li><strong>异步API</strong>：异步API的执行不会阻塞后续其他代码的执行 ，<strong>async</strong>即为异步</li>
</ul>
<p>例如下面这段代码执行结果为先输出before，再输出after，等待2s后再输出last</p>
<p>这里的<code>setTimeout()</code> API就是异步API，不会阻塞后续代码执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;before&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;last&#x27;</span>)</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;after&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="同步异步API的区别"><a href="#同步异步API的区别" class="headerlink" title="同步异步API的区别"></a>同步异步API的区别</h2><h3 id="1-获取执行结果"><a href="#1-获取执行结果" class="headerlink" title="1.获取执行结果"></a>1.获取执行结果</h3><ul>
<li><p>同步API可以通过<strong>返回值</strong>拿到API执行的结果</p>
</li>
<li><p>异步API不能通过返回值拿到API执行结果，可以通过<strong>回调函数的方式</strong>得到执行结果</p>
</li>
</ul>
<p><strong>同步API</strong></p>
<p>通过返回值拿到结果 30</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> datasum = sum(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="comment">//输出30</span></span><br><span class="line"><span class="built_in">console</span>.log(datasum);</span><br></pre></td></tr></table></figure>

<p><strong>异步API</strong></p>
<p>res输出为undefined</p>
<p>执行到定时器时因为定时器为异步API，不会阻塞下面代码的执行，所以早在2s前，msg函数就已经默认返回undefined，此时res输出为undefined，而2s后定时器中的函数才执行</p>
<p>异步API的执行结果<strong>不能通过返回值得到</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">msg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">name</span>:<span class="string">&quot;yang&quot;</span>&#125;</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = msg()</span><br><span class="line"><span class="comment">//输出undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure>

<br>

<p><strong>异步API的执行结果可以通过回调函数得到</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">msg</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        callback(&#123;<span class="attr">name</span>:<span class="string">&quot;yang&quot;</span>&#125;) </span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//输出对象&#123;name:&#x27;yang&#x27;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过给msg函数使用回调函数将异步API的执行结果作为参数传递给回调函数，然后在回调函数中处理异步API的结果</p>
<br>

<h3 id="2-执行顺序"><a href="#2-执行顺序" class="headerlink" title="2.执行顺序"></a>2.执行顺序</h3><p><strong>同步API</strong></p>
<p>同步API按代码编写顺序执行，上一个API执行完毕，下一个API才开始执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;循环后代码&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>对于上述代码，由于是同步API，会先输出0-99999这100000个数字，然后再输出”循环后代码”</p>
<p><strong>异步API</strong></p>
<p>异步API不会阻塞后续代码执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;开始&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;2s&quot;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;0s&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;结束&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>对于上述代码，两个定时器为异步API，不会阻塞后续代码执行</p>
<p>最后结果为：</p>
<ul>
<li><p>“开始”</p>
</li>
<li><p>“结束”</p>
</li>
<li><p>“0s”</p>
</li>
<li><p>“2s”</p>
</li>
</ul>
<p><strong>异步API执行机制</strong>：</p>
<ul>
<li><p>首先执行所有的同步代码，碰到异步代码就先放入<strong>异步任务队列</strong>中(只放入，不执行)</p>
</li>
<li><p>当所有同步代码执行完毕后，开始执行异步任务队列中的异步代码</p>
<ul>
<li>在此处例子中，执行异步代码创建两个定时器，一个定时0s，一个定时2s，并将他们的回调函数放入<strong>回调函数队列</strong>中等待执行</li>
</ul>
</li>
<li><p>异步代码执行完毕后进入回调函数队列，待满足条件时将回调函数队列中的回调函数<strong>调入同步代码执行区</strong>执行</p>
<ul>
<li>经过0s时执行0s定时器的回调函数先输出”0s”</li>
<li>经过2s时再执行2s定时器的回调函数再输出”2s”</li>
</ul>
</li>
<li><p>接着执行<strong>事件循环(eventloop)机制</strong>：循环等待直到有新的异步任务添加到异步任务队列中时，继续执行异步代码</p>
</li>
</ul>
<p><img data-src="/images/08-node%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5API/image-20210428213248420.png" alt="image-20210428213248420"></p>
<h2 id="nodejs中的常见异步API"><a href="#nodejs中的常见异步API" class="headerlink" title="nodejs中的常见异步API"></a>nodejs中的常见异步API</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打开文件是异步API</span></span><br><span class="line">fs.readFile(<span class="string">&#x27;./demo.txt&#x27;</span>,<span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//事件处理函数也是异步API</span></span><br><span class="line"><span class="keyword">var</span> server = http.creatServer();</span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>上述两个异步API执行的结果只能通过<strong>回调函数</strong>获取</p>
<p>异步API不会阻塞后续代码的执行</p>
<br>

<h2 id="后续代码需要使用前面异步API的执行结果"><a href="#后续代码需要使用前面异步API的执行结果" class="headerlink" title="后续代码需要使用前面异步API的执行结果"></a>后续代码需要使用前面异步API的执行结果</h2><p>如果异步API后面代码的执行需要使用前面异步API的结果，但是实际后续代码执行时前面的异步API还没有执行，如何解决这个问题?</p>
<ul>
<li>可以将<strong>后续代码写在异步API的回调函数中</strong></li>
</ul>
<p>例如：需要依次打开三个文件，可以使用回调函数嵌套的方式完成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;./1.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">err , data1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data1);</span><br><span class="line">    <span class="comment">//嵌套在上一个readFile API的回调函数中</span></span><br><span class="line">    fs.readFile(<span class="string">&#x27;./2.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">err , data2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data2);</span><br><span class="line">        fs.readFile(<span class="string">&#x27;./3.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">err , data3</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(data3);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/08-node%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5API/image-20210506201909805.png" alt="image-20210506201909805"></p>
<p>使用这种方式可以解决后续代码使用前面异步API的执行结果的问题</p>
<p>但是会引入<strong>新的问题</strong>：嵌套层数过多导致<strong>维护困难</strong></p>
<p>回调嵌套回调被称为<strong>回调地狱</strong></p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>10-ES7异步函数</title>
    <url>/2021/05/06/10-ES7%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="ES7异步函数"><a href="#ES7异步函数" class="headerlink" title="ES7异步函数"></a>ES7异步函数</h1><p>在09-promise对象中，学习到使用promise对象可以对异步编程语法进行<strong>改进</strong></p>
<ul>
<li>可以将异步API的执行和结果处理分离</li>
<li>可以解决异步API回调函数嵌套的<strong>维护困难</strong>和<strong>回调地狱</strong>问题</li>
</ul>
<p>但是promise对象在处理较多的需要顺序执行的异步API时<strong>仍然比较繁琐</strong></p>
<span id="more"></span>

<ul>
<li>需要使用promise对象将每一个异步API包裹起来</li>
<li>需要使用函数将每一个promise对象包裹以实现顺序调用</li>
<li>获取异步API<strong>结果</strong>和<strong>错误信息</strong>时还要在promise对象中使用resolve和reject两个参数函数<ul>
<li>并在promise对象外部使用promise.then 和 promise.catch 两个方法进行接收</li>
</ul>
</li>
<li>这使得代码比较臃肿繁琐</li>
</ul>
<p>在ES7中定义的<strong>异步函数</strong>可以在实现promise对象功能的基础上使得代码更加的简洁明了</p>
<h2 id="1-异步函数"><a href="#1-异步函数" class="headerlink" title="1.异步函数"></a>1.异步函数</h2><p>异步函数实际上就是基于promise对象，将一些比较繁琐的promise方法进行了封装</p>
<p>然后开放一些简单的关键字代替这些繁琐的操作</p>
<br>

<p><strong>异步函数是异步编程语法的终极解决方案，它可以将异步代码写成同步的形式，消除代码的回调函数嵌套。</strong></p>
<h2 id="2-异步函数使用"><a href="#2-异步函数使用" class="headerlink" title="2.异步函数使用"></a>2.异步函数使用</h2><h3 id="在普通函数的前面加上async，即可创建异步函数"><a href="#在普通函数的前面加上async，即可创建异步函数" class="headerlink" title="在普通函数的前面加上async，即可创建异步函数"></a>在普通函数的前面加上<code>async</code>，即可创建异步函数</h3><p>async即异步的意思</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fn()函数即为一个异步函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn());</span><br><span class="line">fn().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="异步函数的默认返回值为一个promise对象"><a href="#异步函数的默认返回值为一个promise对象" class="headerlink" title="异步函数的默认返回值为一个promise对象"></a>异步函数的默认返回值为一个<strong>promise对象</strong></h3><p>在异步函数中使用return进行结果的返回</p>
<p><code>console.log(fn());</code>返回的结果如下</p>
<p><img data-src="/images/10-ES7%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0/image-20210506214213554.png" alt="image-20210506214213554"></p>
<p>将123包裹在promise对象中进行返回</p>
<p>此处异步函数的<strong>return 即替代了promise对象的resolve函数</strong></p>
<br>

<p>可以使用promise对象的then()方法获取执行结果</p>
<p>即使用<code>fn().then()</code>方法，输出123</p>
<br>

<h3 id="异步函数使用throw抛出错误信息"><a href="#异步函数使用throw抛出错误信息" class="headerlink" title="异步函数使用throw抛出错误信息"></a>异步函数使用throw抛出错误信息</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="string">&#x27;错误&#x27;</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line">fn().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用promise对象的<strong>catch方法</strong>即可获取错误信息<code>&#39;错误&#39;</code></p>
<p>此处throw语句后的return语句不再生效</p>
<p><strong>throw即替代了promise对象中的reject函数</strong></p>
<br>

<h3 id="异步函数的await关键字"><a href="#异步函数的await关键字" class="headerlink" title="异步函数的await关键字"></a>异步函数的await关键字</h3><ul>
<li>他只能出现在异步函数中</li>
<li>await promise可以<strong>暂停异步函数的执行</strong>，等待promise对象返回结果后再继续执行</li>
<li>await可以<strong>直接获取promise对象中的异步数据</strong>，代替了then方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">p1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;p1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">p2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;p2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">p3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;p3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> r1=<span class="keyword">await</span> p1()</span><br><span class="line">    <span class="comment">//r1即为&#x27;p1&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(r1);</span><br><span class="line">    <span class="keyword">let</span> r2=<span class="keyword">await</span> p2()</span><br><span class="line">    <span class="built_in">console</span>.log(r2);</span><br><span class="line">    <span class="keyword">let</span> r3=<span class="keyword">await</span> p3()</span><br><span class="line">    <span class="built_in">console</span>.log(r3);</span><br><span class="line">&#125;</span><br><span class="line">run()</span><br></pre></td></tr></table></figure>

<p>此处有三个异步函数p1()，p2()，p3()需要顺序执行</p>
<p>将三个函数放入run()异步函数中加上await关键字执行</p>
<p>只有当p1()函数执行后的promise对象返回结果后，代码才继续执行</p>
<p>同时可以利用await关键字直接获取返回的promise对象中的异步数据</p>
<br>

<h2 id="3-异步函数在nodejs中的应用"><a href="#3-异步函数在nodejs中的应用" class="headerlink" title="3.异步函数在nodejs中的应用"></a>3.异步函数在nodejs中的应用</h2><p>nodejs中的异步API使用<strong>回调函数</strong>来获取执行结果</p>
<p>因为使用回调函数获取结果，所以<strong>不能使用异步函数中的await关键字</strong></p>
<ul>
<li>await关键字后必须跟一个promise对象</li>
</ul>
<br>

<h3 id="util核心模块的promisify方法"><a href="#util核心模块的promisify方法" class="headerlink" title="util核心模块的promisify方法"></a><code>util</code>核心模块的promisify方法</h3><p>nodejs核心模块util的promisify方法可以<strong>改造异步API</strong></p>
<ul>
<li>在原异步API的基础上，产生一个新的异步API</li>
<li>新的异步API将执行结果包裹在promise对象中返回</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入util模块的promisify方法</span></span><br><span class="line"><span class="keyword">var</span> promisify = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>).promisify</span><br><span class="line"></span><br><span class="line"><span class="comment">//将要改造的异步API包裹在promisify方法中，形成一个新的异步API</span></span><br><span class="line"><span class="keyword">var</span> readFile = promisify(fs.readFile)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用新异步API</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> r1 = <span class="keyword">await</span> readFile(<span class="string">&#x27;./1.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">   <span class="built_in">console</span>.log(r1);</span><br><span class="line">&#125;</span><br><span class="line">run()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>readFile</code> 即为基于<code>fs.readFile</code>改造后的新异步API</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>10-Git命令行命令</title>
    <url>/2022/04/23/10-Git%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Git命令行命令"><a href="#Git命令行命令" class="headerlink" title="Git命令行命令"></a>Git命令行命令</h1><h2 id="1-git-status"><a href="#1-git-status" class="headerlink" title="1. git status"></a>1. <code>git status</code></h2><p>查看你的文件在工作目录与缓存的状态</p>
<ul>
<li>修改没有送入缓存区时</li>
<li>红色代表<strong>修改完但没有送入缓存区</strong></li>
</ul>
<p><img data-src="/images/10-Git%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%91%BD%E4%BB%A4/image-20211019172434607.png" alt="image-20211019172434607"></p>
<span id="more"></span>

<ul>
<li>修改文件送入缓存区并准备提交</li>
<li>绿色代表<strong>修改完并送入缓存区</strong></li>
</ul>
<p><img data-src="/images/10-Git%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%91%BD%E4%BB%A4/image-20211019172858490.png" alt="image-20211019172858490"></p>
<ul>
<li>缓存区文件已经提交到本地仓库，此时缓存区清空</li>
</ul>
<p><img data-src="/images/10-Git%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%91%BD%E4%BB%A4/image-20211019172947560.png" alt="image-20211019172947560"></p>
<br>

<h2 id="2-git-add"><a href="#2-git-add" class="headerlink" title="2. git add"></a>2. <code>git add</code></h2><p>添加文件到缓存</p>
<p><code>git add README</code>：将<code>README</code>文件送入缓存区</p>
<p><code>git add .</code>：将所有修改文件送入缓存区</p>
<br>

<h2 id="3-git-reset-HEAD"><a href="#3-git-reset-HEAD" class="headerlink" title="3. git reset HEAD"></a>3. <code>git reset HEAD</code></h2><p>取消缓存区中已缓存的内容</p>
<p><code>git reset HEAD</code> ：取消缓存区的<strong>所有文件</strong></p>
<p><code>git reset HEAD -- hello.vue</code>：取消缓存区中的**<code>hello.vue</code>文件** </p>
<br>

<h2 id="4-git-remote-add-lt-shortname-gt-lt-URL-gt"><a href="#4-git-remote-add-lt-shortname-gt-lt-URL-gt" class="headerlink" title="4. git remote add &lt;shortname&gt; &lt;URL&gt;"></a>4. <code>git remote add &lt;shortname&gt; &lt;URL&gt;</code></h2><ul>
<li><p>关联<strong>本地仓库与远程仓库</strong></p>
</li>
<li><p>给远程仓库的URL <code>&lt;URL&gt;</code> 起简写名称 <code>&lt;shortname&gt;</code></p>
</li>
<li><p>后续命令可以使用简写名称代替URL</p>
</li>
</ul>
<p><code>git remote add origin https://gitee.com/yang-xiao123/vue_shop.git</code></p>
<ul>
<li><p>给<code>https://gitee.com/yang-xiao123/vue_shop.git</code>这个远程仓库 <strong>vue_shop</strong>的<strong>URL</strong></p>
<p>起简写名称为<strong>origin</strong></p>
</li>
</ul>
<h2 id="5-git-push-lt-远程仓库名-gt-lt-本地分支名-gt-lt-远程分支名-gt"><a href="#5-git-push-lt-远程仓库名-gt-lt-本地分支名-gt-lt-远程分支名-gt" class="headerlink" title="5. git push &lt;远程仓库名&gt; &lt;本地分支名&gt; [&lt;远程分支名&gt;]"></a>5. <code>git push &lt;远程仓库名&gt; &lt;本地分支名&gt; [&lt;远程分支名&gt;]</code></h2><p>将<strong>本地仓库的分支</strong>推送到<strong>远程仓库的对应分支</strong></p>
<p><code>&lt;远程仓库名&gt;</code>即为上述的URL简写名称</p>
<p><code>git push origin master master</code> ：将本地仓库master分支推送到origin仓库的master分支</p>
<ul>
<li><code>&lt;远程分支名&gt;</code>省略时，使用本地分支名作为<code>&lt;远程分支名&gt;</code></li>
</ul>
<br>

<ul>
<li><code>git push -u origin master</code> </li>
<li><strong>-u</strong>：将本地分支master推送到远程分支master并<strong>建立追踪</strong><ul>
<li>将<strong>本地分支master</strong>与<strong>远程分支master</strong>建立追踪</li>
</ul>
</li>
</ul>
<br>

<ul>
<li><code>git push</code></li>
</ul>
<p>将<strong>当前所在的本地分支</strong>推送到<strong>与其建立追踪的远程分支</strong></p>
<ul>
<li>若当前分支<strong>没有建立过远程追踪则报错</strong></li>
</ul>
<br>

<h2 id="6-git-branch"><a href="#6-git-branch" class="headerlink" title="6. git branch"></a>6. <code>git branch</code></h2><p><code>git branch </code>：显示可用分支，当前所在分支<strong>加’*’号并绿色显示</strong></p>
<p><code>git branch &lt;new branch&gt;</code>：创建新分支</p>
<p><code>git branch -d &lt;branchname&gt;</code>：删除分支(删除时不能处于被删除分支上)</p>
<h2 id="7-git-checkout-lt-branchname-gt"><a href="#7-git-checkout-lt-branchname-gt" class="headerlink" title="7. git checkout &lt;branchname&gt;"></a>7. <code>git checkout &lt;branchname&gt;</code></h2><p>切换到新的分支上下文</p>
<p><code>git checkout -b &lt;newbranchname&gt;</code>：创建新分支并切换到该分支</p>
<ul>
<li><strong>会带着当前分支的状态</strong>创建新分支</li>
</ul>
<h2 id="8-git-init"><a href="#8-git-init" class="headerlink" title="8. git init"></a>8. <code>git init</code></h2><p>创建/初始化本地仓库</p>
<ol>
<li>在项目目录下执行命令 <code>git init</code></li>
</ol>
<ul>
<li><p>会创建一个隐藏的<code>.git</code>文件夹</p>
</li>
<li><p>会将项目初始化为本地仓库</p>
</li>
</ul>
<ol start="2">
<li>在gitee或者github上创建远程仓库</li>
<li>将创建的本地仓库与远程仓库关联</li>
</ol>
<ul>
<li><code>git remote add origin https://gitee.com/yang-xiao123/vue_shop.git</code></li>
<li>关联本地仓库与远程仓库并给远程仓库URL取简写名称</li>
</ul>
<ol start="4">
<li>推送本地分支到远程分支</li>
</ol>
<ul>
<li><code>git push ...</code></li>
<li>空的本地仓库不能推送</li>
</ul>
<br>

<h2 id="9-git-clone"><a href="#9-git-clone" class="headerlink" title="9. git clone"></a>9. <code>git clone</code></h2><p>执行<code>git clone [url]</code></p>
<ul>
<li><p>将远程仓库克隆到本地</p>
</li>
<li><p><code>[url]</code>：远程仓库的URL</p>
</li>
</ul>
<h2 id="10-git-commit"><a href="#10-git-commit" class="headerlink" title="10. git commit"></a>10. <code>git commit</code></h2><p>提交缓存到本体仓库</p>
<p><code>git commit -m &quot;add files&quot;</code></p>
<ul>
<li><strong>提交</strong>缓存到本地仓库并<strong>设置摘要</strong>(<code>add files</code>)</li>
</ul>
<p><img data-src="/images/10-Git%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%91%BD%E4%BB%A4/image-20211019192735436.png" alt="image-20211019192735436"></p>
<br>

<h2 id="11-git-log"><a href="#11-git-log" class="headerlink" title="11. git log"></a>11. <code>git log</code></h2><p>显示<strong>一个分支</strong>中提交的更改记录</p>
<ul>
<li><strong>不同分支</strong>的提交记录<strong>互相独立</strong></li>
</ul>
<br>

<h2 id="12-git-merge"><a href="#12-git-merge" class="headerlink" title="12. git merge"></a>12. <code>git merge</code></h2><p>将<strong>目标分支</strong>合并到你的<strong>当前分支</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master	<span class="comment">//当前处于mster分支</span></span><br><span class="line">  removals</span><br><span class="line">$ git merge removals	<span class="comment">//将removals分支合并到master分支(当前分支)</span></span><br></pre></td></tr></table></figure>

<p>当前分支(master)被removals分支覆盖</p>
<br>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li><p>本地仓库的缓存区是<strong>多个分支共享的</strong></p>
<ul>
<li>多个分支执行<code>git add ...</code> 命令会将文件加入同一个缓存区</li>
</ul>
</li>
<li><p>但是本地仓库分支的<strong>提交是独立的</strong></p>
<ul>
<li>在test分支下执行<code>git commit ...</code>命令进行提交</li>
<li>会将缓存区内容提交到test分支(<strong>更新test分支</strong>)</li>
<li>其他分支仍<strong>维持它们上次提交后的状态</strong></li>
</ul>
</li>
<li><p>仓库的<strong>多个分支之间是互相独立的</strong></p>
<ul>
<li>对于login分支进行修改并提交后，只有login分支被更新，其他分支仍维持其上次提交后的状态</li>
</ul>
</li>
<li><p>各个本地仓库的remote是独立的</p>
<ul>
<li>例如 仓库1: <code> git remote add origin [url1]</code> </li>
<li>仓库2: <code>git remote add origin [url2]</code></li>
<li><strong>两个origin不同</strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>11-nodejs全局对象global</title>
    <url>/2021/05/10/11-nodejs%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1global/</url>
    <content><![CDATA[<h1 id="nodejs全局对象global"><a href="#nodejs全局对象global" class="headerlink" title="nodejs全局对象global"></a>nodejs全局对象global</h1><p>浏览器BOM中的全局对象是<strong>window</strong></p>
<p>Node中全局对象是<strong>global</strong></p>
<p>Node全局对象global有许多和window对象相同的方法</p>
<p>使用global对象的方法可以省略global</p>
<ul>
<li>console.log() 在控制台输出</li>
<li>setTimeout() 设置定时器(定时触发一次)</li>
<li>clearTimeout() 清除定时器</li>
<li>setInterval() 设置定时器(每经过设定的时间就触发)</li>
<li>等等</li>
</ul>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>09-promise对象</title>
    <url>/2021/05/06/09-promise%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>promise对象出现的目的是解决nodejs中异步编程中<a href="08-node%E3%80%82%E3%80%82%E3%80%82">回调地狱</a>的问题。</p>
<p>promise并<strong>没有提供新的功能</strong>，它是一种异步编程<strong>语法上的改进</strong></p>
<p>可以将异步API的<strong>执行</strong>和<strong>结果的处理</strong>进行分离</p>
<p>promise是一种构造函数，使用时需要new 生成对象实例</p>
<span id="more"></span>

<br>

<h2 id="Promise基本使用"><a href="#Promise基本使用" class="headerlink" title="Promise基本使用"></a>Promise基本使用</h2><p>new Promise()中传入匿名函数<code>(resolve,reject) =&gt; &#123;&#125;</code></p>
<p>匿名函数的两个参数resolve，reject</p>
<ul>
<li>resolve 函数：当异步API执行成功时调用这个函数</li>
<li>reject函数：异步API执行失败时调用这个函数</li>
</ul>
<p>在匿名函数<code>(resolve,reject) =&gt; &#123;&#125;</code>中书写异步API代码</p>
<ul>
<li>在匿名函数中完成异步API的执行</li>
<li>利用resolve和reject这两个参数函数，在Promise实例对象外部处理异步API的结果</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Promise实例对象</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve , reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//匿名函数中书写异步API代码</span></span><br><span class="line">    fs.readFile(<span class="string">&#x27;./1.txt&#x27;</span>,<span class="string">&#x27;utf-8&#x27;</span>,<span class="function">(<span class="params">err , data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(err != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//文件打开失败调用reject函数</span></span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Promise实例对象外部处理异步API的结果</span></span><br><span class="line"><span class="comment">//在promise实例对象内部调用resolve函数即为调用promise.then()中的匿名函数，参数传递给then()中的匿名函数</span></span><br><span class="line">promise.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//调用reject函数即为调用下面promise.catch()中的匿名函数，此处使用了链式编程省略了promise</span></span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h2 id="Promise解决回调地狱"><a href="#Promise解决回调地狱" class="headerlink" title="Promise解决回调地狱"></a>Promise解决回调地狱</h2><ul>
<li><p>使用三个Promise对象包裹需要顺序执行的三个打开文件的异步API</p>
</li>
<li><p>将三个Promise对象分别用函数包裹保证执行时按函数调用的顺序执行</p>
</li>
<li><p>在使用<code>promise.then()</code>处理异步API结果时</p>
<ul>
<li>```js<br>p1().then((data) =&gt; {<pre><code>console.log(data)
return p2();
</code></pre>
})<br>.then((data) =&gt; {})<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 上面第一个&#96;p1().then()&#96;方法中的&#96;return p2()&#96;，会使**下一个链式编程的then方法变为p2().then**</span><br><span class="line"></span><br><span class="line">  - 即第二个链式编程的then()处理的是**第二个promise对象中的异步API**</span><br><span class="line"></span><br><span class="line">  - 第三个链式编程的then()同理，处理的是**第三个promise对象中的异步API**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用函数包裹Promise对象，保证执行时按函数调用的顺序执行</span><br><span class="line">function p1() &#123;</span><br><span class="line">    return new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">        fs.readFile(&#39;.&#x2F;1.txt&#39;,&#39;utf8&#39;,(err,data) &#x3D;&gt; &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function p2() &#123;</span><br><span class="line">    return new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">        fs.readFile(&#39;.&#x2F;2.txt&#39;,&#39;utf8&#39;,(err,data) &#x3D;&gt; &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function p3() &#123;</span><br><span class="line">    return new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">        fs.readFile(&#39;.&#x2F;3.txt&#39;,&#39;utf8&#39;,(err,data) &#x3D;&gt; &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;p1()的返回值即为第一个promise对象</span><br><span class="line">p1().then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">    &#x2F;&#x2F;此处return p2()，下一个链式编程的then方法即为p2()的返回值的then方法</span><br><span class="line">    return p2()</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;此处即为p2().then()方法</span><br><span class="line">.then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">    return p3()</span><br><span class="line">&#125;)</span><br><span class="line">.then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><img data-src="/images/09-promise%E5%AF%B9%E8%B1%A1/image-20210506211329533.png" alt="image-20210506211329533"></p>
<p>输出结果即为顺序的1 2 3</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>13-用户信息增删改查实例</title>
    <url>/2021/05/24/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="用户信息增删改查实例"><a href="#用户信息增删改查实例" class="headerlink" title="用户信息增删改查实例"></a>用户信息增删改查实例</h1><h2 id="项目目的"><a href="#项目目的" class="headerlink" title="项目目的"></a>项目目的</h2><p><img data-src="/images/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/image-20210524204826501.png" alt="image-20210524204826501"></p>
<span id="more"></span>

<h2 id="1-搭建网站服务器"><a href="#1-搭建网站服务器" class="headerlink" title="1.搭建网站服务器"></a>1.搭建网站服务器</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入http模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务器</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器请求事件</span></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="keyword">async</span> (req,res) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口</span></span><br><span class="line">server.listen(<span class="string">&#x27;3000&#x27;</span>,<span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;服务器开启成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h2 id="2-连接数据库，创建用户集合-users"><a href="#2-连接数据库，创建用户集合-users" class="headerlink" title="2.连接数据库，创建用户集合(users)"></a>2.连接数据库，创建用户集合(users)</h2><p>这部分采用模块化的编程思想：</p>
<p>​    将连接数据库代码写在<strong>index.js模块</strong>中</p>
<p>​    将创建用户集合代码写在<strong>user.js模块</strong>中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入mongoose模块</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接数据库</span></span><br><span class="line">mongoose.connect(<span class="string">&#x27;mongodb://localhost/user09&#x27;</span>,&#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> ,<span class="attr">useUnifiedTopology</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;数据库连接成功&#x27;</span>)&#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;数据库连接失败&#x27;</span>,err)&#125;)</span><br></pre></td></tr></table></figure>

<center>index.js代码</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建集合规则</span></span><br><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        required:<span class="literal">true</span>,</span><br><span class="line">        minlength:<span class="number">2</span>,</span><br><span class="line">        maxlength:<span class="number">5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age:&#123;</span><br><span class="line">        type:<span class="built_in">Number</span>,</span><br><span class="line">        min:<span class="number">18</span>,</span><br><span class="line">        max:<span class="number">80</span></span><br><span class="line">    &#125;,</span><br><span class="line">    password: <span class="built_in">String</span>,</span><br><span class="line">    email:<span class="built_in">String</span>,</span><br><span class="line">    <span class="comment">//代表值为一个数组，元素为String类型</span></span><br><span class="line">    hobbies:[<span class="built_in">String</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建集合</span></span><br><span class="line"><span class="keyword">const</span> User = mongoose.model(<span class="string">&#x27;User&#x27;</span>,userSchema)</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出集合构造函数User供server.js使用</span></span><br><span class="line"><span class="built_in">module</span>.exports = User</span><br></pre></td></tr></table></figure>

<center>user.js代码</center>

<br>

<h2 id="3-客户端访问-list时，将所有用户信息查询出来"><a href="#3-客户端访问-list时，将所有用户信息查询出来" class="headerlink" title="3.客户端访问/list时，将所有用户信息查询出来"></a>3.客户端访问/list时，将所有用户信息查询出来</h2><p>此处因为还没有学习模板引擎，所以采用<strong>直接在server.js文件中进行字符串拼接</strong>的方式给客户端响应数据</p>
<p>在<code>server.on()</code>函数中书写代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此代码在server.on()函数下书写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//请求方式</span></span><br><span class="line"><span class="keyword">const</span> method = req.method</span><br><span class="line"><span class="comment">//请求地址和请求参数获取</span></span><br><span class="line"><span class="keyword">const</span> &#123; pathname,query &#125; = url.parse(req.url,<span class="literal">true</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(method == <span class="string">&#x27;GET&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pathname == <span class="string">&#x27;/list&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> users = <span class="keyword">await</span> User.find()</span><br><span class="line">            <span class="keyword">let</span> list = <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">            &lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;head&gt;</span></span><br><span class="line"><span class="string">                &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;title&gt;用户列表&lt;/title&gt;</span></span><br><span class="line"><span class="string">                &lt;style&gt;css样式省略&lt;/style&gt;</span></span><br><span class="line"><span class="string">            &lt;/head&gt;</span></span><br><span class="line"><span class="string">            &lt;body&gt;</span></span><br><span class="line"><span class="string">                &lt;div&gt;</span></span><br><span class="line"><span class="string">                    &lt;span&gt;&lt;a href=&quot;http://localhost:3000/add&quot;&gt;添加用户&lt;/a&gt;&lt;/span&gt;</span></span><br><span class="line"><span class="string">                    &lt;br/&gt;</span></span><br><span class="line"><span class="string">                    &lt;br&gt;</span></span><br><span class="line"><span class="string">                    &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;</span></span><br><span class="line"><span class="string">                    &lt;tr&gt;</span></span><br><span class="line"><span class="string">                        &lt;td&gt;姓名&lt;/td&gt;</span></span><br><span class="line"><span class="string">                        &lt;td&gt;年龄&lt;/td&gt;</span></span><br><span class="line"><span class="string">                        &lt;td&gt;email&lt;/td&gt;</span></span><br><span class="line"><span class="string">                        &lt;td&gt;爱好&lt;/td&gt;</span></span><br><span class="line"><span class="string">                        &lt;td&gt;操作&lt;/td&gt;</span></span><br><span class="line"><span class="string">                    &lt;/tr&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<center>代码块1</center>

<ul>
<li><p>上述代码块中使用<code>let users = await User.find()</code>代码将users集合中所有文档提取出来存入users数组</p>
</li>
<li><p>使用list变量进行响应的html代码数据拼接</p>
</li>
<li><p>html代码放在<strong>模板字符串</strong>中(``中)</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">users.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">               list+=<span class="string">`</span></span><br><span class="line"><span class="string">               &lt;tr&gt;</span></span><br><span class="line"><span class="string">                   &lt;td&gt;<span class="subst">$&#123;item.name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">                   &lt;td&gt;<span class="subst">$&#123;item.age&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">                   &lt;td&gt;<span class="subst">$&#123;item.email&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">                   &lt;td&gt;</span></span><br><span class="line"><span class="string">               `</span></span><br><span class="line">               <span class="comment">//爱好信息添加</span></span><br><span class="line">               item.hobbies.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                   list+=<span class="string">`</span></span><br><span class="line"><span class="string">                   <span class="subst">$&#123;item&#125;</span></span></span><br><span class="line"><span class="string">               `</span></span><br><span class="line">               &#125;)</span><br><span class="line">               </span><br><span class="line">               list+=<span class="string">`</span></span><br><span class="line"><span class="string">                   &lt;/td&gt;</span></span><br><span class="line"><span class="string">                   &lt;td&gt; </span></span><br><span class="line"><span class="string">                       &lt;span class=&quot;del&quot;&gt;&lt;a href=&quot;/del?id=<span class="subst">$&#123;item._id&#125;</span>&quot;&gt;删除&lt;/a&gt;&lt;/span&gt;</span></span><br><span class="line"><span class="string">                       &lt;span class=&quot;change&quot;&gt;&lt;a href=&quot;/modify?id=<span class="subst">$&#123;item._id&#125;</span>&quot;&gt;修改&lt;/a&gt;&lt;/span&gt;</span></span><br><span class="line"><span class="string">                   &lt;/td&gt;</span></span><br><span class="line"><span class="string">               &lt;/tr&gt;</span></span><br><span class="line"><span class="string">               `</span></span><br><span class="line">           &#125;)</span><br><span class="line">           </span><br><span class="line">           list+=<span class="string">` &lt;/table&gt;</span></span><br><span class="line"><span class="string">           &lt;/body&gt;</span></span><br><span class="line"><span class="string">           &lt;/html&gt;`</span></span><br><span class="line">           res.end(list);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<center>代码块2</center>

<p>代码块2接着代码块1</p>
<ul>
<li>使用users的<code>forEach()</code>方法<strong>遍历数组中所有的文档</strong><ul>
<li>按照每一个文档的信息生成表格中的一行</li>
<li>每一个item即为一个文档的JSON对象</li>
</ul>
</li>
<li>对于文档的hobbies字段(hobbies字段为一个数组)<ul>
<li>使用hobbies.forEach()方法<strong>遍历每一个爱好</strong>并添加到表格中</li>
</ul>
</li>
<li>最后添加删除和修改两个按钮<ul>
<li>按钮提前设置好超链接</li>
<li>为修改和删除跳转做准备</li>
</ul>
</li>
<li><code>res.end(list)</code>语句将list变量存储的html代码响应给客户端</li>
</ul>
<p><img data-src="/images/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/image-20210525214248992.png" alt="将每一个文档信息生成为表格的一行(/list页面)"></p>
<br>

<h2 id="4-添加用户功能-访问-add"><a href="#4-添加用户功能-访问-add" class="headerlink" title="4.添加用户功能(访问/add)"></a>4.添加用户功能(访问/add)</h2><ul>
<li><p>用户可以通过直接访问<code>localhost:3000/add</code>的方式访问添加用户页面</p>
</li>
<li><p>还可以点击/list页面上的添加用户按钮跳转到/add页面进行添加用户操作</p>
<ul>
<li>代码段1中已经设置好添加按钮的跳转路径</li>
</ul>
</li>
<li><p>上述两种访问/add页面的方式<strong>均为GET请求方式</strong></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pathname == <span class="string">&#x27;/add&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> add=<span class="string">`</span></span><br><span class="line"><span class="string">            &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">            &lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;head&gt;</span></span><br><span class="line"><span class="string">                &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;title&gt;添加用户&lt;/title&gt;</span></span><br><span class="line"><span class="string">                &lt;style&gt;</span></span><br><span class="line"><span class="string">                    div&#123;</span></span><br><span class="line"><span class="string">                        margin: 0 auto;</span></span><br><span class="line"><span class="string">                        width: 1000px;</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string">                &lt;/style&gt;</span></span><br><span class="line"><span class="string">            &lt;/head&gt;</span></span><br><span class="line"><span class="string">            &lt;body&gt;</span></span><br><span class="line"><span class="string">                &lt;div&gt;</span></span><br><span class="line"><span class="string">                    &lt;h3&gt;添加用户&lt;/h3&gt;</span></span><br><span class="line"><span class="string">                    &lt;form action=&quot;/add&quot; method=&quot;POST&quot;&gt;</span></span><br><span class="line"><span class="string">                        &lt;label&gt;用户名：&lt;/label&gt;</span></span><br><span class="line"><span class="string">                        &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">                        &lt;label&gt;密码：&lt;/label&gt;</span></span><br><span class="line"><span class="string">                        &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">                        &lt;label&gt;年龄：&lt;/label&gt;</span></span><br><span class="line"><span class="string">                        &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">                        &lt;label&gt;email：&lt;/label&gt;</span></span><br><span class="line"><span class="string">                        &lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">                        &lt;span&gt;爱好:&lt;/span&gt;&lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">                        &lt;label for=&quot;&quot;&gt;吃饭&lt;/label&gt;</span></span><br><span class="line"><span class="string">                        &lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot; value=&quot;吃饭&quot;&gt;</span></span><br><span class="line"><span class="string">                        &lt;label for=&quot;&quot;&gt;睡觉&lt;/label&gt;</span></span><br><span class="line"><span class="string">                        &lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot; value=&quot;睡觉&quot;&gt;</span></span><br><span class="line"><span class="string">                        &lt;label for=&quot;&quot;&gt;打豆豆&lt;/label&gt;</span></span><br><span class="line"><span class="string">                        &lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot; value=&quot;打豆豆&quot;&gt;</span></span><br><span class="line"><span class="string">                        &lt;label for=&quot;&quot;&gt;写代码&lt;/label&gt;</span></span><br><span class="line"><span class="string">                        &lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot; value=&quot;写代码&quot;&gt;&lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">                        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span></span><br><span class="line"><span class="string">                    &lt;/form&gt;</span></span><br><span class="line"><span class="string">                &lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;/body&gt;</span></span><br><span class="line"><span class="string">            &lt;/html&gt;</span></span><br><span class="line"><span class="string">            `</span></span><br><span class="line">            res.end(add)</span><br></pre></td></tr></table></figure>

<center>代码段3</center>

<p>将添加用户的表单信息以POST方式提交给localhost:3000/add</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;/add&quot;</span> method=<span class="string">&quot;POST&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>/add 即为 localhost:3000/add</p>
<p>/add 的 ‘/‘即为服务器URL：localhost:3000/</p>
<p><img data-src="/images/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/image-20210525215640354.png" alt="添加用户页面如下"></p>
<br>

<p><strong>服务器端接收到URL为localhost:3000/add的POST请求</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本代码段代码在server.on()函数下</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(method == <span class="string">&#x27;POST&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pathname == <span class="string">&#x27;/add&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> formData = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="comment">//请求参数传送触发</span></span><br><span class="line">            req.on(<span class="string">&#x27;data&#x27;</span>,<span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">                formData+=param</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">//请求参数传送完毕触发</span></span><br><span class="line">            req.on(<span class="string">&#x27;end&#x27;</span>,<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> userinf = queryString.parse(formData)</span><br><span class="line">                <span class="keyword">await</span> User.create(userinf)</span><br><span class="line">                <span class="comment">//请求重定向到</span></span><br><span class="line">                res.writeHead(<span class="number">301</span>,&#123;</span><br><span class="line">                    Location:<span class="string">&#x27;/list&#x27;</span></span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//重定向完 结束本次响应</span></span><br><span class="line">                res.end()</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<center>代码块4</center>

<ul>
<li><p>使用formData变量接收POST请求参数</p>
<ul>
<li>使用queryString模块的parse方法将字符串格式的formData变量转换为<strong>JSON对象格式的userinf变量</strong></li>
<li>/add页面中input标签的<strong>name属性</strong>与数据库文档中的<strong>相应字段名</strong>统一<ul>
<li>这样接收的请求参数转换为JSON对象后就可以直接添加到数据库</li>
</ul>
</li>
</ul>
</li>
<li><p>调用User集合构造函数的create()方法将新用户信息(userinf变量)添加到数据库</p>
</li>
<li><p>在异步函数中使用await关键字<strong>等待异步API返回结果后再继续执行</strong></p>
<ul>
<li><p><code>req.on(&#39;end&#39;,async ()=&gt;&#123;&#125;)</code>方法的回调函数使用async关键字变为异步函数</p>
</li>
<li><p><code>await User.create(userinf)</code></p>
</li>
<li><p>如果不等待，<strong>可能后续的响应操作会先于创建文档执行</strong></p>
</li>
</ul>
</li>
<li><p>响应时将请求重定向到/list页面</p>
<ul>
<li>直接从/list页面查看添加用户的结果</li>
</ul>
</li>
</ul>
<br>

<h2 id="5-修改用户信息功能-modify"><a href="#5-修改用户信息功能-modify" class="headerlink" title="5.修改用户信息功能(/modify)"></a>5.修改用户信息功能(/modify)</h2><ul>
<li><p>通过/list页面的修改按钮进入修改页面</p>
<p><img data-src="/images/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/image-20210525221836885.png" alt="修改按钮"></p>
</li>
<li><p>/modify页面在/add页面的基础上修改而来</p>
</li>
<li><p>点击哪一个用户信息的修改按钮，跳转到的修改页面就会呈现对应用户的信息</p>
</li>
</ul>
<p><img data-src="/images/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/image-20210525221743719.png" alt="点击张三用户信息的修改按钮后跳转"></p>
<ul>
<li>跳转页面显示对应用户的信息是<strong>通过传递相应用户信息文档的_id字段值</strong>实现的</li>
</ul>
<p><img data-src="/images/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/image-20210525222016451.png" alt="数据库中张三信息文档的_id"></p>
<ul>
<li>在响应给客户端的/list页面的html代码中<ul>
<li>将_id字段的值放入修改按钮的<strong>a标签</strong>中</li>
<li>_id字段的值作为<strong>GET请求的请求参数</strong>传递给服务器</li>
</ul>
</li>
</ul>
<p><img data-src="/images/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/image-20210525222621352.png" alt="点击修改按钮时_id的值传递给服务器"></p>
<ul>
<li><p>服务器端从接收到的请求参数中提取_id值，并将相应用户的信息填入文本框中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取JSON对象格式的请求参数</span></span><br><span class="line"><span class="keyword">let</span> reqinf = url.parse(req.url,<span class="literal">true</span>).query</span><br><span class="line"><span class="comment">//在数据库中查找相应用户信息文档</span></span><br><span class="line"><span class="keyword">let</span> user=<span class="keyword">await</span> User.findOne(&#123;<span class="attr">_id</span>:reqinf.id&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在修改页面的单行文本输入框中填入相应用户的信息</span></span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> value=$&#123;user.name&#125; name=<span class="string">&quot;name&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>效果如上图</p>
</li>
<li><p>修改页面的表单提交时以POST方式发送请求给/modify</p>
<ul>
<li>同样将_id字段值当作请求参数传递给服务端</li>
<li>以便服务端根据_id值更新数据库信息</li>
<li>POST方式的请求也可以使用GET请求方式的方法来传递请求参数(放在地址栏中)</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;/modify?id=$&#123;user._id&#125;&quot;</span> method=<span class="string">&quot;POST&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>服务器端接收到POST请求时将根据_id值更新对应用户信息文档</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用await关键字等待异步API返回结果后再接着执行</span></span><br><span class="line"><span class="keyword">await</span> User.updateOne(&#123;<span class="attr">_id</span>:reqinf.id&#125;,userinf)</span><br></pre></td></tr></table></figure>

<ul>
<li>更新数据库文档信息后请求重定向到/list页面<ul>
<li>直接在/list页面体现修改结果</li>
</ul>
</li>
</ul>
<p><img data-src="/images/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/image-20210525224319251.png" alt="将张三修改为张三123"></p>
<p><img data-src="/images/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/image-20210525224343590.png" alt="修改后结果"></p>
<br>

<h2 id="6-删除用户信息功能-del"><a href="#6-删除用户信息功能-del" class="headerlink" title="6.删除用户信息功能(/del)"></a>6.删除用户信息功能(/del)</h2><ul>
<li>通过/list页面的删除按钮进入删除页面</li>
<li>点击相应数据行的删除按钮会将该文档的_id字段值作为GET请求参数发送给服务器</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;del&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/del?id=$&#123;item._id&#125;&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>发送到<code>http://localhost:3000/del</code></p>
<ul>
<li>服务器接收到请求后</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pathname == <span class="string">&#x27;/del&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">await</span> User.findOneAndDelete(&#123;<span class="attr">_id</span>:query.id&#125;)</span><br><span class="line">            res.writeHead(<span class="number">301</span>,&#123;</span><br><span class="line">                Location:<span class="string">&#x27;/list&#x27;</span></span><br><span class="line">            &#125;)</span><br><span class="line">            res.end()</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>调用<strong>集合构造函数的findOneAndDelete()方法</strong>按照_id字段值删除数据库中相应文档</p>
<p>然后将请求重定向到/list页面，在/list页面就可以看到删除后的效果</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Mongodb数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>14-模板引擎基础</title>
    <url>/2021/05/31/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="模板引擎基础"><a href="#模板引擎基础" class="headerlink" title="模板引擎基础"></a>模板引擎基础</h1><p>文章<a href="https://templar136.github.io/2021/05/24/13-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%AE%9E%E4%BE%8B/">13-用户信息增删改查实例</a>中服务器响应html代码的方式为直接在服务器代码中进行<strong>字符串拼接</strong></p>
<p>这种方式比较<strong>繁琐</strong>，而且<strong>难以维护</strong></p>
<p>使用模板引擎可以简化操作，便于维护</p>
<p><strong>模板引擎</strong></p>
<ul>
<li>实际上是nodejs的<strong>第三方模块</strong></li>
<li>主要用于提高字符串拼接的效率，便于维护</li>
</ul>
<span id="more"></span>

<h2 id="1-模板引擎art-template"><a href="#1-模板引擎art-template" class="headerlink" title="1.模板引擎art-template"></a>1.模板引擎art-template</h2><p>art-template是腾讯公司的模板引擎，应用广泛</p>
<h3 id="1-1安装art-template模板引擎"><a href="#1-1安装art-template模板引擎" class="headerlink" title="1.1安装art-template模板引擎"></a>1.1安装art-template模板引擎</h3><p><code>npm install art-template</code></p>
<h3 id="1-2使用art-template"><a href="#1-2使用art-template" class="headerlink" title="1.2使用art-template"></a>1.2使用art-template</h3><p>引入模板引擎第三方模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> template = <span class="built_in">require</span>(<span class="string">&#x27;art-template&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>返回的template为一个方法</p>
<p><code>const html = template(&quot;模板的路径&quot;,&quot;待拼接的数据&quot;)</code></p>
<ul>
<li><p>模板的路径：模板存放的<strong>绝对路径</strong></p>
<ul>
<li>模板一般存放在views文件夹(views是约定俗成的命名)中，模板文件的后缀一般为.art</li>
<li>如果要拼接html模板，则在.art文件中写入html代码</li>
</ul>
</li>
<li><p>待拼接的数据：<strong>对象格式</strong>的数据</p>
</li>
<li><p>html变量保存拼接完成后的html代码</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拼接路径 __dirname:当前文件所在目录</span></span><br><span class="line"><span class="keyword">let</span> viewpath = path.join(__dirname,<span class="string">&#x27;views&#x27;</span>,<span class="string">&#x27;index.art&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存拼接后的html代码</span></span><br><span class="line"><span class="keyword">const</span> html = template(viewpath,&#123;</span><br><span class="line">    name:<span class="string">&quot;yang&quot;</span>,</span><br><span class="line">    age:<span class="number">20</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="built_in">console</span>.log(html);</span><br></pre></td></tr></table></figure>

<center>app.js代码</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123;age&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<center>Index.art代码</center>

<p>在index.art模板文件中使用<code>&#123;&#123;"属性名"&#125;&#125;</code>将template方法中<code>待拼接的数据</code>拼接到html代码中</p>
<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210531203434078.png" alt="拼接完成后打印html变量"></p>
<p>待拼接的数据已经拼接到html代码中</p>
<br>

<h2 id="2-模板引擎art-template语法"><a href="#2-模板引擎art-template语法" class="headerlink" title="2.模板引擎art-template语法"></a>2.模板引擎art-template语法</h2><p>art-template支持两种语法：<strong>标准语法</strong> 和 <strong>原始语法</strong></p>
<ul>
<li>标准语法：让模板更易读写</li>
<li>原始语法：具有强大的逻辑处理能力</li>
</ul>
<p>标准输出语法：</p>
<p>原始输出语法：&lt;%= 数据 %&gt;</p>
<p>原始语法的输出格式类似于<strong>JSP表达式</strong></p>
<h3 id="2-1输出"><a href="#2-1输出" class="headerlink" title="2.1输出"></a>2.1输出</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 标准语法 --&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123;<span class="number">1</span> + <span class="number">1</span>&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123;<span class="number">1</span> + <span class="number">1</span> == <span class="number">2</span> ? <span class="string">&quot;正确&quot;</span> : <span class="string">&quot;错误&quot;</span>&#125;&#125;&lt;/p&gt;</span><br><span class="line">    </span><br><span class="line">&lt;!-- 原始语法 --&gt;</span><br><span class="line">&lt;p&gt;&lt;%= name %&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;%= <span class="number">1</span>+<span class="number">1</span> %&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;%= <span class="number">1</span>?<span class="string">&quot;正确&quot;</span>:<span class="string">&quot;错误&quot;</span> %&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>数据可以是template方法<strong>第二个参数中的数据</strong></p>
</li>
<li><p>可以是<strong>数字</strong>和<strong>普通字符串</strong></p>
</li>
<li><p>可以<strong>使用运算符操作</strong></p>
</li>
</ul>
<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210531205514506.png" alt="拼接后的html代码"></p>
<br>

<h3 id="2-2原文输出"><a href="#2-2原文输出" class="headerlink" title="2.2原文输出"></a>2.2原文输出</h3><h4 id="2-2-1-模板引擎默认将HTML标签当作普通字符串拼接"><a href="#2-2-1-模板引擎默认将HTML标签当作普通字符串拼接" class="headerlink" title="2.2.1 模板引擎默认将HTML标签当作普通字符串拼接"></a>2.2.1 模板引擎默认将HTML标签当作普通字符串拼接</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> html = template(viewpath,&#123;</span><br><span class="line">    name:<span class="string">&quot;yang&quot;</span>,</span><br><span class="line">    age:<span class="number">20</span>,</span><br><span class="line">    content:<span class="string">&quot;&lt;h1&gt;你好&lt;/h1&gt;&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>01.js</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123;content&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;%= content %&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<center>01.art</center>

<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210531210107038.png" alt="拼接后代码"></p>
<p>输出的html代码中h1标签被当作普通字符串输出</p>
<p>浏览器不会解析这个h1标签</p>
<br>

<h4 id="2-2-2原文输出解析HTML标签"><a href="#2-2-2原文输出解析HTML标签" class="headerlink" title="2.2.2原文输出解析HTML标签"></a>2.2.2原文输出解析HTML标签</h4><p>如果数据中带HTML标签，可以使用原文输出的方式来解析标签</p>
<p>标准语法：<code>&#123;&#123; @数据 &#125;&#125;</code></p>
<p>原始语法：<code>&lt;%- 数据 %&gt;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123;@content&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;%- content %&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>此时输出html代码如下</p>
<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210531211207051.png" alt="输出html代码"></p>
<p>此时拼接的HTML代码中的h1标签<strong>会被浏览器自动解析</strong></p>
<br>

<h3 id="2-3条件判断"><a href="#2-3条件判断" class="headerlink" title="2.3条件判断"></a>2.3条件判断</h3><p>模板中可以根据条件决定显示哪块HTML代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    标准语法	--&gt;</span></span><br><span class="line">    &#123;&#123;if 条件&#125;&#125;...&#123;&#123;/if&#125;&#125;</span><br><span class="line">    &#123;&#123;if 条件&#125;&#125;...&#123;&#123;else if 条件&#125;&#125;...&#123;&#123;/if&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    原始语法	--&gt;</span></span><br><span class="line">	&lt;% if (value) &#123; %&gt;...&lt;% &#125; %&gt;</span><br><span class="line">	&lt;% if (value) &#123; %&gt;...&lt;% &#125; else if (value) &#123; %&gt;...&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<p><strong>标准语法</strong>：将判断条件语句写在<code>&#123;&#123;&#125;&#125;`中，两个`&#123;&#123;&#125;&#125;</code>中的…即为满足条件时显示的HTML代码，以<code>&#123;&#123;/if&#125;&#125;</code>结束</p>
<p><strong>原始语法</strong>：将判断条件语句写在<code>&lt;% %&gt;</code>中，…即为满足条件时显示的HTML代码</p>
<ul>
<li>原始语法格式的<code>&lt;% %&gt;</code><strong>类似于</strong>JSP中的java代码块</li>
<li>在模板的<code>&lt;% %&gt;</code>中可以写<strong>任何原生js代码</strong></li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&#123;&#123;if age&gt;18&#125;&#125;</span><br><span class="line">    年龄大于18</span><br><span class="line">&#123;&#123;else if age &lt; 15&#125;&#125;</span><br><span class="line">    年龄小于15</span><br><span class="line">&#123;&#123;/if&#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;% if (age&gt;18) &#123; %&gt;</span><br><span class="line">    年龄大于18</span><br><span class="line">&lt;% &#125; else if (age &lt; 15) &#123; %&gt;</span><br><span class="line">    年龄小于15</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<center>03.art</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> html = template(viewpath,&#123;</span><br><span class="line">    name:<span class="string">&quot;yang&quot;</span>,</span><br><span class="line">    age:<span class="number">20</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>03.js</center>

<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210531214406700.png" alt="03.js运行后输出HTML代码"></p>
<p>20大于18，输出<code>年龄大于18</code></p>
<br>

<h3 id="2-4循环"><a href="#2-4循环" class="headerlink" title="2.4循环"></a>2.4循环</h3><p>当template()方法的第二个参数中有存放在数组中的数据时，就需要通过循环依次拿出数组中的数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/标准语法</span><br><span class="line">&#123;&#123;each 数据&#125;&#125;</span><br><span class="line">       &#123;&#123;$index&#125;&#125;</span><br><span class="line">       &#123;&#123;$value&#125;&#125;</span><br><span class="line">&#123;&#123;/each&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>数据：要循环输出的数组(一般为template()方法第二个参数中的数据)</p>
<p>$index：每次循环的索引，从0开始</p>
<p>$value：每次循环的数据(数组中的元素)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原始语法</span></span><br><span class="line">&lt;% <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; 数据.length; i++) &#123; %&gt;</span><br><span class="line">   &lt;%= 数据[i].属性名 %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<p>数据：要循环输出的数组</p>
<p>数据[i]：即为数组中的第i个元素</p>
<p>数据[i].属性名：数组中元素的属性(元素为对象)</p>
<p>&lt;% %&gt;标签中写的为原生js的循环语句</p>
<p>通过原始语法的输出标签&lt;%= %&gt;进行输出</p>
<br>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> html = template(viewpath,&#123;</span><br><span class="line">    users:[</span><br><span class="line">        &#123;</span><br><span class="line">            name:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">            age:<span class="number">20</span>,</span><br><span class="line">            sex:<span class="string">&quot;男&quot;</span></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            name:<span class="string">&quot;李四&quot;</span>,</span><br><span class="line">            age:<span class="number">18</span>,</span><br><span class="line">            sex:<span class="string">&quot;女&quot;</span></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            name:<span class="string">&quot;王五&quot;</span>,</span><br><span class="line">            age:<span class="number">22</span>,</span><br><span class="line">            sex:<span class="string">&quot;男&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>04.js</center>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//标准语法</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;&#123;each users&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">            &#123;&#123;$index&#125;&#125;</span><br><span class="line">            &#123;&#123;$value.name&#125;&#125;</span><br><span class="line">            &#123;&#123;$value.age&#125;&#125;</span><br><span class="line">            &#123;&#123;$value.sex&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;&#123;/each&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//原始语法</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &lt;% for(var i = 0; i &lt; users.length; i++) &#123; %&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">            &lt;%= i %&gt;</span><br><span class="line">            &lt;%= users[i].name %&gt;</span><br><span class="line">            &lt;%= users[i].age %&gt;</span><br><span class="line">            &lt;%= users[i].sex %&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<center>04.art</center>

<p>使用循环在ul标签中根据数组元素的个数生成li标签并在li标签中显示数组元素的属性</p>
<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210601211958346.png" alt="循环语句执行结果"></p>
<br>

<h3 id="2-5子模版"><a href="#2-5子模版" class="headerlink" title="2.5子模版"></a>2.5子模版</h3><p>通常一个网站的数个网页有公共的头部和底部，将这些公共代码提取出来后，可以使用模板引擎的<strong>子模版语法</strong>将这些公共代码在所有需要的网页中进行引入。</p>
<p><strong>标准语法</strong>：</p>
<p>子模版语法使用单标签，没有结束标签</p>
<p>标准语法的include 是关键字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123;include <span class="string">&#x27;公共代码模板文件的相对路径&#x27;</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原始语法</strong>：</p>
<p>原始语法的include是方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;% include(<span class="string">&#x27;公共代码模板文件的相对路径&#x27;</span>)%&gt;</span><br></pre></td></tr></table></figure>

<br>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;include &#x27;./05common/header.art&#x27;&#125;&#125;</span><br><span class="line">&lt;% include(&#x27;./05common/header.art&#x27;)%&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;&#123;include &#x27;./05common/footer.art&#x27;&#125;&#125;</span><br><span class="line">&lt;% include(&#x27;./05common/footer.art&#x27;)%&gt;</span><br></pre></td></tr></table></figure>

<center>05.art</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//header.art文件</span></span><br><span class="line">这是头部</span><br><span class="line"></span><br><span class="line"><span class="comment">//footer.art文件</span></span><br><span class="line">这是底部</span><br><span class="line"></span><br><span class="line"><span class="comment">//05.js文件</span></span><br><span class="line"><span class="keyword">const</span> html = template(viewpath,&#123;</span><br><span class="line">    msg:<span class="string">&quot;子模版演示&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210601213402446.png" alt="引入公共代码模板文件header.art和footer.art"></p>
<br>

<h3 id="2-6模板继承"><a href="#2-6模板继承" class="headerlink" title="2.6模板继承"></a>2.6模板继承</h3><ul>
<li><p>在网页中不仅只有头部和底部属于公共代码，页面的HTML骨架(html,body标签等)也属于公共代码</p>
</li>
<li><p>可以<strong>将HTML骨架也提取为公共代码模板文件</strong>，然后通过<strong>模板继承</strong>的方式引入HTML骨架</p>
</li>
<li><p>不同的页面继承HTML骨架后需要<strong>对骨架进行差异化修改</strong></p>
</li>
</ul>
<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210601221400538.png" alt="模板继承和引入/包含子模版"></p>
<h4 id="HTML骨架模板的差异化修改"><a href="#HTML骨架模板的差异化修改" class="headerlink" title="HTML骨架模板的差异化修改"></a>HTML骨架模板的差异化修改</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML骨架模板 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123;block &#x27;title&#x27;&#125;&#125;&#123;&#123;/block&#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    &#123;&#123;block &#x27;link&#x27;&#125;&#125;&#123;&#123;/block&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;&#123;block &#x27;content&#x27;&#125;&#125;&#123;&#123;/block&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<center>HTML骨架文件layout.art</center>

<p>差异化修改需要用到<strong>双标签block</strong></p>
<p>将block标签放在骨架模板的各个位置，后续页面进行继承时就可以<strong>替换这些block标签</strong>以达到<strong>差异化修改</strong>的目的</p>
<p><code>&#123;&#123;block '名字'&#125;&#125;&#123;&#123;/block&#125;&#125;</code></p>
<p>名字：自定义的每个block的<strong>标识</strong>，继承骨架的页面可以通过名字对block标签进行替换</p>
<br>

<h4 id="继承HTML骨架文件并替换block标签"><a href="#继承HTML骨架文件并替换block标签" class="headerlink" title="继承HTML骨架文件并替换block标签"></a>继承HTML骨架文件并替换block标签</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//继承骨架</span><br><span class="line">&#123;&#123;extend &#x27;./common/layout.art&#x27;&#125;&#125;</span><br><span class="line"></span><br><span class="line">//替换相应block标签</span><br><span class="line">&#123;&#123;block &#x27;title&#x27;&#125;&#125;首页&#123;&#123;/block&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;block &#x27;link&#x27;&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;main.css&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123;/block&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;block &#x27;content&#x27;&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;&#123;/block&#125;&#125;</span><br></pre></td></tr></table></figure>

<center>继承HTML骨架的06.art</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> html = template(viewpath,&#123;</span><br><span class="line">    msg:<span class="string">&quot;模版继承演示&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>06.js</center>

<p><strong>继承骨架文件</strong></p>
<p><code>&#123;&#123;extend 'HTML骨架文件的路径'&#125;&#125;</code></p>
<p><strong>替换block标签</strong></p>
<p><code>&#123;&#123;block '名字'&#125;&#125;...&#123;&#123;/block&#125;&#125;</code></p>
<p>使用名字定位要替换的block标签</p>
<p>…代表的内容将替换骨架中的相应block标签</p>
<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210601220333675.png" alt="继承骨架模板并差异化修改"></p>
<p>红框即为block标签被替换后的效果</p>
<br>

<h3 id="2-7-模板配置"><a href="#2-7-模板配置" class="headerlink" title="2.7 模板配置"></a>2.7 模板配置</h3><h4 id="2-7-1-向模板中导入变量"><a href="#2-7-1-向模板中导入变量" class="headerlink" title="2.7.1 向模板中导入变量"></a>2.7.1 向模板中导入变量</h4><p> <code>template.defaults.imports.变量名 = 变量值</code></p>
<ul>
<li><p>此语句写在js文件中，变量值为js文件中引入的模块。</p>
</li>
<li><p>变量名自定义，可以使用<strong>自定义的变量名</strong>在模板文件(.art)中使用导入的变量</p>
</li>
</ul>
<br>

<h5 id="模板中格式化时间的实例"><a href="#模板中格式化时间的实例" class="headerlink" title="模板中格式化时间的实例"></a>模板中格式化时间的实例</h5><p>使用<code>dateformat</code> <a href="https://www.npmjs.com/package/dateformat">npm包</a></p>
<p><code>npm install dateformat</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dateformat = <span class="built_in">require</span>(<span class="string">&#x27;dateformat&#x27;</span>)</span><br><span class="line"><span class="comment">//导入模板变量</span></span><br><span class="line"><span class="comment">//将dateformat方法作为变量导入模板</span></span><br><span class="line">template.defaults.imports.dateformat = dateformat</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> viewpath = path.join(__dirname,<span class="string">&#x27;views&#x27;</span>,<span class="string">&#x27;07.art&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> html = template(viewpath,&#123;</span><br><span class="line">    time:<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(html);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<center>07.js</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123;dateformat(time,<span class="string">&#x27;yyyy-mm-dd&#x27;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure>

<center>07.art</center>

<p>使用自定义的变量名(dateformat)在模板文件中调用导入的变量(dateformat模块方法)将时间格式化为年月日表示</p>
<p>运行07.js效果如下</p>
<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210622165807460.png" alt="直接输出time变量"></p>
<p><img data-src="/images/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/image-20210622165830082.png" alt="对time变量使用dateformat方法格式化后输出"></p>
<br>

<h4 id="2-7-2-设置模板根目录和默认后缀"><a href="#2-7-2-设置模板根目录和默认后缀" class="headerlink" title="2.7.2 设置模板根目录和默认后缀"></a>2.7.2 设置模板根目录和默认后缀</h4><p><strong>设置模板根目录</strong></p>
<p><code>template.defaults.root = 路径</code></p>
<p>设置模板根目录后，template方法执行时会将模板根目录与<strong>第一个参数</strong>(路径)进行拼接</p>
<p><strong>设置模板默认后缀</strong></p>
<p><code>template.defaults.extname = 后缀</code></p>
<ul>
<li><p>当template方法第一个参数(路径)中的文件<strong>没有</strong>后缀时会<strong>自动添加设置的默认后缀</strong></p>
</li>
<li><p>当template方法第一个参数(路径)中的文件<strong>有</strong>后缀时<strong>不做操作</strong></p>
</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> template = <span class="built_in">require</span>(<span class="string">&#x27;art-template&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> dateformat = <span class="built_in">require</span>(<span class="string">&#x27;dateformat&#x27;</span>)</span><br><span class="line">template.defaults.imports.dateformat = dateformat</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置模板根目录</span></span><br><span class="line"><span class="comment">//根目录为当前目录下的views文件夹</span></span><br><span class="line">template.defaults.root = path.join(__dirname,<span class="string">&#x27;views&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置模板默认后缀</span></span><br><span class="line"><span class="comment">//默认后缀设置为.art</span></span><br><span class="line">template.defaults.extname = <span class="string">&#x27;.art&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当前打开的模板文件路径为__dirname/views/07.art</span></span><br><span class="line"><span class="keyword">const</span> html = template(<span class="string">&#x27;07&#x27;</span>,&#123;</span><br><span class="line">    time:<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(html);</span><br></pre></td></tr></table></figure>

<center>07.js</center>

<p>可以打开并输出07.art模板的内容</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>15-学生信息管理系统实例</title>
    <url>/2021/07/29/15-%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="15-学生信息管理系统实例"><a href="#15-学生信息管理系统实例" class="headerlink" title="15-学生信息管理系统实例"></a>15-学生信息管理系统实例</h1><p><img data-src="/images/15-%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B/image-20210729094611957.png" alt="image-20210729094611957"></p>
<h2 id="4-创建路由并实现页面模板呈递"><a href="#4-创建路由并实现页面模板呈递" class="headerlink" title="4.创建路由并实现页面模板呈递"></a>4.创建路由并实现页面模板呈递</h2><p>之前通过请求方式和请求URL来区分请求的方式较繁琐</p>
<p>使用<strong>第三方模块router</strong>简化路由</p>
<span id="more"></span>

<h3 id="第三方模块router"><a href="#第三方模块router" class="headerlink" title="第三方模块router"></a>第三方模块router</h3><p>功能：简便的实现路由，易于维护</p>
<p><code>npm install router</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入模块</span></span><br><span class="line"><span class="keyword">const</span> getRouter = <span class="built_in">require</span>(<span class="string">&#x27;router&#x27;</span>)</span><br><span class="line"><span class="comment">//获取路由对象router</span></span><br><span class="line"><span class="keyword">const</span> router = getRouter()</span><br><span class="line"><span class="comment">//使用router的get或post方法处理相应请求</span></span><br><span class="line">	<span class="comment">//第一个参数为请求URL</span></span><br><span class="line">	<span class="comment">//第二个参数为处理的回调函数</span></span><br><span class="line">router.get(<span class="string">&#x27;/add&#x27;</span>,<span class="function">(<span class="params"> req,res </span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">router.get(<span class="string">&#x27;/list&#x27;</span>,<span class="function">(<span class="params"> req,res </span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">&#x27;list&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//调用router对象启用路由</span></span><br><span class="line"><span class="comment">//router对象的第三个参数是回调函数(必需)</span></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    router(req,res,<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="5-实现静态资源访问"><a href="#5-实现静态资源访问" class="headerlink" title="5.实现静态资源访问"></a>5.实现静态资源访问</h2><p>静态资源：css，图片等</p>
<p>使用<strong>第三方模块serve-static</strong></p>
<h3 id="第三方模块serve-static"><a href="#第三方模块serve-static" class="headerlink" title="第三方模块serve-static"></a>第三方模块serve-static</h3><p>功能：实现静态资源访问服务</p>
<p><code>npm install serve-static</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.引入模块</span></span><br><span class="line"><span class="keyword">const</span> serveStatic = <span class="built_in">require</span>(<span class="string">&#x27;serve-static&#x27;</span>)</span><br><span class="line"><span class="comment">//2.设定静态资源存放目录</span></span><br><span class="line"><span class="keyword">const</span> serve = serveStatic(path.join(__dirname,<span class="string">&#x27;public&#x27;</span>))</span><br><span class="line"><span class="comment">//在server.on()方法中调用serve方法（当服务器接收到请求时判断是否为静态资源请求从而做出反应）</span></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    router(req , res, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">    <span class="comment">//3.serve方法启动静态资源访问服务</span></span><br><span class="line">    	<span class="comment">//第三个参数是必需的回调函数</span></span><br><span class="line">    serve(req , res , <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h2 id="7-实现学生信息展示功能"><a href="#7-实现学生信息展示功能" class="headerlink" title="7.实现学生信息展示功能"></a>7.实现学生信息展示功能</h2><h3 id="第三方模块dateformat"><a href="#第三方模块dateformat" class="headerlink" title="第三方模块dateformat"></a>第三方模块dateformat</h3><p><a href="https://templar136.github.io/2021/05/31/14-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80/">14-模板引擎基础中提到过</a></p>
<br>

<h2 id="8-进一步将实例模块化"><a href="#8-进一步将实例模块化" class="headerlink" title="8.进一步将实例模块化"></a>8.进一步将实例模块化</h2><p>注意到<strong>router路由</strong>的代码可以独立出来</p>
<p>所以创建route文件夹下的index.js文件，将与router路由有关的代码放入</p>
<p>然后使用require将这个模块引入主模块app.js</p>
<p><img data-src="/images/15-%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B/image-20210805115329922.png" alt="route文件夹下的index.js文件"></p>
<p>将router路由代码提出时要注意<strong>需要的依赖模块</strong></p>
<p>app.js文件中只保留<strong>第三方、用户自定义模块的引入</strong>，<strong>路径拼接</strong>，<strong>服务器创建</strong>和<strong>模板配置</strong>等代码</p>
<p>这样的代码更接近于实际开发的模块化格式</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>16-Express框架</title>
    <url>/2021/08/11/16-Express%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="16-Express框架"><a href="#16-Express框架" class="headerlink" title="16-Express框架"></a>16-Express框架</h1><ul>
<li><p>Express是基于Node平台的<strong>web应用开发框架</strong></p>
</li>
<li><p>是Node的第三方模块</p>
</li>
</ul>
<p>使用<code>npm install express</code>下载</p>
<p>Express框架简化了创建web应用的过程</p>
<span id="more"></span>

<h2 id="1-Express框架特性"><a href="#1-Express框架特性" class="headerlink" title="1.Express框架特性"></a>1.Express框架特性</h2><ul>
<li>方便简洁的路由定义方式（router模块就来源于Express框架）</li>
<li>获取HTTP请求参数进行简化处理</li>
<li>对模板引擎支持度高，方便渲染动态HTML页面</li>
<li>提供了<strong>中间件机制</strong>有效控制HTTP请求</li>
<li>拥有大量<strong>第三方中间件</strong>对功能进行扩展</li>
</ul>
<h3 id="1-1简单样例"><a href="#1-1简单样例" class="headerlink" title="1.1简单样例"></a>1.1简单样例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入express框架</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">//创建网站服务器</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="comment">//设置路由</span></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">&#x27;网站主页&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/list&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(&#123;<span class="attr">mes</span>:<span class="string">&#x27;这是list页面&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;yang&#x27;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="string">&#x27;3000&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;服务器开启成功&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>express框架可以直接<strong>使用express()方法创建网站服务器</strong></li>
<li>app网站服务器对象可以使用<strong>get和post方法</strong>处理相应的HTTP请求</li>
<li>使用**res.send()**可以向客户端发送响应<ul>
<li>send方法内部会自动检测响应内容的类型</li>
<li>send方法会自动设置http状态码</li>
<li>send方法会<strong>自动设置响应内容类型和编码</strong></li>
<li>send方法可以直接向客户端<strong>响应对象</strong>，end方法不能直接响应对象</li>
</ul>
</li>
<li>express框架创建的网站服务器在访问不存在的路由时会显示<code>Cannot Get ‘目的路由’</code><ul>
<li>原生js创建的网站服务器访问不存在的路由时会显示页面不存在</li>
</ul>
</li>
</ul>
<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210811155312569.png" alt="send方法自动设置响应内容类型和编码格式"></p>
<br>

<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210811155427958.png" alt="send方法响应的对象"></p>
<h2 id="2-中间件"><a href="#2-中间件" class="headerlink" title="2.中间件"></a>2.中间件</h2><p>中间件就是<strong>一堆方法</strong>，可以<strong>接受客户端发来的请求</strong>、对<strong>请求做出响应</strong>，也可以<strong>将请求发给下一个中间件处理</strong></p>
<p>常见的Express框架中间件有<strong>app.get    app.post    app.use</strong></p>
<p><strong>中间件函数</strong>放在中间件中使用</p>
<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210817163003090.png" alt="image-20210817163003090"></p>
<h3 id="2-1中间件构成"><a href="#2-1中间件构成" class="headerlink" title="2.1中间件构成"></a>2.1中间件构成</h3><p>中间件主要由两部分构成</p>
<ul>
<li>Express框架提供的接受请求的<strong>中间件方法</strong></li>
<li>开发人员提供的<strong>请求处理函数</strong></li>
</ul>
<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210817163707714.png" alt="两个中间件"></p>
<p>app.get/post方法就是中间件方法</p>
<p>‘处理函数’就是请求处理函数</p>
<br>

<h3 id="2-2中间件将请求传递"><a href="#2-2中间件将请求传递" class="headerlink" title="2.2中间件将请求传递"></a>2.2中间件将请求传递</h3><p>可以针对同一个请求设置多个中间件，对同一个请求进行多次处理</p>
<p>默认情况，请求从上到下<strong>匹配到第一个中间件就终止</strong></p>
<p>调用next方法可以将请求的控制权交给下一个中间件，直到遇到结束请求的中间件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求处理函数中加入next参数</span></span><br><span class="line">app.get(<span class="string">&#x27;/request&#x27;</span>,<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//给请求对象添加name属性</span></span><br><span class="line">    req.name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">    <span class="comment">//调用next方法传递请求</span></span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/request&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(req.name)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="string">&#x27;3000&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;服务器开启成功&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="2-3-app-use中间件"><a href="#2-3-app-use中间件" class="headerlink" title="2.3 app.use中间件"></a>2.3 app.use中间件</h3><p>app.use中间件可以匹配<strong>任意请求方式(GET/POST)<strong>的</strong>特定或全部路径的请求</strong></p>
<p>app.use方法直接传入请求处理函数，代表接受<strong>任意路径</strong>的GET/POST请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;所有请求经过&#x27;</span>)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>app.use方法传入请求路径和请求处理函数，代表接受**特定请求路径(包括以这个字符串开头的请求路径)**的GET/POST请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">&#x27;/request&#x27;</span>,<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;请求地址为/request的请求经过app.use&#x27;</span>)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="2-4中间件的应用"><a href="#2-4中间件的应用" class="headerlink" title="2.4中间件的应用"></a>2.4中间件的应用</h3><p>1.路由保护，客户端访问需要登陆的页面时，先使用中间件判断用户登陆状态，根据登陆状态做出不同响应</p>
<p>2.网站维护公告，在所有路由最上层定义接受所有请求的中间件，直接为客户端做出正在维护的响应</p>
<p>3.自定义404页面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最后一个接受所有请求的中间件实现自定义404页面</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//res.status()设置响应的状态码</span></span><br><span class="line">    <span class="comment">//可以链式编程</span></span><br><span class="line">    res.status(<span class="number">404</span>).send(<span class="string">&#x27;访问的页面不存在&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>如果不使用res.status()手动设置404的状态码，Express框架会自动设置为200</li>
</ul>
<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210819165416631.png" alt="自定义404页面"></p>
<br>

<h3 id="2-5错误处理中间件"><a href="#2-5错误处理中间件" class="headerlink" title="2.5错误处理中间件"></a>2.5错误处理中间件</h3><p>程序执行过程中会出现一些无法预料的错误，比如文件读取失败，数据库链接失败等等</p>
<p>错误处理中间件可以集中处理此类问题，避免程序因为突发的不可预料错误崩溃</p>
<p><strong>同步代码和异步代码发生错误时的处理方式不同</strong></p>
<ul>
<li>错误处理中间件的处理函数有<strong>err错误对象</strong>作为参数</li>
<li>当<strong>同步代码</strong>执行发生错误时会自动进入错误处理中间件</li>
<li>使用<strong>throw关键字</strong>手动抛出错误模拟突发错误</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">&#x27;/index&#x27;</span>,<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//手动抛出错误</span></span><br><span class="line">    <span class="comment">//此代码执行后会自动进入错误处理中间件</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;程序执行出错&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误处理中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//err.message即为错误对象的信息（&#x27;程序执行出错&#x27;）</span></span><br><span class="line">    res.status(<span class="number">500</span>).send(err.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>同步代码发生错误</center>

<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210820152012585.png" alt="同步代码出错时客户端结果"></p>
<br>

<ul>
<li><strong>异步代码</strong>发生错误时<strong>不会自动进入错误处理中间件</strong></li>
<li>异步代码发生错误需要<strong>手动触发</strong>错误处理中间件<ul>
<li>手动触发：发生错误时<strong>调用next方法</strong>并将<strong>错误对象</strong>作为参数传递</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">&#x27;/index&#x27;</span>,<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//打开一个不存在的文件造成异步代码出错</span></span><br><span class="line">    fs.readFile(<span class="string">&#x27;./demo.txt&#x27;</span>,<span class="function">(<span class="params">err,result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="comment">//若出错则手动触发错误处理中间件</span></span><br><span class="line">            next(err)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.send(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>异步代码出错</center>

<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210820152603090.png" alt="异步代码出错客户端响应结果"></p>
<p>客户端显示错误信息，没有此文件或目录</p>
<br>

<h3 id="2-6异步函数的错误捕获"><a href="#2-6异步函数的错误捕获" class="headerlink" title="2.6异步函数的错误捕获"></a>2.6异步函数的错误捕获</h3><p>在Node.js中，异步API的错误信息通过回调函数获取，支持Promise对象的异步API发生错误可以通过catch方法获取</p>
<p><strong>try catch</strong> 可以捕获<strong>异步函数</strong>以及其他<strong>同步代码在</strong>执行过程中发生的错误，但是<strong>不能捕获其他类型API发生的错误</strong></p>
<ul>
<li><strong>例如：不能捕获回调函数和promise对象的错误</strong></li>
</ul>
<p>此处读取一个不存在的文件模拟错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promisify = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>).promisify</span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/index&#x27;</span>,<span class="keyword">async</span> (req,res,next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//尝试执行</span></span><br><span class="line">        <span class="keyword">await</span> readFile(<span class="string">&#x27;/demo.txt&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="comment">//发生错误时手动触发错误处理中间件</span></span><br><span class="line">        next(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>程序会尝试执行try中的代码，若成功执行则跳过catch执行之后的代码</li>
<li>如果try中的代码发生错误，则会进入catch中执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不使用try catch</span></span><br><span class="line">app.get(<span class="string">&#x27;/index&#x27;</span>,<span class="keyword">async</span> (req,res,next) =&gt; &#123;</span><br><span class="line">	<span class="comment">//异步函数执行出错后程序一直等待响应</span></span><br><span class="line">    <span class="keyword">await</span> readFile(<span class="string">&#x27;/demo.txt&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>不使用try catch时，若异步函数出错则<strong>报错并停止运行</strong></li>
</ul>
<br>

<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210821154102258.png" alt="使用try catch后的执行结果"></p>
<ul>
<li>使用try catch时，错误处理中间件向客户端响应错误信息</li>
<li>服务器后台不再报错，<strong>程序可以继续执行</strong>，这增加了程序的健壮性</li>
</ul>
<br>

<h3 id="2-7构建模块化路由"><a href="#2-7构建模块化路由" class="headerlink" title="2.7构建模块化路由"></a>2.7构建模块化路由</h3><p>将所有的路由写在一个文件中会导致维护困难，代码繁琐。</p>
<p>构建网站时，通常将路由分类，把<strong>一类路由写在一个模块中</strong>。</p>
<p>构建模块化路由需要用到<strong>express框架下的创建路由对象方法</strong></p>
<p><code>express.Router()</code></p>
<h4 id="2-7-1模块化路由基础代码"><a href="#2-7-1模块化路由基础代码" class="headerlink" title="2.7.1模块化路由基础代码"></a>2.7.1模块化路由基础代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建路由对象home</span></span><br><span class="line"><span class="keyword">const</span> home = express.Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">//将请求路径和路由对象匹配</span></span><br><span class="line">app.use(<span class="string">&#x27;/home&#x27;</span>,home)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在home路由下继续创建二级路由</span></span><br><span class="line"><span class="comment">//访问/home/index得到响应</span></span><br><span class="line">home.get(<span class="string">&#x27;/index&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">&#x27;欢迎来到首页&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>路由对象home下也有get和post方法，用来创建二级路由实现路由分类</p>
<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210821160838792.png" alt="访问二级路由"></p>
<h4 id="2-7-2模块化路由实例"><a href="#2-7-2模块化路由实例" class="headerlink" title="2.7.2模块化路由实例"></a>2.7.2模块化路由实例</h4><p>将两个不同的路由home和admin写成两个路由模块</p>
<p>在主模块中引入这两个路由模块实现模块化路由</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> admin = express.Router()</span><br><span class="line"></span><br><span class="line">admin.get(<span class="string">&#x27;/index&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">&#x27;欢迎来到管理首页&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = admin</span><br></pre></td></tr></table></figure>

<center>admin.js</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> home = express.Router()</span><br><span class="line"></span><br><span class="line">home.get(<span class="string">&#x27;/index&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">&#x27;欢迎来到主站首页&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = home</span><br></pre></td></tr></table></figure>

<center>home.js</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">&#x27;./route/home&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> admin = <span class="built_in">require</span>(<span class="string">&#x27;./route/admin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&#x27;/home&#x27;</span>,home)</span><br><span class="line">app.use(<span class="string">&#x27;/admin&#x27;</span>,admin)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;服务器开启成功&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>app.js</center>

<br>

<h2 id="3-Express模块请求处理"><a href="#3-Express模块请求处理" class="headerlink" title="3.Express模块请求处理"></a>3.Express模块请求处理</h2><h3 id="3-1获取get请求参数"><a href="#3-1获取get请求参数" class="headerlink" title="3.1获取get请求参数"></a>3.1获取get请求参数</h3><p>使用<code>req.query</code>获取</p>
<ul>
<li>此方法会返回对象形式的GET请求参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&#x27;/index&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(req.query)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;服务器开启&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="3-2获取POST请求参数"><a href="#3-2获取POST请求参数" class="headerlink" title="3.2获取POST请求参数"></a>3.2获取POST请求参数</h3><p>使用第三方模块<code>body-parser</code>下的<code>urlencoded</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//拦截所有请求提取POST请求参数</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123;<span class="attr">extended</span>:<span class="literal">false</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理POST请求参数</span></span><br><span class="line">app.post(<span class="string">&#x27;/add&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span>&#123;</span><br><span class="line">    res.send(req.body)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;服务器开启&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用body-parser模块下的urlendoded方法获取POST请求参数</p>
<ul>
<li>自动在req对象下创建<strong>body属性</strong>存放对象格式的POST请求参数</li>
</ul>
</li>
<li><p>urlencoded方法有一个必填属性<code>extended: true/false</code></p>
<ul>
<li>false：使用系统模块<strong>queryString</strong>将POST请求参数格式化为对象格式</li>
<li>true：使用第三方模块<strong>qs</strong>将POST请求参数格式化为对象格式</li>
</ul>
</li>
</ul>
<br>

<h3 id="3-3app-use中间件作为参数的处理函数"><a href="#3-3app-use中间件作为参数的处理函数" class="headerlink" title="3.3app.use中间件作为参数的处理函数"></a>3.3app.use中间件作为参数的处理函数</h3><p>获取POST请求参数中直接将<code>bodyParser.urlencoded(&#123;extended:false&#125;)</code>方法作为处理函数传入app.use中间件中</p>
<p>实际上<code>bodyParser.urlencoded</code>方法的<strong>返回值就是一个函数</strong>，作为处理函数传入没有问题</p>
<br>

<ul>
<li>将一个<strong>返回值为函数的函数</strong>作为app.use中间件的处理函数传入有一点好处<ul>
<li>这样可以<strong>在外层函数传入额外的参数</strong>来更灵活的操作内部的请求处理函数</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(fn(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//请求处理函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">req,res,next</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.a == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(req.url)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(req.method)</span><br><span class="line">        &#125;</span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：这里在外层函数传入了一个对象作为参数，内部请求处理函数可以根据这个参数的值做出一些判断等操作</p>
<br>

<h3 id="3-4-express框架路由参数"><a href="#3-4-express框架路由参数" class="headerlink" title="3.4 express框架路由参数"></a>3.4 express框架路由参数</h3><p>不同于上述获取GET请求参数的方法，express框架还有一种方式可以<strong>获取GET请求参数</strong></p>
<p>这种方式规定了要传入的参数，使请求更加容易理解</p>
<ul>
<li>直接在<code>app.get()</code>中间件的请求路径中指定要传入的参数<ul>
<li>此时参数格式不再是 ?  &amp; 格式，<strong>改为请求路径规定的格式</strong></li>
<li>此时请求路径<strong>规定的参数必须全部传入</strong>才能正常访问</li>
<li>使用<strong>req.params</strong>属性接受传入的GET参数</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//:id即代表要传入一个名为id的参数</span></span><br><span class="line"><span class="comment">//规定多个参数时使用/分隔</span></span><br><span class="line">app.get(<span class="string">&#x27;/index/:id&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span>&#123;</span><br><span class="line">    res.send(req.params)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>访问<strong>localhost:3000/index/123</strong></p>
<p>此处的123即为 <strong>:id</strong></p>
<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210829163716879.png" alt="返回对象格式的GET请求参数"></p>
<br>

<h3 id="3-5-静态资源的处理"><a href="#3-5-静态资源的处理" class="headerlink" title="3.5 静态资源的处理"></a>3.5 静态资源的处理</h3><p>通过express框架内置的<strong>express.static</strong>方法实现静态文件的请求处理</p>
<p><code>app.use(express.static(&#39;public&#39;))</code></p>
<p>此时将静态文件放在public文件夹下就可以访问</p>
<ul>
<li>请求被app.use中间件拦截后会由express.static方法判断<strong>请求的是否为静态资源文件</strong><ul>
<li>是，直接在public目录下找到该静态资源文件并响应给客户端后结束请求</li>
<li>否，将控制权移交下一个中间件</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拦截请求后判读是否请求静态资源文件</span></span><br><span class="line">app.use(express.static(path.join(__dirname,<span class="string">&#x27;public&#x27;</span>)))</span><br></pre></td></tr></table></figure>

<p>访问<strong>localhost:3000/css/1.css</strong></p>
<p>即找到public/css/1.css文件并响应</p>
<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210829170305061.png" alt="1.css文件响应"></p>
<p>还可以设置一个虚拟路径标识静态资源</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(express.static(<span class="string">&#x27;static&#x27;</span>,path.join(__dirname,<span class="string">&#x27;public&#x27;</span>)))</span><br></pre></td></tr></table></figure>

<p>此时访问路径变为<strong>localhost:3000/static/css/1.css</strong></p>
<br>

<h3 id="3-6-express-art-template模板引擎"><a href="#3-6-express-art-template模板引擎" class="headerlink" title="3.6 express-art-template模板引擎"></a>3.6 express-art-template模板引擎</h3><p>art-template模板引擎为了更好的支持express框架而封装了express-art-template</p>
<p>使用时要同时安装art-template和express-art-template模块</p>
<p>使用：</p>
<ul>
<li>指定渲染某种后缀的模板时使用什么模板引擎<ul>
<li>app.engine中间件</li>
</ul>
</li>
<li>指定模板存放目录<ul>
<li>app.set中间件配置</li>
<li>第一个参数views是express框架固定的写法</li>
<li>第二个参数是模板存放目录的绝对路径</li>
</ul>
</li>
<li>指定模板的默认后缀<ul>
<li>第一个参数view engine也是固定写法</li>
</ul>
</li>
<li>使用<strong>res.render</strong>方法完成模板的渲染和响应<ul>
<li>第一个参数写模板路径，方法会自动拼接默认后缀</li>
<li>第二个参数为要拼接的数据</li>
<li>方法将拼接后的模板<strong>直接响应给客户端</strong></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当渲染后缀为art的模板时使用express-art-template模板引擎</span></span><br><span class="line">app.engine(<span class="string">&#x27;art&#x27;</span>,<span class="built_in">require</span>(<span class="string">&#x27;express-art-template&#x27;</span>))</span><br><span class="line"><span class="comment">//指定模板存放目录</span></span><br><span class="line">app.set(<span class="string">&#x27;views&#x27;</span>,path.join(__dirname,<span class="string">&#x27;views&#x27;</span>))</span><br><span class="line"><span class="comment">//指定默认后缀为art(即不写后缀时默认拼接的后缀)</span></span><br><span class="line">app.set(<span class="string">&#x27;view engine&#x27;</span>,<span class="string">&#x27;art&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/index&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//渲染模板并向客户端返回</span></span><br><span class="line">    res.render(<span class="string">&#x27;index&#x27;</span>,&#123;</span><br><span class="line">        msg:<span class="string">&#x27;123&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="3-7-app-locals对象下添加模板公共数据"><a href="#3-7-app-locals对象下添加模板公共数据" class="headerlink" title="3.7 app.locals对象下添加模板公共数据"></a>3.7 app.locals对象下添加模板公共数据</h3><p>有时<strong>多个模板需要使用同样的数据</strong>，如果在每个模板拼接时都加入这些重复数据，会导致产生大量冗余代码</p>
<p>将多个模板需要使用的<strong>公共数据作为变量写在app.locals对象下</strong>，这样所有的模板都可以使用这些公共数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在app.locals下添加公共数据users</span></span><br><span class="line">app.locals.users = [&#123;<span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;,</span><br><span class="line">                    &#123;<span class="attr">name</span>:<span class="string">&#x27;lisi&#x27;</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;</span><br><span class="line">                   ]</span><br><span class="line">app.get(<span class="string">&#x27;/list&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//渲染模板并向客户端返回</span></span><br><span class="line">    res.render(<span class="string">&#x27;list&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;&#123;each users&#125;&#125;</span><br><span class="line">        &lt;li&gt;&#123;&#123;$value.name&#125;&#125;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&#123;&#123;$value.age&#125;&#125;&lt;/li&gt;</span><br><span class="line">    &#123;&#123;/each&#125;&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<center>模板中使用公共数据</center>

<p><img data-src="/images/16-Express%E6%A1%86%E6%9E%B6/image-20210830131510961.png" alt="拼接公共数据后响应"></p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>JS执行机制(同步异步)</title>
    <url>/2021/04/13/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6(%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5)/</url>
    <content><![CDATA[<h1 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h1><h2 id="1-JS是单线程"><a href="#1-JS是单线程" class="headerlink" title="1.JS是单线程"></a>1.JS是单线程</h2><ul>
<li>JavaScript语言的一大特点就是<strong>单线程</strong>，同一时间只能做一件事。</li>
</ul>
<p>这是因为JavaScript诞生的目的所致——JavaScript是为了处理页面中用户的交互，以及操作DOM而诞生的。</p>
<p>我们对一个DOM元素进行操作时，<strong>不能同时进行多种操作</strong>，而只能先添加，再修改，然后删除。</p>
<ul>
<li>单线程意味着任务需要排队，前一个任务结束，后一个任务才开始。这样如果JS的执行时间过长就会导致页面渲染不连贯。导致页面渲染呈现阻塞的感觉。</li>
</ul>
<span id="more"></span>

<h2 id="2-同步和异步"><a href="#2-同步和异步" class="headerlink" title="2.同步和异步"></a>2.同步和异步</h2><ul>
<li>为了解决JS单线程导致的任务排队问题，利用多核CPU的计算能力，H5提出了Web Worker标准，允许JavaScript脚本<strong>创建多个线程</strong>。于是JS中出现了<strong>同步</strong>和<strong>异步</strong>。</li>
</ul>
<p><img data-src="/images/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6(%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5)/image-20210408185914871.png" alt="image-20210408185914871"></p>
<p>上面这段代码按照单线程的思路：先输出1 等待1s后输出2 再输出3，如果定时器等待时间过长就会出现渲染阻塞的感觉。</p>
<p>而允许JavaScript创建多个线程后，输出顺序变成了先输出1和3，等待1s后再输出2</p>
<ul>
<li>同步异步的<strong>本质区别</strong>：各个流程的执行顺序不同。</li>
</ul>
<h3 id="2-1同步"><a href="#2-1同步" class="headerlink" title="2.1同步"></a>2.1同步</h3><ul>
<li>同步：<strong>前一个任务执行完毕再开始执行下一个任务</strong>，程序的执行顺序与任务的排列顺序是一致的、同步的。</li>
</ul>
<h3 id="2-2异步"><a href="#2-2异步" class="headerlink" title="2.2异步"></a>2.2异步</h3><ul>
<li>异步：同时可以执行多个任务，下一个任务不必等待上一个任务执行完。</li>
</ul>
<h3 id="2-3同步任务和异步任务"><a href="#2-3同步任务和异步任务" class="headerlink" title="2.3同步任务和异步任务"></a>2.3同步任务和异步任务</h3><ul>
<li><p>同步任务：同步任务都在<strong>主线程</strong>上执行，形成一个执行栈</p>
</li>
<li><p>异步任务：JS的异步是通过回调函数实现的</p>
<ul>
<li>常见的异步任务有以下几类</li>
</ul>
<ol>
<li><strong>普通事件</strong>中的回调函数，如click、resize等事件中的回调函数</li>
<li><strong>资源加载</strong>中的回调函数，如load、error等事件中的回调函数</li>
<li><strong>定时器</strong>中的回调函数，如setTimeout、setInterval等定时器中的回调函数</li>
</ol>
<ul>
<li>异步任务相关的<strong>回调函数</strong>添加到<strong>回调函数队列</strong>(消息队列)中</li>
</ul>
</li>
</ul>
<p><img data-src="/images/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6(%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5)/image-20210408205300165.png" alt="image-20210408205300165"></p>
<p>上图的<code>console.log(1)</code>和<code>console.log(2)</code>都是<strong>同步任务</strong></p>
<p>定时器setTimeout()属于<strong>异步任务</strong></p>
<p>定时器中的回调函数即<code>function()&#123;console.log(3)&#125;</code> 要在<strong>异步任务队列</strong>中的定时器代码被执行时加入<strong>回调函数队列</strong></p>
<p><img data-src="/images/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6(%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5)/image-20210428214905524.png" alt="image-20210428214905524"></p>
<h3 id="2-4JS执行机制"><a href="#2-4JS执行机制" class="headerlink" title="2.4JS执行机制"></a>2.4JS执行机制</h3><ol>
<li><p>先按顺序执行代码，<strong>同步任务放入同步代码执行区中执行</strong></p>
</li>
<li><p>将遇到的异步任务放入异步代码执行区中，此时<strong>不执行异步任务</strong>(等待同步任务执行完后开始执行)</p>
<ul>
<li>此处将setTimeout定时器代码放入异步代码执行区中</li>
<li>然后继续执行下面的同步任务</li>
</ul>
</li>
<li><p>一旦同步代码执行区中的同步任务执行完毕后，系统就会进入异步代码执行区开始执行异步任务</p>
<ul>
<li>此处设定0s的定时器并将回调函数放入回调函数队列中</li>
</ul>
</li>
<li><p>当回调函数队列中的回调函数满足条件后就调入同步代码执行区执行</p>
<ul>
<li>此处经过0s后将<code>console.log(3)</code>回调函数调入同步代码执行区执行</li>
</ul>
</li>
<li><p>当前同步任务和异步任务都执行完毕后，通过<strong>事件循环</strong>继续查看任务队列，若有新的异步任务就继续执行</p>
<p>上图的输出次序为1、2、3</p>
</li>
</ol>
<ul>
<li><strong>事件循环</strong>(event loop)：同步代码执行区不断的重复获取任务、执行任务、再获取任务、再执行，这种循环<strong>机制</strong>被称为事件循环</li>
</ul>
<h4 id="2-4-1有多个异步任务时的执行机制"><a href="#2-4-1有多个异步任务时的执行机制" class="headerlink" title="2.4.1有多个异步任务时的执行机制"></a>2.4.1有多个异步任务时的执行机制</h4><p><img data-src="/images/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6(%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5)/image-20210428215837351.png" alt="image-20210428215837351"></p>
<p>此时有两个同步任务</p>
<ol>
<li>console.log(1);</li>
<li>console.log(2);</li>
</ol>
<p>两个异步任务</p>
<ol>
<li>onclick</li>
<li>setTimeout</li>
</ol>
<ul>
<li>第1个异步任务的回调函数只有当<strong>点击事件发生时</strong>，才被调入同步代码执行区执行</li>
<li>第2个异步任务的回调函数，<strong>等经过3s后</strong>才被调入同步任务执行区执行</li>
<li>这两个异步任务的回调函数<strong>执行顺序取决于点击事件发生的时间</strong></li>
<li>同步代码执行区中的同步任务执行完后，会通过事件循环不断地查看异步代码执行区是否有新的异步任务，有就继续执行异步任务。<ul>
<li>例如在当前所有同步、异步任务执行完毕后，又触发了一次点击事件，此时通过事件循环发现任务队列中有一个等待的异步任务，就将这个异步任务的回调函数放入回调函数队列中并直接调入同步代码执行区执行。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>http核心模块构建简单WEB服务器</title>
    <url>/2021/04/13/http%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E6%9E%84%E5%BB%BA%E7%AE%80%E5%8D%95WEB%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="1-http核心模块构建简单WEB服务器"><a href="#1-http核心模块构建简单WEB服务器" class="headerlink" title="1.http核心模块构建简单WEB服务器"></a>1.http核心模块构建简单WEB服务器</h1><span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Node中有一个核心模块：http</span></span><br><span class="line"><span class="comment">//这个模块就是用来创建编写服务器的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器</span></span><br><span class="line">    <span class="comment">//接受请求</span></span><br><span class="line">    <span class="comment">//处理请求</span></span><br><span class="line">    <span class="comment">//给出响应(反馈)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.引入核心模块http</span></span><br><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用http.createServer()创建一个WEB服务器</span></span><br><span class="line"><span class="comment">//      方法返回一个Server实例</span></span><br><span class="line"><span class="keyword">var</span> server=http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.注册request请求事件，当浏览器请求发向服务器时触发</span></span><br><span class="line"><span class="comment">//第二个参数是事件处理函数</span></span><br><span class="line">    <span class="comment">//请求处理函数中接收两个参数</span></span><br><span class="line">        <span class="comment">//Request   请求对象</span></span><br><span class="line">            <span class="comment">//获取客户端的一些请求信息，例如请求路径</span></span><br><span class="line">        <span class="comment">//Response  响应对象</span></span><br><span class="line">            <span class="comment">//用来给客户端发送响应信息</span></span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//服务器接收到客户端请求后就在后台输出 请求的url(路径)</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;接受到请求，请求路径为：&quot;</span>+request.url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//response对象的write()方法可以给客户端发送响应数据</span></span><br><span class="line">        <span class="comment">//此时客户端访问http://127.0.0.1/3000/ 时会返回hello nodejs</span></span><br><span class="line">    response.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    response.write(<span class="string">&quot; nodejs&quot;</span>);</span><br><span class="line">    <span class="comment">//可以有多个write()但最后必须有一个end()结束响应 否则客户端会一直等待</span></span><br><span class="line">    response.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.绑定端口号，启动服务器</span></span><br><span class="line"><span class="comment">//第二个参数的函数在服务器启动时执行(起日志作用)</span></span><br><span class="line">server.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//在3000端口启动服务器</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;服务器启动成功，可以通过http://127.0.0.1:3000/访问&quot;</span>);</span><br><span class="line">    <span class="comment">//127.0.0.1也可以换成localhost</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="1-1搭建服务器时的IP和端口号简单解释"><a href="#1-1搭建服务器时的IP和端口号简单解释" class="headerlink" title="1.1搭建服务器时的IP和端口号简单解释"></a>1.1搭建服务器时的IP和端口号简单解释</h2><p>在端口3000上打开服务器</p>
<p>IP标识一台计算机</p>
<p>端口标识一个应用程序</p>
<p>IP:端口号 可以<strong>唯一标识一台计算机上的一个应用程序</strong></p>
<p>这里localhost:3000即为本机上的由<code>nodejs</code>搭建的服务器应用程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.listen(3000,function()&#123;  </span><br><span class="line">    console.log(&quot;服务器启动成功，可以通过http:&#x2F;&#x2F;127.0.0.1&#x2F;3000&#x2F;访问&quot;);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="1-2中文乱码的解决方法"><a href="#1-2中文乱码的解决方法" class="headerlink" title="1.2中文乱码的解决方法"></a>1.2中文乱码的解决方法</h2><p>​    加上头部让浏览器明确以utf-8编码格式解析</p>
<ul>
<li><p>第一种方法</p>
<p>通过meta元数据声明当前文本的编码格式为utf-8</p>
<p>加上<code>response.write(&#39;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;/head&gt;&#39;);</code></p>
</li>
<li><p>第二种方法</p>
<p>加上<code>response.setHeader(&quot;Content-Type&quot;,&quot;text/plain; charset=utf-8&quot;)</code></p>
<p><strong>不同响应内容对应的响应类型是不一样的</strong> 例如text/plain 或 text/html</p>
<p>第二种方法加上的头部可以在浏览器中查看</p>
<p>F12 Network下查看</p>
<p><img data-src="/images/http%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E6%9E%84%E5%BB%BA%E7%AE%80%E5%8D%95WEB%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20210412202501529.png" alt="image-20210412202501529"></p>
<p><img data-src="/images/http%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E6%9E%84%E5%BB%BA%E7%AE%80%E5%8D%95WEB%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20210412202544524.png" alt="image-20210412202544524"></p>
</li>
</ul>
<h2 id="1-3-setHeader-方法"><a href="#1-3-setHeader-方法" class="headerlink" title="1.3 setHeader()方法"></a>1.3 setHeader()方法</h2><p>在响应头部添加响应类型字段</p>
<p><code>res.setHeader(&quot;Content-Type&quot;,&quot;text/plain; charset=utf-8&quot;)</code></p>
<ul>
<li><p>Content-Type，<strong>响应内容类型</strong></p>
<ul>
<li><p>不同的响应内容要填入不同的类型(text/plain、text/html等)</p>
</li>
<li><p>text/plain，为响应数据的格式，text/plain为普通文本，响应的数据会被当作<strong>普通文本</strong>处理(html标签也会被当作普通文本)</p>
</li>
<li><p>text/html，为<strong>html文本</strong>，响应数据中的<strong>html标签会被浏览器自动识别并解释执行</strong></p>
</li>
</ul>
</li>
<li><p>charset=utf-8，指明返回的数据是utf-8格式编码，解决中文乱码问题 </p>
</li>
</ul>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>web服务器响应文件中的数据</title>
    <url>/2021/04/13/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="1-web服务器响应文件中的数据"><a href="#1-web服务器响应文件中的数据" class="headerlink" title="1.web服务器响应文件中的数据"></a>1.web服务器响应文件中的数据</h1><h2 id="1-1Nodejs构建web服务器代码如下"><a href="#1-1Nodejs构建web服务器代码如下" class="headerlink" title="1.1Nodejs构建web服务器代码如下"></a>1.1Nodejs构建web服务器代码如下</h2><span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入核心模块http和fs</span></span><br><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs=<span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务器</span></span><br><span class="line"><span class="keyword">var</span> server=http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> url=req.url;</span><br><span class="line">    <span class="keyword">if</span>(url==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//请求时响应html文件</span></span><br><span class="line">        fs.readFile(<span class="string">&quot;todoList.html&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//请求失败时响应普通文本</span></span><br><span class="line">                res.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/plain; charset=utf-8&quot;</span>) </span><br><span class="line">                res.end(<span class="string">&quot;文件读取失败&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//请求成功时响应html文本</span></span><br><span class="line">                res.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/html; charset=utf-8&quot;</span>) </span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//因为html文件中引用了jQuery.js文件，所以要手动添加这个文件的访问路径</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(url==<span class="string">&quot;/jQuery.js&quot;</span>)&#123;</span><br><span class="line">        fs.readFile(<span class="string">&quot;jQuery.js&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)</span><br><span class="line">            &#123;</span><br><span class="line">                res.end(<span class="string">&quot;load faild&quot;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">&quot;3000&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;服务器启动成功,可以访问3000端口&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打开文件中的数据使用fs核心模块的<code>fs.readFile()</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">&quot;todoList.html&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>nodejs将文件中的<strong>数据</strong>响应给浏览器</p>
<p>将<code>fs.readFile</code>返回的文件中数据data用res.end(data)响应给浏览器并加上相应格式的响应类型Content-Type</p>
<p><strong>注意这里的data直接响应给浏览器解释执行，不需要呈现出来查看，所以不需要toString()方法转换为可识别字符串</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/html; charset=utf-8&quot;</span>) </span><br><span class="line">res.end(data);</span><br></pre></td></tr></table></figure>

<p>在浏览器中访问如下</p>
<p><img data-src="/images/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/image-20210412223931130.png" alt="image-20210412223931130"></p>
<h2 id="1-2如果响应的html文件中有外部引入的文件如css样式或者js文件，则需要手动添加到这些文件的请求url"><a href="#1-2如果响应的html文件中有外部引入的文件如css样式或者js文件，则需要手动添加到这些文件的请求url" class="headerlink" title="1.2如果响应的html文件中有外部引入的文件如css样式或者js文件，则需要手动添加到这些文件的请求url"></a>1.2如果响应的html文件中有外部引入的文件如css样式或者js文件，则需要手动添加到这些文件的请求url</h2><p><img data-src="/images/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/image-20210412223645626.png" alt="image-20210412223645626"></p>
<p>例如html文件中有外部引入的jQuery.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;./jQuery.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>则需要手动添加到jQuery.js文件的请求url</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(url==<span class="string">&quot;/jQuery.js&quot;</span>)&#123;</span><br><span class="line">        fs.readFile(<span class="string">&quot;jQuery.js&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)</span><br><span class="line">            &#123;</span><br><span class="line">                res.end(<span class="string">&quot;load faild&quot;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.end(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-Content-Type内容类型"><a href="#2-Content-Type内容类型" class="headerlink" title="2.Content-Type内容类型"></a>2.Content-Type内容类型</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/plain; charset=utf-8&quot;</span>) </span><br></pre></td></tr></table></figure>

<p>不同的响应内容要填入不同的类型(text/plain、text/html等)</p>
<p><a href="http://tool.oschina.net/commons">http://tool.oschina.net/commons</a></p>
<p>上面的网址可以查看不同类型的数据使用什么响应类型</p>
<h1 id="3-服务器根据不同的请求URL可以返回不同的数据"><a href="#3-服务器根据不同的请求URL可以返回不同的数据" class="headerlink" title="3.服务器根据不同的请求URL可以返回不同的数据"></a>3.服务器根据不同的请求URL可以返回不同的数据</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">server.on(<span class="string">&quot;request&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;接受到请求，请求路径为：&quot;</span>+request.url);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> url=request.url;</span><br><span class="line">    <span class="comment">//判断url不同 响应不同的数据</span></span><br><span class="line">    <span class="keyword">if</span>(url==<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//可以使用end()直接响应数据后结束</span></span><br><span class="line">            <span class="comment">//响应内容只能是 字符串和二进制数串</span></span><br><span class="line">            <span class="comment">//数字，布尔值，数组，对象等需要使用JSON转换成字符串</span></span><br><span class="line">        response.end(<span class="string">&quot;hello nodejs&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当url为&quot;/login&quot;时</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(url==<span class="string">&quot;/login&quot;</span>)&#123;</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/plain; charset=utf-8&quot;</span>)</span><br><span class="line">        response.end(<span class="string">&quot;登陆页面&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当url为&quot;/shuzu&quot;时</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(url==<span class="string">&quot;/shuzu&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">        <span class="comment">//响应经过JSON转换后的字符串&quot;[1,2,3,4]&quot;</span></span><br><span class="line">        response.end(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当url为&quot;/html&quot;时</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(url==<span class="string">&quot;/html&quot;</span>)&#123;</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/html; charset=utf-8&quot;</span>) </span><br><span class="line">        response.end(<span class="string">&quot;&lt;p&gt;你好&lt;a href=&#x27;#&#x27;&gt;点击超链接&lt;/a&gt;&lt;/p&gt;&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//其他url返回&quot;404 Not Found.&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        response.end(<span class="string">&quot;404 Not Found.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>URL为/html时</p>
<p><img data-src="/images/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/image-20210414200745087.png" alt="image-20210414200745087"></p>
<p>URL为/login时</p>
<p><img data-src="/images/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/image-20210414200823281.png" alt="image-20210414200823281"></p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>12-数据库相关概念</title>
    <url>/2021/05/11/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h1><h2 id="1-使用MongoDB数据库"><a href="#1-使用MongoDB数据库" class="headerlink" title="1.使用MongoDB数据库"></a>1.使用MongoDB数据库</h2><p>MongoDB数据库<strong>可以使用js语法操作</strong>，前端开发人员更容易上手学习</p>
<p>MongoDB数据库是典型的<strong>非关系型数据库</strong>，数据可以使用<strong>JSON文件</strong>进行导入</p>
<p>MySQL则是典型的<strong>关系型数据库</strong>，数据被组织成<strong>表的形式</strong>存储</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511201521744.png" alt="image-20210511201521744"></p>
<span id="more"></span>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511201756252.png" alt="image-20210511201756252"></p>
<ul>
<li><p>此处页面中的admin和api等都是database</p>
<ul>
<li>Mongedb数据库软件中有三个默认的数据库：<strong>config，admin，local</strong></li>
</ul>
</li>
<li><p>roles是collection，一组数据的集合</p>
</li>
<li><p>右边显示的三条数据即为roles这个集合中的具体数据——<strong>文档document</strong></p>
<ul>
<li>每个文档实际上就是一个<strong>JSON对象</strong></li>
</ul>
</li>
<li><p>此处显示的文档中有三个<strong>字段field</strong></p>
</li>
</ul>
<h2 id="2-Nodejs操作数据库"><a href="#2-Nodejs操作数据库" class="headerlink" title="2.Nodejs操作数据库"></a>2.Nodejs操作数据库</h2><p>nodejs操作数据库需要第三方模块 <strong>mongoose模块</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//安装第三方模块</span></span><br><span class="line">npm install mongoose</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入mongoose模块</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-1打开数据库"><a href="#2-1打开数据库" class="headerlink" title="2.1打开数据库"></a>2.1打开数据库</h3><p>Mongodb数据库软件在安装时选择<strong>作为服务</strong>安装</p>
<p>可以直接通过打开服务的方式打开Mongodb数据库软件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">net start mongodb<span class="comment">//打开数据库</span></span><br><span class="line">net stop mongodb<span class="comment">//关闭数据库</span></span><br></pre></td></tr></table></figure>

<p>以管理员身份在CMD中开启关闭服务</p>
<h3 id="2-2数据库连接"><a href="#2-2数据库连接" class="headerlink" title="2.2数据库连接"></a>2.2数据库连接</h3><p>nodejs使用mongoose模块的<code>connect()</code>方法连接数据库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>)</span><br><span class="line"></span><br><span class="line">mongoose.connect(<span class="string">&#x27;mongodb://localhost/test&#x27;</span>)</span><br><span class="line">    .then(<span class="built_in">console</span>.log(<span class="string">&#x27;数据库开启成功&#x27;</span>))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;数据库开启失败&#x27;</span>,err))</span><br></pre></td></tr></table></figure>

<p>connect()方法返回一个<strong>promise对象</strong>，使用promise对象的**then()<strong>和</strong>catch()**方法接收结果和处理错误</p>
<p>connect()方法的参数为一个URL</p>
<ul>
<li>这个URL使用mongodb作为协议名</li>
<li>localhost即为主机的名字(IP/域名)，此处因为数据库运行在本机所以使用localhost</li>
<li>/test即为数据库名字(mongodb数据库会<strong>自动创建不存在的数据库</strong>，所以不需要显式的创建数据库)</li>
</ul>
<center>运行这个js文件显示如下</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511205146851.png" alt="image-20210511205146851"></p>
<p>将<code>&#123;useNewUrlParser:true,useUnifiedTopology:true&#125;</code>作为connect()方法的第二个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mongoose.connect(<span class="string">&#x27;mongodb://localhost/test&#x27;</span>,&#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> ,<span class="attr">useUnifiedTopology</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511205344686.png" alt="image-20210511205344686"></p>
<h3 id="2-3创建数据库"><a href="#2-3创建数据库" class="headerlink" title="2.3创建数据库"></a>2.3创建数据库</h3><p>MongoDB中不需要显式的创建数据库，打开数据库时<strong>不存在的数据库会被自动创建</strong></p>
<h3 id="2-4数据库的增添"><a href="#2-4数据库的增添" class="headerlink" title="2.4数据库的增添"></a>2.4数据库的增添</h3><h4 id="2-4-1创建集合"><a href="#2-4-1创建集合" class="headerlink" title="2.4.1创建集合"></a>2.4.1创建集合</h4><p>创建集合分两步</p>
<ul>
<li>1.设定集合规则</li>
<li>2.应用集合规则创建集合</li>
</ul>
<p><strong>设定集合规则</strong></p>
<p>使用<code>mongoose.Schema()</code><strong>构造函数</strong>创建实例对象来设定集合规则</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数传入一个JSON对象做为参数</span></span><br><span class="line"><span class="comment">//JSON对象中的属性即为文档中字段的名字和类型</span></span><br><span class="line"><span class="keyword">const</span> courseSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    teacher:<span class="built_in">String</span>,</span><br><span class="line">    isPublished:<span class="built_in">Boolean</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>创建的集合中的文档有三个字段</p>
<ul>
<li>name字段，数据类型为String</li>
<li>teacher字段，数据类型为String</li>
<li>isPublished字段，数据类型为Boolean</li>
</ul>
<p><strong>创建集合</strong></p>
<p>使用<code>mongoose.model()</code>方法创建集合</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个参数为集合名称</span></span><br><span class="line">    <span class="comment">//集合名称首字母大写</span></span><br><span class="line">    <span class="comment">//集合在数据库中实际的名称为courses</span></span><br><span class="line"><span class="comment">//第二个参数为应用的集合规则</span></span><br><span class="line"><span class="keyword">const</span> Course = mongoose.model(<span class="string">&#x27;Course&#x27;</span>,courseSchema);</span><br></pre></td></tr></table></figure>

<p>集合名称为Course，在数据库中实际创建的集合名称为<strong>courses</strong></p>
<p> <code>mongoose.model()</code>方法返回当前集合的构造函数</p>
<p>即上述代码的Course即为<strong>集合的构造函数</strong></p>
<p>集合的构造函数中的方法可以操作集合</p>
<p><strong>创建的新数据库如果没有文档数据，MongoDB中是不会创建这个数据库的，compass可视化软件中自然也看不到新数据库</strong></p>
<h4 id="2-4-2创建文档"><a href="#2-4-2创建文档" class="headerlink" title="2.4.2创建文档"></a>2.4.2创建文档</h4><p>创建文档向集合中插入数据分两步</p>
<ul>
<li>创建集合实例，写入新文档的数据</li>
<li>调用集合实例对象的save方法将文档保存在数据库中</li>
</ul>
<br>

<p><strong>创建集合实例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建集合的实例对象</span></span><br><span class="line"><span class="comment">//作为参数的JSON对象的属性即为文档中的字段和值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> courseDoc = <span class="keyword">new</span> Course(&#123;</span><br><span class="line">  name : <span class="string">&#x27;Node.js&#x27;</span>,</span><br><span class="line">  teacher:<span class="string">&#x27;黑马讲师&#x27;</span>,</span><br><span class="line">  isPublished: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>创建了一个集合实例(<strong>文档</strong>)</p>
<ul>
<li><p>name字段值为：’Node.js’</p>
</li>
<li><p>teacher字段值为：’黑马讲师’</p>
</li>
<li><p>isPublished字段值为：true</p>
<br></li>
</ul>
<p><strong>将集合保存到数据库</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保存数据到数据库</span></span><br><span class="line">courseDoc.save()</span><br></pre></td></tr></table></figure>

<p>调用创建的集合实例的save方法将新建的文档保存到数据库</p>
<br>

<center>在compass可视化软件中查看</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511214047191.png" alt="image-20210511214047191"></p>
<p>test数据库下的courses集合中有一个文档</p>
<p>_id字段是MongoDB数据库为每一个文档自动添加的唯一标识ID，类型为ObjectId</p>
<h4 id="2-4-3创建文档的另一种方式"><a href="#2-4-3创建文档的另一种方式" class="headerlink" title="2.4.3创建文档的另一种方式"></a>2.4.3创建文档的另一种方式</h4><p>使用集合构造函数的create()方法创建文档</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用集合构造函数的creat方法创建文档</span></span><br><span class="line"><span class="comment">//第一个参数为新建文档数据的JSON对象表示</span></span><br><span class="line"><span class="comment">//第二个参数为回调函数</span></span><br><span class="line">Course.create(&#123;<span class="attr">name</span>:<span class="string">&#x27;Javascript&#x27;</span>, <span class="attr">teacher</span>:<span class="string">&#x27;黑马讲师&#x27;</span>,<span class="attr">isPublished</span>:<span class="literal">false</span>&#125;, <span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>成功添加文档</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511215734414.png" alt="image-20210511215734414"></p>
<br>

<h5 id="Nodejs中对数据库的所有操作都是异步操作"><a href="#Nodejs中对数据库的所有操作都是异步操作" class="headerlink" title="Nodejs中对数据库的所有操作都是异步操作"></a>Nodejs中对数据库的所有操作都是异步操作</h5><ul>
<li><p>包括连接数据库，创建数据库和创建文档都是<strong>异步API</strong></p>
</li>
<li><p>其中返回promise对象的异步API可以应用<strong>异步函数</strong>编程的方法</p>
<br></li>
</ul>
<p>create()方法获取异步API结果的方式有两种</p>
<ul>
<li><p>利用<strong>回调函数</strong>得到，形如上述2.4.3代码</p>
</li>
<li><p>create()方法返回<strong>promise对象</strong>，使用promise对象的then()和catch()方法获取结果和处理错误信息</p>
<br></li>
</ul>
<p><strong>利用create()方法返回的promise对象来获取异步API结果</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用promise对象获取异步API的结果</span></span><br><span class="line"><span class="comment">//链式编程</span></span><br><span class="line">Course.create(&#123;<span class="attr">name</span>:<span class="string">&#x27;Javascript123&#x27;</span>, <span class="attr">teacher</span>:<span class="string">&#x27;黑马讲师&#x27;</span>,<span class="attr">isPublished</span>:<span class="literal">false</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure>

<center>后台返回数据</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511220815270.png" alt="image-20210511220815270"></p>
<center>compass显示</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511220907741.png" alt="image-20210511220907741"></p>
<h4 id="2-4-4MongoDB数据库导入数据"><a href="#2-4-4MongoDB数据库导入数据" class="headerlink" title="2.4.4MongoDB数据库导入数据"></a>2.4.4MongoDB数据库导入数据</h4><p>使用MongoDB提供的<code>mongoimport</code>命令导入文件中数据</p>
<p><code>mongoimport -d &#39;数据库名称&#39; -c &#39;集合名称&#39; --file &#39;要导入的文件路径&#39;</code></p>
<p><code>mongoimport -d &#39;数据库名称&#39; -c &#39;集合名称&#39; --jsonArray &#39;要导入的文件路径&#39;</code></p>
<br>

<p>因为mongoimport.exe这个文件路径不在系统环境变量的路径中</p>
<p><strong>需要我们手动添加文件的路径</strong></p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511231654210.png" alt="image-20210511231654210"></p>
<p>我在本机MongoDB安装目录下的bin文件夹中没有找到mongoimport.exe这个文件</p>
<p>所以在<a href="https://www.mongodb.com/try/download/database-tools?tck=docs_databasetools">MongoDB官网下载Tools</a></p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511231935779.png" alt="image-20210511231935779"></p>
<p>将压缩包中的<code>命令.exe</code>文件复制到环境变量设置的目录下，就可以使用这些命令</p>
<br>

<p><strong>导入user.json文件中的数据</strong></p>
<p>此处test数据库中不存在users集合</p>
<p>使用mongoimport命令会<strong>自动创建users集合</strong></p>
<ul>
<li>集合规则根据json文件中的json对象设置</li>
</ul>
<p>此处json文件中是一个包含三个json对象作为元素的数组</p>
<ul>
<li>所以使用<code>--jsonArray</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mongoimport -d test -c users --jsonArray .\要导入的文件\user.json</span><br></pre></td></tr></table></figure>

<center>.json文件内容</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511233918423.png" alt="image-20210511233918423"></p>
<center>导入成功</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511234355272.png" alt="image-20210511234355272"></p>
<center>compass软件</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511234514655.png" alt="image-20210511234514655"></p>
<p>test数据库下自动创建users集合并写入3个文档</p>
<br>

<p><strong>当json文件中存放单个json对象时，导入命令如下</strong></p>
<p>使用–file</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mongoimport -d test -c users --file .\要导入的文件\user.json</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511234828596.png" alt="image-20210511234828596"></p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210511234837217.png" alt="image-20210511234837217"></p>
<br>

<h3 id="2-5数据库的查询"><a href="#2-5数据库的查询" class="headerlink" title="2.5数据库的查询"></a>2.5数据库的查询</h3><p>查询文档两种方式：</p>
<ul>
<li>使用集合构造函数的<strong>find()方法</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Course为集合的构造函数</span></span><br><span class="line"><span class="keyword">const</span> Course = mongoose.model(<span class="string">&#x27;Course&#x27;</span>,courseSchema);<span class="comment">//courses</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查询集合中所有的文档(当find方法没有参数时)</span></span><br><span class="line">Course.find().then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p>find()方法<strong>默认返回promise对象</strong></p>
<p>promise对象的then方法接收的<strong>查询结果为一个数组</strong></p>
<p>数组中的元素为查询到的文档的JSON对象表示，当查询不到任何文档时返回空数组</p>
<p>find()方法使用<strong>一个JSON对象作为参数</strong>，json对象中属性即为查找条件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Course.find(&#123;<span class="attr">name</span>: <span class="string">&quot;Javascript&quot;</span>&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p><code>&#123;name: &quot;Javascript&quot;&#125;</code>即为查找name字段值为Javascript的文档</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512213042106.png" alt="image-20210512213042106"></p>
<br>

<ul>
<li><p>使用集合构造函数的<strong>findOne()方法</strong></p>
<ul>
<li><p>findOne()方法<strong>查询结果为一个JSON对象</strong>，而find()方法<strong>查询结果为一个包含0或多个JSON对象的数组</strong></p>
</li>
<li><p>findOne()方法和find()方法都默认返回promise对象，使用promise对象的then方法获取执行结果</p>
</li>
<li><p>findOne()方法和find()方法的参数设置格式相同</p>
</li>
<li><p>当findOne()方法<strong>没有参数时</strong>返回集合中的第一个文档的JSON对象</p>
</li>
<li><p><strong>有参数时</strong>会返回满足参数条件的第一个文档的JSON对象</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Course.findOne(&#123;<span class="attr">name</span>: <span class="string">&quot;Javascript123&quot;</span>&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512213745252.png" alt="image-20210512213745252"></p>
<br>

<h4 id="2-5-1按范围查询"><a href="#2-5-1按范围查询" class="headerlink" title="2.5.1按范围查询"></a>2.5.1按范围查询</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.find(&#123;<span class="attr">age</span>:&#123;<span class="attr">$gt</span>:<span class="number">21</span>,<span class="attr">$lt</span>:<span class="number">23</span>&#125;&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p>将作为find()方法参数的JSON对象中的<strong>属性值改为表示匹配信息JSON的对象</strong></p>
<p><code>&#123;age:&#123;$gt:21,$lt:23&#125;&#125;</code></p>
<ul>
<li>$gt代表大于</li>
<li>$lt代表小于</li>
</ul>
<p>表示匹配age字段值大于21，小于23的文档</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512221148976.png" alt="image-20210512221148976"></p>
<br>

<h4 id="2-5-2按匹配包含查询"><a href="#2-5-2按匹配包含查询" class="headerlink" title="2.5.2按匹配包含查询"></a>2.5.2按匹配包含查询</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.find(&#123;<span class="attr">hobbies</span>:&#123;<span class="attr">$in</span>:[<span class="string">&#x27;篮球&#x27;</span>]&#125;&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p><code>&#123;hobbies:&#123;$in:[&#39;篮球&#39;]&#125;&#125;</code></p>
<p>匹配hobbies字段中包含篮球的文档，数组中可以填写多个包含项</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512221742490.png" alt="image-20210512221742490"></p>
<br>

<h4 id="2-5-3选择查询的字段"><a href="#2-5-3选择查询的字段" class="headerlink" title="2.5.3选择查询的字段"></a>2.5.3选择查询的字段</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.find().select(<span class="string">&quot;name age&quot;</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p>对find()方法<strong>返回的promise对象使用select()方法</strong>选择要查询的字段名</p>
<ul>
<li><p>_id字段是每次查询时默认要查询的字段</p>
</li>
<li><p>在select方法的参数字段名前加<code>-</code>意味着查询时不显示这个字段</p>
</li>
<li><p><code>select(&quot;name age -_id&quot;)</code>即意味着查询name，age字段，不查询_id字段</p>
</li>
</ul>
<p><code>&quot;name age&quot;</code>要查询的字段名作为select方法的参数，字段名用空格隔开</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512222153159.png" alt="image-20210512222153159"></p>
<br>

<h4 id="2-5-4对查询结果按照某字段排序"><a href="#2-5-4对查询结果按照某字段排序" class="headerlink" title="2.5.4对查询结果按照某字段排序"></a>2.5.4对查询结果按照某字段排序</h4><p>查询商品的信息时会使用排序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.find().sort(<span class="string">&quot;age&quot;</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p>对find()方法<strong>返回的promise对象使用sort()方法</strong>进行排序</p>
<ul>
<li>按照sort()方法的参数填写的字段名排序<ul>
<li>字段名前加<code>-</code>即意为降序排序</li>
<li>不加<code>-</code>即意为升序排序</li>
</ul>
</li>
</ul>
<center>按年龄升序排序</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512222459529.png" alt="image-20210512222459529"></p>
<br>

<center>年龄降序排序</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.find().sort(<span class="string">&quot;-age&quot;</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512222552276.png" alt="image-20210512222552276"></p>
<br>

<h4 id="2-5-5查询时跳过数据，限制查询数量"><a href="#2-5-5查询时跳过数据，限制查询数量" class="headerlink" title="2.5.5查询时跳过数据，限制查询数量"></a>2.5.5查询时跳过数据，限制查询数量</h4><p>limit()和skip()方法结合使用可以实现分页功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//跳过第1条文档，查询最多2条文档</span></span><br><span class="line">User.find().skip(<span class="number">1</span>).limit(<span class="number">2</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p>对find()方法<strong>返回的promise对象</strong></p>
<ul>
<li>使用skip()方法设置<strong>跳过多少条数据</strong></li>
<li>使用limit()方法设置<strong>最多查询多少条数据</strong></li>
</ul>
<center>总共四条数据，跳过一条查询两条</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210512222941101.png" alt="image-20210512222941101"></p>
<br>

<h3 id="2-6数据库文档的删除"><a href="#2-6数据库文档的删除" class="headerlink" title="2.6数据库文档的删除"></a>2.6数据库文档的删除</h3><h4 id="2-6-1删除单个文档"><a href="#2-6-1删除单个文档" class="headerlink" title="2.6.1删除单个文档"></a>2.6.1删除单个文档</h4><p>使用集合构造函数的findOneAndDelete()方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找并删除匹配的第一条文档</span></span><br><span class="line">User.findOneAndDelete(&#123;<span class="attr">_id</span>:<span class="string">&#x27;609bdfc298ed4e560fe78266&#x27;</span>&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<ul>
<li>查找并删除<strong>匹配的第一条文档</strong></li>
<li>此例删除_id字段为’609bdfc298ed4e560fe78266’的文档</li>
<li>result为被删除文档的<strong>JSON对象</strong></li>
<li>参数为空则会删除集合中的第一个元素</li>
</ul>
<br>

<h4 id="2-6-2删除多个文档"><a href="#2-6-2删除多个文档" class="headerlink" title="2.6.2删除多个文档"></a>2.6.2删除多个文档</h4><p>使用集合构造函数的deleteMany()方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.deleteMany(&#123;<span class="attr">hobbies</span>:&#123;<span class="attr">$in</span>:<span class="string">&#x27;足球&#x27;</span>&#125;&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<ul>
<li>一次删除满足条件的所有文档</li>
<li>本例删除所有hobbies字段中<strong>包含’足球’的文档</strong></li>
<li>参数为空时会<strong>删除集合中所有文档</strong></li>
<li>result为一个对象，包含<strong>三个属性</strong><ul>
<li>ok: 1，值为1即表示删除成功</li>
<li>n: 2，2即表示删除了两个文档</li>
<li>deleteCount：2，删除计数为2</li>
</ul>
</li>
</ul>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210513224626695.png" alt="image-20210513224626695"></p>
<br>

<h3 id="2-7数据库文档修改"><a href="#2-7数据库文档修改" class="headerlink" title="2.7数据库文档修改"></a>2.7数据库文档修改</h3><h4 id="2-7-1修改单个文档"><a href="#2-7-1修改单个文档" class="headerlink" title="2.7.1修改单个文档"></a>2.7.1修改单个文档</h4><p>使用集合构造函数的<code>updateOne()</code>方法</p>
<ul>
<li>updateOne(‘查询条件’,’要修改的值’)</li>
<li>只能修改一个匹配文档</li>
<li>返回promise对象</li>
<li>执行结果result为一个对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.updateOne(&#123;<span class="attr">name</span>:<span class="string">&quot;杨启明&quot;</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&quot;杨启明1&quot;</span>&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p>找到name字段值为杨启明的文档，修改其name字段值为杨启明1</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517212114554.png" alt="image-20210517212114554"></p>
<center>上图红框即为result表示的对象</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517212203837.png" alt="image-20210517212203837"></p>
<h4 id="2-7-2修改多个文档"><a href="#2-7-2修改多个文档" class="headerlink" title="2.7.2修改多个文档"></a>2.7.2修改多个文档</h4><p>集合构造函数的updateMany()方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">User.updateMany(&#123;&#125;,&#123;<span class="attr">age</span>:<span class="number">18</span>&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br></pre></td></tr></table></figure>

<p>第一个参数为空对象即为修改集合中的所有文档</p>
<p>将集合中所有文档中的age字段值改为18</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517212536168.png" alt="image-20210517212536168"></p>
<br>

<h3 id="2-8Mongoose验证"><a href="#2-8Mongoose验证" class="headerlink" title="2.8Mongoose验证"></a>2.8Mongoose验证</h3><p>Mongoose在创建集合规则时可以<strong>为文档的字段设定验证条件</strong>，不满足验证条件的文档在存入数据库时会报错</p>
<p>字段的验证条件在<strong>设定集合规则</strong>时指定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> postSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    <span class="comment">//name:&#123;&#125; JSON对象中写name字段的具体验证要求</span></span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        required:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-8-1-required规则"><a href="#2-8-1-required规则" class="headerlink" title="2.8.1 required规则"></a>2.8.1 required规则</h4><p>required规则取值可以有两种</p>
<ul>
<li>boolean值</li>
<li>数组(数组中可以自定义报错信息)</li>
</ul>
<p><strong>1.require规则值为boolean值</strong></p>
<p><code>required:true</code>代表该字段是必须的(mongoose默认规定字段可以为空)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将一个空文档存入数据库</span></span><br><span class="line">Post.create(&#123;&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517214350607.png" alt="image-20210517214350607"></p>
<center>红框报错，name字段是必须的</center>

<br>

<p><strong>当没有设置required字段为true时</strong></p>
<p>将空文档存入数据库也不会报错</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517214658740.png" alt="image-20210517214658740"></p>
<center>红框即为存入的空文档</center>

<br>

<p><strong>2.required规则值为数组</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> postSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    <span class="comment">//name:&#123;&#125; JSON对象中写name字段的具体验证要求</span></span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">//required规则值为数组</span></span><br><span class="line">        required:[</span><br><span class="line">            <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&#x27;请填入必填项标题&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>数组第一个元素为是否为必填项</p>
<p>第二个参数为报错信息</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517215346089.png" alt="image-20210517215346089"></p>
<center>报错信息变为'请填入必填项标题'</center>

<h4 id="2-8-2-字段长度限制"><a href="#2-8-2-字段长度限制" class="headerlink" title="2.8.2 字段长度限制"></a>2.8.2 字段长度限制</h4><p><strong>针对于type为String的字段值</strong></p>
<p><strong>minlength</strong>规则：限制最小长度</p>
<p><strong>maxlength</strong>规则：限制最大长度</p>
<p>同样规则值可以为数组，第二个元素为报错信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> postSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    <span class="comment">//name:&#123;&#125; JSON对象中写name字段的具体验证要求</span></span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        required:[</span><br><span class="line">            <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&#x27;请填入必填项标题&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">//最小长度为2</span></span><br><span class="line">        minlength:[<span class="number">2</span>,<span class="string">&#x27;输入值小于最小长度2&#x27;</span>],</span><br><span class="line">        <span class="comment">//最大长度为5</span></span><br><span class="line">        maxlength:[<span class="number">5</span>,<span class="string">&#x27;输入值大于最大长度5&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个文档name字段值为&#x27;helloworld&#x27;，并存入数据库</span></span><br><span class="line">Post.create(&#123;<span class="attr">name</span>:<span class="string">&#x27;helloworld&#x27;</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517215830774.png" alt="image-20210517215830774"></p>
<center>长度大于5报错</center>

<br>

<h4 id="2-8-3-trim规则"><a href="#2-8-3-trim规则" class="headerlink" title="2.8.3 trim规则"></a>2.8.3 trim规则</h4><p>trim：规定是否去除字符串两边多余的空格</p>
<p>trim规则的值为boolean值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> postSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    <span class="comment">//name:&#123;&#125; JSON对象中写name字段的具体验证要求</span></span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        required:[</span><br><span class="line">            <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&#x27;请填入必填项标题&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">        minlength:[<span class="number">2</span>,<span class="string">&#x27;输入值小于最小长度2&#x27;</span>],</span><br><span class="line">        maxlength:[<span class="number">5</span>,<span class="string">&#x27;输入值大于最大长度5&#x27;</span>],</span><br><span class="line">        trim:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//name字段值为&#x27;   a bc  &#x27;</span></span><br><span class="line">Post.create(&#123;<span class="attr">name</span>:<span class="string">&#x27;   a bc  &#x27;</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br></pre></td></tr></table></figure>

<p>代码中设置name字段值为’       a bc   ‘</p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517220251295.png" alt="image-20210517220251295"></p>
<center>消除多余空格后的文档数据</center>

<br>

<h4 id="2-8-4数值大小限制"><a href="#2-8-4数值大小限制" class="headerlink" title="2.8.4数值大小限制"></a>2.8.4数值大小限制</h4><p>针对于type为Number的字段值</p>
<p>min：最小数值</p>
<p>max：最大数值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">age:&#123;</span><br><span class="line">       type:<span class="built_in">Number</span>,</span><br><span class="line">       <span class="comment">//数值最小值  Number类型</span></span><br><span class="line">       min:<span class="number">18</span>,</span><br><span class="line">       <span class="comment">//数值最大值</span></span><br><span class="line">       max:<span class="number">70</span>,</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>

<br>

<h4 id="2-8-5默认值设置"><a href="#2-8-5默认值设置" class="headerlink" title="2.8.5默认值设置"></a>2.8.5默认值设置</h4><p>使用<strong>default</strong>设置字段默认值，在没有显式创建这个字段时，字段会使用默认值创建</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">publishDate:&#123;</span><br><span class="line"></span><br><span class="line">    type:<span class="built_in">Date</span>,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:<span class="built_in">Date</span>.now</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>publishDate字段的默认值为当前时间</p>
<p>Date内置对象的now属性可以获取当前时间</p>
<br>

<h4 id="2-8-6枚举设置"><a href="#2-8-6枚举设置" class="headerlink" title="2.8.6枚举设置"></a>2.8.6枚举设置</h4><p>使用enmu设置字段<strong>可选的值</strong>，字段的值<strong>不在enmu设定的值中会报错</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">category:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">//枚举值(该字段可选的值)</span></span><br><span class="line">        enum:[<span class="string">&#x27;小说&#x27;</span>,<span class="string">&#x27;散文&#x27;</span>,<span class="string">&#x27;说明文&#x27;</span>]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>category字段的可选值为小说、散文和说明文</p>
<p>enum属性的值也可以是一个对象</p>
<p>values：可选的值数组</p>
<p>message：自定义错误信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum:&#123;</span><br><span class="line">            values: [<span class="string">&#x27;小说&#x27;</span>,<span class="string">&#x27;散文&#x27;</span>,<span class="string">&#x27;说明文&#x27;</span>],</span><br><span class="line">            message: <span class="string">&#x27;不在可选范围内&#x27;</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="2-8-7自定义验证规则"><a href="#2-8-7自定义验证规则" class="headerlink" title="*2.8.7自定义验证规则"></a>*2.8.7自定义验证规则</h4><p>validate：自定义规则,为一个JSON对象</p>
<p>validator：自定义规则验证函数，是validate的元素</p>
<ul>
<li>返回boolean值</li>
<li>true代表验证成功，false代表失败</li>
<li>v即为要验证的字段值</li>
</ul>
<p>message：自定义报错信息，是validate的元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">author:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">//自定义验证规则</span></span><br><span class="line">        validate:&#123;</span><br><span class="line">            <span class="comment">//进行验证的函数</span></span><br><span class="line">            validator:<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">//返回boolean值</span></span><br><span class="line">                <span class="comment">//true代表验证成功，false代表失败</span></span><br><span class="line">                <span class="comment">//v即为要验证的字段值</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//v的值小于4即验证通过</span></span><br><span class="line">                <span class="keyword">return</span> v &amp;&amp; v.length&lt;<span class="number">4</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//自定义规则报错信息</span></span><br><span class="line">            message:<span class="string">&#x27;不满足作者字段验证条件&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Post.create(&#123;<span class="attr">name</span>:<span class="string">&#x27;01&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">category</span>:<span class="string">&#x27;小说&#x27;</span>,<span class="attr">author</span>:<span class="string">&#x27;abc&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br></pre></td></tr></table></figure>

<center>创建并保存包含4个字段的文档</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210517224430291.png" alt="image-20210517224430291"></p>
<center>保存成功</center>

<ul>
<li>name字段：必填项验证</li>
<li>age字段：数值大小验证</li>
<li>category字段：enmu枚举验证</li>
<li>author字段：自定义验证(长度小于4)</li>
<li>publishDate字段：没有显式创建，使用默认值自动创建</li>
</ul>
<br>

<h4 id="2-8-8通过代码获得错误信息"><a href="#2-8-8通过代码获得错误信息" class="headerlink" title="2.8.8通过代码获得错误信息"></a>2.8.8通过代码获得错误信息</h4><p>集合构造函数的create()方法返回<strong>promise对象</strong></p>
<p>可以使用promise的<strong>then方法</strong>获取执行结果</p>
<p>可以使用promise的<strong>catch方法</strong>获取错误信息</p>
<ul>
<li>catch获取的错误信息以对象的形式返回</li>
</ul>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210518205149772.png" alt="image-20210518205149772"></p>
<center>catch方法返回的对象</center>

<p>具体错误信息提示放在错误对象的errors属性中</p>
<p>如果有多个错误，例如：category字段和author字段都错误</p>
<p>errors中就会嵌套两个相应的错误字段对象</p>
<p>错误字段对象下的properties对象中的message属性存放的就是定义的message错误信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Post.create(&#123;<span class="attr">name</span>:<span class="string">&#x27;01&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">category</span>:<span class="string">&#x27;小说1&#x27;</span>,<span class="attr">author</span>:<span class="string">&#x27;abcde&#x27;</span>&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="comment">//获取错误对象下的errors属性</span></span><br><span class="line">        <span class="keyword">var</span> errin = err.errors</span><br><span class="line">        <span class="comment">//循环每个错误字段对象(categoty和author对象)取其properties对象中的message属性</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> errin)</span><br><span class="line">        	<span class="built_in">console</span>.log(errin[i].properties.message);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210518212854641.png" alt="image-20210518212854641"></p>
<center>取得的message错误信息</center>

<br>

<h3 id="2-9集合关联"><a href="#2-9集合关联" class="headerlink" title="2.9集合关联"></a>2.9集合关联</h3><p>有时数据库的两个集合存在关联</p>
<p>例如<strong>posts文章集合</strong>中文档有一个字段是作者<strong>author</strong></p>
<p><strong>users用户集合</strong>中的用户信息即为<strong>作者信息</strong></p>
<p>在查询posts集合中文档的<strong>作者author信息</strong>时，就需要<strong>关联users集合</strong></p>
<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210518220527147.png" alt="image-20210518220527147"></p>
<center>关联时在posts集合文档的author字段存入users集合文档的_id</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设定user集合规则</span></span><br><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设定post集合规则</span></span><br><span class="line"><span class="keyword">const</span> postSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    title:<span class="built_in">String</span>,</span><br><span class="line">    author:&#123;</span><br><span class="line">        type:mongoose.Schema.Types.ObjectId,</span><br><span class="line">        ref:<span class="string">&#x27;User&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>创建两个集合</center>

<br>

<h4 id="2-9-1使用字段设置关联信息"><a href="#2-9-1使用字段设置关联信息" class="headerlink" title="2.9.1使用字段设置关联信息"></a>2.9.1使用字段设置关联信息</h4><p>posts集合的author字段关联users集合</p>
<ul>
<li><p>author字段的<strong>值类型</strong>为<code>mongoose.Schema.Types.ObjectId</code>，即为文档**_id字段的类型**</p>
</li>
<li><p>ref属性的值为<strong>与本集合关联的集合的构造函数</strong>，此处与posts集合关联的集合为users集合(User为users集合构造函数)</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关联一个文档</span></span><br><span class="line">author:&#123;</span><br><span class="line">        type:mongoose.Schema.Types.ObjectId,</span><br><span class="line">        ref:<span class="string">&#x27;User&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义数组关联多个文档(购物车实例)</span></span><br><span class="line">author:[&#123;</span><br><span class="line">      	type:mongoose.Schema.Types.ObjectId,</span><br><span class="line">        ref:<span class="string">&#x27;User&#x27;</span>  </span><br><span class="line">    &#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">//关联了两个users集合中的文档 </span></span><br><span class="line">Post.create(&#123;<span class="attr">title</span>:<span class="string">&#x27;Firstpost&#x27;</span>,<span class="attr">author</span>:[<span class="string">&#x27;60bec059f4f10041f482247c&#x27;</span>,<span class="string">&#x27;60bec059f4f10041f482247d&#x27;</span>]&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br></pre></td></tr></table></figure>

<center>红框即为关联的user集合文档的_id字段值</center>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210518220222814.png" alt="image-20210518220222814"></p>
<center>右侧为user集合中的文档</center>

<h4 id="2-9-2-populate-方法查询关联字段信息"><a href="#2-9-2-populate-方法查询关联字段信息" class="headerlink" title="2.9.2 populate()方法查询关联字段信息"></a>2.9.2 populate()方法查询关联字段信息</h4><p>此时posts集合文档中的author字段存储的是users集合中文档的_id值，不方便查看作者信息</p>
<p>使用populate()方法<strong>在查询文档时将关联字段的信息一并查询出来</strong></p>
<ul>
<li>参数即为用来设置关联信息的字段author</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Post.find().populate(<span class="string">&#x27;author&#x27;</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/12-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210518221746819.png" alt="image-20210518221746819"></p>
<p>此时查询出的posts集合中的文档<strong>author字段值为 关联的users集合中对应文档的JSON对象</strong>，方便查看</p>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Mongodb数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>01-Vue</title>
    <url>/2021/09/10/01-Vue/</url>
    <content><![CDATA[<h1 id="Vue学习"><a href="#Vue学习" class="headerlink" title="Vue学习"></a>Vue学习</h1><h2 id="1-什么是Vue"><a href="#1-什么是Vue" class="headerlink" title="1.什么是Vue"></a>1.什么是Vue</h2><ul>
<li>2014年Vue.js正式发布</li>
<li>15年10月27日，正式发布1.0.0</li>
<li>16年4月27日，<strong>发布2.0的预览版本</strong>（主要学习的版本）</li>
<li>现在已经有<strong>3.0</strong>版本的Vue</li>
</ul>
<span id="more"></span>

<p>Vue是一个<strong>渐进式Javascript框架</strong></p>
<p><a href="https://cn.vuejs.org/">Vue官方网站</a></p>
<ul>
<li><strong>框架</strong>：主要提供一些基础性的服务如 <strong>虚拟DOM</strong>和<strong>双向数据绑定</strong>等 节省实际开发代码量</li>
<li>库：主要提供大量的API 如jQuery等 现在<strong>库和框架的界限已经不明显</strong></li>
<li><strong>渐进式</strong>：声明式渲染 -&gt; 组件系统 -&gt; 客户端路由 -&gt; 集中式状态管理 -&gt; 项目构建<ul>
<li>从左至右Vue的使用逐渐深入，项目规模逐渐增大</li>
</ul>
</li>
</ul>
<p>Vue的<strong>主要优点</strong></p>
<ul>
<li>易用：熟悉HTML，CSS和JavaScript后可快速上手Vue</li>
<li>灵活：在一个库和一个框架之间伸缩</li>
<li>高效：20KB运行大小，超快虚拟DOM</li>
</ul>
<br>

<h2 id="2-Hello-Vue简单程序"><a href="#2-Hello-Vue简单程序" class="headerlink" title="2. Hello Vue简单程序"></a>2. Hello Vue简单程序</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello Vue<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入Vue.js框架 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用插值表达式完成Vue的输出 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Vue的插值表达式中可以完成原生js表达式的基本运算 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;1 + 2&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg+&#x27;123&#x27;&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//创建Vue实例</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//el:元素挂载位置 （css选择器或者DOM对象）</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//data：模型数据 值是对象 可以存放键值对类型的数据</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> test = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&#x27;#add&#x27;</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                msg:<span class="string">&#x27;Hello Vue&#x27;</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在官方网站下载<strong>开发版的Vue.js文件</strong><ul>
<li>文件的引入方式类似jQuery.js</li>
</ul>
</li>
</ul>
<br>

<ol>
<li>使用Vue时要<strong>创建Vue实例</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">&#x27;#add&#x27;</span>,</span><br><span class="line">            data:&#123;</span><br><span class="line">                msg:<span class="string">&#x27;Hello Vue&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>el</strong>：元素挂载位置 （css选择器或者DOM对象），即Vue的输出在哪个HTML标签中</li>
<li><strong>data</strong>：模型数据 值是对象 可以存放键值对类型的数据</li>
</ul>
<br>

<ol start="2">
<li>输出Vue数据时使用<strong>插值表达式</strong></li>
</ol>
<ul>
<li><strong>插值表达式</strong>： msg为模型数据中的数据<ul>
<li>插值表达式将数值填充到HTML标签中</li>
<li>也可以完成<strong>基本的计算操作</strong>（如加减和字符串拼接等）</li>
</ul>
</li>
<li>使用Vue进行输出时<strong>不需要书写底层的操作DOM的代码</strong>，简化了开发流程</li>
</ul>
<ol start="3">
<li><p>Vue代码运行原理</p>
<p>Vue框架将<strong>Vue代码转换为原生js代码</strong>运行</p>
<p>称为编译过程</p>
</li>
</ol>
<h2 id="3-Vue模板语法"><a href="#3-Vue模板语法" class="headerlink" title="3. Vue模板语法"></a>3. Vue模板语法</h2><p>Vue<strong>有着自己的一套语法规则</strong>，就像<strong>前端模板引擎art-template</strong>有着自己的一套语法规则一样</p>
<p>模板语法所做的工作就是<strong>前端渲染</strong></p>
<h3 id="3-1-前端渲染"><a href="#3-1-前端渲染" class="headerlink" title="3.1 前端渲染"></a>3.1 前端渲染</h3><p>前端渲染就是<strong>把数据填充到HTML标签中</strong></p>
<p>将<strong>数据和模板结合进行前端渲染</strong>，最后得到静态HTML内容</p>
<br>

<h3 id="3-2-前端渲染的方式"><a href="#3-2-前端渲染的方式" class="headerlink" title="3.2 前端渲染的方式"></a>3.2 前端渲染的方式</h3><ul>
<li>原生js拼接字符串</li>
<li>使用前端模板引擎art-templat</li>
<li>使用Vue特有的模板语法</li>
</ul>
<h4 id="3-2-1-原生js拼接字符串"><a href="#3-2-1-原生js拼接字符串" class="headerlink" title="3.2.1 原生js拼接字符串"></a>3.2.1 原生js拼接字符串</h4><p>将数据<strong>以字符串的方式拼接</strong>并显示在HTML标签中</p>
<p><strong>缺点</strong>：不同开发人员的代码风格不同，导致项目<strong>后期维护困难</strong></p>
<h4 id="3-2-2-前端模板引擎"><a href="#3-2-2-前端模板引擎" class="headerlink" title="3.2.2 前端模板引擎"></a>3.2.2 前端模板引擎</h4><p>例如art-template模板引擎</p>
<ul>
<li>使用<strong>自己的一套模板语法规则</strong></li>
<li>代码规范程度高，易于维护</li>
</ul>
<p><strong>缺点</strong>：没有提供专门的<strong>事件机制</strong>，需要使用原始的方法实现事件绑定等操作</p>
<h4 id="3-2-3-Vue特有模板语法"><a href="#3-2-3-Vue特有模板语法" class="headerlink" title="3.2.3 Vue特有模板语法"></a>3.2.3 Vue特有模板语法</h4><p>Vue模板的特有语法更加易用，解决了上述渲染方式的缺点</p>
<ul>
<li>插值表达式</li>
<li><strong>指令</strong></li>
<li>事件绑定</li>
<li>属性绑定</li>
<li>样式绑定</li>
<li>分支循环结构</li>
</ul>
<br>

<h3 id="3-3-Vue指令"><a href="#3-3-Vue指令" class="headerlink" title="3.3 Vue指令"></a>3.3 Vue指令</h3><ul>
<li>Vue指令本质就是自定义属性</li>
<li>自定义属性：<ul>
<li>H5规定的自定义属性如 <strong>data-</strong></li>
<li>普通的自定义属性如 <strong>abc=’123’</strong></li>
</ul>
</li>
<li>Vue指令<strong>以v-开始</strong> （例如v-cloak）</li>
</ul>
<h4 id="3-3-1-v-cloak指令"><a href="#3-3-1-v-cloak指令" class="headerlink" title="3.3.1 v-cloak指令"></a>3.3.1 v-cloak指令</h4><ul>
<li><p>插值表达式存在<strong>闪动现象</strong></p>
<ul>
<li>闪动：即在<strong>快速刷新浏览器或者浏览器卡顿</strong>时，对于插值表达式<strong>可能会先在浏览器显示<strong>，</strong>再被替换为真正的数据</strong></li>
<li><strong>Vue在渲染数据时</strong>实际是先将放到HTML标签中，然后再迅速替换为真正的数据，所以会出现闪动的情况</li>
</ul>
</li>
<li><p>指令的<strong>本质就是自定义属性</strong></p>
</li>
<li><p>使用<strong>v-cloak指令</strong>可以解决闪动的问题</p>
<ul>
<li>可以先将该插值表达式隐藏，等待在内存中完成替换后一次显示最终结果</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/* v-cloak指令可以解决插值表达式的闪动问题 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-attr">[v-cloak]</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>:none;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在style标签中使用属性选择器设置指令<ul>
<li>[v-cloak]即为css中的属性选择器</li>
</ul>
</li>
<li>在<strong>渲染的标签中</strong>作为<strong>自定义属性</strong>加入该指令</li>
</ul>
<h4 id="3-3-2-数据绑定指令"><a href="#3-3-2-数据绑定指令" class="headerlink" title="3.3.2 数据绑定指令"></a>3.3.2 数据绑定指令</h4><ul>
<li>v-text</li>
<li>v-html</li>
<li>v-pre</li>
</ul>
<ol>
<li><p><strong>v-text</strong></p>
<p>填充纯文本，与直接使用插值表达式效果相同，并且没有闪动问题</p>
<p>相比于插值表达式更加简洁</p>
<p>v-text属性值为data中的数据变量</p>
</li>
<li><p><strong>v-html</strong></p>
<p>填充html代码片段</p>
<p>使用这个指令渲染的数据中的<strong>html标签会被浏览器解析</strong></p>
<p>v-html属性值为data中的数据变量</p>
<p><strong>注意：</strong></p>
<ul>
<li>有安全问题</li>
<li>只有数据来源是本网站时使用，来自<strong>第三方的数据不可用</strong>（容易被xss攻击）</li>
</ul>
</li>
<li><p><strong>v-pre</strong></p>
<p>填充原始信息</p>
<p>将要输出的数据原封不同的显示在页面中，<strong>不经过Vue框架渲染</strong></p>
<p>使用v-pre输出时，页面中会直接显示</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 插值表达式 --&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;!-- 填充纯文本数据 --&gt;</span><br><span class="line">&lt;div v-text=<span class="string">&#x27;msg&#x27;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;!-- 填充HTML片段 --&gt;</span><br><span class="line">&lt;div v-html=<span class="string">&#x27;msg1&#x27;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;!-- 填充原始信息(不通过Vue框架解析) --&gt;</span><br><span class="line">&lt;div v-pre&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data:&#123;</span><br><span class="line">    	msg:<span class="string">&#x27;Hello Vue&#x27;</span>,</span><br><span class="line">        msg1:<span class="string">&#x27;&lt;h1&gt;Hello Vue&lt;/h1&gt;&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/01-Vue/image-20210910190456163-1632056227618.png" alt="三种指令显示结果"></p>
<h4 id="3-3-3-数据响应式"><a href="#3-3-3-数据响应式" class="headerlink" title="3.3.3 数据响应式"></a>3.3.3 数据响应式</h4><ol>
<li><p><strong>何为响应式</strong></p>
<p>html5响应式布局：屏幕尺寸的变化导致样式的变化</p>
<p><strong>数据响应式</strong>：数据的变化导致页面内容的变化（具有响应式功能的数据<strong>在浏览器控制台被修改时</strong>，页面中会同步改变）</p>
</li>
<li><p><strong>数据绑定</strong></p>
<p>将数据填充到html标签的过程</p>
</li>
<li><p><strong>v-once指令</strong></p>
<p>只编译一次</p>
<p>即有这个属性的标签<strong>在数据绑定完成后就不再具有响应式的功能</strong>，在l浏览器控制台修改时，页面不会变化</p>
<ul>
<li>可以让Vue框架不必一直监听该数据，提高性能</li>
</ul>
</li>
</ol>
<h4 id="3-3-4-双向数据绑定"><a href="#3-3-4-双向数据绑定" class="headerlink" title="3.3.4 双向数据绑定"></a>3.3.4 双向数据绑定</h4><p><strong>数据绑定是单向的</strong>：即模板数据-&gt;页面（模板数据发生变化后页面也跟着发生变化）</p>
<p><strong>双向数据绑定</strong>：用户修改数据时，对应的模板数据值也发生变化，这<strong>与数据绑定的单向一起称为双向数据绑定</strong></p>
<ul>
<li><p>双向数据绑定多用于用户交互的场景中，例如文本输入框</p>
</li>
<li><p>实现双向数据绑定<strong>使用指令v-model</strong></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 插值表达式 --&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;!-- 双向数据绑定文本输入框 --&gt;</span><br><span class="line">&lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>文本输入框的v-model属性代表 当前<strong>文本输入框的内容</strong>与<strong>模板数据msg</strong>双向绑定</li>
</ul>
<p><img data-src="/images/01-Vue/image-20210910192914355-1632056227619.png"></p>
<ul>
<li>当用户修改文本框中的内容时，上方渲染的模板数据内容同步变化</li>
<li>当控制台更改模板数据msg时，文本输入框的内容也会跟着变化</li>
</ul>
<h4 id="3-3-5-MVVM思想"><a href="#3-3-5-MVVM思想" class="headerlink" title="3.3.5 MVVM思想"></a>3.3.5 MVVM思想</h4><p><strong>MVVM思想是Vue的核心设计思想</strong></p>
<p>将不同功能代码放在不同的模块（模块化），再通过特定方式在它们之间建立联系</p>
<p>**M(model)**：模型，即数据</p>
<p>**V(view)**：视图，即模板</p>
<p>**VM(view-model)**：联系view和model的控制逻辑</p>
<p><img data-src="/images/01-Vue/image-20210910193805108-1632056227619.png" alt="view-model"></p>
<ul>
<li>view视图模板的变化通过<strong>DOM监听事件</strong>去联系修改model中的数据<ul>
<li>v-model指令底层用到了事件监听</li>
<li><strong>文本框变化影响模板数据值就使用了事件监听</strong></li>
</ul>
</li>
<li>model中的数据通过上面提到过的<strong>数据绑定</strong>影响view的显示</li>
<li>view-model就是完成上述工作的<strong>控制逻辑</strong></li>
</ul>
<br>

<h4 id="3-3-6-事件绑定"><a href="#3-3-6-事件绑定" class="headerlink" title="3.3.6 事件绑定"></a>3.3.6 事件绑定</h4><p>Vue使用<strong>v-on</strong>指令处理事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue使用v-on指令事件绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&#x27;num++&#x27;</span>&gt;</span>num++<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- v-on指令的简化写法 v-on:替换为@ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;num++&#x27;</span>&gt;</span>num++<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>v-on:&#39;标准事件名&#39;=&#39;表达式或函数&#39;</code></p>
<ul>
<li>标准事件名即click,blur等</li>
<li>表达式或函数，即可以直接写代码作为事件处理函数，也可以传递自定义函数作为处理函数</li>
<li>v-on: 可以简化为@</li>
</ul>
<p>在处理函数处直接写代码显然是不合适的，<strong>应该传递自定义函数做为处理函数</strong></p>
<p>Vue实例中的<strong>methods对象</strong>中存储自定义函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> test = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">&#x27;#add&#x27;</span>,</span><br><span class="line">            data:&#123;</span><br><span class="line">                num:<span class="number">0</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                sum:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="comment">//this即为Vue实例test</span></span><br><span class="line">                    <span class="built_in">this</span>.num++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 传递函数作为事件处理函数（仅传递函数名） --&gt;</span><br><span class="line">&lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;sum&#x27;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line">&lt;!-- 传递函数调用 --&gt;</span><br><span class="line">&lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;sum()&#x27;</span>&gt;</span>按钮4<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在Vue实例的methods方法中定义了<strong>sum函数</strong>实现num++的功能</p>
<ul>
<li><strong>this指的即为Vue实例test</strong></li>
</ul>
</li>
<li><p>使用函数作为事件处理函数时，有两种方式</p>
<ul>
<li>只传递函数名</li>
<li>传递函数调用</li>
</ul>
</li>
</ul>
<h4 id="3-3-7-事件参数传递"><a href="#3-3-7-事件参数传递" class="headerlink" title="3.3.7 事件参数传递"></a>3.3.7 事件参数传递</h4><p>3.3.6中提到事件绑定传递函数作为处理函数有两种方式</p>
<ul>
<li>传递函数名</li>
<li>传递函数调用</li>
</ul>
<ol>
<li><p><strong>传递函数名</strong></p>
<p>此时<strong>事件对象event默认作为函数的第一个参数传递</strong>（不需要显式传参），但此时<strong>不能传递其他参数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 传递函数作为事件处理函数（仅传递函数名） --&gt;</span><br><span class="line">        &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;sum1&#x27;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">sum1:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(event.target.innerHTML);</span><br><span class="line">                    <span class="built_in">this</span>.num++</span><br><span class="line">                &#125;,</span><br></pre></td></tr></table></figure></li>
<li><p><strong>传递函数调用</strong></p>
<p>此时<strong>可以传递除事件对象以外的参数</strong>，但是事件对象参数必须作为<strong>最后一个参数</strong>（必须显式传参），并且<strong>名为$event</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 传递函数调用 --&gt;</span><br><span class="line">        &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;sum2(1,$event)&#x27;</span>&gt;</span>按钮4<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line">            </span><br><span class="line">sum2:<span class="function"><span class="keyword">function</span>(<span class="params">p,event</span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(p)</span><br><span class="line">                    <span class="built_in">console</span>.log(event.target.innerHTML);</span><br><span class="line">                    <span class="built_in">this</span>.num++</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img data-src="/images/01-Vue/image-20210910201546753-1632056227619.png" alt="两种方式的事件绑定触发后结果"></p>
<h4 id="3-3-8-事件修饰符"><a href="#3-3-8-事件修饰符" class="headerlink" title="3.3.8 事件修饰符"></a>3.3.8 事件修饰符</h4><p>事件修饰符可以<strong>简化一些事件操作</strong>比如 <strong>阻止默认行为</strong>，<strong>阻止冒泡</strong>等（官网有详解）</p>
<p><code>v-on:click.&#39;时间修饰符&#39;</code></p>
<p>即可完成事件操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 阻止事件冒泡 --&gt;</span><br><span class="line">&lt;div @click=<span class="string">&#x27;sum2&#x27;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">&#x27;sum1&#x27;</span>&gt;</span>按钮4<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line">&lt;!-- 阻止默认行为 --&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;http://www.baidu.com&quot;</span> @click.prevent&gt;百度&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"> methods:&#123;</span><br><span class="line">                sum1:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">                   <span class="comment">//阻止冒泡</span></span><br><span class="line">                    <span class="comment">//event.stopPropagation()</span></span><br><span class="line">                &#125;,</span><br><span class="line">                sum2:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(event.target.innerHTML);</span><br><span class="line">                    <span class="built_in">this</span>.num++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>例如<code>v-on:click.stop</code>可以<strong>阻止事件冒泡</strong></p>
</li>
<li><p>例如<code>v-on:click.prevent</code>可以<strong>阻止事件默认行为</strong></p>
</li>
<li><p>事件修饰符还可以链式调用</p>
</li>
</ul>
<h4 id="3-3-9-按键修饰符"><a href="#3-3-9-按键修饰符" class="headerlink" title="3.3.9 按键修饰符"></a>3.3.9 按键修饰符</h4><p>主要用于<strong>键盘事件</strong>的筛选</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">&#x27;fn&#x27;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码即<strong>当文本输入框按下enter建时触发fn处理函数</strong></p>
<p>若不加enter则按下任意键都会触发fn函数</p>
<p>官方网站有所有按键修饰符的说明</p>
<h4 id="3-3-10-自定义按键修饰符"><a href="#3-3-10-自定义按键修饰符" class="headerlink" title="3.3.10 自定义按键修饰符"></a>3.3.10 自定义按键修饰符</h4><p>Vue官方<strong>提供的按键修饰符是有限的</strong>，当我们希望使用Vue官方没有的定义的按键修饰符时，可以自定义</p>
<ul>
<li>在script标签中使用下面代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给编号为65的按键a自定义一个按键修饰符f1</span></span><br><span class="line">Vue.config.keyCodes.f1 = <span class="number">65</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时按下f1按键修饰符代表的按键a,就会触发fn函数</span></span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-on:keyup.f1=<span class="string">&#x27;fn&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>f1即为<strong>自定义的按键修饰符名</strong></p>
<p>65为<strong>按键a</strong>在keyCode中的编号（每个按键都有一个唯一编号）（其中字母对应的keyCode值为<strong>该大写字母的ASC码值</strong>）</p>
<br>

<h4 id="3-3-11-属性绑定"><a href="#3-3-11-属性绑定" class="headerlink" title="3.3.11 属性绑定"></a>3.3.11 属性绑定</h4><p>Vue可以<strong>动态处理属性值</strong></p>
<p>就像之前学习过的<strong>getAttribute()和setAttribute()</strong></p>
<ul>
<li>使用v-bind指令动态修改属性值</li>
<li>v-bind简写为:</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-bind指令指定属性值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>百度1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- v-bind指令简写为: --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>百度2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 通过点击事件切换a标签跳转地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;handle&#x27;</span>&gt;</span>切换<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line">                handle:function()&#123;</span><br><span class="line">                    this.url=&#x27;http://itcast.cn&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="3-3-11-使用底层代码实现双向数据绑定"><a href="#3-3-11-使用底层代码实现双向数据绑定" class="headerlink" title="3.3.11 使用底层代码实现双向数据绑定"></a>3.3.11 使用底层代码实现双向数据绑定</h4><p>之前双向数据绑定使用了v-model指令</p>
<p>现在使用<strong>属性绑定 和 事件绑定</strong>写底层代码实现v-model指令的功能</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 底层代码实现双向数据绑定 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&#x27;msg&#x27;</span> <span class="attr">v-on:input</span>=<span class="string">&#x27;inputC&#x27;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 底层代码简写 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&#x27;msg&#x27;</span> <span class="attr">v-on:input</span>=<span class="string">&#x27;msg=$event.target.value&#x27;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用v-model指令实现双向数据绑定 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&#x27;msg&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                msg:<span class="string">&#x27;hello&#x27;</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line"><span class="javascript">                inputC:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.msg = event.target.value</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>v-on:input=&#39;inputC&#39;</code>指令可以简写为<code>v-on:input=&#39;msg=$event.target.value&#39;</code><ul>
<li>不使用处理函数而<strong>直接在指令中通过$event获取输入框的值覆盖模板数据</strong></li>
</ul>
</li>
<li>实际上v-model指令就是<strong>调用了v-bind指令进行属性绑定让文本框显示模板数据的值</strong>，并且<strong>在文本框输入时触发事件</strong>，在事件中获取文本框的值并覆盖模板数据</li>
<li>使用底层代码v-bind指令和v-on指令可以实现v-model的功能</li>
</ul>
<br>

<h4 id="3-3-11-样式绑定-class"><a href="#3-3-11-样式绑定-class" class="headerlink" title="3.3.11 样式绑定 class"></a>3.3.11 样式绑定 class</h4><ul>
<li>对象格式的样式绑定</li>
<li>数组格式的对象绑定</li>
</ul>
<ol>
<li><p><strong>对象格式的样式绑定</strong></p>
<p>使用属性绑定的<strong>指令v-bind修改class属性的值</strong>，即修改类名</p>
<p>可以指定该类是否应用在标签上</p>
<ul>
<li>v-bind:class的值为<strong>对象</strong>，对象中存<strong>储键值</strong>对</li>
<li>每个键值对中 <strong>键为类名</strong>，<strong>值为一个模板数据</strong></li>
<li>有<strong>多个样式则键值对用逗号隔开</strong></li>
<li>若<strong>模板数据为true</strong>则该类名所对应的<strong>样式应用</strong>，否则不应用</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        .div1&#123;</span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">1px</span> red solid;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .color&#123;</span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: YELLOW;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&#x27;&#123;div1:isDiv1,color:isColor&#125;&#x27;</span>&gt;</span>样式绑定测试<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&#x27;change&#x27;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                isDiv1:<span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">                isColor:<span class="literal">true</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line"><span class="javascript">                change:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.isDiv1 = !<span class="built_in">this</span>.isDiv1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>isDiv1和isColor两个模板数据默认为true，所以开始两个类名所对应的样式都应用在div上</li>
<li>点击按钮将模板数据取反则两个样式都不应用</li>
</ul>
<ol start="2">
<li><strong>数组格式的样式绑定</strong></li>
</ol>
<ul>
<li>v-bind:class的值为<strong>数组</strong>，数组中的<strong>元素为模板数据变量</strong></li>
<li><strong>模板数据变量的值为类名</strong></li>
<li>Vue框架从模板数据中获得类名后渲染在标签的class属性中</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数组格式对象绑定 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&#x27;[div1Class,colorClass]&#x27;</span>&gt;</span>数组样式绑定测试<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;change1&#x27;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	data:&#123;</span><br><span class="line">                isDiv1:true,</span><br><span class="line">                isColor:true,</span><br><span class="line">                div1Class:&#x27;div1&#x27;,</span><br><span class="line">                colorClass:&#x27;color&#x27;</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                change:function()&#123;</span><br><span class="line">                    this.isDiv1 = !this.isDiv1</span><br><span class="line">                &#125;,</span><br><span class="line">                change1:function()&#123;</span><br><span class="line">                    this.div1Class=&#x27;&#x27;,</span><br><span class="line">                    this.colorClass=&#x27;&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>点击按钮后将模板数据置空字符串，div样式消失</li>
</ul>
<h4 id="3-3-12-样式绑定class的细节"><a href="#3-3-12-样式绑定class的细节" class="headerlink" title="3.3.12 样式绑定class的细节"></a>3.3.12 样式绑定class的细节</h4><ul>
<li>对象格式和数组格式可以<strong>结合使用</strong></li>
<li><code>v-bind:class</code>中class的值可以<strong>简化操作</strong></li>
<li>默认的class样式 会与样式绑定的样式<strong>一起生效</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 两种格式结合使用 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&#x27;[div1Class,&#123;color:isColor&#125;]&#x27;</span>&gt;</span>结合使用<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 简化class值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&#x27;objClass&#x27;</span>&gt;</span>对象格式简化<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&#x27;arrayClass&#x27;</span>&gt;</span>数组格式简化<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 原有的class与样式绑定共存 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fsize&quot;</span> <span class="attr">v-bind:class</span>=<span class="string">&#x27;arrayClass&#x27;</span>&gt;</span>样式共存<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>数组格式的样式绑定<strong>中的元素</strong>可以使用对象格式的样式绑定</li>
<li>直接将样式绑定写在标签内明显<strong>不易维护</strong>，将其<strong>作为模板数据</strong>，通过在标签中<strong>样式绑定模板数据变量来实现样式</strong><ul>
<li>数组格式和对象格式都可以简化</li>
</ul>
</li>
<li>标签原有的class属性与样式绑定的属性<strong>同时存在时</strong>，<strong>标签会结合两种样式</strong></li>
</ul>
<h4 id="3-3-13-样式绑定-style"><a href="#3-3-13-样式绑定-style" class="headerlink" title="3.3.13 样式绑定 style"></a>3.3.13 样式绑定 style</h4><p>样式绑定可以绑定标签内联属性style</p>
<p>同样也分为<strong>对象格式</strong>与<strong>数组格式</strong>，数组格式中，后面元素的样式会<strong>覆盖前面元素存在的样式</strong>，<strong>新增的样式保留</strong></p>
<ul>
<li><code>v-bind:style=&#39;&#123;&#125;&#39;</code>    值为对象，对象中属性为<strong>标准样式名</strong>（width等），属性值即为具体的样式设置（可以通过模板数据传递）</li>
<li><code>v-bind:style=&#39;objStyle&#39;</code>  为了简化，可以传入<strong>模板数据objStyle</strong>作为style值<ul>
<li>objStyle对象中设置样式属性</li>
</ul>
</li>
<li><code>v-bind:style=&#39;[objStyle,nextStyle]&#39;</code>数组中传入<strong>多个样式对象</strong>，<strong>后面的样式会覆盖前面的重复样式</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 对象格式style样式绑定，对象的属性为标准样式名，属性值即为设置的具体样式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&#x27;&#123;width:widthStyle,height:heightStyle,border:borderStyle&#125;&#x27;</span>&gt;</span>style样式绑定<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 简化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&#x27;objStyle&#x27;</span>&gt;</span>style值传入模板数据对象<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数组格式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&#x27;[objStyle,nextStyle]&#x27;</span>&gt;</span>数组格式<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data:&#123;</span><br><span class="line">                widthStyle:&#x27;100px&#x27;,</span><br><span class="line">                heightStyle:&#x27;100px&#x27;,</span><br><span class="line">                borderStyle:&#x27;solid 1px red&#x27;,</span><br><span class="line">				//样式对象</span><br><span class="line">                objStyle:&#123;</span><br><span class="line">                    width:&#x27;100px&#x27;,</span><br><span class="line">                    height:&#x27;100px&#x27;,</span><br><span class="line">                    border:&#x27;solid 1px red&#x27;</span><br><span class="line">                &#125;,</span><br><span class="line"></span><br><span class="line">                nextStyle:&#123;</span><br><span class="line">                    width:&#x27;200px&#x27;,</span><br><span class="line">                    backgroundColor:&#x27;yellow&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>nextStyle对象中的<strong>width:200px会覆盖objStyle中的width:100px</strong></li>
<li>nextStyle对象中的backgroundColor<strong>作为objStyle中没有的样式会保留</strong></li>
</ul>
<h3 id="3-4-分支结构-v-if"><a href="#3-4-分支结构-v-if" class="headerlink" title="3.4 分支结构 v-if"></a>3.4 分支结构 v-if</h3><p>Vue模板语法有自己的分支结构语法，就像art-template使用<code>&#123;&#123;if&#125;&#125;&#123;&#123;else&#125;&#125;&#123;&#123;/if&#125;&#125;</code>实现分支一样</p>
<p><strong>Vue分支指令</strong></p>
<ul>
<li>v-if</li>
<li>v-else-if</li>
<li>v-else</li>
</ul>
<p><strong>Vue中显示隐藏指令</strong></p>
<ul>
<li>v-show</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&#x27;score==100&#x27;</span>&gt;</span>满分<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&#x27;score&gt;80&#x27;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>优秀以下<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&#x27;flag&#x27;</span>&gt;</span>显示<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">         <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line">                score:69,</span><br><span class="line"><span class="javascript">                flag:<span class="literal">true</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>v-if v-else-if v-else</code>：实现if，else if 和else的作用<ul>
<li>指令的<strong>值为判断条件</strong></li>
</ul>
</li>
<li><code>v-show</code> 指令的值为<strong>true或false</strong>代表该标签是否隐藏（样式是否加上<strong>display:none</strong>属性）</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><p>分支指令<code>v-if</code>等，一个分支结构中只有<strong>满足条件的标签才被渲染</strong></p>
</li>
<li><p><code>v-show</code>显示隐藏指令中，无论指令值为true或false，<strong>标签都会被渲染</strong>，指令值只决定<strong>该渲染好的标签是否显示</strong></p>
</li>
<li><p>如果一个标签<strong>经常要显示或者隐藏</strong>，使用v-show，<strong>对样式的修改开销要比重新渲染标签小</strong></p>
</li>
</ul>
<br>

<h3 id="3-5-循环结构-v-for"><a href="#3-5-循环结构-v-for" class="headerlink" title="3.5 循环结构 v-for"></a>3.5 循环结构 v-for</h3><p>指令<code>v-for</code></p>
<p>要循环生成哪个标签，v-for指令就在哪个标签上</p>
<p>可以循环<strong>数组</strong>和<strong>对象</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 循环数组fruits生成3个li标签 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&#x27;(item,index) in fruits&#x27;</span>&gt;</span>&#123;&#123;index+&#x27;---&#x27;+item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 使用key属性指定唯一标识提高Vue性能 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">:key</span>=<span class="string">&#x27;index&#x27;</span> <span class="attr">v-for</span>=<span class="string">&#x27;(item,index) in myFruits&#x27;</span>&gt;</span>&#123;&#123;index+&#x27;---&#x27;+item.ename+&#x27;---&#x27;+item.cname&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="javascript">                fruits:[<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;pear&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>],</span></span><br><span class="line">                myFruits:[</span><br><span class="line">                    &#123;</span><br><span class="line"><span class="javascript">                        ename:<span class="string">&#x27;apple&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        cname:<span class="string">&#x27;苹果&#x27;</span></span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line"><span class="javascript">                        ename:<span class="string">&#x27;pear&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                        cname:<span class="string">&#x27;梨子&#x27;</span></span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当v-for指令的值为<code>(item,index) in fruits</code>时 <strong>循环数组</strong><ul>
<li>会循环fruits数组，<strong>循环索引</strong>为第二个参数index，<strong>循环值</strong>为第一个参数item（第二个参数固定为循环索引）</li>
<li>上述代码即循环渲染三个li标签，依次填入apple,pear,orange</li>
</ul>
</li>
</ul>
<br>

<ul>
<li>当v-for指令的值为<code>(value,key,index) in object</code> 时<strong>循环对象</strong><ul>
<li>第一个参数为<strong>值</strong>，第二个参数为<strong>建</strong>，第三个参数为<strong>循环索引</strong>（三个参数顺序固定）</li>
<li>对象中数据以<strong>键值对</strong>存储<strong>（键:值）</strong></li>
</ul>
</li>
</ul>
<br>

<ul>
<li>使用 <code>:key=&#39;index&#39;</code>属性绑定一个key自定义属性(<strong>v-bind简写为:</strong>)，值为每个li标签唯一的循环索引index<ul>
<li>使用key属性，设置<strong>其值为一系列兄弟标签中唯一的值</strong>，可以帮助Vue区分不同元素，<strong>提高性能</strong></li>
<li>但是在展示效果上有无key属性没有区别</li>
<li><strong>key值的选择遵循以下规则</strong><ul>
<li>一般选择每项数据的id值</li>
<li>若没有id则选择循环索引</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>

<h3 id="3-6-分支和循环结合使用"><a href="#3-6-分支和循环结合使用" class="headerlink" title="3.6 分支和循环结合使用"></a>3.6 分支和循环结合使用</h3><p>v-if指令和v-for指令结合使用</p>
<ul>
<li>即使用v-if指令判断v-for循环的<strong>标签是否渲染</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">           &lt;ul&gt;</span><br><span class="line">               &lt;!-- 分支循环结合 只渲染循环索引为<span class="number">1</span>的标签 --&gt;</span><br><span class="line">               &lt;li v-<span class="keyword">if</span>=<span class="string">&#x27;index==1&#x27;</span> v-<span class="keyword">for</span>=<span class="string">&#x27;(item,index) in fruits&#x27;</span>&gt;&#123;&#123;index+<span class="string">&#x27;---&#x27;</span>+item&#125;&#125;&lt;/li&gt;</span><br><span class="line">           &lt;/ul&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">   &lt;script&gt;</span><br><span class="line">       <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">           el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">           data:&#123;</span><br><span class="line">               fruits:[<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;pear&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>],</span><br><span class="line">           &#125;,</span><br><span class="line">           methods:&#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">   &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述代码循环fruits数组时，只有<strong>当循环索引为1时</strong>，该次循环的标签才会被渲染</li>
<li>最后结果只有数组第二项pear的li标签被渲染（索引为1）</li>
</ul>
<br>

<h3 id="3-7-tab选项卡简单案例"><a href="#3-7-tab选项卡简单案例" class="headerlink" title="3.7 tab选项卡简单案例"></a>3.7 tab选项卡简单案例</h3><ul>
<li>运用Vue框架实现一个选项卡切换案例<ul>
<li>当点击选项时，该选项<strong>背景色变成orange色</strong>，并且<strong>显示该项对应的图片</strong></li>
</ul>
</li>
</ul>
<p><img data-src="/images/01-Vue/image-20210911220749418-1632056227619.png" alt="案例效果"></p>
<p><strong>实现步骤</strong></p>
<ul>
<li>实现传统静态UI效果（不做解释）</li>
<li><strong>基于数据重构UI效果</strong><ul>
<li>结构样式<strong>重构为Vue模板语法形式</strong></li>
<li><strong>处理事件绑定和js逻辑</strong></li>
</ul>
</li>
</ul>
<h4 id="3-7-1-结构样式重构为Vue模板语法模式"><a href="#3-7-1-结构样式重构为Vue模板语法模式" class="headerlink" title="3.7.1 结构样式重构为Vue模板语法模式"></a>3.7.1 结构样式重构为Vue模板语法模式</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tab&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 循环生成li标签 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span> <span class="attr">:class</span>=<span class="string">&quot;liClass(index)&quot;</span> <span class="attr">:key</span>=<span class="string">&#x27;item.id&#x27;</span> <span class="attr">v-for</span>=<span class="string">&#x27;(item,index) in list&#x27;</span> @<span class="attr">click</span>=<span class="string">&#x27;handle(index)&#x27;</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 循环生成显示图片的div --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[divClass(index),&#x27;images&#x27;]&quot;</span> <span class="attr">:key</span>=<span class="string">&#x27;item.id&#x27;</span> <span class="attr">v-for</span>=<span class="string">&#x27;(item,index) in list&#x27;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&#x27;item.path&#x27;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用Vue模板语法<strong>循环生成li标签</strong><ul>
<li>v-for循环 模板数据list数组</li>
<li>:key属性绑定</li>
<li>:class样式绑定（为js逻辑显示或隐藏标签准备）</li>
<li>显示图片div标签同理</li>
</ul>
</li>
<li>使用Vue模板语法<strong>循环生成显示图片的div</strong></li>
</ul>
<h4 id="3-7-2-处理事件绑定和js逻辑"><a href="#3-7-2-处理事件绑定和js逻辑" class="headerlink" title="3.7.2 处理事件绑定和js逻辑"></a>3.7.2 处理事件绑定和js逻辑</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">            data:&#123;</span><br><span class="line">                <span class="comment">//当前选中项索引 判断选中项并修改其样式</span></span><br><span class="line">                currentIndex:<span class="number">0</span>,</span><br><span class="line">                <span class="comment">//选项数组</span></span><br><span class="line">                list:[&#123;</span><br><span class="line">                    id:<span class="number">1</span>,</span><br><span class="line">                    name:<span class="string">&#x27;img1&#x27;</span>,</span><br><span class="line">                    path:<span class="string">&#x27;./img/01.jpg&#x27;</span></span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    id:<span class="number">2</span>,</span><br><span class="line">                    name:<span class="string">&#x27;img2&#x27;</span>,</span><br><span class="line">                    path:<span class="string">&#x27;./img/02.jpg&#x27;</span></span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    id:<span class="number">3</span>,</span><br><span class="line">                    name:<span class="string">&#x27;img3&#x27;</span>,</span><br><span class="line">                    path:<span class="string">&#x27;./img/03.jpg&#x27;</span></span><br><span class="line">                &#125;],</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                handle:<span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.currentIndex = index</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">//判断li是否显示</span></span><br><span class="line">                liClass:<span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">                    <span class="comment">//当前项就是被选中项</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">this</span>.currentIndex == index)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&#x27;active&#x27;</span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">//判断存放图像div是否显示</span></span><br><span class="line">                divClass:<span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">this</span>.currentIndex == index)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&#x27;show&#x27;</span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>currentIndex模板数据默认为0，即<strong>默认选中第一项</strong></p>
<ul>
<li>选项卡点击事件处理函数<strong>handle</strong><ul>
<li>点击时<strong>将被点击标签的索引index覆盖currentIndex</strong>（currentIndex为当前被点击项的索引）</li>
</ul>
</li>
</ul>
</li>
<li><p>标签的class属性 调用<strong>liClass</strong>和<strong>divClass</strong>函数</p>
<ul>
<li>使用<strong>currentIndex模板数据</strong>和<strong>当前标签循环索引index</strong>比较，若相同则<strong>当前项被选中</strong><ul>
<li>函数返回修改选项卡背景颜色的<strong>类名active</strong>或显示图片div的<strong>类名show</strong></li>
<li>若没有选中则返回<strong>空字符串</strong>（即不添加类名）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>本案例所写的模板的结构即为<strong>声明式编程</strong></li>
<li><strong>声明式编程：</strong>即<strong>模板的结构</strong>和<strong>最终显示的结果</strong>基本相同</li>
</ul>
<br>

<h4 id="3-7-3-Vue模板语法与原生js编写此案例的区别"><a href="#3-7-3-Vue模板语法与原生js编写此案例的区别" class="headerlink" title="3.7.3 Vue模板语法与原生js编写此案例的区别"></a>3.7.3 Vue模板语法与原生js编写此案例的区别</h4><ul>
<li>在使用Vue模板语法重构页面时：<strong>从模板中即能看见循环生成选项卡和图片div</strong></li>
<li>而使用原生js时：通常<strong>在js逻辑中循环创造DOM元素</strong>并<strong>直接通过API添加到页面中其他DOM元素下</strong>，模板中不能反应出选项卡和图片div的循环生成</li>
</ul>
<h4 id="3-7-4-遇见的问题"><a href="#3-7-4-遇见的问题" class="headerlink" title="3.7.4 遇见的问题"></a>3.7.4 遇见的问题</h4><ol>
<li><p><strong>属性绑定时的值书写格式</strong></p>
<ul>
<li>值为<strong>模板数据</strong>时，<strong>不需要加引号</strong>，直接书写</li>
<li>值<strong>不是模板数据</strong>时，<strong>需要加引号</strong>，否则Vue模板会在模板数据中查找此变量</li>
<li>例如属性绑定class，<strong>class的值使用style标签中定义的类名时需要加引号</strong></li>
</ul>
</li>
<li><p><strong>css样式中li .active 和 li.active的区别</strong></p>
</li>
</ol>
<ul>
<li><code>li .active</code>：中间有空格，li标签的<strong>后代中</strong>类名为active的标签应用此样式</li>
<li><code>li.active</code>：中间无空格，类名为active的<strong>li标签</strong>应用此样式</li>
</ul>
<br>

<h2 id="4-Vue常用特性"><a href="#4-Vue常用特性" class="headerlink" title="4. Vue常用特性"></a>4. Vue常用特性</h2><ul>
<li>表单操作</li>
<li>自定义指令</li>
<li>计算属性</li>
<li>过滤器</li>
<li>侦听器</li>
<li>生命周期</li>
</ul>
<h3 id="4-1-表单操作"><a href="#4-1-表单操作" class="headerlink" title="4.1 表单操作"></a>4.1 表单操作</h3><ul>
<li>单行文本框 text</li>
<li>单选框 radio</li>
<li>复选框 checkbox</li>
<li>多行文本框 textarea</li>
<li>多选下拉列表 select</li>
</ul>
<p><strong>表单操作中的提交不通过表单默认事件，通常由js手动控制</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单选框双向数据绑定 --&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 当v-model指令的值等于value值时，该单选框被选中 操控gender的值即可变更单选框状态--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">v-model</span>=<span class="string">&#x27;gender&#x27;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> <span class="attr">v-model</span>=<span class="string">&#x27;gender&#x27;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 多选框双向数据绑定时模板数据使用数组hobby 数组中元素对应value时，该复选框被选中 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;ball&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">v-model</span>=<span class="string">&#x27;hobby&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;ball&quot;</span>&gt;</span>篮球<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sing&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> <span class="attr">v-model</span>=<span class="string">&#x27;hobby&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;sing&quot;</span>&gt;</span>唱歌<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;code&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> <span class="attr">v-model</span>=<span class="string">&#x27;hobby&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;code&quot;</span>&gt;</span>写代码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<center>单选和复选框表单域</center>

<ul>
<li><p>注意：</p>
<ul>
<li><p>模板数据gender值为<strong>Number类型的数字1</strong>或<strong>字符串“1”</strong>时，“男”单选框<strong>均会被选中</strong></p>
</li>
<li><p>但在页面中的<strong>单选表单域</strong>修改选中项时，模板数据会被<strong>绑定为字符串的”1”或者”2”</strong></p>
</li>
<li><p>复选框表单域被修改时同理，数组中的元素被绑定为<strong>字符串</strong></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>职业：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&#x27;occupation&#x27;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span>请选择职业...<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>教师<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>软件工程师<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>律师<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">&#x27;desc&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<center>单/多选下拉框和多行文本框表单域</center>

<ul>
<li>下拉框在select中进行双向数据绑定，同样与value比较</li>
<li>select中<strong>加上multiple即变为多选下拉框</strong>（浏览器中按住shift完成多选）</li>
<li>单选下拉框 ：绑定的数据可以是<strong>Number类型</strong>（修改单选下拉框时，模板数据绑定为<strong>Number</strong>）</li>
<li>多选下拉框 ：绑定的数据是<strong>数组</strong>（不是数组时浏览器控制台报错）（修改多选下拉框时，模板数据数组中元素<strong>绑定为字符串</strong>）</li>
<li>多行文本框表单域双向数据绑定<strong>与单行文本框相同</strong>（不需要与value比较）</li>
</ul>
<h3 id="4-1-表单修饰符"><a href="#4-1-表单修饰符" class="headerlink" title="4.1 表单修饰符"></a>4.1 表单修饰符</h3><p>与按键修饰符与时间i叙事符类似，表单也有表单修饰符</p>
<ul>
<li><strong>number</strong>：将<strong>输入域值绑定为数值</strong>（默认为字符串）</li>
<li><strong>trim</strong>：输入域值绑定到模板数据时<strong>去除前后空格</strong></li>
<li><strong>lazy</strong>：将v-model双向数据绑定的触发事件由<strong>input改为change</strong><ul>
<li>对于单行文本框来说：默认<strong>输入时进行双向数据绑定</strong>，现在改为<strong>文本框失去焦点时绑定</strong></li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.number</span>=<span class="string">&#x27;msg&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.trim</span>=<span class="string">&#x27;msg&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.lazy</span>=<span class="string">&#x27;msg&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-自定义指令"><a href="#4-2-自定义指令" class="headerlink" title="4.2 自定义指令"></a>4.2 自定义指令</h3><p>Vue内置指令数量有限，当内置指令不能满足需求是，可以自定义</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-focus</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Vue.directive(&#x27;focus&#x27;,&#123;</span><br><span class="line">            inserted:function(el)&#123;</span><br><span class="line">                //el即为指令绑定的元素</span><br><span class="line">                //el.focus()即聚焦该元素</span><br><span class="line">                el.focus()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<center>自定义指令在页面刷新时聚焦文本框</center>

<ul>
<li>自定义指令使用<code>Vue.directive</code>方法</li>
<li>第一个参数为<strong>自定义指令名</strong></li>
<li>第二个参数为一个对象，对象中使用<strong>钩子函数</strong><ul>
<li><strong>钩子函数名</strong>在Vue官方文档中定义，代表了不同调用时间</li>
<li>钩子函数传递<strong>el</strong>作为参数</li>
<li>el即为<strong>自定义指令绑定的元素</strong></li>
</ul>
</li>
</ul>
<p><img data-src="/images/01-Vue/image-20210912202743773-1632056227619.png" alt="可选的钩子函数"></p>
<h4 id="4-2-1-自定义指令的钩子函数参数"><a href="#4-2-1-自定义指令的钩子函数参数" class="headerlink" title="4.2.1 自定义指令的钩子函数参数"></a>4.2.1 自定义指令的钩子函数参数</h4><p>钩子函数参数在官方文档中有定义</p>
<p><img data-src="/images/01-Vue/image-20210912202416182-1632056227619.png" alt="钩子函数参数"></p>
<p><strong>使用钩子函数参数实现改变文本框背景颜色</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-bcolor=<span class="string">&#x27;&quot;orange&quot;&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line">Vue.directive(<span class="string">&#x27;bcolor&#x27;</span>,&#123;</span><br><span class="line">            bind:<span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">                <span class="comment">//el即为指令绑定的元素 可以直接操作DOM</span></span><br><span class="line">                <span class="comment">//binding对象参数</span></span><br><span class="line">                el.style.backgroundColor = binding.value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>自定义指令的<strong>绑定值orange</strong>可以通过<code>binding.value</code>获取</p>
</li>
<li><p>通过<strong>el</strong>可以修改DOM元素的属性</p>
</li>
</ul>
<p><img data-src="/images/01-Vue/image-20210912203243372-1632056227619.png" alt="修改背景色为orange色"></p>
<br>

<h4 id="4-2-2-局部指令"><a href="#4-2-2-局部指令" class="headerlink" title="4.2.2 局部指令"></a>4.2.2 局部指令</h4><p>自定义指令还可通过<strong>局部指令</strong>的方式来定义</p>
<ul>
<li>局部指令：只能在<strong>本组件(Vue实例)范围中使用</strong></li>
<li><strong>Vue实例是一种组件</strong></li>
</ul>
<p>上面第一种自定义指令的方式使用<code>Vue.directive</code>方法，称为<strong>全局指令</strong></p>
<ul>
<li>全局指令<strong>没有范围限制</strong></li>
</ul>
<p><strong>局部指令定义</strong>：在组件（Vue实例）中使用<code>directives</code>选项</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">            data:&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//使用directives选项</span></span><br><span class="line">            directives:&#123;</span><br><span class="line">                <span class="comment">//自定义focus指令</span></span><br><span class="line">                focus:&#123;</span><br><span class="line">                    bind:<span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">                    el.style.backgroundColor = binding.value</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="4-3-计算属性"><a href="#4-3-计算属性" class="headerlink" title="4.3 计算属性"></a>4.3 计算属性</h3><p>在<strong>插值表达式中对模板数据进行计算处理</strong>时，会导致模板看起来很复杂</p>
<p>使用计算属性可以让模板看起来更简洁</p>
<p><strong>计算属性</strong>：Vue实例中的computed属性，可以将复杂的计算表达式<strong>提取为计算属性中的方法</strong>，使用时<strong>直接在插值表达式中调用方法即可</strong></p>
<ul>
<li>计算属性中的函数结构需要<strong>使用return返回</strong></li>
<li>计算属性中的函数<strong>只能处理模板数据</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;!-- 直接书写表达式 --&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;msg.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;!-- 使用计算属性 --&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;reverseString&#125;&#125;&lt;/div&gt;</span><br><span class="line">            </span><br><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">            data:&#123;</span><br><span class="line">                msg:<span class="string">&#x27;nihao&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//计算属性</span></span><br><span class="line">            computed:&#123;</span><br><span class="line">                reverseString:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.msg.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<center>使用计算属性简化字符串反转的表达式</center>

<p><code>&#123;&#123;reverseString&#125;&#125;</code>显然比<code>&#123;&#123;msg.split('').reverse().join('')&#125;&#125;</code><strong>更加简洁</strong></p>
<p><img data-src="/images/01-Vue/image-20210912205802547-1632056227619.png" alt="计算结果"></p>
<h3 id="4-4-计算属性和方法的区别"><a href="#4-4-计算属性和方法的区别" class="headerlink" title="4.4 计算属性和方法的区别"></a>4.4 计算属性和方法的区别</h3><p>计算属性（conputed）和 方法（methods）都是Vue实例中的属性，区别在于<strong>是否缓存</strong></p>
<p><strong>计算属性</strong>：基于<strong>它的依赖</strong>（进行计算的模板数据）进行<strong>缓存</strong>，调用时只需写名字</p>
<p><strong>方法</strong>：没有缓存，调用时遵循函数调用使用()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">		&lt;!-- 计算属性 --&gt;</span><br><span class="line">           &lt;div&gt;&#123;&#123;reverseString&#125;&#125;&lt;/div&gt;</span><br><span class="line">           &lt;div&gt;&#123;&#123;reverseString&#125;&#125;&lt;/div&gt;</span><br><span class="line">           &lt;!-- 方法 --&gt;</span><br><span class="line">           &lt;div&gt;&#123;&#123;reverseMessage()&#125;&#125;&lt;/div&gt;</span><br><span class="line">           &lt;div&gt;&#123;&#123;reverseMessage()&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line">               reverseMessage:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                   <span class="built_in">console</span>.log(<span class="string">&#x27;Message&#x27;</span>);</span><br><span class="line">                   <span class="keyword">return</span> <span class="built_in">this</span>.msg.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="comment">//计算属性</span></span><br><span class="line">           computed:&#123;</span><br><span class="line">               reverseString:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                   <span class="built_in">console</span>.log(<span class="string">&#x27;String&#x27;</span>);</span><br><span class="line">                   <span class="keyword">return</span> <span class="built_in">this</span>.msg.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法reverseMessage</strong>和<strong>计算属性reverseString</strong>均执行两次</p>
<p><img data-src="/images/01-Vue/image-20210912211135678-1632056227619.png" alt="执行结果"></p>
<p>但是结果中方法的Message<strong>输出了两次</strong>，但是计算属性的String<strong>只输出了一次</strong></p>
<ul>
<li>这就是<strong>有无缓存的区别</strong></li>
<li>计算属性<code>reverseString</code>依赖的模板数据msg在两次执行期间<strong>没有改变</strong>，当第二次执行时会<strong>直接获取第一次缓存的结果进行返回</strong>，不再进行计算，所以第二次的输出语句被略过了</li>
<li>方法<code>reverseMessage</code>每次调用都会执行一次函数，所以输出两次</li>
<li>当计算表达式<strong>计算量巨大但依赖数据不变且进行多次调用</strong>时，使用计算属性可以利用缓存的特性<strong>提高性能</strong></li>
</ul>
<br>

<h3 id="4-5-侦听器"><a href="#4-5-侦听器" class="headerlink" title="4.5 侦听器"></a>4.5 侦听器</h3><p>侦听器：监听数据（Vue实例data属性中的数据）的变化，当数据变化时会触发监听器所绑定的方法</p>
<p>监听器应用场景：<strong>数据变化时执行异步或开销较大的操作</strong></p>
<ul>
<li>侦听器为<strong>Vue实例中的属性watch</strong>，侦听器绑定方法写在watch属性中，<strong>方法名即为监听的数据名</strong>，变化时会自动调用</li>
<li>监听数据的最新值通过<strong>绑定方法的参数</strong>获取</li>
</ul>
<h4 id="4-5-1侦听器基本用法"><a href="#4-5-1侦听器基本用法" class="headerlink" title="4.5.1侦听器基本用法"></a>4.5.1侦听器基本用法</h4><p>使用侦听器侦听<strong>firstName和lastName两个模板数据</strong>，当其中一个变化时，使用新值组合成fullName</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&#x27;firstName&#x27;</span>&gt;</span><br><span class="line">           &lt;br&gt;</span><br><span class="line">           &lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&#x27;lastName&#x27;</span>&gt;</span><br><span class="line">           &lt;div&gt;&#123;&#123;fullName&#125;&#125;&lt;/div&gt;</span><br><span class="line">           &lt;!-- <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> --&gt;</span><br><span class="line">		<span class="comment">//计算属性 完成拼接</span></span><br><span class="line">           <span class="comment">// computed:&#123;</span></span><br><span class="line">           <span class="comment">//     fullName:function()&#123;</span></span><br><span class="line">           <span class="comment">//         return this.firstName + &#x27;  &#x27; + this.lastName</span></span><br><span class="line">           <span class="comment">//     &#125;</span></span><br><span class="line">           <span class="comment">// &#125;,</span></span><br><span class="line">		<span class="comment">//侦听器完成</span></span><br><span class="line">           watch:&#123;</span><br><span class="line">               firstName:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                   <span class="built_in">this</span>.fullName = val + <span class="string">&#x27; &#x27;</span>+ <span class="built_in">this</span>.lastName</span><br><span class="line">               &#125;,</span><br><span class="line">               lastName:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                   <span class="built_in">this</span>.fullName = <span class="built_in">this</span>.firstName + <span class="string">&#x27;  &#x27;</span> + val</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现的效果为 两个文本框中任何一个改变 下方的div都会展现改变后的fullName</li>
<li>本例中实际上使用侦听器和计算属性可以达到同样的效果，本例只是为了演示侦听器的基本用法</li>
</ul>
<br>

<h4 id="4-5-2-侦听器应用场景简单案例-用户名验证"><a href="#4-5-2-侦听器应用场景简单案例-用户名验证" class="headerlink" title="4.5.2 侦听器应用场景简单案例-用户名验证"></a>4.5.2 侦听器应用场景简单案例-用户名验证</h4><p>用户在文本框中输入用户名，在文本框失去焦点时，判断用户名是否存在并显示不同的提示信息</p>
<p>实现步骤：</p>
<ul>
<li>通过v-model实现文本框数据绑定</li>
<li>提示信息存储在模板数据中</li>
<li><strong>监听器监听输出信息变化</strong></li>
<li>修改触发事件（失去焦点时）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;label <span class="keyword">for</span>=<span class="string">&quot;&quot;</span>&gt;请输入用户名:&lt;/label&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.lazy=<span class="string">&#x27;uname&#x27;</span>&gt;</span><br><span class="line">&lt;span&gt;&#123;&#123;tip&#125;&#125;&lt;/span&gt;	</span><br><span class="line"></span><br><span class="line">	methods:&#123;</span><br><span class="line">                checkName:<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> that = <span class="built_in">this</span></span><br><span class="line">                    <span class="comment">//使用定时器模拟异步API</span></span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(name == <span class="string">&#x27;admin&#x27;</span>)&#123;</span><br><span class="line">                            that.tip = <span class="string">&#x27;用户名存在请重新输入&#x27;</span></span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            that.tip = <span class="string">&#x27;可以使用&#x27;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,<span class="number">2000</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            watch:&#123;</span><br><span class="line">                uname:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.checkName(val)</span><br><span class="line">                    <span class="built_in">this</span>.tip = <span class="string">&#x27;请稍候&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用表单修饰符lazy改变触发为失去焦点后进行数据绑定</li>
<li><strong>使用定时器模拟异步代码执行</strong></li>
<li>此时<code>this.tip=&#39;请稍后&#39;</code>代码位于方法checkName后<ul>
<li>但是方法checkName执行到定时器时<strong>将异步代码挂起</strong></li>
<li><strong>先显示请稍后</strong>，两秒后再显示判断结果</li>
</ul>
</li>
<li>注意：<ul>
<li>setTimeout定时器中调用Vue实例data属性中的tip数据时，<strong>使用that改变this指向</strong></li>
<li>setTimeout定时器this指向<strong>默认为window</strong></li>
</ul>
</li>
</ul>
<h3 id="4-6-过滤器"><a href="#4-6-过滤器" class="headerlink" title="4.6 过滤器"></a>4.6 过滤器</h3><p>过滤器可以进行数据的格式化处理，比如将字符串格式化为首字母大写，日期格式化为指定格式等</p>
<ul>
<li>过滤器像自定义指令一样分为<strong>全局过滤器和局部过滤器</strong></li>
</ul>
<p><strong>全局过滤器</strong></p>
<ul>
<li>使用Vue框架的<code>filter</code>方法<ul>
<li>第一个参数为<strong>过滤器名称</strong>，第二个参数为<strong>过滤处理函数</strong>（函数接受一个参数即<strong>要过滤的数据</strong>）</li>
</ul>
</li>
</ul>
<p><strong>局部过滤器</strong></p>
<ul>
<li>在Vue实例中的<code>filters</code>属性中定义局部过滤器 函数名为过滤器名称 仅能在当前Vue实例中使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&#x27;msg&#x27;</span>&gt;</span><br><span class="line">            &lt;!-- 插值表达式使用过滤器 --&gt;</span><br><span class="line">            &lt;div&gt;&#123;&#123;msg | upper&#125;&#125;&lt;/div&gt;</span><br><span class="line">            &lt;!-- 级联使用 --&gt;</span><br><span class="line">            &lt;div&gt;&#123;&#123;msg | upper | lower&#125;&#125;&lt;/div&gt;</span><br><span class="line">            &lt;!-- 属性绑定时使用过滤器 --&gt;</span><br><span class="line">            &lt;div :msg=<span class="string">&#x27;msg | upper&#x27;</span>&gt;测试属性绑定过滤&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//全局过滤器</span></span><br><span class="line">        <span class="comment">// Vue.filter(&#x27;upper&#x27;,function(val)&#123;</span></span><br><span class="line">        <span class="comment">//     return val.charAt(0).toUpperCase() + val.slice(1)</span></span><br><span class="line">        <span class="comment">// &#125;)</span></span><br><span class="line">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">            el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">            data:&#123;</span><br><span class="line">                msg:<span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//局部过滤器</span></span><br><span class="line">            filters:&#123;</span><br><span class="line">                <span class="comment">//数据首字母大写</span></span><br><span class="line">                upper:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> val.charAt(<span class="number">0</span>).toUpperCase() + val.slice(<span class="number">1</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">//数据首字母小写</span></span><br><span class="line">                lower:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> val.charAt(<span class="number">0</span>).toLowerCase() + val.slice(<span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<center>使用过滤器将数据格式化为首字母大写或者小写的数据</center>

<ul>
<li>过滤器使用方法：<ul>
<li><strong>插值表达式</strong>中使用：**”|”**前是要过滤的数据，后面是过滤器名</li>
<li>标签<strong>属性绑定</strong>时v-bind指令的绑定值过滤</li>
<li>可以级联过滤，即使用<strong>多个”|”进行多次过滤</strong></li>
</ul>
</li>
</ul>
<h4 id="4-6-1-过滤器使用时传参"><a href="#4-6-1-过滤器使用时传参" class="headerlink" title="4.6.1 过滤器使用时传参"></a>4.6.1 过滤器使用时传参</h4><p>过滤器在使用时可以传递参数</p>
<p>过滤器处理函数<strong>第一个参数默认为待处理的数据</strong>，使用过滤器时传递的参数，<strong>从处理函数第二个参数开始接受</strong></p>
<center><big>格式化日期简单案例</big></center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 向过滤器format传递参数 --&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;msg | format(<span class="string">&#x27;yyyy-MM-dd&#x27;</span>)&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处arg = &#x27;yyyy-MM-dd&#x27;</span></span><br><span class="line">        Vue.filter(<span class="string">&#x27;format&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">val, arg</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//使用正则表达式格式化日期</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">dateFormat</span>(<span class="params">date, format</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> date === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">                    <span class="keyword">var</span> mts = date.match(<span class="regexp">/(\/Date\((\d+)\)\/)/</span>);</span><br><span class="line">                    <span class="keyword">if</span> (mts &amp;&amp; mts.length &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                        date = <span class="built_in">parseInt</span>(mts[<span class="number">2</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                date = <span class="keyword">new</span> <span class="built_in">Date</span>(date);</span><br><span class="line">                <span class="keyword">if</span> (!date || date.toUTCString() == <span class="string">&quot;Invalid Date&quot;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> map = &#123;</span><br><span class="line">                    <span class="string">&quot;M&quot;</span>: date.getMonth() + <span class="number">1</span>, <span class="comment">//月份 </span></span><br><span class="line">                    <span class="string">&quot;d&quot;</span>: date.getDate(), <span class="comment">//日 </span></span><br><span class="line">                    <span class="string">&quot;h&quot;</span>: date.getHours(), <span class="comment">//小时 </span></span><br><span class="line">                    <span class="string">&quot;m&quot;</span>: date.getMinutes(), <span class="comment">//分 </span></span><br><span class="line">                    <span class="string">&quot;s&quot;</span>: date.getSeconds(), <span class="comment">//秒 </span></span><br><span class="line">                    <span class="string">&quot;q&quot;</span>: <span class="built_in">Math</span>.floor((date.getMonth() + <span class="number">3</span>) / <span class="number">3</span>), <span class="comment">//季度 </span></span><br><span class="line">                    <span class="string">&quot;S&quot;</span>: date.getMilliseconds() <span class="comment">//毫秒 </span></span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                format = format.replace(<span class="regexp">/([yMdhmsqS])+/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">all, t</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> v = map[t];</span><br><span class="line">                    <span class="keyword">if</span> (v !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (all.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                            v = <span class="string">&#x27;0&#x27;</span> + v;</span><br><span class="line">                            v = v.substr(v.length - <span class="number">2</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> v;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t === <span class="string">&#x27;y&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> (date.getFullYear() + <span class="string">&#x27;&#x27;</span>).substr(<span class="number">4</span> - all.length);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> all;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> format;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dateFormat(val, arg);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="4-7-生命周期"><a href="#4-7-生命周期" class="headerlink" title="4.7 生命周期"></a>4.7 生命周期</h3><p>一个Vue实例的生命周期指从其<strong>被创建开始到其被销毁结束</strong></p>
<h4 id="生命周期的主要阶段"><a href="#生命周期的主要阶段" class="headerlink" title="生命周期的主要阶段"></a>生命周期的主要阶段</h4><p>共有八种生命周期方法(钩子函数)</p>
<ul>
<li>其this自动指向当前Vue实例</li>
<li>不能使用<strong>箭头函数</strong>创建生命周期方法，这会使得<strong>this指向混乱(变为undefined)</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeCreate:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&quot;beforeCreate&quot;</span>);</span><br><span class="line">         &#125;,</span><br><span class="line">         created:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&#x27;created&#x27;</span>);</span><br><span class="line">         &#125;,</span><br><span class="line">         beforeMount:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&#x27;beforeMount&#x27;</span>);</span><br><span class="line">         &#125;,</span><br><span class="line">         mounted:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&#x27;mounted&#x27;</span>);</span><br><span class="line">         &#125;,</span><br><span class="line">         beforeUpdate:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&#x27;beforeUpdate&#x27;</span>);</span><br><span class="line">         &#125;,</span><br><span class="line">         update:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&#x27;update&#x27;</span>);</span><br><span class="line">         &#125;,</span><br><span class="line">         beforeDestoty:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&#x27;beforeDestoty&#x27;</span>);</span><br><span class="line">         &#125;,</span><br><span class="line">         destotyed:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&#x27;destotyed&#x27;</span>);</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<center>代码段1</center>

<ul>
<li>八种生命周期方法在Vue实例中与<code>data和methods</code>等属性是<strong>同级的</strong></li>
</ul>
<h5 id="挂载阶段（初始化相关属性）"><a href="#挂载阶段（初始化相关属性）" class="headerlink" title="挂载阶段（初始化相关属性）"></a>挂载阶段（初始化相关属性）</h5><p>当Vue实例创建时调用以下四种方法</p>
<ul>
<li>beforeCreate</li>
<li>created</li>
<li>beforeMount</li>
<li><strong>mounted</strong>方法：<ul>
<li>初始化完成时调用，模板内容(data)已存在，可以向视图(view)中填充数据</li>
</ul>
</li>
</ul>
<p><img data-src="/images/01-Vue/image-20210919170833461-1632056227619.png" alt="image-20210919170833461"></p>
<p>当Vue实例创建时，控制台会输出上述四行（根据代码段1定义的钩子函数） </p>
<h5 id="更新阶段（元素或组件的变更）"><a href="#更新阶段（元素或组件的变更）" class="headerlink" title="更新阶段（元素或组件的变更）"></a>更新阶段（元素或组件的变更）</h5><ul>
<li>beforeUpdate</li>
<li>Updated</li>
</ul>
<p>当<strong>修改data中的属性</strong>时会触发上面两个函数</p>
<h5 id="销毁阶段（销毁Vue实例）"><a href="#销毁阶段（销毁Vue实例）" class="headerlink" title="销毁阶段（销毁Vue实例）"></a>销毁阶段（销毁Vue实例）</h5><ul>
<li>beforeDestroy</li>
<li>destroyed</li>
</ul>
<p>当使用<code>this.$destroy()</code>销毁实例时会调用上面方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//methods中的方法</span></span><br><span class="line">destroynow:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    				<span class="comment">//销毁实例</span></span><br><span class="line">                    <span class="built_in">this</span>.$destroy()</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>销毁实例后，<strong>data和methods和computed中的数据全部被清除</strong>，之后再通过调用方法修改data中的数据没有效果</p>
]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>17-多人博客管理系统项目</title>
    <url>/2021/08/30/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="多人博客管理系统项目"><a href="#多人博客管理系统项目" class="headerlink" title="多人博客管理系统项目"></a>多人博客管理系统项目</h1><ul>
<li>分为两部分<ul>
<li><strong>展示页面</strong>：博客前台展示文章总览页面和文章详情页面</li>
<li><strong>管理页面</strong>：查看上传的文章列表，注册的用户列表，对文章增删查改等</li>
</ul>
</li>
</ul>
<h2 id="1-项目初始化"><a href="#1-项目初始化" class="headerlink" title="1.项目初始化"></a>1.项目初始化</h2><h3 id="1-1-创建项目目录文件夹"><a href="#1-1-创建项目目录文件夹" class="headerlink" title="1.1 创建项目目录文件夹"></a>1.1 创建项目目录文件夹</h3><ul>
<li>myblog_project：项目根目录<ul>
<li>public：静态资源文件夹</li>
<li>route：模块化路由文件夹</li>
<li>model：数据库和数据处理文件夹</li>
<li>views：模板文件夹</li>
<li>app.js：项目入口(主模块)</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h3 id="1-2-初始化项目描述文件"><a href="#1-2-初始化项目描述文件" class="headerlink" title="1.2 初始化项目描述文件"></a>1.2 初始化项目描述文件</h3><ul>
<li><code>npm init- y</code></li>
</ul>
<h3 id="1-3-下载依赖模块"><a href="#1-3-下载依赖模块" class="headerlink" title="1.3 下载依赖模块"></a>1.3 下载依赖模块</h3><ul>
<li><code>npm install express mongoose art-template express-art-template</code></li>
</ul>
<h3 id="1-4-创建网站服务器"><a href="#1-4-创建网站服务器" class="headerlink" title="1.4 创建网站服务器"></a>1.4 创建网站服务器</h3><ul>
<li>访问路径为localhost:80</li>
</ul>
<h3 id="1-5-模块化路由"><a href="#1-5-模块化路由" class="headerlink" title="1.5 模块化路由"></a>1.5 模块化路由</h3><p>route文件夹下创建两个js文件</p>
<ul>
<li>home.js：展示页面路由模块</li>
<li>admin.js：管理页面路由模块</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> home = express.Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">//二级目录设置为&#x27;/&#x27;,访问时只需输入一级目录，浏览器自动加上&#x27;/&#x27;</span></span><br><span class="line">home.get(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">&#x27;博客展示页面&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = home</span><br></pre></td></tr></table></figure>

<center>home.js模块</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">&#x27;./route/home&#x27;</span>)</span><br><span class="line">app.use(<span class="string">&#x27;/home&#x27;</span>,home)</span><br></pre></td></tr></table></figure>

<center>主模块中引入路由模块并匹配一级路由</center>

<h3 id="1-6-请求静态页面处理"><a href="#1-6-请求静态页面处理" class="headerlink" title="1.6 请求静态页面处理"></a>1.6 请求静态页面处理</h3><p>将静态页面放在public文件夹下(例如管理页面和内容页面的js和css文件)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态资源请求</span></span><br><span class="line">    <span class="comment">//放在最上层避免模块化路由路径干扰</span></span><br><span class="line">app.use(express.static(path.join(__dirname,<span class="string">&#x27;public&#x27;</span>)))</span><br></pre></td></tr></table></figure>

<p>在app.js中使用<code>express.static</code>方法处理静态资源请求</p>
<h3 id="1-7-博客管理页面模板构建"><a href="#1-7-博客管理页面模板构建" class="headerlink" title="1.7 博客管理页面模板构建"></a>1.7 博客管理页面模板构建</h3><p>将后缀为.art的模板文件放在<strong>views文件下的admin文件夹</strong>中</p>
<ul>
<li>本项目中管理页面和内容页面的<strong>html文件使用art-template模板引擎渲染</strong>，所以改后缀为.art后放入views文件夹中</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板文件目录设置</span></span><br><span class="line">app.set(<span class="string">&#x27;views&#x27;</span>,path.join(__dirname,<span class="string">&#x27;views&#x27;</span>))</span><br><span class="line"><span class="comment">//模板默认后缀设置</span></span><br><span class="line">app.set(<span class="string">&#x27;view engine&#x27;</span>,<span class="string">&#x27;art&#x27;</span>)</span><br><span class="line"><span class="comment">//设置art后缀的模板使用的模板引擎</span></span><br><span class="line">app.engine(<span class="string">&#x27;art&#x27;</span>,<span class="built_in">require</span>(<span class="string">&#x27;express-art-template&#x27;</span>))</span><br></pre></td></tr></table></figure>

<center>app.js中配置如下</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">admin.get(<span class="string">&#x27;/login&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.render(<span class="string">&#x27;admin/login&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>admin.js中配置对模板请求的响应</center>

<h3 id="1-8-模板中相对路径的问题"><a href="#1-8-模板中相对路径的问题" class="headerlink" title="1.8 模板中相对路径的问题"></a>1.8 模板中相对路径的问题</h3><p>模板中许多外链文件如css和js文件使用的都是<strong>相对路径</strong></p>
<p>模板中的相对路径是<strong>相对于浏览器地址栏的路径</strong></p>
<p>改为<strong>绝对路径</strong>可以避免因路由对象的虚拟路径而取不到静态资源文件的问题</p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210830203446873.png" alt="login.art模板中的相对路径"></p>
<br>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210830203543389.png" alt="相对路径相对于浏览器地址栏的路径"></p>
<p>此时浏览器将地址栏中的login当作文件，所以<strong>相对路径即相对于/abc</strong></p>
<ul>
<li><p>可见此时请求静态资源<code>base.css</code>的路径变为了<code>http://localhost/abc/css/base.css</code></p>
</li>
<li><p>而<code>base.css</code>静态资源文件并不在<code>/public/abc</code>文件夹下，并且public文件夹下也并不存在abc文件夹，所以无法获取静态资源文件</p>
</li>
<li><p>/abc只是admin路由对象匹配的<strong>虚拟路径</strong>，这个虚拟路径<strong>随时可以发生变化</strong></p>
</li>
<li><p>所以在模块中使用相对路径获取静态资源文件并不合适</p>
</li>
<li><p>改为使用<strong>绝对路径</strong>解决这个问题</p>
</li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210830204312384.png" alt="login.art模板中使用绝对路径"></p>
<p>在原先的相对路径前加上<code>&#39;/&#39;</code>使其变为绝对路径，同时根据静态资源文件的路径加上admin</p>
<p>此时请求静态资源文件的路径变为<code>http://localhost/admin/css/base.css</code></p>
<p>经过<code>express.static</code>方法处理后在<code>/public/admin/css/base.css</code>找到静态资源文件</p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210830205046226.png" alt="模板使用绝对路径获取静态资源文件"></p>
<br>

<h3 id="1-9-优化模板中公共代码"><a href="#1-9-优化模板中公共代码" class="headerlink" title="1.9 优化模板中公共代码"></a>1.9 优化模板中公共代码</h3><p>将模板中公共代码提取为子模版</p>
<p>将除login.art外的<strong>四个模板的头部和侧边栏提取为子模版</strong></p>
<p>子模版header.art和aside.art存放在**/views/admin/common**文件夹下</p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210830210812174.png" alt="子模版引入"></p>
<br>

<h3 id="1-10-提取模板骨架"><a href="#1-10-提取模板骨架" class="headerlink" title="1.10 提取模板骨架"></a>1.10 提取模板骨架</h3><p>将除login.art外的四个模板中的开头结尾html结构提取到<code>./common/layout.art</code>文件中</p>
<p>让四个模板继承骨架文件layout.art，并填上各自模板独立的内容</p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210831163400493.png" alt="修改后的user.art模板"></p>
<br>

<h2 id="2-登录功能"><a href="#2-登录功能" class="headerlink" title="2. 登录功能"></a>2. 登录功能</h2><h3 id="2-1-创建用户集合初始化用户"><a href="#2-1-创建用户集合初始化用户" class="headerlink" title="2.1 创建用户集合初始化用户"></a>2.1 创建用户集合初始化用户</h3><ul>
<li>连接数据库</li>
<li>创建用户集合</li>
<li>初始化用户</li>
</ul>
<h4 id="2-1-1-连接数据库"><a href="#2-1-1-连接数据库" class="headerlink" title="2.1.1 连接数据库"></a>2.1.1 连接数据库</h4><p>model文件夹下的connect.js文件连接<strong>数据库blog</strong></p>
<h4 id="2-1-2-创建用户集合"><a href="#2-1-2-创建用户集合" class="headerlink" title="2.1.2 创建用户集合"></a>2.1.2 创建用户集合</h4><p>model文件夹下的user.js文件创建用户集合</p>
<p>用户<strong>user集合</strong>规则：用户名，邮箱，密码，角色，状态</p>
<p>状态：0代表启用(默认为0)，1代表禁用</p>
<p>导出<strong>集合构造函数User</strong></p>
<h4 id="2-1-3-创建初始化用户"><a href="#2-1-3-创建初始化用户" class="headerlink" title="2.1.3 创建初始化用户"></a>2.1.3 创建初始化用户</h4><p>在user.js文件中创建一个初始化管理员用户</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个初始化用户</span></span><br><span class="line">User.create(&#123;</span><br><span class="line">    username:<span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    email:<span class="string">&#x27;zhangsan@123.com&#x27;</span>,</span><br><span class="line">    password:<span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">    role:<span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">    state:<span class="number">0</span></span><br><span class="line">&#125;).then( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;初始化用户创建成功&#x27;</span>);</span><br><span class="line">&#125;).catch( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;初始化用户创建失败&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210831213028363.png" alt="创建的初始化用户"></p>
<br>

<h3 id="2-2-提交前客户端一次验证"><a href="#2-2-提交前客户端一次验证" class="headerlink" title="2.2 提交前客户端一次验证"></a>2.2 提交前客户端一次验证</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提取表单所有控件并转化为方便处理的对象格式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serializeToJSON</span> (<span class="params">form</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = &#123;&#125;</span><br><span class="line">    <span class="comment">//serializeArray()方法</span></span><br><span class="line">    <span class="comment">//将表单所有控件按名值提取为对象并组成一个数组</span></span><br><span class="line">    <span class="comment">//[&#123;name:&#x27;email&#x27;,value:&#x27;....&#x27;&#125;,&#123;name:&#x27;password&#x27;,value:&#x27;...&#x27;&#125;]</span></span><br><span class="line">    <span class="keyword">let</span> f = form.serializeArray()</span><br><span class="line">    <span class="comment">//将上述提取的数组简化为&#123;email:&#x27;...&#x27;,password:&#x27;...&#x27;&#125;</span></span><br><span class="line">    f.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;   </span><br><span class="line">        result[item.name] = item.value</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>common.js</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;/admin/js/common.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt; </span><br><span class="line">    $(<span class="string">&#x27;#loginForm&#x27;</span>).on(<span class="string">&#x27;submit&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> result = serializeToJSON($(<span class="built_in">this</span>))</span><br><span class="line">        <span class="comment">//判断用户是否输入邮箱</span></span><br><span class="line">        <span class="comment">//trim()方法：去除字符串两边空格</span></span><br><span class="line">        <span class="keyword">if</span>(result.email.trim().length == <span class="number">0</span>)&#123;</span><br><span class="line">            alert(<span class="string">&#x27;请输入邮箱&#x27;</span>)</span><br><span class="line">            <span class="comment">//阻止程序运行并阻止表单默认提交事件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//判断用户是否输入密码</span></span><br><span class="line">        <span class="keyword">if</span>(result.password.trim().length == <span class="number">0</span>)&#123;</span><br><span class="line">            alert(<span class="string">&#x27;请输入密码&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<center>login.art模板中进行客户端提交验证</center>

<h4 id="2-2-1-获取用户输入数据"><a href="#2-2-1-获取用户输入数据" class="headerlink" title="2.2.1 获取用户输入数据"></a>2.2.1 获取用户输入数据</h4><p><strong>serializeArray()方法</strong>提取表单中所有控件为<code>[&#123;name:&#39;...&#39;,value:&#39;...&#39;&#125;,&#123;name:&#39;...&#39;,value:&#39;...&#39;&#125;]</code>形式</p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210831223205408.png" alt="serializeArray()方法提取表单控件"></p>
<p>将这种形式的数组进一步简化为易于处理的对象格式 <code>&#123;email:&#39;...&#39;,password:&#39;...&#39;&#125;</code></p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210831224117617.png" alt="处理后的用户输入数据"></p>
<p>使用**自定义函数serializeToJSON()**实现</p>
<ul>
<li>发现**serializeToJSON()**函数的功能比较常用</li>
<li>所以将serializeToJSON()函数提取到一个静态js文件common.js中</li>
<li>文件放在<code>/public/admin/js</code>文件夹下</li>
<li>其他模板获取静态js文件后即可使用这个函数</li>
</ul>
<h4 id="2-2-2-提交验证"><a href="#2-2-2-提交验证" class="headerlink" title="2.2.2 提交验证"></a>2.2.2 提交验证</h4><p>获取用户输入后进行邮箱和密码是否输入的验证</p>
<ul>
<li>若没有则弹出警示框提醒并阻止程序运行和表单提交</li>
<li>若都输入则正常提交</li>
</ul>
<br>

<h3 id="2-3-提交后服务器端二次验证"><a href="#2-3-提交后服务器端二次验证" class="headerlink" title="2.3 提交后服务器端二次验证"></a>2.3 提交后服务器端二次验证</h3><p>当客户端浏览器禁用JavaScript时，客户端一次验证就会失效，所以以防万一需要在服务端二次验证</p>
<ul>
<li>使用body-parser第三方模块获取post请求参数</li>
<li>进行二次验证</li>
</ul>
<p>若<strong>验证失败</strong>则设置响应码为400并响应<strong>error.art</strong>错误模板</p>
<ul>
<li>错误模板继承<strong>layout.art</strong>HTML骨架</li>
<li>再加入3s后返回登录页面的定时器</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123;block <span class="string">&#x27;script&#x27;</span>&#125;&#125;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            location.href = <span class="string">&#x27;/admin/login&#x27;</span> </span><br><span class="line">        &#125;,<span class="number">3000</span>)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&#123;&#123;/block&#125;&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="2-4-服务端查找用户是否存在"><a href="#2-4-服务端查找用户是否存在" class="headerlink" title="2.4 服务端查找用户是否存在"></a>2.4 服务端查找用户是否存在</h3><p>在admin.js路由模块中接受表单post请求时判断用户是否存在</p>
<ul>
<li>先引入model/user.js模块<strong>获取用户集合构造函数</strong></li>
<li>接着findOne方法匹配用户信息</li>
<li>找不到则返回错误信息</li>
<li>找到用户<ul>
<li>密码错误，返回错误信息</li>
<li>密码正确，显示登录成功</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据库查找用户</span></span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> User.findOne(&#123;<span class="attr">email</span>:email&#125;)</span><br><span class="line">    <span class="comment">//如果用户存在</span></span><br><span class="line">    <span class="keyword">if</span>(user)&#123;</span><br><span class="line">        <span class="comment">//密码正确</span></span><br><span class="line">        <span class="keyword">if</span>(user.password == password)&#123;</span><br><span class="line">            res.send(<span class="string">&#x27;登录成功&#x27;</span>)</span><br><span class="line">        <span class="comment">//密码错误</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.render(<span class="string">&#x27;admin/error&#x27;</span>,&#123;<span class="attr">msg</span>:<span class="string">&#x27;邮箱或密码错误&#x27;</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果用户不存在</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.render(<span class="string">&#x27;admin/error&#x27;</span>,&#123;<span class="attr">msg</span>:<span class="string">&#x27;邮箱或密码错误&#x27;</span>&#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<center>admin.js中查找用户是否存在部分代码</center>

<br>

<h3 id="2-5-密码加密-bcrypt"><a href="#2-5-密码加密-bcrypt" class="headerlink" title="2.5 密码加密 bcrypt"></a>2.5 密码加密 bcrypt</h3><p>用户的密码直接以明文形式存放在数据库中是不安全的</p>
<p><strong>使用第三方模块bcrypt进行密码加密</strong></p>
<ul>
<li><p>哈希加密</p>
</li>
<li><p>在密文中加入随机字符串增加破解难度</p>
</li>
</ul>
<h4 id="2-5-1-安装bcrypt模块"><a href="#2-5-1-安装bcrypt模块" class="headerlink" title="2.5.1 安装bcrypt模块"></a>2.5.1 安装bcrypt模块</h4><p>安装前需要三个依赖</p>
<ul>
<li>python 2.x<ul>
<li><strong>在环境变量中配置path</strong></li>
</ul>
</li>
<li>node-gyp 模块<ul>
<li><code>npm install -g node-gyp</code> </li>
<li>全局安装</li>
</ul>
</li>
<li>windows-build-tools 模块<ul>
<li><code>npm install --global --production windows-build-tools</code></li>
<li>在<strong>管理员权限</strong>下安装</li>
<li>全局安装</li>
</ul>
</li>
</ul>
<p>安装bcrypt模块</p>
<ul>
<li><code>npm install bcrypt</code><ul>
<li><strong>管理员权限</strong></li>
</ul>
</li>
</ul>
<br>

<h4 id="2-5-2-加密密码和比对明文密文"><a href="#2-5-2-加密密码和比对明文密文" class="headerlink" title="2.5.2 加密密码和比对明文密文"></a>2.5.2 加密密码和比对明文密文</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">createUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//生成随机数</span></span><br><span class="line">    <span class="comment">//参数数值越大，随机数越复杂</span></span><br><span class="line">    <span class="comment">//默认为10</span></span><br><span class="line">    <span class="keyword">const</span> salt = <span class="keyword">await</span> bcrypt.genSalt(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">//生成加密密码，第一个参数为明文，第二个参数为生成的随机数</span></span><br><span class="line">    <span class="keyword">const</span> pass = <span class="keyword">await</span> bcrypt.hash(<span class="string">&#x27;123456&#x27;</span>,salt)</span><br><span class="line">    <span class="comment">//创建一个初始化用户</span></span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> User.create(&#123;</span><br><span class="line">        username:<span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">        email:<span class="string">&#x27;zhangsan@123.com&#x27;</span>,</span><br><span class="line">        password:pass,</span><br><span class="line">        role:<span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">        state:<span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>创建密码加密的用户文档</center>

<p><code>bcrypt.genSalt(10)</code></p>
<ul>
<li>生成随机字符串，参数越大越复杂，默认为10</li>
<li>返回promise对象</li>
</ul>
<p><code>bcrypt.hash(‘明文’,随机字符串)</code></p>
<ul>
<li><p>返回加密后的密码密文</p>
</li>
<li><p>返回promise对象</p>
</li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210901111933091.png" alt="数据库中的加密密码"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比对明文密码与密文密码</span></span><br><span class="line"><span class="comment">//bcrypt.compare()方法</span></span><br><span class="line"><span class="comment">//第一个参数为明文密码，第二个参数为密文密码</span></span><br><span class="line"><span class="comment">//返回布尔值</span></span><br><span class="line"><span class="keyword">let</span> isValid = <span class="keyword">await</span> bcrypt.compare(password,user.password)</span><br><span class="line"><span class="comment">//密码正确</span></span><br><span class="line"><span class="keyword">if</span>( isValid )&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;登录成功&#x27;</span>)</span><br><span class="line"><span class="comment">//密码错误</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    res.render(<span class="string">&#x27;admin/error&#x27;</span>,&#123;<span class="attr">msg</span>:<span class="string">&#x27;邮箱或密码错误&#x27;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>登录时比对用户输入的明文密码和数据库中的密文密码</center>

<p><code>bcrypt.compare(&#39;明文密码&#39;,密文密码)</code></p>
<ul>
<li><p>返回值为promise对象</p>
</li>
<li><p>使用await关键字获取promise对象结果为<strong>布尔值</strong></p>
<ul>
<li>真 即代表比对成功</li>
</ul>
</li>
</ul>
<h3 id="2-6-cookie和session"><a href="#2-6-cookie和session" class="headerlink" title="2.6 cookie和session"></a>2.6 cookie和session</h3><p>上述客户端登录发送请求给服务端，服务端做出响应后，客户端和服务器端的<strong>连接就断开了</strong>（HTTP协议无连接）</p>
<p>连接断开后就相当于没有登录，再次发送请求时会重置req对象</p>
<p>这是因为<strong>http协议的无状态性</strong>导致的</p>
<p>使用cookie和session存储客户端和服务器的关系数据可以解决这个问题</p>
<h4 id="2-6-1-cookie"><a href="#2-6-1-cookie" class="headerlink" title="2.6.1 cookie"></a>2.6.1 cookie</h4><p>cookie是浏览器在<strong>客户端本地存储</strong>中开辟的一块空间，主要供服务端存储数据</p>
<ul>
<li><p>cookie中的数据以<strong>域名</strong>(Domain)区分</p>
</li>
<li><p>cookie是有<strong>过期时间</strong>的，过期cookie会被浏览器自动删除</p>
</li>
<li><p>cookie会随着客户端的请求<strong>一起被发送到服务器</strong></p>
</li>
<li><p>客户端<strong>第一次</strong>向服务器发送请求时(此时客户端没有存储cookie)，服务端将cookie信息与响应一同发送给客户端</p>
<ul>
<li>客户端接受到响应和cookie信息后将cookie存储在本地硬盘</li>
<li>之后每次客户端发送请求都会带上存储的cookie</li>
</ul>
</li>
</ul>
<h4 id="2-6-2-session"><a href="#2-6-2-session" class="headerlink" title="2.6.2 session"></a>2.6.2 session</h4><p>session实际上就是一个存储在<strong>服务端内存</strong>的对象，在session中可以存储多条数据，每条数据都有一个<code>sessionId</code>作为<strong>唯一标识</strong></p>
<ul>
<li><strong>cookie一般用来存储sessionId</strong>，客户端接受到自己的sessionId后，每次请求都带上自己的sessionId，服务端根据sessionId就可以确定客户端的身份，并维持联系。</li>
</ul>
<h4 id="2-6-3-在登录功能中应用cookie和session"><a href="#2-6-3-在登录功能中应用cookie和session" class="headerlink" title="2.6.3 在登录功能中应用cookie和session"></a>2.6.3 在登录功能中应用cookie和session</h4><p>使用第三方模块<code>express-session</code></p>
<ul>
<li>express框架官方提供的模块</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入express-session对象 用来设置服务器端session</span></span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">&#x27;express-session&#x27;</span>)</span><br><span class="line"><span class="comment">//建立session对象</span></span><br><span class="line">app.use(session(&#123;<span class="attr">secret</span>:<span class="string">&#x27;secret key&#x27;</span>&#125;))</span><br></pre></td></tr></table></figure>

<p>使用app.use拦截所有请求，并设置session对象</p>
<ul>
<li>session方法有一个必填参数secret<ul>
<li>即加密sessionId所用的密钥</li>
<li>密钥可以自定义</li>
<li>此处设置为<code>secret key</code></li>
</ul>
</li>
<li><strong>session对象设置在请求对象下 req.session</strong></li>
</ul>
<p>创建session对象后，当服务端<strong>向session对象中存入数据时</strong>，session对象就会为数据指定唯一的sessionId</p>
<p>并且随着响应把sessionId存放在客户端cookie中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//密码正确</span></span><br><span class="line"><span class="keyword">if</span>( isValid )&#123;</span><br><span class="line">    <span class="comment">//将用户名存储在session对象中</span></span><br><span class="line">    req.session.username = user.username</span><br><span class="line">    res.send(<span class="string">&#x27;登录成功&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>login.js中登录请求路由处理函数部分代码</center>

<p>处理<strong>用户登录请求</strong>时，在服务器二次验证用户存在并且密码正确时<strong>将用户名username存储在session对象中</strong></p>
<p>此时就在session对象中存入了数据，session对象<strong>自动生成sessionId</strong>并随着响应<strong>自动发送</strong>cookie（响应中无需书写添加cookie代码）</p>
<ul>
<li>谷歌浏览器 <strong>检查-&gt;Application-&gt;cookie选项</strong> 就可以看到cookie</li>
<li>红框中字符串即为加密后的sessionId</li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210901172232221.png" alt="客户端存储的cookie"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用户查询页面二级路由</span></span><br><span class="line">admin.get(<span class="string">&#x27;/user&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.render(<span class="string">&#x27;admin/user&#x27;</span>,&#123;<span class="attr">msg</span>:req.session.username&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>admin.js用户查询页面部分代码</center>

<p>在登录后<strong>查询用户页面</strong>时，将session中存放的username作为拼接数据显示在模板中</p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210901172822822.png" alt="session对象中的username显示在模板中"></p>
<p>至此完成了cookie和session在登录功能中的应用</p>
<br>

<h3 id="2-7-登录后跳转到用户列表页面并显示用户名"><a href="#2-7-登录后跳转到用户列表页面并显示用户名" class="headerlink" title="2.7 登录后跳转到用户列表页面并显示用户名"></a>2.7 登录后跳转到用户列表页面并显示用户名</h3><p>因为有多个模板的右上角都需要显示用户名，所以将数据写为<strong>app.locals下的对象</strong>供所有模板使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将user作为模板公共拼接数据</span></span><br><span class="line"><span class="comment">//req.app即为app.js模块中的app对象</span></span><br><span class="line">req.app.locals.userInfo = user</span><br><span class="line"><span class="comment">//重定向到用户展示页面</span></span><br><span class="line">res.redirect(<span class="string">&#x27;/admin/user&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>重定向使用express框架提供的<strong>res.redirect()方法</strong></p>
<p>将user作为公共拼接数据</p>
<p>然后在header.art模板中使用userInfo.username拼接用户名即可</p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210901210811789.png" alt="显示登录用户的用户名"></p>
<br>

<h3 id="2-8-登录拦截"><a href="#2-8-登录拦截" class="headerlink" title="2.8 登录拦截"></a>2.8 登录拦截</h3><p>用户在没有登录时只能访问<code>localhost/admin/login</code>登录页面</p>
<p><strong>此时访问其他页面都应该跳转到登录页面</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//登录拦截</span></span><br><span class="line"><span class="comment">//app.use匹配以&#x27;/admin&#x27;开头的请求路径</span></span><br><span class="line">app.use(<span class="string">&#x27;/admin&#x27;</span>,<span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//访问的不是登录页面且没有登录信息</span></span><br><span class="line">    <span class="comment">//此时req.url结果为/admin后面的url</span></span><br><span class="line">    <span class="keyword">if</span>(req.url!=<span class="string">&#x27;/login&#x27;</span> &amp;&amp; !req.session.username)&#123;</span><br><span class="line">        <span class="comment">//重定向</span></span><br><span class="line">        res.redirect(<span class="string">&#x27;/admin/login&#x27;</span>)</span><br><span class="line">    <span class="comment">//有登录信息则放行</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>app.js中登录拦截的代码</center>

<ul>
<li><p>这段代码应该<strong>写在admin路由对象匹配路径的代码前面</strong></p>
</li>
<li><p>通过req.url判断请求的是否为登录页面</p>
</li>
<li><p>同过session对象下有无username属性判断发送请求的客户端是否登录</p>
</li>
</ul>
<br>

<h3 id="2-9-退出登录功能实现"><a href="#2-9-退出登录功能实现" class="headerlink" title="2.9 退出登录功能实现"></a>2.9 退出登录功能实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//登出页面路由</span></span><br><span class="line">admin.get(<span class="string">&#x27;/logout&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//删除session</span></span><br><span class="line">    req.session.destroy(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//删除cookie</span></span><br><span class="line">        res.clearCookie(<span class="string">&#x27;connect.sid&#x27;</span>)</span><br><span class="line">        <span class="comment">//重定向到登录页面</span></span><br><span class="line">        res.redirect(<span class="string">&#x27;/admin/login&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>用户登出时<strong>删除session</strong> <code>req.session.destory</code><ul>
<li>自动根据cookie存储的sessionId删除对应的用户session信息</li>
</ul>
</li>
<li>在<code>req.session.destory</code>的回调函数中<strong>删除cookie</strong>并将页面重定向到登陆页面</li>
<li>删除cookie：<code>res.clearCookie(&#39;cookie名&#39;)</code><ul>
<li>connect.sid为express框架的默认cookie名</li>
</ul>
</li>
</ul>
<br>

<p><strong>注意：</strong></p>
<ul>
<li>express-session模块使用时默认会设置未初始化cookie<ul>
<li>即当客户端向服务端发送请求时就会存储一个cookie</li>
<li>这个cookie不存储用户的sessionId</li>
<li>我们希望用户退出登录时<strong>将这个未初始化cookie也删除</strong></li>
</ul>
</li>
<li>默认的cookie过期时间为null<ul>
<li>即当浏览器关闭时就会删除cookie</li>
<li>我们希望<strong>设置cookie过期时间为一天后</strong></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建立session对象</span></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">    <span class="comment">//加密cookie</span></span><br><span class="line">    secret:<span class="string">&#x27;secret key&#x27;</span>,</span><br><span class="line">    <span class="comment">//不添加未初始化cookie</span></span><br><span class="line">    saveUninitialized:<span class="literal">false</span>,</span><br><span class="line">    cookie:&#123;</span><br><span class="line">        <span class="comment">//设置过期时间(毫秒)</span></span><br><span class="line">        maxAge:<span class="number">24</span> * <span class="number">60</span> *<span class="number">60</span> * <span class="number">1000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<br>

<h3 id="2-10-app-js和admin-js文件优化"><a href="#2-10-app-js和admin-js文件优化" class="headerlink" title="2.10 app.js和admin.js文件优化"></a>2.10 app.js和admin.js文件优化</h3><p><strong>1. 对于网站入口文件app.js</strong></p>
<ul>
<li>我们通常只希望其进行<strong>模块引入</strong>和<strong>简单的配置</strong>工作</li>
<li><strong>功能性的代码</strong>通常通过其他模块引入</li>
</ul>
<p>app.js中的登录拦截就是功能性代码，需要将其分离</p>
<p>在<strong>myblog_project文件夹</strong>下(即<strong>app.js所在目录下</strong>)创建<strong>middleware文件夹</strong>来存放app.js使用的功能性中间件代码</p>
<ul>
<li>将登录拦截app.use中间件的<strong>第二个参数即处理函数抽离</strong>并放在middleware文件夹下的loginGuard.js文件中</li>
<li>在loginGuard.js文件中开放这个函数并<strong>通过require引回app.js中使用</strong></li>
<li>这样可以维持app.js的简单性</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//登录拦截</span></span><br><span class="line">app.use(<span class="string">&#x27;/admin&#x27;</span>,<span class="built_in">require</span>(<span class="string">&#x27;./middleware/loginGuard&#x27;</span>))</span><br></pre></td></tr></table></figure>

<center>app.js登录拦截代码</center>

<p><code>require(&#39;./middleware/loginGuard&#39;)</code>的返回值即为导出的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//访问的不是登录页面且没有登录信息</span></span><br><span class="line">    <span class="comment">//此时req.url结果为/admin后面的url</span></span><br><span class="line">    <span class="keyword">if</span>(req.url!=<span class="string">&#x27;/login&#x27;</span> &amp;&amp; !req.session.username)&#123;</span><br><span class="line">        res.redirect(<span class="string">&#x27;/admin/login&#x27;</span>)</span><br><span class="line">    <span class="comment">//有登录信息则放行</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>loginGuard.js文件</center>

<p><strong>2. 对于路由模块admin.js</strong></p>
<ul>
<li>我们希望它作为一个<strong>路由列表文件</strong></li>
<li>具体的<strong>路由处理函数</strong>需要分离</li>
</ul>
<p>在admin.js所在目录下建立admin文件夹(存放admin.js文件的路由处理函数)</p>
<p>使用app.js文件分离功能函数的方式进行分离即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> admin = express.Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">//登录页面路由</span></span><br><span class="line">admin.get(<span class="string">&#x27;/login&#x27;</span>,<span class="built_in">require</span>(<span class="string">&#x27;./admin/loginPage&#x27;</span>))</span><br><span class="line"><span class="comment">//用户列表页面路由</span></span><br><span class="line">admin.get(<span class="string">&#x27;/user&#x27;</span>,<span class="built_in">require</span>(<span class="string">&#x27;./admin/userPage&#x27;</span>))</span><br><span class="line"><span class="comment">//登出页面路由</span></span><br><span class="line">admin.get(<span class="string">&#x27;/logout&#x27;</span>,<span class="built_in">require</span>(<span class="string">&#x27;./admin/logout&#x27;</span>))</span><br><span class="line"><span class="comment">//登录请求处理路由</span></span><br><span class="line">admin.post(<span class="string">&#x27;/login&#x27;</span>,<span class="built_in">require</span>(<span class="string">&#x27;./admin/login&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = admin</span><br></pre></td></tr></table></figure>

<center>优化后的admin.js文件，仅作为路由列表文件</center>

<br>

<h2 id="3-用户注册功能"><a href="#3-用户注册功能" class="headerlink" title="3. 用户注册功能"></a>3. 用户注册功能</h2><p>当用户点击用户展示页面的新增用户按钮时<strong>跳转到注册用户页面</strong>进行用户注册</p>
<p>在admin.js文件中定义<strong>跳转到注册页面的路由</strong>和<strong>注册信息提交的路由</strong></p>
<p>使用<strong>joi第三方模块</strong>可以方便的进行对象格式验证</p>
<h3 id="3-1-joi第三方模块"><a href="#3-1-joi第三方模块" class="headerlink" title="3.1 joi第三方模块"></a>3.1 joi第三方模块</h3><p><code>npm install joi</code></p>
<ul>
<li><p>下载版本为<strong>17.4.2</strong></p>
</li>
<li><p>创建验证规则</p>
<ul>
<li><code>Joi.object(&#123;&#125;)</code>方法，对象作为参数，对对象的属性进行限制</li>
<li>可以指定待验证属性的<strong>类型</strong>，<strong>长度</strong>，<strong>是否必填</strong>等</li>
<li>可以自定义验证不通过时的报错信息</li>
</ul>
</li>
<li><p>进行验证</p>
<ul>
<li>第一种方式<ul>
<li><code>const &#123;value,error&#125; = schema.validate(‘待验证对象’)</code></li>
<li>schema为验证规则</li>
<li>通过时value为待验证对象，error为undefined</li>
<li>不通过时value为待验证对象，error为错误对象</li>
</ul>
</li>
<li>第二种方式<ul>
<li><code>schema.validateAsync(‘待验证对象’)</code></li>
<li>返回promise对象</li>
<li>使用<strong>异步函数错误捕获</strong>的方式**(try catch)**</li>
<li>在catch中进行错误信息的输出**(err.message输出简要错误信息)**</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入模块</span></span><br><span class="line"><span class="keyword">const</span> Joi = <span class="built_in">require</span>(<span class="string">&#x27;joi&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建验证规则</span></span><br><span class="line"><span class="keyword">const</span> schema = Joi.object(&#123;</span><br><span class="line">    <span class="comment">//username属性的值为字符串，最短2，最长10，必填</span></span><br><span class="line">    <span class="comment">//error()方法可以自定义报错信息</span></span><br><span class="line">    username: Joi.string().min(<span class="number">2</span>).max(<span class="number">10</span>).required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;username验证不通过&#x27;</span>)),</span><br><span class="line">    birthyear: Joi.number().min(<span class="number">1900</span>).max(<span class="number">2021</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种验证方式</span></span><br><span class="line"><span class="keyword">const</span> &#123;value,error&#125; = schema.validate(&#123;<span class="attr">birthyear</span>:<span class="number">1901</span>&#125;)</span><br><span class="line"><span class="comment">//value为验证对象</span></span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br><span class="line"><span class="comment">//验证通过时error为undefined，没通过error为错误对象</span></span><br><span class="line"><span class="built_in">console</span>.log(error.message);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种验证方式</span></span><br><span class="line"><span class="comment">//使用异步函数错误捕获</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//value为验证对象</span></span><br><span class="line">        <span class="keyword">const</span> value = <span class="keyword">await</span> schema.validateAsync(&#123;<span class="attr">birthyear</span>:<span class="number">1900</span>&#125;)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="comment">//输出错误信息</span></span><br><span class="line">        <span class="built_in">console</span>.log(err.message);</span><br><span class="line">        <span class="comment">//终止</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;验证通过&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run()</span><br></pre></td></tr></table></figure>

<h3 id="3-2-使用joi模块实现服务端注册信息验证"><a href="#3-2-使用joi模块实现服务端注册信息验证" class="headerlink" title="3.2 使用joi模块实现服务端注册信息验证"></a>3.2 使用joi模块实现服务端注册信息验证</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Joi = <span class="built_in">require</span>(<span class="string">&#x27;joi&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设定验证规则</span></span><br><span class="line"><span class="keyword">const</span> schema = Joi.object(&#123;</span><br><span class="line">    username: Joi.string().min(<span class="number">2</span>).max(<span class="number">10</span>).required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;用户名验证不通过&#x27;</span>)),</span><br><span class="line">    email: Joi.string().email().required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;邮箱验证不通过&#x27;</span>)),</span><br><span class="line">    password: Joi.string().regex(<span class="regexp">/^[a-zA-Z0-9]&#123;3,30&#125;&amp;/</span>).required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;密码验证不通过&#x27;</span>)),</span><br><span class="line">    role: Joi.string().valid(<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;normal&#x27;</span>).required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;角色值验证不通过&#x27;</span>)),</span><br><span class="line">    state: Joi.number().valid(<span class="number">0</span>,<span class="number">1</span>).required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;状态验证不通过&#x27;</span>)),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> (req,res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">await</span> schema.validateAsync(req.body)</span><br><span class="line">    <span class="comment">//验证不通过则重定向到注册页面并在页面显示错误提示</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        res.redirect(<span class="string">`/admin/user-edit?message=<span class="subst">$&#123;err.message&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    res.send(req.body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>regex(/^[a-zA-Z0-9]&#123;3,30&#125;&amp;/)</code> 密码验证使用正则表达式</p>
<ul>
<li>长度为<strong>3到30</strong>(包括边界)并由<strong>大小写字母和数字0-9</strong>组成的字符串可以通过验证</li>
</ul>
</li>
<li><p><code>valid(&#39;admin&#39;,&#39;normal)</code> 角色验证使用可选字符串</p>
<ul>
<li>只有admin或normal两个字符串可以通过</li>
<li>valid中选择数字同理，只有特定数字可以通过验证</li>
</ul>
</li>
<li><p><code>email()</code>代表符合邮箱字符串格式才能通过</p>
</li>
<li><p>验证不通过时<strong>将错误信息作为请求参数加入重定向url中</strong></p>
<ul>
<li>重定向请求处理时<strong>将参数中的错误信息与模板拼接</strong></li>
</ul>
</li>
<li><p>执行res.redirect()重定向时要<strong>接着return</strong></p>
<ul>
<li>因为重定向时会默认执行res.end()方法结束请求</li>
<li>如果下面的代码还有res.send这类结束请求的代码就会报错</li>
</ul>
</li>
</ul>
<h3 id="3-3-用户添加到数据库"><a href="#3-3-用户添加到数据库" class="headerlink" title="3.3 用户添加到数据库"></a>3.3 用户添加到数据库</h3><p>用户提交信息通过服务端格式验证后，继续判断邮箱是否已经注册，若<strong>没有注册则将用户添加到数据库</strong>并将页面重定向到用户展示页面</p>
<p>若已经注册则重定向回注册页面并显示<strong>邮箱已被注册</strong></p>
<ul>
<li>判断邮箱是否已经注册<ul>
<li>没有注册则将密码加密</li>
<li>然后将新用户信息存入数据库</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//验证用户提交的邮箱是否存在</span></span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> User.findOne(&#123;<span class="attr">email</span>:req.body.email&#125;)</span><br><span class="line">    <span class="comment">//如果存在则重定向回注册页面并显示错误</span></span><br><span class="line">    <span class="keyword">if</span>(user)&#123;</span><br><span class="line">        <span class="keyword">return</span> res.redirect(<span class="string">`/admin/user-edit?message=当前邮箱已经注册`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不存在则可以注册</span></span><br><span class="line">    <span class="comment">//加密用户密码</span></span><br><span class="line">    <span class="keyword">const</span> salt = <span class="keyword">await</span> bcrypt.genSalt(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">//生成加密密码，第一个参数为明文，第二个参数为生成的随机数</span></span><br><span class="line">    <span class="keyword">const</span> password = <span class="keyword">await</span> bcrypt.hash(req.body.password,salt)</span><br><span class="line">    req.body.password = password</span><br><span class="line">    <span class="comment">//在数据库中创建新用户</span></span><br><span class="line">    <span class="keyword">await</span> User.create(req.body)</span><br><span class="line">    <span class="comment">//重定向到用户展示页面</span></span><br><span class="line">    <span class="keyword">return</span> res.redirect(<span class="string">&#x27;/admin/user&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-4-优化user-editSubmit-js文件"><a href="#3-4-优化user-editSubmit-js文件" class="headerlink" title="3.4 优化user-editSubmit.js文件"></a>3.4 优化user-editSubmit.js文件</h3><h4 id="3-4-1-提交信息格式验证代码优化"><a href="#3-4-1-提交信息格式验证代码优化" class="headerlink" title="3.4.1 提交信息格式验证代码优化"></a>3.4.1 提交信息格式验证代码优化</h4><ul>
<li>验证提交信息格式的代码属于<strong>用户数据处理的代码</strong>，并可能多次使用<ul>
<li>将其提取放在<strong>model/user.js</strong>文件中</li>
<li>model文件夹存放<strong>数据处理</strong>的文件</li>
<li>user.js文件存放<strong>用户数据处理</strong>代码</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//验证用户注册信息格式函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validateSubmit</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> schema = Joi.object(&#123;</span><br><span class="line">        username: Joi.string().min(<span class="number">2</span>).max(<span class="number">10</span>).required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;用户名验证不通过&#x27;</span>)),</span><br><span class="line">        email: Joi.string().email().required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;邮箱验证不通过&#x27;</span>)),</span><br><span class="line">        password: Joi.string().regex(<span class="regexp">/^[a-zA-Z0-9]&#123;3,16&#125;$/</span>).required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;密码验证不通过&#x27;</span>)),</span><br><span class="line">        role: Joi.string().valid(<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;normal&#x27;</span>).required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;角色值验证不通过&#x27;</span>)),</span><br><span class="line">        state: Joi.number().valid(<span class="number">0</span>,<span class="number">1</span>).required().error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;状态验证不通过&#x27;</span>)),</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> schema.validateAsync(user)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//导出User集合构造函数和注册信息格式验证函数</span></span><br><span class="line"><span class="comment">//使用对象,方便之后其他对象导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    User,</span><br><span class="line">    validateSubmit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-2-重定向错误处理代码优化"><a href="#3-4-2-重定向错误处理代码优化" class="headerlink" title="3.4.2 重定向错误处理代码优化"></a>3.4.2 重定向错误处理代码优化</h4><ul>
<li>格式验证不通过和邮箱已经被注册时进行重定向属于<strong>错误处理代码</strong><ul>
<li>将其提取后放在app.js文件中的<strong>错误处理中间件中</strong></li>
<li><strong>next()方法接受字符串作为参数</strong>，需要将对象转换为字符串(<code>JSON.stringify()</code>方法)</li>
<li><strong>next()方法的参数</strong>即为错误处理中间件的<strong>err参数</strong></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// return res.redirect(`/admin/user-edit?message=当前邮箱已经注册`)</span></span><br><span class="line"><span class="comment">//将原本的重定向代码替换为下面的next()方法</span></span><br><span class="line">next(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">path</span>:<span class="string">&#x27;/admin/user-edit&#x27;</span>,<span class="attr">message</span>:<span class="string">&#x27;当前邮箱已经注册&#x27;</span>&#125;))</span><br></pre></td></tr></table></figure>

<center>user-editSubmit.js文件中跳转错误处理中间件</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入模块化路由</span></span><br><span class="line"><span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">&#x27;./route/home&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> admin = <span class="built_in">require</span>(<span class="string">&#x27;./route/admin&#x27;</span>)</span><br><span class="line">app.use(<span class="string">&#x27;/home&#x27;</span>,home)</span><br><span class="line">app.use(<span class="string">&#x27;/admin&#x27;</span>,admin)</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误处理中间件</span></span><br><span class="line"><span class="comment">//next()方法的参数即为错误处理中间件的err参数</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//转换回对象提取数据</span></span><br><span class="line">    <span class="keyword">const</span> &#123;path,message&#125; = <span class="built_in">JSON</span>.parse(err)</span><br><span class="line">    <span class="comment">//重定向</span></span><br><span class="line">    res.redirect(<span class="string">`<span class="subst">$&#123;path&#125;</span>?message=<span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>app.js中错误处理中间件</center>

<h2 id="4-用户列表页面"><a href="#4-用户列表页面" class="headerlink" title="4. 用户列表页面"></a>4. 用户列表页面</h2><p>用户登录成功或者注册成功时<strong>会跳转到用户列表页面</strong></p>
<p>用户列表页面需要<strong>显示当前数据库中已注册用户的信息</strong></p>
<ul>
<li>请求用户列表页面时将数据库中的所有注册用户数据<strong>作为拼接数据进行模板渲染</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;User&#125; = <span class="built_in">require</span>(<span class="string">&#x27;../../model/user&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> (req,res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> users = <span class="keyword">await</span> User.find()</span><br><span class="line">    res.render(<span class="string">&#x27;admin/user&#x27;</span>,&#123;</span><br><span class="line">        users:users</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>userPage.js</center>

<ul>
<li>在用户列表页面模板中<strong>通过循环显示用户数据</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123;each users&#125;&#125;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;&#123;&#123;@$value._id&#125;&#125;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;&#123;&#123;$value.username&#125;&#125;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;&#123;&#123;$value.email&#125;&#125;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;&#123;&#123;$value.role == <span class="string">&#x27;admin&#x27;</span> ? <span class="string">&#x27;管理员&#x27;</span> : <span class="string">&#x27;普通用户&#x27;</span>&#125;&#125;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;&#123;&#123;$value.state == <span class="number">0</span> ? <span class="string">&#x27;启用&#x27;</span> : <span class="string">&#x27;禁用&#x27;</span>&#125;&#125;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        &lt;a href=<span class="string">&quot;user-edit.html&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;glyphicon glyphicon-edit&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line">		&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;glyphicon glyphicon-remove&quot;</span> data-toggle=<span class="string">&quot;modal&quot;</span> data-target=<span class="string">&quot;.confirm-modal&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">	&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&#123;&#123;/each&#125;&#125;</span><br></pre></td></tr></table></figure>

<center>user.art模板循环显示用户信息</center>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210906172011394.png" alt="用户列表页面实际效果"></p>
<br>

<h3 id="4-1-用户列表分页显示功能"><a href="#4-1-用户列表分页显示功能" class="headerlink" title="4.1 用户列表分页显示功能"></a>4.1 用户列表分页显示功能</h3><p>实现分页功能的几个要点：</p>
<ul>
<li>每一页显示的数据条数</li>
<li>数据库中要显示的数据总条数</li>
<li>当前要显示的页码<ul>
<li>当前要显示的页码通过get请求参数传递到服务器</li>
<li>若为最后一页则要取消下一页按钮</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前请求的页码参数</span></span><br><span class="line"><span class="keyword">const</span> page = req.query.page || <span class="number">1</span></span><br><span class="line"><span class="comment">//设定一页显示的数据条数</span></span><br><span class="line"><span class="keyword">const</span> pageSize = <span class="number">1</span></span><br><span class="line"><span class="comment">//获取数据库中数据总条数</span></span><br><span class="line"><span class="comment">//参数为匹配条件，空则匹配所有数据</span></span><br><span class="line"><span class="keyword">const</span> count = <span class="keyword">await</span> User.countDocuments(&#123;&#125;)</span><br><span class="line"><span class="comment">//总页数</span></span><br><span class="line"><span class="keyword">const</span> total = <span class="built_in">Math</span>.ceil(count/pageSize)</span><br><span class="line"><span class="comment">//当前页首条数据开始位置</span></span><br><span class="line"><span class="keyword">const</span> start = (page - <span class="number">1</span>) * pageSize</span><br><span class="line"><span class="comment">//从数据库中查询当前页数据</span></span><br><span class="line"><span class="keyword">const</span> users = <span class="keyword">await</span> User.find().limit(pageSize).skip(start)</span><br><span class="line"><span class="comment">//渲染模板</span></span><br><span class="line">res.render(<span class="string">&#x27;admin/user&#x27;</span>,&#123;</span><br><span class="line">    users:users</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>userPage.js中分页功能代码</center>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;% for (var i=1 ; i&lt;=total ; i++) &#123; %&gt;</span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/admin/user?page=&lt;%= i %&gt;&quot;</span>&gt;</span>&lt;%= i %&gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<center>user.art中使用模板原始语法循环生成每一页按钮</center>

<ul>
<li><p>获取请求页码时 <code>|| 1</code>，此时若请求中没有传递页码参数，page = 1，默认显示第一页数据</p>
</li>
<li><p>当页首条数据在数据库中序号为 <code>(page - 1) * pageSize</code></p>
</li>
<li><p>总页数计算时向上取整，不满一页的数据也算一页</p>
</li>
<li><p>查询时使用<code>limit()</code>和<code>skip()</code>方法</p>
<ul>
<li>limit()  限制一次查询的数据条数</li>
<li>skip()   限制本次查询从哪一条数据开始<ul>
<li>参数为数据在数据库中的序号</li>
<li>数据库中的<strong>第1条数据序号为0</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-1-1-适时取消上一页-下一页按钮"><a href="#4-1-1-适时取消上一页-下一页按钮" class="headerlink" title="4.1.1 适时取消上一页/下一页按钮"></a>4.1.1 适时取消上一页/下一页按钮</h4><p>当前页为第一页或者最后一页时隐藏上一页或下一页按钮</p>
<p><strong>防止访问不存在的页导致错误</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">style</span>=<span class="string">&quot;display: &lt;%= page-1==0 ? &#x27;none&#x27; : &#x27;inline&#x27;%&gt;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/admin/user?page=&lt;%= page-1 %&gt;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="symbol">&amp;laquo;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<center>user.art中上一页按钮显示隐藏</center>

<p>使用<strong>模板原始语法修改li标签display属性值</strong>实现隐藏显示</p>
<p>当前页page=1时即隐藏上一页按钮</p>
<p>下一页按钮同理</p>
<ul>
<li>此处html模板中显示使用inline，修改为显示时也使用inline</li>
<li>下一页判断时<code>page-0+1</code>先使用<code>page-0</code>将<strong>字符串隐式转换为数字再进行加法</strong></li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210906223507179.png" alt="当前显示第一页时隐藏上一页按钮"></p>
<br>

<h2 id="5-用户信息修改功能"><a href="#5-用户信息修改功能" class="headerlink" title="5. 用户信息修改功能"></a>5. 用户信息修改功能</h2><h3 id="5-1-用户信息修改页面"><a href="#5-1-用户信息修改页面" class="headerlink" title="5.1 用户信息修改页面"></a>5.1 用户信息修改页面</h3><p><strong>用户信息修改</strong>和<strong>新用户添加</strong>使用同一个模板即<code>user-edit.art</code></p>
<p>当用户点击用户列表页面的编辑按钮时，将要修改的用户ID作为get参数发送，请求地址<code>/admin/user-edit</code>（修改和添加使用同一个请求地址）</p>
<p>将要修改的用户信息填入文本框</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求参数是否有id参数</span></span><br><span class="line"><span class="keyword">if</span>(id)&#123;</span><br><span class="line">    <span class="comment">//用户信息修改</span></span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> User.findOne(&#123;<span class="attr">_id</span>:id&#125;)</span><br><span class="line">    res.render(<span class="string">&#x27;admin/user-edit&#x27;</span>,&#123;</span><br><span class="line">        message:message,</span><br><span class="line">        user:user,</span><br><span class="line">        <span class="comment">//link来区分修改和添加提交地址</span></span><br><span class="line">        link:<span class="string">&#x27;/admin/user-editChange&#x27;</span>,</span><br><span class="line">        button:<span class="string">&#x27;修改&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//添加新用户</span></span><br><span class="line"> 	res.render(<span class="string">&#x27;admin/user-edit&#x27;</span>,&#123;</span><br><span class="line">        message:message,</span><br><span class="line">        link:<span class="string">&#x27;/admin/user-edit&#x27;</span>,</span><br><span class="line">        button:<span class="string">&#x27;添加&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>user-edit.js中处理修改和新增用户请求</center>

<ul>
<li>首先从请求参数中解构出id参数</li>
<li><strong>判断id参数是否存在</strong><ul>
<li>是 修改请求<ul>
<li>数据库中查询要修改的用户数据</li>
<li>作为模板拼接数据渲染</li>
</ul>
</li>
<li>否 新增用户请求(用户注册)</li>
</ul>
</li>
</ul>
<br>

<p><strong>user-edit.art模板渲染时注意的问题</strong></p>
<ul>
<li>因为新增用户时<strong>不需要将用户数据作为拼接数据</strong>，所以模板中使用user数据时要<strong>先判断user是否存在</strong><ul>
<li>如果新增用户时模板<strong>使用一个不存在的拼接数据</strong>，会报错</li>
<li><code>&#123;&#123;@user && user._id&#125;&#125;</code>使用与运算符判断，如果user拼接数据存在，再填入user._id，否则留空<ul>
<li>使用@进行id的原文输出(id在数据库中存储的格式为<code>ObjectId</code>)</li>
</ul>
</li>
</ul>
</li>
<li>修改信息和新增用户<strong>使用不同的表单提交地址</strong><ul>
<li>使用拼接数据<code>link</code>区分提交地址</li>
</ul>
</li>
<li>两个页面提交按钮的文字不同 <strong>修改/提交</strong> 使用button拼接数据区分</li>
<li>修改用户信息时<strong>密码并不显示在文本框中</strong>，用户需进行下一步验证才能修改密码</li>
</ul>
<br>

<h3 id="5-2-用户信息修改提交"><a href="#5-2-用户信息修改提交" class="headerlink" title="5.2 用户信息修改提交"></a>5.2 用户信息修改提交</h3><p>点击提交按钮后发送<strong>post请求</strong>到<code>/admin/user-modify</code>地址</p>
<ul>
<li><strong>将修改用户的id</strong>作为get参数</li>
<li><strong>修改信息</strong>作为post参数</li>
<li>post请求也可以添加get参数</li>
</ul>
<p>服务器接受请求后使用bcrypt模块<strong>比对用户输入的密码和数据库中的密码</strong></p>
<ul>
<li>成功则允许修改，更新数据库中用户数据</li>
<li>失败则重定向回修改页面并显示错误信息</li>
</ul>
<h4 id="5-2-1-密码比对错误时"><a href="#5-2-1-密码比对错误时" class="headerlink" title="5.2.1 密码比对错误时"></a>5.2.1 密码比对错误时</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//密码比对失败</span></span><br><span class="line"><span class="comment">//调用错误处理中间件重定向回修改页面并显示错误信息</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">path</span>:<span class="string">&#x27;/admin/user-edit&#x27;</span>,<span class="attr">message</span>:<span class="string">&#x27;密码错误，请重试&#x27;</span>,<span class="attr">id</span>:id&#125;</span><br><span class="line">next(<span class="built_in">JSON</span>.stringify(obj))</span><br></pre></td></tr></table></figure>

<center>user-modify.js文件密码比对失败时处理</center>

<p>比对失败时，将<strong>重定向地址</strong>，<strong>错误信息</strong>，<strong>用户id</strong>(重定向后显示用户信息使用)作为错误对象传递到错误处理中间件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误处理中间件</span></span><br><span class="line"><span class="comment">//出错后带着错误信息重定向</span></span><br><span class="line">app.use(<span class="function">(<span class="params">err,req,res,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">JSON</span>.parse(err)</span><br><span class="line">    <span class="comment">//修改用户信息密码比对错误时的 result = &#123;path:&#x27;...&#x27;,message:&#x27;...&#x27;,id:...&#125;</span></span><br><span class="line">    <span class="keyword">const</span> params = []</span><br><span class="line">    <span class="comment">//通过循环将要添加的多个请求参数存入数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> attr <span class="keyword">in</span> result)&#123;</span><br><span class="line">        <span class="keyword">if</span>(attr != <span class="string">&#x27;path&#x27;</span>)&#123;</span><br><span class="line">            params.push(<span class="string">`<span class="subst">$&#123;attr&#125;</span>=<span class="subst">$&#123;result[attr]&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用数组join方法以&amp;分隔 将多个请求参数添加到url中</span></span><br><span class="line">    res.redirect(<span class="string">`<span class="subst">$&#123;result.path&#125;</span>?<span class="subst">$&#123;params.join(<span class="string">&#x27;&amp;&#x27;</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>app.js中改进后的错误处理中间件</center>

<ul>
<li>之前的错误处理中间件在重定向时<strong>将请求参数固定写为一个</strong>，但是重定向时的<strong>请求参数个数通常不定</strong></li>
<li>需要动态根据每个错误修改参数个数</li>
</ul>
<p>使用<strong>循环遍历错误对象</strong>，将其中每个请求参数存入数组</p>
<p>使用<strong>数组join方法</strong>将每个元素以&amp;拼接后作为url中的请求参数</p>
<ul>
<li><strong>注意：</strong>以变量获取对象属性时使用**[]**，例如上述代码第二次循环时<code>attr = message</code></li>
<li>获取<code>result.message</code>属性时，代码为<code>result[attr]</code></li>
</ul>
<p>此时当用户在修改用户信息页面<strong>输入错误的密码并点击修改按钮</strong>后，页面重定向到修改用户信息页面并提示错误信息</p>
<br>

<h4 id="5-2-2-密码比对成功时"><a href="#5-2-2-密码比对成功时" class="headerlink" title="5.2.2 密码比对成功时"></a>5.2.2 密码比对成功时</h4><p>更新数据库中对应用户的<strong>除密码外的信息</strong></p>
<p>然后重定向到用户列表页面，修改后的结果可以在列表页面查看</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//密码比对成功</span></span><br><span class="line"><span class="comment">//更新数据库中信息(密码不更新)</span></span><br><span class="line"><span class="keyword">await</span> User.updateOne(&#123;<span class="attr">_id</span>:id&#125;,&#123;</span><br><span class="line">    username:username,</span><br><span class="line">    email:email,</span><br><span class="line">    role:role,</span><br><span class="line">    state:state</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//重定向到用户列表页面</span></span><br><span class="line">res.redirect(<span class="string">&#x27;/admin/user&#x27;</span>)</span><br></pre></td></tr></table></figure>

<br>

<h2 id="6-用户删除功能"><a href="#6-用户删除功能" class="headerlink" title="6. 用户删除功能"></a>6. 用户删除功能</h2><p>在用户列表页面点击用户信息后的删除按钮将用户删除</p>
<ul>
<li>给删除按钮添加自定义属性<code>data-id</code>(即为要删除用户的id)</li>
<li>script代码加入删除按钮点击事件，在处理函数中获取data-id属性值</li>
<li>将<strong>用户id</strong>设置为表单隐藏域的<strong>value属性值</strong></li>
<li>表单设置为GET请求，提交地址为<code>/admin/user-delete</code></li>
<li>服务器端设置删除路由<code>/admin/user-delete</code></li>
<li>服务端接受请求获取GET请求参数id</li>
<li>根据id删除对应用户</li>
<li><strong>重定向回用户列表页面</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    $(<span class="string">&#x27;.delete&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    	<span class="comment">//获取删除按钮自定义属性</span></span><br><span class="line">        <span class="keyword">let</span> id = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;data-id&#x27;</span>)</span><br><span class="line">        <span class="comment">//将id值 给表单隐藏域的value属性</span></span><br><span class="line">        $(<span class="string">&#x27;#userDelete&#x27;</span>).val(id)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<center>删除按钮点击事件</center>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;您确定要删除这个用户吗?&lt;/p&gt;</span><br><span class="line"><span class="comment">//表单隐藏域</span></span><br><span class="line">&lt;input type=<span class="string">&quot;hidden&quot;</span> name=<span class="string">&quot;id&quot;</span> id=<span class="string">&quot;userDelete&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<center>表单隐藏域</center>

<ul>
<li>表单隐藏域即为一个<strong>type值为hidden的input标签</strong></li>
<li>他不显示在页面中，只起<strong>设定表单请求参数的作用</strong></li>
<li>当表单以GET请求方式提交时，隐藏域请求参数<strong>仍显示在地址栏中（localhost/admin/user-delete?id=…）</strong></li>
</ul>
<br>

<h2 id="7-文章管理功能"><a href="#7-文章管理功能" class="headerlink" title="7.文章管理功能"></a>7.文章管理功能</h2><ul>
<li>给<strong>文章列表页面</strong>和<strong>文章编辑页面</strong>添加路由</li>
<li><code>views/admin/commom</code>文件夹下的<strong>aside.art侧边栏模板文件</strong>中为文章管理和用户管理添加超链接</li>
<li>在用户页面(列表和编辑)和文章页面的路由处理函数中添加模板公共拼接数据，根据变量<strong>currentLink的值</strong>判断侧边栏选中项</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;a <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item &#123;&#123;currentLink == &#x27;user&#x27; ? &#x27;active&#x27; : &#x27;&#x27;&#125;&#125;&quot;</span> href=<span class="string">&quot;/admin/user&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<center>aside.art文件中判断侧边栏是否选中用户管理</center>

<h3 id="7-1-创建文章集合articles"><a href="#7-1-创建文章集合articles" class="headerlink" title="7.1 创建文章集合articles"></a>7.1 创建文章集合articles</h3><p>创建集合规则时注意：文章集合中的<strong>一个作者字段即对应用户集合中一个的文档</strong>（一条用户信息），需要使用<strong>集合关联</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建集合规则</span></span><br><span class="line"><span class="keyword">const</span> articleSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    title:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        required:[<span class="literal">true</span>,<span class="string">&#x27;请输入标题&#x27;</span>],</span><br><span class="line">        minlength:<span class="number">4</span>,</span><br><span class="line">        maxlength:<span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//作者实际就是用户集合中的文档（用户信息）</span></span><br><span class="line">    <span class="comment">//集合关联</span></span><br><span class="line">    author:&#123;</span><br><span class="line">        type:mongoose.Schema.Types.ObjectId,</span><br><span class="line">        ref:<span class="string">&#x27;User&#x27;</span>,</span><br><span class="line">        required:[<span class="literal">true</span>,<span class="string">&#x27;请写作者&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    publishDate:&#123;</span><br><span class="line">        type:<span class="built_in">Date</span>,</span><br><span class="line">        <span class="keyword">default</span>:<span class="built_in">Date</span>.now</span><br><span class="line">    &#125;,</span><br><span class="line">    cover:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>:<span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    content:&#123;</span><br><span class="line">        type:<span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>创建文章集合规则</center>

<h3 id="7-2-添加文章功能"><a href="#7-2-添加文章功能" class="headerlink" title="7.2 添加文章功能"></a>7.2 添加文章功能</h3><ul>
<li>给article-edit.art页面的表单设置提交地址，提交方式，<strong>编码类型</strong>，请求参数名<ul>
<li>编码类型需要设置为<strong>multipart/form-data</strong>，表单数据以二进制编码</li>
<li>表单中<strong>上传文件时</strong>，数据<strong>必须以二进制编码</strong></li>
</ul>
</li>
<li>设置文章添加路由</li>
<li>表单数据以二进制编码时，接收表单数据需要使用<strong>第三方模块formidable</strong></li>
</ul>
<h4 id="7-2-1-formidable模块-处理二进制表单数据"><a href="#7-2-1-formidable模块-处理二进制表单数据" class="headerlink" title="7.2.1 formidable模块 处理二进制表单数据"></a>7.2.1 formidable模块 处理二进制表单数据</h4><ul>
<li>支持解析GET/POST请求参数，<strong>解析上传文件</strong></li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210908202048388.png" alt="formidable模块基本使用"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//formidable模块处理二进制表单数据(有文件上传的表单)</span></span><br><span class="line"><span class="keyword">const</span> formidable = <span class="built_in">require</span>(<span class="string">&#x27;formidable&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//创建表单解析对象form</span></span><br><span class="line">    <span class="keyword">const</span> form = formidable.IncomingForm()</span><br><span class="line">    <span class="comment">//设定上传文件存储位置</span></span><br><span class="line">    form.uploadDir = path.join(__dirname,<span class="string">&#x27;../&#x27;</span>,<span class="string">&#x27;../&#x27;</span>,<span class="string">&#x27;public&#x27;</span>,<span class="string">&#x27;uploads&#x27;</span>)</span><br><span class="line">    <span class="comment">//保留上传文件后缀</span></span><br><span class="line">    form.keepExtensions = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//解析表单数据</span></span><br><span class="line">    <span class="comment">//第一个参数为请求对象 第二个为回调函数</span></span><br><span class="line">    form.parse(req,<span class="function">(<span class="params">err,fields,files</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//err为错误对象 出错为对象 正常为null</span></span><br><span class="line">        <span class="comment">//fields 对象类型 为普通请求参数(非文件上传参数)</span></span><br><span class="line">        <span class="comment">//files 对象类型 上传文件的相关信息</span></span><br><span class="line">        res.send(fields)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>article-add.js文件处理二进制表单数据</center>

<ul>
<li>上传文件保存在<code>myblog_project/public/uploads</code>文件夹下</li>
<li>保留文件后缀</li>
</ul>
<br>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210908203033806.png" alt="fields对象内容"></p>
<ul>
<li>fields对象内容<ul>
<li>除cover上传文件参数外的<strong>其他普通参数</strong></li>
</ul>
</li>
</ul>
<br>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210908203525686.png" alt="files对象内容"></p>
<ul>
<li>对象中有cover（文件上传的参数名）属性</li>
<li>cover属性是一个对象<ul>
<li>size文件大小</li>
<li>path文件在本地存储路径（避免文件名重复会使用一个随机生成的）</li>
<li>name文件上传时的名字</li>
<li>type文件类型</li>
<li>mtime最后修改时间</li>
</ul>
</li>
</ul>
<br>

<h4 id="7-2-2-添加文章页面显示登录用户id"><a href="#7-2-2-添加文章页面显示登录用户id" class="headerlink" title="7.2.2 添加文章页面显示登录用户id"></a>7.2.2 添加文章页面显示登录用户id</h4><p>使用模板公共拼接数据<strong>userInfo</strong>（login.js文件中用户登录后将用户对象做为公共拼接数据userInfo）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input name=<span class="string">&quot;author&quot;</span> type=<span class="string">&quot;text&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;form-control&quot;</span> readonly value=<span class="string">&quot;&#123;&#123;@userInfo._id&#125;&#125;&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>使用@原文输出id</p>
<br>

<h4 id="7-2-3-上传文章封面显示缩略图"><a href="#7-2-3-上传文章封面显示缩略图" class="headerlink" title="7.2.3 上传文章封面显示缩略图"></a>7.2.3 上传文章封面显示缩略图</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文件上传文本框加上multiple属性后可以一次选择多个文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;cover&quot;</span> <span class="attr">id</span>=<span class="string">&quot;files&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>文件上传文本框（type=’file’）</li>
<li>加multiple属性可以一次选择多个文件上传</li>
</ul>
<br>

<p><strong>文件读取对象 FileReader</strong></p>
<p>JS的文件读取对象FileReader可以读取通过文件上传文本框上传的文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建文件读取对象</span></span><br><span class="line"><span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line"><span class="comment">//读取文件</span></span><br><span class="line">reader.readAsDataURL(<span class="string">&#x27;文件&#x27;</span>)</span><br><span class="line"><span class="comment">//监听文件读取完毕事件（文件读取是异步API，不能使用返回值获取结果）</span></span><br><span class="line"><span class="comment">//reader.result即为读取文件的内容</span></span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(reader.result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<center>文件读取对象基本使用</center>



<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210908210224806.png" alt="右侧为读取图片时reader.result内容"></p>
<ul>
<li>对于图片文件的读取，上图右侧即为读取后reader.result的内容</li>
<li>将reader.result的内容<strong>直接作为img标签src属性的值</strong>，效果与直接外链图片一致</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="comment">//获取上传文件文本框（type=&#x27;file&#x27;）</span></span><br><span class="line">        <span class="keyword">let</span> file = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#files&#x27;</span>)</span><br><span class="line">        <span class="comment">//获取预览img标签</span></span><br><span class="line">        <span class="keyword">let</span> preview = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#preview&#x27;</span>)</span><br><span class="line">        <span class="comment">//监听文件上传事件 上传文件文本框change即代表有文件上传</span></span><br><span class="line">        file.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//创建文件读取对象</span></span><br><span class="line">            <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line">            <span class="comment">//读取文件</span></span><br><span class="line">            reader.readAsDataURL(<span class="built_in">this</span>.files[<span class="number">0</span>])</span><br><span class="line">            <span class="comment">//监听文件读取完毕事件（文件读取是异步API，不能使用返回值获取结果）</span></span><br><span class="line">            reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                preview.src = reader.result</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<center>article-edit.art文件中上传文件显示缩略图</center>

<ul>
<li>有文件上传时即开始创建文件读取对象FileReader</li>
<li>文件上传文本框的<strong>this.files</strong> 为上传文件的列表</li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210908213035902.png" alt="this.files（上传一个文件）"></p>
<ul>
<li>this.files[0]即为上传的第一个文件<ul>
<li><code>reader.readAsDataURL(this.files[0])</code>  即读取文件列表中第一个文件</li>
</ul>
</li>
<li>文件读取完毕后直接<strong>将结果作为缩略图img标签的src属性</strong></li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210908213411425.png" alt="缩略图效果"></p>
<br>

<h4 id="7-2-4-添加文章存入数据库"><a href="#7-2-4-添加文章存入数据库" class="headerlink" title="7.2.4 添加文章存入数据库"></a>7.2.4 添加文章存入数据库</h4><ul>
<li>将新增文章存入数据库时<strong>两个字段需要注意</strong>：<ul>
<li>author字段存储的是<strong>登录用户的id</strong><ul>
<li>用户id在提交前已经通过公共拼接数据写入文本框value属性</li>
</ul>
</li>
<li>cover字段存储的是<strong>封面文件在服务器本地的绝对存储路径</strong> （也就是模板渲染图片时使用的路径）</li>
</ul>
</li>
</ul>
<h5 id="7-2-4-1-获取封面文件在服务器本地的绝对存储路径"><a href="#7-2-4-1-获取封面文件在服务器本地的绝对存储路径" class="headerlink" title="7.2.4.1 获取封面文件在服务器本地的绝对存储路径"></a>7.2.4.1 获取封面文件在服务器本地的绝对存储路径</h5><p>解析表单数据<code>form.parse</code>方法中回调函数的<strong>files参数存储上传文件的信息</strong></p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210908215109564.png" alt="files对象存储上传文件信息"></p>
<p>其中cover对象的path参数即为上传文件在服务器本机的绝对路径</p>
<p>对绝对路径进行截取获得的<strong>\uploads\upload_5a8abecaac6a7be8db59a90461efb878.jpg <strong>即为</strong>文章集合中cover字段的值</strong></p>
<ul>
<li>在app.js文件中已经设置过<strong>静态资源文件的存放路径为public文件夹下</strong>，所以从public后开始截取</li>
<li>模板文件中的绝对路径使用 <strong>‘/ ’</strong> 开头</li>
<li>使用字符串的<strong>split方法</strong>以public分割字符串，<strong>分割后数组的第二个元素即为cover的值</strong></li>
</ul>
<br>

<p>因为表单中的所有参数被分在两个变量（fields，files）中，所以<strong>创建数据库集合中文档使用的对象需要进行组合</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组合文章数据</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    title:fields.title,</span><br><span class="line">    author:fields.author,</span><br><span class="line">    publishDate:fields.publishDate == <span class="string">&#x27;&#x27;</span> ? <span class="built_in">Date</span>.now() : fields.publishDate,</span><br><span class="line">    <span class="comment">//以public分割的后部分路径</span></span><br><span class="line">    cover:files.cover.path.split(<span class="string">&#x27;public&#x27;</span>)[<span class="number">1</span>],</span><br><span class="line">    content:fields.content,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存入数据库</span></span><br><span class="line"><span class="keyword">await</span> Article.create(obj)</span><br><span class="line"><span class="comment">//重定向到文章列表页</span></span><br><span class="line">res.redirect(<span class="string">&#x27;/admin/article&#x27;</span>)</span><br></pre></td></tr></table></figure>

<center>article-add.js文件 将添加的文章存入数据库</center>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210908222811917.png" alt="数据库中的文章信息"></p>
<br>

<h3 id="7-3-文章列表页面"><a href="#7-3-文章列表页面" class="headerlink" title="7.3 文章列表页面"></a>7.3 文章列表页面</h3><p>查询数据库中所有文章，作为拼接数据，在模板中渲染</p>
<ul>
<li>查询时需要用到<strong>多集合关联查询</strong>（populate()方法）<ul>
<li>查询时author字段值为<strong>mongoose文档对象格式</strong></li>
<li>render方法与其冲突</li>
<li>使用lean()将其<strong>转换为普通对象格式</strong></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询文章集合所有文档</span></span><br><span class="line">    <span class="comment">//链式调用populate()方法 </span></span><br><span class="line">    <span class="comment">//多集合联合查询author字段</span></span><br><span class="line">        <span class="comment">//即查询_id值为author字段值的User集合中的文档</span></span><br><span class="line">        <span class="comment">//并用这个文档对象替换author的值</span></span><br><span class="line">    <span class="comment">//使用lean()缓和查询数据库与渲染模板的冲突</span></span><br><span class="line"><span class="keyword">let</span> articles = <span class="keyword">await</span> Article.find().populate(<span class="string">&#x27;author&#x27;</span>).lean()</span><br><span class="line"></span><br><span class="line"><span class="comment">//渲染模板</span></span><br><span class="line">res.render(<span class="string">&#x27;admin/article&#x27;</span>,&#123;</span><br><span class="line">    articles:articles</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h4 id="7-3-1发布时间格式处理"><a href="#7-3-1发布时间格式处理" class="headerlink" title="7.3.1发布时间格式处理"></a>7.3.1发布时间格式处理</h4><p>使用<strong>第三方模块dateformat</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入dateFormat模块格式化时间</span></span><br><span class="line"><span class="keyword">const</span> dateFormat= <span class="built_in">require</span>(<span class="string">&#x27;dateformat&#x27;</span>)</span><br><span class="line"><span class="comment">//引入art-template</span></span><br><span class="line"><span class="keyword">const</span> template = <span class="built_in">require</span>(<span class="string">&#x27;art-template&#x27;</span>)</span><br><span class="line"><span class="comment">//模板中导入外部变量</span></span><br><span class="line">template.defaults.imports.dateFormat = dateFormat</span><br></pre></td></tr></table></figure>

<center>app.js中引入dateformat模块并向模板导入外部变量</center>

<ul>
<li>项目使用了两个模板 ‘express-art-template’和’art-template’</li>
<li>将dateformat作为art-template模板的外部变量导入</li>
<li>在模板中使用<code>dateFormat(&#39;时间数据&#39;,&#39;格式化格式&#39;)</code>进行格式化</li>
<li><code>&#123;&#123;dateFormat($value.publishDate,'yyyy-mm-dd')&#125;&#125;</code> 格式化为年-月-日</li>
</ul>
<br>

<h4 id="7-3-2-文章列表页面分页"><a href="#7-3-2-文章列表页面分页" class="headerlink" title="7.3.2 文章列表页面分页"></a>7.3.2 文章列表页面分页</h4><p>文章列表页面使用<strong>第三方模块mongoose-sex-page</strong>实现，使用<strong>与用户列表页面分页不同的方法</strong></p>
<p><code>npm install mongoose-sex-page</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入mongoose-sex-page模块进行分页</span></span><br><span class="line"><span class="keyword">const</span> pagination = <span class="built_in">require</span>(<span class="string">&#x27;mongoose-sex-page&#x27;</span>)</span><br><span class="line"><span class="comment">//查询文章集合所有文档</span></span><br><span class="line">    <span class="comment">//链式调用populate()方法 </span></span><br><span class="line">        <span class="comment">//多集合联合查询author字段</span></span><br><span class="line">        <span class="comment">//即查询_id值为author字段值的User集合中的文档</span></span><br><span class="line">        <span class="comment">//并用这个文档对象替换author的值</span></span><br><span class="line">    <span class="comment">//使用mongoose-sex-page模块分页</span></span><br><span class="line">        <span class="comment">//page:当前显示第几页</span></span><br><span class="line">        <span class="comment">//size:一页显示多少条数据</span></span><br><span class="line">        <span class="comment">//display:页面下方分页按钮显示几页</span></span><br><span class="line">        <span class="comment">//exec():从数据库中查询</span></span><br><span class="line">    <span class="keyword">let</span> articles = <span class="keyword">await</span> pagination(Article).page(page).size(<span class="number">2</span>).display(<span class="number">2</span>).populate(<span class="string">&#x27;author&#x27;</span>).exec()</span><br><span class="line">    <span class="comment">//将查询出的对象先转换为JSON字符串再转换为对象</span></span><br><span class="line">    <span class="comment">//将author字段值的类型由mongoose文档对象转换为普通对象避免渲染模板时的冲突</span></span><br><span class="line">    <span class="keyword">let</span> temp = <span class="built_in">JSON</span>.stringify(articles)</span><br><span class="line">    articles = <span class="built_in">JSON</span>.parse(temp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// res.send(articles)</span></span><br><span class="line"></span><br><span class="line">    res.render(<span class="string">&#x27;admin/article&#x27;</span>,&#123;</span><br><span class="line">        articles:articles</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>pagination(‘集合构造函数’).page().size().display().exec()</strong></p>
<ul>
<li>集合构造函数：即要从<strong>哪个集合中查询数据并分页</strong></li>
<li>page()：参数为<strong>当前显示的页码</strong></li>
<li>size()：参数为<strong>一页显示的数据条数</strong></li>
<li>display()：参数为<strong>页面中分页按钮条显示几个按钮</strong><ul>
<li>若参数为2则一次显示2个按钮 1 2</li>
</ul>
</li>
<li>exec()：代表按照前面设定的规则开始在数据库中查询</li>
</ul>
<br>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210909124935375.png" alt="分页模块查询后的结果articles"></p>
</li>
<li><p>上述红框records对象即为<strong>第一页的两条数据</strong></p>
</li>
<li><p>total：总共查询出的数据条数</p>
</li>
<li><p>pages：分页的总页数</p>
</li>
<li><p>display属性为一个数组（循环数组显示分页按钮）</p>
</li>
</ul>
<br>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210909125348445.png" alt="分页效果"></p>
<ul>
<li>一页显示两条数据(<strong>size(2)</strong>)</li>
<li>下方分页按钮条显示两个按钮 1 2 (<strong>display(2)</strong>)</li>
</ul>
<br>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;each articles.display&#125;&#125;</span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/admin/article?page=&#123;&#123;$value&#125;&#125;&quot;</span>&gt;</span>&#123;&#123;$value&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;&#123;/each&#125;&#125;</span><br></pre></td></tr></table></figure>

<center>article.art模板中遍历display数组生成分页按钮并指定请求地址和显示的值</center>

<p>在请求地址中<strong>加入相应的page参数</strong>，服务端<strong>根据page参数返回相应的页码数据</strong></p>
<br>

<h5 id="7-3-2-1-分页按钮功能实现"><a href="#7-3-2-1-分页按钮功能实现" class="headerlink" title="7.3.2.1 分页按钮功能实现"></a>7.3.2.1 分页按钮功能实现</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 上一页按钮 --&gt;</span></span><br><span class="line">&#123;&#123;if articles.page &gt; 1&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/admin/article?page=&#123;&#123;articles.page - 1&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="symbol">&amp;laquo;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;&#123;/if&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定页面按钮 1 2 3 --&gt;</span></span><br><span class="line">&#123;&#123;each articles.display&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/admin/article?page=&#123;&#123;$value&#125;&#125;&quot;</span>&gt;</span>&#123;&#123;$value&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;&#123;/each&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下一页按钮 &gt; --&gt;</span></span><br><span class="line">&#123;&#123;if articles.page &lt; articles.pages&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/admin/article?page=&#123;&#123;articles.page - 0 + 1&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="symbol">&amp;raquo;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;&#123;/if&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>模板<strong>标准语法if判断</strong>，<strong>满足条件时if所包裹的代码才执行</strong></p>
<br>

<h4 id="7-3-3-文章修改和删除功能与用户的修改删除同理"><a href="#7-3-3-文章修改和删除功能与用户的修改删除同理" class="headerlink" title="7.3.3 文章修改和删除功能与用户的修改删除同理"></a>7.3.3 文章修改和删除功能与用户的修改删除同理</h4><br>

<h2 id="8-为mongoDB数据库添加账户"><a href="#8-为mongoDB数据库添加账户" class="headerlink" title="8.为mongoDB数据库添加账户"></a>8.为mongoDB数据库添加账户</h2><p>mongoDB数据库安装后<strong>默认不需要登录账户就可以访问修改数据库数据</strong>，安全性不足</p>
<p>为了提高安全性，给mongoDB数据库设置账户，mongoDB数据库有<strong>两种账户</strong>：</p>
<ul>
<li>超级管理员（roles:[‘root’]）</li>
<li>单个数据库管理员<ul>
<li>先创建超级管理员后才能创建单个数据库管理员</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\Windows\system32&gt; mongo</span><br><span class="line"></span><br><span class="line">&gt; use admin</span><br><span class="line"></span><br><span class="line">&gt; db.createUser(&#123;user:&#39;root&#39;,pwd:&#39;root&#39;,roles:[&#39;root&#39;]&#125;)</span><br><span class="line"></span><br><span class="line">&gt; use blog</span><br><span class="line"></span><br><span class="line">&gt; db.createUser(&#123;user:&#39;blogadmin&#39;,pwd:&#39;blogadmin&#39;,roles:[&#39;readWrite&#39;]&#125;)</span><br><span class="line"></span><br><span class="line">&gt; exit</span><br><span class="line"></span><br><span class="line">PS C:\Windows\system32&gt; net stop mongodb</span><br><span class="line"></span><br><span class="line">PS C:\Windows\system32&gt; mongod --remove</span><br><span class="line"></span><br><span class="line">PS C:\Windows\system32&gt; mongod --logpath&#x3D;&#39;C:\Mongodb\Server\4.4\log\mongod.log&#39; --dbpath&#x3D;&#39;C:\Mongodb\Server\4.4\data&#39; --install -auth</span><br><span class="line"></span><br><span class="line">PS C:\Windows\system32&gt; net start mongoDB</span><br><span class="line">MongoDB 服务正在启动 .</span><br><span class="line">MongoDB 服务已经启动成功。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>进入数据库下的admin数据库和blog数据库分别创建超级管理员和单个数据库管理员</p>
</li>
<li><p>退出卸载mongoDB服务</p>
</li>
<li><p>重新安装服务并指定日志文件和数据库文件存放位置</p>
<ul>
<li>使用-auth参数指定开启账户验证</li>
</ul>
</li>
<li><p>安装完后重启mongoDB服务</p>
</li>
<li><p>自此连接数据库时的connect方法第一个参数需要传递账号密码才能对数据库进行操作</p>
<ul>
<li><p>blog数据库账号密码都为<strong>blogadmin</strong></p>
</li>
<li><p>```js<br>//blog数据库的账号密码都为blogadmin<br>mongoose.connect(‘mongodb://blogadmin:blogadmin@localhost/blog’)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">## 9. 开发环境和生产环境</span><br><span class="line"></span><br><span class="line">- 开发环境：项目**开发人员使用的电脑上的环境**</span><br><span class="line">- 生产环境：项目放到真实的网站服务器上运行时，该**网站服务器主机的环境**</span><br><span class="line"></span><br><span class="line">项目放到**生产环境**运行时需要**对一些修改做出限制**，**不能在生产环境随意更改项目配置**</span><br><span class="line"></span><br><span class="line">项目在**开发环境**运行时可以将客户端请求项目时的测试结果打印在控制台方便开发人员调试</span><br><span class="line"></span><br><span class="line">所以项目运行时需要**区分运行的环境**进行不同的操作</span><br><span class="line"></span><br><span class="line">- 通过**系统变量NODE_ENV**的值来区别运行环境</span><br><span class="line">  - development：开发环境</span><br><span class="line">  - production：生产环境</span><br><span class="line"></span><br><span class="line">![新建系统变量NODE_ENV](&#x2F;images&#x2F;17-多人博客管理系统项目&#x2F;image-20210909200331019.png)</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">- 通过&#96;process.env.NODE_ENV&#96;查询系统变量中的NODE_ENV变量</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">&#x2F;&#x2F;检查运行环境</span><br><span class="line">if(process.env.NODE_ENV &#x3D;&#x3D; &#39;development&#39;)&#123;</span><br><span class="line">    console.log(&#39;开发环境&#39;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    console.log(&#39;生产环境&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<center>app.js检查项目运行环境</center>

<br>

<h3 id="9-1-开发环境将客户端请求打印在控制台（morgan模块）"><a href="#9-1-开发环境将客户端请求打印在控制台（morgan模块）" class="headerlink" title="9.1 开发环境将客户端请求打印在控制台（morgan模块）"></a>9.1 开发环境将客户端请求打印在控制台（morgan模块）</h3><p>使用<strong>第三方模块morgan</strong></p>
<ul>
<li>morgan是一个中间件函数</li>
<li>使用时app.use中间件<strong>放在上层避免其他中间件干扰</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检查运行环境</span></span><br><span class="line"><span class="keyword">if</span>(process.env.NODE_ENV == <span class="string">&#x27;development&#x27;</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开发环境&#x27;</span>);</span><br><span class="line">    <span class="comment">//dev是固定参数</span></span><br><span class="line">    <span class="comment">//morgan是中间件函数</span></span><br><span class="line">    <span class="comment">//将请求信息打印在控制台</span></span><br><span class="line">    app.use(morgan(<span class="string">&#x27;dev&#x27;</span>))</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;生产环境&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>app.js文件客户端请求打印</center>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210909203316334.png" alt="打印的请求信息"></p>
<br>

<h3 id="9-2-不同运行环境使用不同的配置信息（config模块）"><a href="#9-2-不同运行环境使用不同的配置信息（config模块）" class="headerlink" title="9.2 不同运行环境使用不同的配置信息（config模块）"></a>9.2 不同运行环境使用不同的配置信息（config模块）</h3><p><strong>config第三方模块</strong>：可以将不同运行环境下的配置信息抽离到单独的文件中，模块自动判断运行环境并应用相应的配置文件，节省了切换运行环境时手动更换配置信息的维护成本。</p>
<ul>
<li>安装conifg模块<ul>
<li><code>npm i config</code></li>
</ul>
</li>
<li>在项目根目录下创建config文件夹（名称固定）<ul>
<li>文件夹下创建三个json文件<ul>
<li>development.json：开发环境配置文件</li>
<li>production.json：生产环境配置文件</li>
<li>default.json：默认配置文件（在上面两个文件中都获取不到的配置信息在default.json文件中查找）</li>
</ul>
</li>
</ul>
</li>
<li>使用**config.get(‘配置信息名’)**可以获取相应环境下的配置信息</li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210909204804531.png" alt="获取开发环境下的title配置信息"></p>
<br>

<h4 id="9-2-1-将连接数据库信息抽离到开发环境配置文件中"><a href="#9-2-1-将连接数据库信息抽离到开发环境配置文件中" class="headerlink" title="9.2.1 将连接数据库信息抽离到开发环境配置文件中"></a>9.2.1 将连接数据库信息抽离到开发环境配置文件中</h4><p>数据库连接中的<strong>数据库账号密码、地址和端口等</strong>需要抽离到配置文件中方便开发人员修改</p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210909205952850.png" alt="数据库连接信息抽离到开发环境配置文件中"></p>
<br>

<ul>
<li>抽离到配置文件中后，通过<strong>config模块的get方法</strong>获取配置信息后连接数据库</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mongoose.connect(<span class="string">`mongodb://<span class="subst">$&#123;config.get(<span class="string">&#x27;db.user&#x27;</span>)&#125;</span>:<span class="subst">$&#123;config.get(<span class="string">&#x27;db.pwd&#x27;</span>)&#125;</span>@<span class="subst">$&#123;config.get(<span class="string">&#x27;db.host&#x27;</span>)&#125;</span>:<span class="subst">$&#123;config.get(<span class="string">&#x27;db.port&#x27;</span>)&#125;</span>/<span class="subst">$&#123;config.get(<span class="string">&#x27;db.dbname&#x27;</span>)&#125;</span>`</span>,&#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> ,<span class="attr">useUnifiedTopology</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h4 id="9-2-2-将敏感配置信息存储在环境变量中"><a href="#9-2-2-将敏感配置信息存储在环境变量中" class="headerlink" title="9.2.2 将敏感配置信息存储在环境变量中"></a>9.2.2 将敏感配置信息存储在环境变量中</h4><p>一些敏感的配置信息如数据库密码，不应该存放在项目文件中，以防止在分享代码时泄露造成安全隐患</p>
<p><strong>config模块可以在环境变量中提取配置信息</strong>，将<strong>敏感信息存放在系统变量</strong>中就可以防止密码泄露</p>
<ul>
<li>在项目根目录下config文件夹下创建custom-environment-variables.json文件（文件名固定）<ul>
<li>这个文件实现从系统变量中获取配置信息</li>
<li>将<strong>系统变量名</strong>作为这个文件中<strong>配置项属性的值</strong>即可</li>
</ul>
</li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210909211437982.png" alt="从系统变量中获取配置信息"></p>
<p><strong>注意：</strong></p>
<ul>
<li><strong>custom-environment-variables.json</strong>文件内部的db属性要与<strong>development.json</strong>文件中的db属性<strong>格式相同</strong></li>
<li>将<strong>development.json</strong>文件中的敏感配置信息pwd密码<strong>删除</strong>，通过<strong>custom-environment-variables.json</strong>文件<strong>获取系统变量app_pwd的值作为pwd配置项的值</strong></li>
<li>此时数据库连接时会获取系统变量app_pwd的值作为数据库密码，防止了分享代码时密码泄露的隐患</li>
</ul>
<br>

<br>

<br>

<h2 id="10-博客网站前台展示页面"><a href="#10-博客网站前台展示页面" class="headerlink" title="10. 博客网站前台展示页面"></a>10. 博客网站前台展示页面</h2><p>前面在 <strong>7.文章管理功能</strong> 开发完毕时，博客的所有管理页面就完成了</p>
<p>现在开始开发博客网站前台展示页面</p>
<h3 id="10-1-建立路由"><a href="#10-1-建立路由" class="headerlink" title="10.1 建立路由"></a>10.1 建立路由</h3><ul>
<li>博客前台文章总览页面（/home）</li>
<li>博客文章详情页面（/home/article）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> home = express.Router()</span><br><span class="line"></span><br><span class="line"><span class="comment">//博客前台首页(文章总览)</span></span><br><span class="line">home.get(<span class="string">&#x27;/&#x27;</span>,<span class="built_in">require</span>(<span class="string">&#x27;./home/index&#x27;</span>))</span><br><span class="line"><span class="comment">//文章详情页面</span></span><br><span class="line">home.get(<span class="string">&#x27;/article&#x27;</span>,<span class="built_in">require</span>(<span class="string">&#x27;./home/article&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = home</span><br></pre></td></tr></table></figure>

<center>route/home.js</center>

<h3 id="10-2-模板文件处理"><a href="#10-2-模板文件处理" class="headerlink" title="10.2 模板文件处理"></a>10.2 模板文件处理</h3><ul>
<li>博客前台的两个模板文件 <strong>default.art</strong> 和 <strong>article.art</strong>文件存放在/views/home文件夹下</li>
<li>路由处理函数中渲染模板</li>
<li>对模板中的<strong>外链文件路径使用绝对路径</strong></li>
<li>提取两个模板文件的<strong>HTML骨架</strong></li>
<li>提取两个模板文件的<strong>公共部分</strong></li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210909222033037.png" alt="抽离骨架提取公共代码后的default.art文件"></p>
<br>

<h3 id="10-3-从数据库中查询文章并显示在用户总览页面"><a href="#10-3-从数据库中查询文章并显示在用户总览页面" class="headerlink" title="10.3 从数据库中查询文章并显示在用户总览页面"></a>10.3 从数据库中查询文章并显示在用户总览页面</h3><ul>
<li>查询文章数据时使用<strong>多集合级联查询</strong>和<strong>分页规则查询</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询文章</span></span><br><span class="line"><span class="comment">//多集合级联查询</span></span><br><span class="line"><span class="comment">//分页规则查询</span></span><br><span class="line"><span class="keyword">let</span> articles = <span class="keyword">await</span> pagination(Article).page(<span class="number">1</span>).size(<span class="number">4</span>).display(<span class="number">3</span>).populate(<span class="string">&#x27;author&#x27;</span>).exec()</span><br><span class="line"><span class="comment">//转换格式避免渲染冲突</span></span><br><span class="line"><span class="keyword">let</span> temp = <span class="built_in">JSON</span>.stringify(articles)</span><br><span class="line">articles = <span class="built_in">JSON</span>.parse(temp)</span><br><span class="line"></span><br><span class="line"><span class="comment">// res.send(articles)</span></span><br><span class="line">res.render(<span class="string">&#x27;home/default&#x27;</span>,&#123;</span><br><span class="line">    results:articles</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>index.js文件查询文章数据并渲染总览页面</center>

<br>

<ul>
<li><p>渲染default.art页面时<strong>注意：</strong></p>
<ul>
<li><p>每一个文章块<strong>li标签的class值为 fl 和 fr 交替出现</strong></p>
<ul>
<li>渲染时 遍历文章数据数组时 用遍历序号<strong>对2取余</strong>的值判断该文章模块class的取值</li>
<li>即偶数为fl，奇数为fr</li>
</ul>
</li>
<li><p>用户名为<strong>author.username</strong></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 遍历文章数组生成文章预览块 --&gt;</span></span><br><span class="line">		&#123;&#123;each results.records&#125;&#125;</span><br><span class="line">		<span class="comment">&lt;!-- 判断class值 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;&#123;&#123;$index % 2 == 0 ? &#x27;fl&#x27; : &#x27;fr&#x27;&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/home/article?id=&#123;&#123;@$value._id&#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;thumbnail&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;$value.cover&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;article-title&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/home/article?id=&#123;&#123;@$value._id&#125;&#125;&quot;</span>&gt;</span>&#123;&#123;$value.title&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article-info&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;author&quot;</span>&gt;</span>&#123;&#123;$value.author.username&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;$value.publishDate&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;brief&quot;</span>&gt;</span></span><br><span class="line">					&#123;&#123;$value.content&#125;&#125;</span><br><span class="line">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		&#123;&#123;/each&#125;&#125;</span><br></pre></td></tr></table></figure>

<center>default.art模块遍历results拼接数据生成文章块</center>

<br>

<h4 id="10-3-1-文章数据格式处理"><a href="#10-3-1-文章数据格式处理" class="headerlink" title="10.3.1 文章数据格式处理"></a>10.3.1 文章数据格式处理</h4><p>文章信息在总览页面显示时要注意：</p>
<ul>
<li>日期以’yyyy-mm-dd‘的格式显示，用<strong>dateFormat第三方模块</strong>实现</li>
<li>文章内容节选需要<strong>去除HTML标签</strong>，<strong>原文输出</strong>，<strong>节选长度</strong><ul>
<li>去除HTML标签使用字符串的replace方法<ul>
<li>使用<strong>正则表达式匹配HTML标签</strong>并替换为空字符串（注意匹配时全局）</li>
<li><code>replace(/&lt;[^&gt;]+&gt;/g,&#39;&#39;)</code></li>
</ul>
</li>
<li>原文输出是为了<strong>防止将空格显示为&amp;nbsp</strong>等情况<ul>
<li>在数据变量前加@原文输出</li>
</ul>
</li>
<li>节选长度使用字符串substr方法自定义<ul>
<li><code>substr(0,100)</code>节选0到100的字符显示</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>

<h4 id="10-3-2-分页按钮条处理"><a href="#10-3-2-分页按钮条处理" class="headerlink" title="10.3.2 分页按钮条处理"></a>10.3.2 分页按钮条处理</h4><p><strong>文章总览页面</strong>的分页原理与<strong>文章列表页面</strong>一致</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 分页开始 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page w1100&quot;</span>&gt;</span></span><br><span class="line">		&#123;&#123;if results.page &gt; 1&#125;&#125;</span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/home/?page=&#123;&#123;results.page - 1&#125;&#125;&quot;</span>&gt;</span>上一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		&#123;&#123;/if&#125;&#125;</span><br><span class="line">        </span><br><span class="line">		&#123;&#123;each results.display&#125;&#125;</span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/home/?page=&#123;&#123;$value&#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&#123;&#123;results.page == $value ? &#x27;active&#x27; : &#x27;&#x27;&#125;&#125;&quot;</span>&gt;</span>&#123;&#123;$value&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		&#123;&#123;/each&#125;&#125;</span><br><span class="line">        </span><br><span class="line">		&#123;&#123;if results.page &lt; results.pages&#125;&#125;</span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/home/?page=&#123;&#123;results.page - 0 + 1&#125;&#125;&quot;</span>&gt;</span>下一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		&#123;&#123;/if&#125;&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 分页结束 --&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>页码按钮增加了选中状态，若<strong>页码按钮值等于当前页码</strong>，则设置class为active进行颜色标记</li>
</ul>
<br>

<h3 id="10-4-文章详情页面"><a href="#10-4-文章详情页面" class="headerlink" title="10.4 文章详情页面"></a>10.4 文章详情页面</h3><p>在文章总览页面的每个文章模块中加入超链接 将该文章的<strong>id值作为get参数传递</strong></p>
<p>服务器接受到请求后根据id查询文章信息并渲染文章详情页面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> (req,res) =&gt; &#123;</span><br><span class="line">    <span class="comment">//接受id参数</span></span><br><span class="line">    <span class="keyword">const</span> id = req.query.id</span><br><span class="line">    <span class="comment">//数据库中查询文章信息</span></span><br><span class="line">    <span class="comment">//多集合级联查询author</span></span><br><span class="line">    <span class="comment">//lean()转换格式</span></span><br><span class="line">    <span class="keyword">let</span> article = <span class="keyword">await</span> Article.findOne(&#123;<span class="attr">_id</span>:id&#125;).populate(<span class="string">&#x27;author&#x27;</span>).lean()</span><br><span class="line">    res.render(<span class="string">&#x27;home/article&#x27;</span>,&#123;</span><br><span class="line">        article:article</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>article.js文章详情页面请求处理</center>

<br>

<br>

<h2 id="11-普通用户和管理用户权限区分"><a href="#11-普通用户和管理用户权限区分" class="headerlink" title="11. 普通用户和管理用户权限区分"></a>11. 普通用户和管理用户权限区分</h2><p>通过用户信息中的<strong>role属性</strong>分别两种用户</p>
<ul>
<li>normal：普通用户</li>
<li>admin：管理员用户</li>
</ul>
<br>

<h3 id="11-1-登录页面处理函数修改"><a href="#11-1-登录页面处理函数修改" class="headerlink" title="11.1 登录页面处理函数修改"></a>11.1 登录页面处理函数修改</h3><p>两种用户登录后应该跳转到不同页面</p>
<ul>
<li>普通用户登录后跳转到<strong>前台首页</strong></li>
<li>管理用户登录后跳转到<strong>用户列表</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断用户角色</span></span><br><span class="line"><span class="keyword">if</span>(user.role == <span class="string">&#x27;normal&#x27;</span>)&#123;</span><br><span class="line">    <span class="comment">//普通用户登录后跳转到前台首页</span></span><br><span class="line">    res.redirect(<span class="string">&#x27;/home/&#x27;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//重定向到用户展示页面</span></span><br><span class="line">    res.redirect(<span class="string">&#x27;/admin/user&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>login.js区分用户修改登陆后显示的页面</center>

<br>

<h3 id="11-2-登录拦截处理函数修改"><a href="#11-2-登录拦截处理函数修改" class="headerlink" title="11.2 登录拦截处理函数修改"></a>11.2 登录拦截处理函数修改</h3><p>之前登录拦截处理函数<strong>只拦截没有登录的用户</strong>，登录后的任意用户都可以访问网站所有网页</p>
<p>现在<strong>普通用户登录后是没有权限访问博客管理页面的</strong></p>
<ul>
<li>将登录成功时将用户的<strong>角色信息存储在session对象中</strong><ul>
<li>修改login.js文件添加<code>req.session.role = user.role</code></li>
</ul>
</li>
<li>登录拦截处理时，当用户登录后，判断用户角色<ul>
<li>若为普通用户，则其<strong>访问/admin下的管理页面时重定向到前台首页</strong></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(req.session.role == <span class="string">&#x27;normal&#x27;</span>)&#123;</span><br><span class="line">    <span class="comment">//普通用户尝试访问管理页面时重定向回前台首页</span></span><br><span class="line">    <span class="keyword">return</span> res.redirect(<span class="string">&#x27;/home/&#x27;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//管理用户放行</span></span><br><span class="line">    next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>loginGuard.js修改后判断用户角色</center>

<br>

<br>

<h2 id="12-文章详情页评论功能"><a href="#12-文章详情页评论功能" class="headerlink" title="12. 文章详情页评论功能"></a>12. 文章详情页评论功能</h2><ul>
<li>model文件夹下创建comment.js文件<strong>创建评论集合</strong></li>
<li>提交评论表单时判断用户登陆状态</li>
<li>服务器端创建处理评论请求的路由</li>
<li>路由处理函数中接受评论信息</li>
<li>将评论信息存储在评论集合中</li>
<li>重定向回文章详情页，并将文章评论信息更新</li>
</ul>
<h3 id="12-1-创建评论集合"><a href="#12-1-创建评论集合" class="headerlink" title="12.1 创建评论集合"></a>12.1 创建评论集合</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建集合构造函数</span></span><br><span class="line"><span class="keyword">const</span> commentSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    aid:&#123;</span><br><span class="line">        type:mongoose.Schema.Types.ObjectId,</span><br><span class="line">        ref:<span class="string">&#x27;Article&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    uid:&#123;</span><br><span class="line">        type:mongoose.Schema.Types.ObjectId,</span><br><span class="line">        ref:<span class="string">&#x27;User&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    publishDate:&#123;</span><br><span class="line">        type:<span class="built_in">Date</span>,</span><br><span class="line">        <span class="keyword">default</span>:<span class="built_in">Date</span>.now</span><br><span class="line">    &#125;,</span><br><span class="line">    commentContent:&#123;</span><br><span class="line">        type:<span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h3 id="12-2-评论时判断用户状态"><a href="#12-2-评论时判断用户状态" class="headerlink" title="12.2 评论时判断用户状态"></a>12.2 评论时判断用户状态</h3><p>通过login.js文件在用户登录时添加的<strong>模板公共拼接数据userInfo来判断</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 判断用户登录状态 --&gt;</span></span><br><span class="line">&#123;&#123;if userInfo&#125;&#125;</span><br><span class="line">	<span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;comment-form&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">class</span>=<span class="string">&quot;comment&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;items&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">&#123;&#123;else&#125;&#125;</span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h4</span>&gt;</span>请登陆后再评论<span class="tag">&lt;/<span class="name">h4</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;&#123;/if&#125;&#125;</span><br></pre></td></tr></table></figure>

<center>artcle.art模板</center>

<p><strong>注意：</strong></p>
<ul>
<li>userInfo是模板公共拼接数据，当用户退出时，<strong>logout.js处理函数中需要清除userInfo变量</strong>，否则会导致bug</li>
<li>通过对userInfo置null来清除用户信息</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//登出后清除模板公共数据中的用户信息</span></span><br><span class="line">req.app.locals.userInfo = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="12-3-创建评论功能路由并处理请求"><a href="#12-3-创建评论功能路由并处理请求" class="headerlink" title="12.3 创建评论功能路由并处理请求"></a>12.3 创建评论功能路由并处理请求</h3><ul>
<li>在article.art模板中的<strong>表单设置请求地址等参数</strong></li>
<li>创建评论路由</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//评论提交路由</span></span><br><span class="line">home.post(<span class="string">&#x27;/comment&#x27;</span>,<span class="built_in">require</span>(<span class="string">&#x27;./home/comment&#x27;</span>))</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>处理评论请求函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取评论集合构造函数</span></span><br><span class="line"><span class="keyword">const</span> &#123; Comment &#125; = <span class="built_in">require</span>(<span class="string">&quot;../../model/comment&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> (req,res) =&gt; &#123;</span><br><span class="line">    <span class="comment">//获取评论表单参数</span></span><br><span class="line">    <span class="keyword">const</span> body = req.body</span><br><span class="line">    <span class="comment">//将评论添加到评论集合</span></span><br><span class="line">    <span class="keyword">await</span> Comment.create(body)</span><br><span class="line">    <span class="comment">//重定向回文章详情页</span></span><br><span class="line">    res.redirect(<span class="string">&#x27;/home/article?id=&#x27;</span> + body.aid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210910104323832.png" alt="数据库中comments集合中的评论数据"></p>
<br>

<h3 id="12-4-文章详情页显示对应的评论信息"><a href="#12-4-文章详情页显示对应的评论信息" class="headerlink" title="12.4 文章详情页显示对应的评论信息"></a>12.4 文章详情页显示对应的评论信息</h3><ul>
<li>文章详情页处理函数中，使用<strong>文章id</strong>查询在评论集合中查询出<strong>属于当前文章的所有评论</strong>，将其作为拼接数据渲染模板</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询当前文章的所有评论（使用文章id匹配）</span></span><br><span class="line"><span class="comment">//联合查询出用户信息（显示用户名等）</span></span><br><span class="line"><span class="keyword">let</span> comments = <span class="keyword">await</span> Comment.find(&#123;<span class="attr">aid</span>:id&#125;).populate(<span class="string">&#x27;uid&#x27;</span>).lean()</span><br><span class="line"></span><br><span class="line"><span class="comment">//渲染模板（评论数组作为拼接数据）</span></span><br><span class="line">res.render(<span class="string">&#x27;home/article&#x27;</span>,&#123;</span><br><span class="line">    article:article,</span><br><span class="line">    comments:comments</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<center>article.js处理函数</center>

<br>

<ul>
<li>遍历评论数组生成评论</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 生成评论 --&gt;</span></span><br><span class="line">&#123;&#123;each comments&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mb10&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article-info&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;author&quot;</span>&gt;</span>&#123;&#123;$value.uid.username&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;dateFormat($value.publishDate,&#x27;yyyy-mm-dd&#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;$value.uid.email&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;comment-content&quot;</span>&gt;</span></span><br><span class="line">		&#123;&#123;$value.content&#125;&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;&#123;/each&#125;&#125;</span><br></pre></td></tr></table></figure>

<center>article.art模板生成评论</center>

<br>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210910105508674.png" alt="显示评论"></p>
<br>

<br>

<h2 id="开发过程遇见的问题"><a href="#开发过程遇见的问题" class="headerlink" title="开发过程遇见的问题"></a>开发过程遇见的问题</h2><h3 id="1-连接mongoDB数据库时报错TextEncoder-is-not-defined"><a href="#1-连接mongoDB数据库时报错TextEncoder-is-not-defined" class="headerlink" title="1.连接mongoDB数据库时报错TextEncoder is not defined"></a>1.连接mongoDB数据库时报错TextEncoder is not defined</h3><p>低于<strong>v11版本</strong>的Node运行环境<strong>不支持TextEncoder方法</strong></p>
<p>将node版本升级到v11解决</p>
<p>进行项目开发时<strong>明确使用的环境版本非常重要</strong>，并且在开发中经常会遇到<strong>不同的项目使用不同版本的Node</strong>，此时频繁切换不同版本的Node非常麻烦。</p>
<p>使用<strong>nvm</strong> 来管理node版本</p>
<br>

<h3 id="2-多集合级联查询与render方法渲染模板冲突"><a href="#2-多集合级联查询与render方法渲染模板冲突" class="headerlink" title="2. 多集合级联查询与render方法渲染模板冲突"></a>2. 多集合级联查询与render方法渲染模板冲突</h3><p><strong>第一种解决办法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> articles = <span class="keyword">await</span> pagination(Article).page(page).size(<span class="number">2</span>).display(<span class="number">2</span>).populate(<span class="string">&#x27;author&#x27;</span>).exec()</span><br><span class="line">    <span class="comment">//将查询出的对象先转换为JSON字符串再转换为对象</span></span><br><span class="line">    <span class="comment">//将author字段值的类型由mongoose文档对象转换为普通对象避免渲染模板时的冲突</span></span><br><span class="line">    <span class="keyword">let</span> temp = <span class="built_in">JSON</span>.stringify(articles)</span><br><span class="line">    articles = <span class="built_in">JSON</span>.parse(temp)</span><br></pre></td></tr></table></figure>

<ul>
<li>将查询结果使用**JSON.stringify()和JSON.parse()**方法转换</li>
<li>将mongoose的<strong>文档格式对象</strong>转化为<strong>普通对象</strong></li>
</ul>
<p><strong>第二种解决办法</strong></p>
<ul>
<li>在populate()方法后链式调用lean()方法</li>
<li>原理与第一种方法相同</li>
<li>但是<strong>使用mongoose-sex-page模块进行分页时与lean()方法冲突</strong></li>
<li>故使用第一种方法</li>
</ul>
<br>

<h3 id="3-实现分页按钮条上一页-下一页按钮隐藏时的问题"><a href="#3-实现分页按钮条上一页-下一页按钮隐藏时的问题" class="headerlink" title="3. 实现分页按钮条上一页/下一页按钮隐藏时的问题"></a>3. 实现分页按钮条上一页/下一页按钮隐藏时的问题</h3><p>如果直接在标签内style属性中的<strong>display属性中使用模板标准语法进行条件表达式判断</strong></p>
<ul>
<li>此时当<strong>VSCODE语言模式选择为HTML时会提示错误</strong>，但项目仍能运行</li>
<li>将语言模式改为art时，不会报错，但文件中又不会提示代码补全</li>
<li>综上，<strong>使用模板标准语法的判断语句</strong>来实现上一页/下一页的隐藏显示</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;if results.page &lt; results.pages&#125;&#125;</span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/home/?page=&#123;&#123;results.page - 0 + 1&#125;&#125;&quot;</span>&gt;</span>下一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">&#123;&#123;/if&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当满足判断条件时，即当前页码小于最后一页时显示下一页，否则隐藏</li>
</ul>
<br>

<h3 id="4-模板中相对路径的问题"><a href="#4-模板中相对路径的问题" class="headerlink" title="4. 模板中相对路径的问题"></a>4. 模板中相对路径的问题</h3><p>模板中许多外链文件如css和js文件使用的都是<strong>相对路径</strong></p>
<p>模板中的相对路径是<strong>相对于浏览器地址栏的路径</strong></p>
<p>改为<strong>绝对路径</strong>可以避免因路由对象的虚拟路径而取不到静态资源文件的问题</p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210830203446873.png" alt="login.art模板中的相对路径"></p>
<br>

<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210830203543389.png" alt="相对路径相对于浏览器地址栏的路径"></p>
<p>此时浏览器将地址栏中的login当作文件，所以<strong>相对路径即相对于/abc</strong></p>
<ul>
<li><p>可见此时请求静态资源<code>base.css</code>的路径变为了<code>http://localhost/abc/css/base.css</code></p>
</li>
<li><p>而<code>base.css</code>静态资源文件并不在<code>/public/abc</code>文件夹下，并且public文件夹下也并不存在abc文件夹，所以无法获取静态资源文件</p>
</li>
<li><p>/abc只是admin路由对象匹配的<strong>虚拟路径</strong>，这个虚拟路径<strong>随时可以发生变化</strong></p>
</li>
<li><p>所以在模块中使用相对路径获取静态资源文件并不合适</p>
</li>
<li><p>改为使用<strong>绝对路径</strong>解决这个问题</p>
</li>
</ul>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210830204312384.png" alt="login.art模板中使用绝对路径"></p>
<p>在原先的相对路径前加上<code>&#39;/&#39;</code>使其变为绝对路径，同时根据静态资源文件的路径加上admin</p>
<p>此时请求静态资源文件的路径变为<code>http://localhost/admin/css/base.css</code></p>
<p>经过<code>express.static</code>方法处理后在<code>/public/admin/css/base.css</code>找到静态资源文件</p>
<p><img data-src="/images/17-%E5%A4%9A%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/image-20210830205046226.png" alt="模板使用绝对路径获取静态资源文件"></p>
<br>

<h3 id="5-用户退出登录后在浏览器仍有cookie保存"><a href="#5-用户退出登录后在浏览器仍有cookie保存" class="headerlink" title="5. 用户退出登录后在浏览器仍有cookie保存"></a>5. 用户退出登录后在浏览器仍有cookie保存</h3><p><code>logout.js</code>处理函数中在用户退出登陆后<strong>删除服务端session和客户端cookie</strong></p>
<p>但是退出登陆后在浏览器仍然保存一个cookie</p>
<p><strong>原因为：</strong></p>
<p>express-session模块使用时默认会设置未初始化cookie</p>
<ul>
<li>即当客户端向服务端发送请求时就会存储一个cookie</li>
<li>这个cookie不存储用户的sessionId</li>
<li>我们希望用户退出登录时<strong>将这个未初始化cookie也删除</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建立session对象</span></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">    <span class="comment">//加密cookie</span></span><br><span class="line">    secret:<span class="string">&#x27;secret key&#x27;</span>,</span><br><span class="line">    <span class="comment">//默认不添加未初始化cookie</span></span><br><span class="line">    saveUninitialized:<span class="literal">false</span>,</span><br><span class="line">    cookie:&#123;</span><br><span class="line">        <span class="comment">//设置过期时间(毫秒)</span></span><br><span class="line">        maxAge:<span class="number">24</span> * <span class="number">60</span> *<span class="number">60</span> * <span class="number">1000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在app.js文件中建立session对象时<code>saveUninitialized:false</code></p>
</li>
<li><p>将这个属性置为false则不会自动添加未初始化cookie</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Mongodb数据库</tag>
        <tag>Express</tag>
      </tags>
  </entry>
</search>
